import { r as Ue, j as cs, a as mT, R as $3 } from './vendor_react-C8wG62CJ.js';
function eO(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != 'string' && !Array.isArray(i)) {
      for (const r in i)
        if (r !== 'default' && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get ? s : { enumerable: !0, get: () => i[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' })
  );
}
var Mb =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
      ? window
      : typeof global < 'u'
        ? global
        : typeof self < 'u'
          ? self
          : {};
function cy(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default')
    ? n.default
    : n;
}
function tO(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var e = n.default;
  if (typeof e == 'function') {
    var t = function i() {
      var r = !1;
      try {
        r = this instanceof i;
      } catch {}
      return r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, '__esModule', { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            }
      );
    }),
    t
  );
}
var va = {},
  ig = {},
  rg = {},
  Tb;
function fi() {
  return (
    Tb ||
      ((Tb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.Log = n.LogLevel = void 0));
        const e = ' DEBUG ',
          t = '  INFO ',
          i = '  WARN ',
          r = ' ERROR ';
        function s(o) {
          return (o.unshift('[Statsig]'), o);
        }
        n.LogLevel = { None: 0, Error: 1, Warn: 2, Info: 3, Debug: 4 };
        class a {
          static info(...l) {
            a.level >= n.LogLevel.Info && console.info(t, ...s(l));
          }
          static debug(...l) {
            a.level >= n.LogLevel.Debug && console.debug(e, ...s(l));
          }
          static warn(...l) {
            a.level >= n.LogLevel.Warn && console.warn(i, ...s(l));
          }
          static error(...l) {
            a.level >= n.LogLevel.Error && console.error(r, ...s(l));
          }
        }
        ((n.Log = a), (a.level = n.LogLevel.Warn));
      })(rg)),
    rg
  );
}
var Cb;
function Ws() {
  return (
    Cb ||
      ((Cb = 1),
      (function (n) {
        var e, t, i;
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._getInstance =
            n._getStatsigGlobalFlag =
            n._getStatsigGlobal =
              void 0));
        const r = fi(),
          s = () => {
            try {
              return typeof __STATSIG__ < 'u' ? __STATSIG__ : d;
            } catch {
              return d;
            }
          };
        n._getStatsigGlobal = s;
        const a = (f) => (0, n._getStatsigGlobal)()[f];
        n._getStatsigGlobalFlag = a;
        const o = (f) => {
          const p = (0, n._getStatsigGlobal)();
          return f
            ? p.instances && p.instances[f]
            : (p.instances &&
                Object.keys(p.instances).length > 1 &&
                r.Log.warn(
                  'Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.'
                ),
              p.firstInstance);
        };
        n._getInstance = o;
        const l = '__STATSIG__',
          c = typeof window < 'u' ? window : {},
          u = typeof Mb < 'u' ? Mb : {},
          h = typeof globalThis < 'u' ? globalThis : {},
          d =
            (i =
              (t = (e = c[l]) !== null && e !== void 0 ? e : u[l]) !== null &&
              t !== void 0
                ? t
                : h[l]) !== null && i !== void 0
              ? i
              : { instance: n._getInstance };
        ((c[l] = d), (u[l] = d), (h[l] = d));
      })(ig)),
    ig
  );
}
var sg = {},
  Rb;
function Sv() {
  return (
    Rb ||
      ((Rb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.Diagnostics = void 0));
        const e = new Map(),
          t = 'start',
          i = 'end',
          r = 'statsig::diagnostics';
        n.Diagnostics = {
          _getMarkers: (c) => e.get(c),
          _markInitOverallStart: (c) => {
            o(c, s({}, t, 'overall'));
          },
          _markInitOverallEnd: (c, u, h) => {
            o(
              c,
              s(
                {
                  success: u,
                  error: u
                    ? void 0
                    : {
                        name: 'InitializeError',
                        message: 'Failed to initialize',
                      },
                  evaluationDetails: h,
                },
                i,
                'overall'
              )
            );
          },
          _markInitNetworkReqStart: (c, u) => {
            o(c, s(u, t, 'initialize', 'network_request'));
          },
          _markInitNetworkReqEnd: (c, u) => {
            o(c, s(u, i, 'initialize', 'network_request'));
          },
          _markInitProcessStart: (c) => {
            o(c, s({}, t, 'initialize', 'process'));
          },
          _markInitProcessEnd: (c, u) => {
            o(c, s(u, i, 'initialize', 'process'));
          },
          _clearMarkers: (c) => {
            e.delete(c);
          },
          _formatError(c) {
            if (c && typeof c == 'object')
              return {
                code: l(c, 'code'),
                name: l(c, 'name'),
                message: l(c, 'message'),
              };
          },
          _getDiagnosticsData(c, u, h, d) {
            var f;
            return {
              success: c?.ok === !0,
              statusCode: c?.status,
              sdkRegion:
                (f = c?.headers) === null || f === void 0
                  ? void 0
                  : f.get('x-statsig-region'),
              isDelta: h.includes('"is_delta":true') === !0 ? !0 : void 0,
              attempt: u,
              error: n.Diagnostics._formatError(d),
            };
          },
          _enqueueDiagnosticsEvent(c, u, h, d) {
            const f = n.Diagnostics._getMarkers(h);
            if (f == null || f.length <= 0) return -1;
            const p = f[f.length - 1].timestamp - f[0].timestamp;
            n.Diagnostics._clearMarkers(h);
            const m = a(c, {
              context: 'initialize',
              markers: f.slice(),
              statsigOptions: d,
            });
            return (u.enqueue(m), p);
          },
        };
        function s(c, u, h, d) {
          return Object.assign(
            { key: h, action: u, step: d, timestamp: Date.now() },
            c
          );
        }
        function a(c, u) {
          return {
            eventName: r,
            user: c,
            value: null,
            metadata: u,
            time: Date.now(),
          };
        }
        function o(c, u) {
          var h;
          const d = (h = e.get(c)) !== null && h !== void 0 ? h : [];
          (d.push(u), e.set(c, d));
        }
        function l(c, u) {
          if (u in c) return c[u];
        }
      })(sg)),
    sg
  );
}
var _a = {},
  ya = {},
  ag = {},
  xa = {},
  Ib;
function uy() {
  if (Ib) return xa;
  ((Ib = 1),
    Object.defineProperty(xa, '__esModule', { value: !0 }),
    (xa._isTypeMatch = xa._typeOf = void 0));
  function n(t) {
    return Array.isArray(t) ? 'array' : typeof t;
  }
  xa._typeOf = n;
  function e(t, i) {
    const r = (s) =>
      Array.isArray(s) ? 'array' : s === null ? 'null' : typeof s;
    return r(t) === r(i);
  }
  return ((xa._isTypeMatch = e), xa);
}
var Pb;
function cc() {
  return (
    Pb ||
      ((Pb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._getSortedObject = n._DJB2Object = n._DJB2 = void 0));
        const e = uy(),
          t = (s) => {
            let a = 0;
            for (let o = 0; o < s.length; o++) {
              const l = s.charCodeAt(o);
              ((a = (a << 5) - a + l), (a = a & a));
            }
            return String(a >>> 0);
          };
        n._DJB2 = t;
        const i = (s, a) =>
          (0, n._DJB2)(JSON.stringify((0, n._getSortedObject)(s, a)));
        n._DJB2Object = i;
        const r = (s, a) => {
          if (s == null) return null;
          const o = Object.keys(s).sort(),
            l = {};
          return (
            o.forEach((c) => {
              const u = s[c];
              if (a === 0 || (0, e._typeOf)(u) !== 'object') {
                l[c] = u;
                return;
              }
              l[c] = (0, n._getSortedObject)(u, a != null ? a - 1 : a);
            }),
            l
          );
        };
        n._getSortedObject = r;
      })(ag)),
    ag
  );
}
var Db;
function Kp() {
  if (Db) return ya;
  ((Db = 1),
    Object.defineProperty(ya, '__esModule', { value: !0 }),
    (ya._getStorageKey = ya._getUserStorageKey = void 0));
  const n = cc();
  function e(i, r, s) {
    var a;
    if (s) return s(i, r);
    const o = r && r.customIDs ? r.customIDs : {},
      l = [
        `uid:${(a = r?.userID) !== null && a !== void 0 ? a : ''}`,
        `cids:${Object.keys(o)
          .sort((c, u) => c.localeCompare(u))
          .map((c) => `${c}-${o[c]}`)
          .join(',')}`,
        `k:${i}`,
      ];
    return (0, n._DJB2)(l.join('|'));
  }
  ya._getUserStorageKey = e;
  function t(i, r, s) {
    return r ? e(i, r, s) : (0, n._DJB2)(`k:${i}`);
  }
  return ((ya._getStorageKey = t), ya);
}
var og = {},
  Ob;
function Jp() {
  return (
    Ob ||
      ((Ob = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.NetworkParam = n.NetworkDefault = n.Endpoint = void 0),
          (n.Endpoint = {
            _initialize: 'initialize',
            _rgstr: 'rgstr',
            _download_config_specs: 'download_config_specs',
          }),
          (n.NetworkDefault = {
            [n.Endpoint._rgstr]: 'https://prodregistryv2.org/v1',
            [n.Endpoint._initialize]: 'https://featureassets.org/v1',
            [n.Endpoint._download_config_specs]:
              'https://api.statsigcdn.com/v1',
          }),
          (n.NetworkParam = {
            EventCount: 'ec',
            SdkKey: 'k',
            SdkType: 'st',
            SdkVersion: 'sv',
            Time: 't',
            SessionID: 'sid',
            StatsigEncoded: 'se',
            IsGzipped: 'gz',
          }));
      })(og)),
    og
  );
}
var lg = {},
  Lb;
function Bo() {
  return (
    Lb ||
      ((Lb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._getUnloadEvent =
            n._getCurrentPageUrlSafe =
            n._addDocumentEventListenerSafe =
            n._addWindowEventListenerSafe =
            n._isServerEnv =
            n._getDocumentSafe =
            n._getWindowSafe =
              void 0));
        const e = () => (typeof window < 'u' ? window : null);
        n._getWindowSafe = e;
        const t = () => {
          var l;
          const c = (0, n._getWindowSafe)();
          return (l = c?.document) !== null && l !== void 0 ? l : null;
        };
        n._getDocumentSafe = t;
        const i = () => {
          if ((0, n._getDocumentSafe)() !== null) return !1;
          const l =
            typeof process < 'u' &&
            process.versions != null &&
            process.versions.node != null;
          return typeof EdgeRuntime == 'string' || l;
        };
        n._isServerEnv = i;
        const r = (l, c) => {
          const u = (0, n._getWindowSafe)();
          typeof u?.addEventListener == 'function' && u.addEventListener(l, c);
        };
        n._addWindowEventListenerSafe = r;
        const s = (l, c) => {
          const u = (0, n._getDocumentSafe)();
          typeof u?.addEventListener == 'function' && u.addEventListener(l, c);
        };
        n._addDocumentEventListenerSafe = s;
        const a = () => {
          var l;
          try {
            return (l = (0, n._getWindowSafe)()) === null || l === void 0
              ? void 0
              : l.location.href.split(/[?#]/)[0];
          } catch {
            return;
          }
        };
        n._getCurrentPageUrlSafe = a;
        const o = () => {
          const l = (0, n._getWindowSafe)();
          return l && 'onpagehide' in l ? 'pagehide' : 'beforeunload';
        };
        n._getUnloadEvent = o;
      })(lg)),
    lg
  );
}
var Oi = {},
  Ub;
function gT() {
  if (Ub) return Oi;
  ((Ub = 1),
    Object.defineProperty(Oi, '__esModule', { value: !0 }),
    (Oi._createLayerParameterExposure =
      Oi._createConfigExposure =
      Oi._mapExposures =
      Oi._createGateExposure =
      Oi._isExposureEvent =
        void 0));
  const n = 'statsig::config_exposure',
    e = 'statsig::gate_exposure',
    t = 'statsig::layer_exposure',
    i = (u, h, d, f, p) => (
      d.bootstrapMetadata && (f.bootstrapMetadata = d.bootstrapMetadata),
      {
        eventName: u,
        user: h,
        value: null,
        metadata: c(d, f),
        secondaryExposures: p,
        time: Date.now(),
      }
    ),
    r = ({ eventName: u }) => u === e || u === n || u === t;
  Oi._isExposureEvent = r;
  const s = (u, h, d) => {
    var f, p, m;
    const g = { gate: h.name, gateValue: String(h.value), ruleID: h.ruleID };
    return (
      ((f = h.__evaluation) === null || f === void 0 ? void 0 : f.version) !=
        null && (g.configVersion = h.__evaluation.version),
      i(
        e,
        u,
        h.details,
        g,
        a(
          (m =
            (p = h.__evaluation) === null || p === void 0
              ? void 0
              : p.secondary_exposures) !== null && m !== void 0
            ? m
            : [],
          d
        )
      )
    );
  };
  Oi._createGateExposure = s;
  function a(u, h) {
    return u
      .map((d) => (typeof d == 'string' ? (h ?? {})[d] : d))
      .filter((d) => d != null);
  }
  Oi._mapExposures = a;
  const o = (u, h, d) => {
    var f, p, m, g;
    const v = { config: h.name, ruleID: h.ruleID };
    return (
      ((f = h.__evaluation) === null || f === void 0 ? void 0 : f.version) !=
        null && (v.configVersion = h.__evaluation.version),
      ((p = h.__evaluation) === null || p === void 0 ? void 0 : p.passed) !=
        null && (v.rulePassed = String(h.__evaluation.passed)),
      i(
        n,
        u,
        h.details,
        v,
        a(
          (g =
            (m = h.__evaluation) === null || m === void 0
              ? void 0
              : m.secondary_exposures) !== null && g !== void 0
            ? g
            : [],
          d
        )
      )
    );
  };
  Oi._createConfigExposure = o;
  const l = (u, h, d, f) => {
    var p, m, g, v, y, _, x;
    const S = h.__evaluation,
      b =
        ((p = S?.explicit_parameters) === null || p === void 0
          ? void 0
          : p.includes(d)) === !0;
    let A = '',
      E =
        (m = S?.undelegated_secondary_exposures) !== null && m !== void 0
          ? m
          : [];
    b &&
      ((A =
        (g = S.allocated_experiment_name) !== null && g !== void 0 ? g : ''),
      (E = (v = S.secondary_exposures) !== null && v !== void 0 ? v : []));
    const w =
        (y = h.__evaluation) === null || y === void 0
          ? void 0
          : y.parameter_rule_ids,
      M = {
        config: h.name,
        parameterName: d,
        ruleID: (_ = w?.[d]) !== null && _ !== void 0 ? _ : h.ruleID,
        allocatedExperiment: A,
        isExplicitParameter: String(b),
      };
    return (
      ((x = h.__evaluation) === null || x === void 0 ? void 0 : x.version) !=
        null && (M.configVersion = h.__evaluation.version),
      i(t, u, h.details, M, a(E, f))
    );
  };
  Oi._createLayerParameterExposure = l;
  const c = (u, h) => (
    (h.reason = u.reason),
    u.lcut && (h.lcut = String(u.lcut)),
    u.receivedAt && (h.receivedAt = String(u.receivedAt)),
    h
  );
  return Oi;
}
var ba = {},
  kb;
function Qp() {
  return (
    kb ||
      ((kb = 1),
      Object.defineProperty(ba, '__esModule', { value: !0 }),
      (ba.LoggingEnabledOption = ba.LogEventCompressionMode = void 0),
      (ba.LogEventCompressionMode = {
        Disabled: 'd',
        Enabled: 'e',
        Forced: 'f',
      }),
      (ba.LoggingEnabledOption = {
        disabled: 'disabled',
        browserOnly: 'browser-only',
        always: 'always',
      })),
    ba
  );
}
var cg = {},
  Bb;
function Ys() {
  return (
    Bb ||
      ((Bb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._setObjectInStorage =
            n._getObjectFromStorage =
            n.Storage =
              void 0));
        const e = fi(),
          t = Bo(),
          i = {},
          r = {
            isReady: () => !0,
            isReadyResolver: () => null,
            getProviderName: () => 'InMemory',
            getItem: (h) => (i[h] ? i[h] : null),
            setItem: (h, d) => {
              i[h] = d;
            },
            removeItem: (h) => {
              delete i[h];
            },
            getAllKeys: () => Object.keys(i),
          };
        let s = null;
        try {
          const h = (0, t._getWindowSafe)();
          h &&
            h.localStorage &&
            typeof h.localStorage.getItem == 'function' &&
            (s = {
              isReady: () => !0,
              isReadyResolver: () => null,
              getProviderName: () => 'LocalStorage',
              getItem: (d) => h.localStorage.getItem(d),
              setItem: (d, f) => h.localStorage.setItem(d, f),
              removeItem: (d) => h.localStorage.removeItem(d),
              getAllKeys: () => Object.keys(h.localStorage),
            });
        } catch {
          e.Log.warn('Failed to setup localStorageProvider.');
        }
        let a = s ?? r,
          o = a;
        function l(h) {
          try {
            return h();
          } catch (d) {
            if (d instanceof Error && d.name === 'SecurityError')
              return (n.Storage._setProvider(r), null);
            throw d;
          }
        }
        n.Storage = {
          isReady: () => o.isReady(),
          isReadyResolver: () => o.isReadyResolver(),
          getProviderName: () => o.getProviderName(),
          getItem: (h) => l(() => o.getItem(h)),
          setItem: (h, d) => l(() => o.setItem(h, d)),
          removeItem: (h) => o.removeItem(h),
          getAllKeys: () => o.getAllKeys(),
          _setProvider: (h) => {
            ((a = h), (o = h));
          },
          _setDisabled: (h) => {
            h ? (o = r) : (o = a);
          },
        };
        function c(h) {
          const d = n.Storage.getItem(h);
          return JSON.parse(d ?? 'null');
        }
        n._getObjectFromStorage = c;
        function u(h, d) {
          n.Storage.setItem(h, JSON.stringify(d));
        }
        n._setObjectInStorage = u;
      })(cg)),
    cg
  );
}
var Ic = {},
  Nb;
function vT() {
  if (Nb) return Ic;
  ((Nb = 1),
    Object.defineProperty(Ic, '__esModule', { value: !0 }),
    (Ic.UrlConfiguration = void 0));
  const n = cc(),
    e = Jp(),
    t = {
      [e.Endpoint._initialize]: 'i',
      [e.Endpoint._rgstr]: 'e',
      [e.Endpoint._download_config_specs]: 'd',
    };
  let i = class {
    constructor(s, a, o, l) {
      ((this.customUrl = null),
        (this.fallbackUrls = null),
        (this.endpoint = s),
        (this.endpointDnsKey = t[s]),
        a && (this.customUrl = a),
        !a &&
          o &&
          (this.customUrl = o.endsWith('/') ? `${o}${s}` : `${o}/${s}`),
        l && (this.fallbackUrls = l));
      const c = e.NetworkDefault[s];
      this.defaultUrl = `${c}/${s}`;
    }
    getUrl() {
      var s;
      return (s = this.customUrl) !== null && s !== void 0
        ? s
        : this.defaultUrl;
    }
    getChecksum() {
      var s;
      const a = ((s = this.fallbackUrls) !== null && s !== void 0 ? s : [])
        .sort()
        .join(',');
      return (0, n._DJB2)(this.customUrl + a);
    }
  };
  return ((Ic.UrlConfiguration = i), Ic);
}
var ug = {},
  Fb;
function hy() {
  return (
    Fb ||
      ((Fb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._notifyVisibilityChanged =
            n._subscribeToVisiblityChanged =
            n._isUnloading =
            n._isCurrentlyVisible =
              void 0));
        const e = Bo(),
          t = 'foreground',
          i = 'background',
          r = [];
        let s = t,
          a = !1;
        const o = () => s === t;
        n._isCurrentlyVisible = o;
        const l = () => a;
        n._isUnloading = l;
        const c = (h) => {
          r.unshift(h);
        };
        n._subscribeToVisiblityChanged = c;
        const u = (h) => {
          h !== s && ((s = h), r.forEach((d) => d(h)));
        };
        ((n._notifyVisibilityChanged = u),
          (0, e._addWindowEventListenerSafe)('focus', () => {
            ((a = !1), (0, n._notifyVisibilityChanged)(t));
          }),
          (0, e._addWindowEventListenerSafe)('blur', () =>
            (0, n._notifyVisibilityChanged)(i)
          ),
          (0, e._addDocumentEventListenerSafe)('visibilitychange', () => {
            (0, n._notifyVisibilityChanged)(
              document.visibilityState === 'visible' ? t : i
            );
          }),
          (0, e._addWindowEventListenerSafe)((0, e._getUnloadEvent)(), () => {
            ((a = !0), (0, n._notifyVisibilityChanged)(i));
          }));
      })(ug)),
    ug
  );
}
var zb;
function _T() {
  if (zb) return _a;
  zb = 1;
  var n =
    (_a && _a.__awaiter) ||
    function (x, S, b, A) {
      function E(w) {
        return w instanceof b
          ? w
          : new b(function (M) {
              M(w);
            });
      }
      return new (b || (b = Promise))(function (w, M) {
        function T(O) {
          try {
            L(A.next(O));
          } catch (z) {
            M(z);
          }
        }
        function D(O) {
          try {
            L(A.throw(O));
          } catch (z) {
            M(z);
          }
        }
        function L(O) {
          O.done ? w(O.value) : E(O.value).then(T, D);
        }
        L((A = A.apply(x, S || [])).next());
      });
    };
  (Object.defineProperty(_a, '__esModule', { value: !0 }),
    (_a.EventLogger = void 0));
  const e = Kp(),
    t = cc(),
    i = fi(),
    r = Jp(),
    s = Bo(),
    a = gT(),
    o = Qp(),
    l = Ys(),
    c = vT(),
    u = hy(),
    h = 100,
    d = 1e4,
    f = 1e3,
    p = 6e5,
    m = 500,
    g = 200,
    v = {},
    y = { Startup: 'startup', GainedFocus: 'gained_focus' };
  let _ = class bl {
    static _safeFlushAndForget(S) {
      var b;
      (b = v[S]) === null || b === void 0 || b.flush().catch(() => {});
    }
    static _safeRetryFailedLogs(S) {
      var b;
      (b = v[S]) === null || b === void 0 || b._retryFailedLogs(y.GainedFocus);
    }
    constructor(S, b, A, E) {
      var w, M;
      ((this._sdkKey = S),
        (this._emitter = b),
        (this._network = A),
        (this._options = E),
        (this._queue = []),
        (this._lastExposureTimeMap = {}),
        (this._nonExposedChecks = {}),
        (this._hasRunQuickFlush = !1),
        (this._creationTime = Date.now()),
        (this._loggingEnabled =
          (w = E?.loggingEnabled) !== null && w !== void 0
            ? w
            : E?.disableLogging === !0
              ? o.LoggingEnabledOption.disabled
              : o.LoggingEnabledOption.browserOnly),
        E?.loggingEnabled &&
          E.disableLogging !== void 0 &&
          i.Log.warn(
            'Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.'
          ),
        (this._maxQueueSize =
          (M = E?.loggingBufferMaxSize) !== null && M !== void 0 ? M : h));
      const T = E?.networkConfig;
      this._logEventUrlConfig = new c.UrlConfiguration(
        r.Endpoint._rgstr,
        T?.logEventUrl,
        T?.api,
        T?.logEventFallbackUrls
      );
    }
    setLogEventCompressionMode(S) {
      this._network.setLogEventCompressionMode(S);
    }
    setLoggingEnabled(S) {
      if (this._loggingEnabled === 'disabled' && S !== 'disabled') {
        const b = this._getStorageKey(),
          A = (0, l._getObjectFromStorage)(b);
        (A && this._queue.push(...A), l.Storage.removeItem(b));
      }
      this._loggingEnabled = S;
    }
    enqueue(S) {
      this._shouldLogEvent(S) &&
        (this._normalizeAndAppendEvent(S),
        this._quickFlushIfNeeded(),
        this._queue.length > this._maxQueueSize &&
          bl._safeFlushAndForget(this._sdkKey));
    }
    incrementNonExposureCount(S) {
      var b;
      const A =
        (b = this._nonExposedChecks[S]) !== null && b !== void 0 ? b : 0;
      this._nonExposedChecks[S] = A + 1;
    }
    reset() {
      (this.flush().catch(() => {}), (this._lastExposureTimeMap = {}));
    }
    start() {
      var S;
      const b = (0, s._isServerEnv)();
      (b &&
        ((S = this._options) === null || S === void 0
          ? void 0
          : S.loggingEnabled) !== 'always') ||
        ((v[this._sdkKey] = this),
        b ||
          (0, u._subscribeToVisiblityChanged)((A) => {
            A === 'background'
              ? bl._safeFlushAndForget(this._sdkKey)
              : A === 'foreground' && bl._safeRetryFailedLogs(this._sdkKey);
          }),
        this._retryFailedLogs(y.Startup),
        this._startBackgroundFlushInterval());
    }
    stop() {
      return n(this, void 0, void 0, function* () {
        (this._flushIntervalId &&
          (clearInterval(this._flushIntervalId),
          (this._flushIntervalId = null)),
          delete v[this._sdkKey],
          yield this.flush());
      });
    }
    flush() {
      return n(this, void 0, void 0, function* () {
        if ((this._appendAndResetNonExposedChecks(), this._queue.length === 0))
          return;
        const S = this._queue;
        ((this._queue = []), yield this._sendEvents(S));
      });
    }
    _quickFlushIfNeeded() {
      this._hasRunQuickFlush ||
        ((this._hasRunQuickFlush = !0),
        !(Date.now() - this._creationTime > g) &&
          setTimeout(() => bl._safeFlushAndForget(this._sdkKey), g));
    }
    _shouldLogEvent(S) {
      var b;
      if (
        ((b = this._options) === null || b === void 0
          ? void 0
          : b.loggingEnabled) !== 'always' &&
        (0, s._isServerEnv)()
      )
        return !1;
      if (!(0, a._isExposureEvent)(S)) return !0;
      const A = S.user ? S.user : { statsigEnvironment: void 0 },
        E = (0, e._getUserStorageKey)(this._sdkKey, A),
        w = S.metadata ? S.metadata : {},
        M = [
          S.eventName,
          E,
          w.gate,
          w.config,
          w.ruleID,
          w.allocatedExperiment,
          w.parameterName,
          String(w.isExplicitParameter),
          w.reason,
        ].join('|'),
        T = this._lastExposureTimeMap[M],
        D = Date.now();
      return T && D - T < p
        ? !1
        : (Object.keys(this._lastExposureTimeMap).length > f &&
            (this._lastExposureTimeMap = {}),
          (this._lastExposureTimeMap[M] = D),
          !0);
    }
    _sendEvents(S) {
      return n(this, void 0, void 0, function* () {
        var b, A;
        if (this._loggingEnabled === 'disabled')
          return (this._saveFailedLogsToStorage(S), !1);
        try {
          const w =
            (0, u._isUnloading)() &&
            this._network.isBeaconSupported() &&
            ((A =
              (b = this._options) === null || b === void 0
                ? void 0
                : b.networkConfig) === null || A === void 0
              ? void 0
              : A.networkOverrideFunc) == null;
          return (
            this._emitter({ name: 'pre_logs_flushed', events: S }),
            (w
              ? this._sendEventsViaBeacon(S)
              : yield this._sendEventsViaPost(S)
            ).success
              ? (this._emitter({ name: 'logs_flushed', events: S }), !0)
              : (i.Log.warn('Failed to flush events.'),
                this._saveFailedLogsToStorage(S),
                !1)
          );
        } catch {
          return (i.Log.warn('Failed to flush events.'), !1);
        }
      });
    }
    _sendEventsViaPost(S) {
      return n(this, void 0, void 0, function* () {
        var b;
        const A = yield this._network.post(this._getRequestData(S)),
          E = (b = A?.code) !== null && b !== void 0 ? b : -1;
        return { success: E >= 200 && E < 300 };
      });
    }
    _sendEventsViaBeacon(S) {
      return { success: this._network.beacon(this._getRequestData(S)) };
    }
    _getRequestData(S) {
      return {
        sdkKey: this._sdkKey,
        data: { events: S },
        urlConfig: this._logEventUrlConfig,
        retries: 3,
        isCompressable: !0,
        params: { [r.NetworkParam.EventCount]: String(S.length) },
        credentials: 'same-origin',
      };
    }
    _saveFailedLogsToStorage(S) {
      for (; S.length > m; ) S.shift();
      const b = this._getStorageKey();
      try {
        const A = this._getFailedLogsFromStorage(b);
        (0, l._setObjectInStorage)(b, [...A, ...S]);
      } catch {
        i.Log.warn('Unable to save failed logs to storage');
      }
    }
    _getFailedLogsFromStorage(S) {
      let b = [];
      try {
        const A = (0, l._getObjectFromStorage)(S);
        return (Array.isArray(A) && (b = A), b);
      } catch {
        return [];
      }
    }
    _retryFailedLogs(S) {
      const b = this._getStorageKey();
      n(this, void 0, void 0, function* () {
        l.Storage.isReady() || (yield l.Storage.isReadyResolver());
        const A = (0, l._getObjectFromStorage)(b);
        if (!A) return;
        (S === y.Startup && l.Storage.removeItem(b),
          (yield this._sendEvents(A)) &&
            S === y.GainedFocus &&
            l.Storage.removeItem(b));
      }).catch(() => {
        i.Log.warn('Failed to flush stored logs');
      });
    }
    _getStorageKey() {
      return `statsig.failed_logs.${(0, t._DJB2)(this._sdkKey)}`;
    }
    _normalizeAndAppendEvent(S) {
      S.user &&
        ((S.user = Object.assign({}, S.user)), delete S.user.privateAttributes);
      const b = {},
        A = this._getCurrentPageUrl();
      A && (b.statsigMetadata = { currentPage: A });
      const E = Object.assign(Object.assign({}, S), b);
      (i.Log.debug('Enqueued Event:', E), this._queue.push(E));
    }
    _appendAndResetNonExposedChecks() {
      Object.keys(this._nonExposedChecks).length !== 0 &&
        (this._normalizeAndAppendEvent({
          eventName: 'statsig::non_exposed_checks',
          user: null,
          time: Date.now(),
          metadata: { checks: Object.assign({}, this._nonExposedChecks) },
        }),
        (this._nonExposedChecks = {}));
    }
    _getCurrentPageUrl() {
      var S;
      if (
        ((S = this._options) === null || S === void 0
          ? void 0
          : S.includeCurrentPageUrlWithEvents) !== !1
      )
        return (0, s._getCurrentPageUrlSafe)();
    }
    _startBackgroundFlushInterval() {
      var S, b;
      const A =
          (b =
            (S = this._options) === null || S === void 0
              ? void 0
              : S.loggingIntervalMs) !== null && b !== void 0
            ? b
            : d,
        E = setInterval(() => {
          const w = v[this._sdkKey];
          !w || w._flushIntervalId !== E
            ? clearInterval(E)
            : bl._safeFlushAndForget(this._sdkKey);
        }, A);
      this._flushIntervalId = E;
    }
  };
  return ((_a.EventLogger = _), _a);
}
var hg = {},
  Vb;
function Ff() {
  return (
    Vb ||
      ((Vb = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.StatsigMetadataProvider = n.SDK_VERSION = void 0),
          (n.SDK_VERSION = '3.29.1'));
        let e = { sdkVersion: n.SDK_VERSION, sdkType: 'js-mono' };
        n.StatsigMetadataProvider = {
          get: () => e,
          add: (t) => {
            e = Object.assign(Object.assign({}, e), t);
          },
        };
      })(hg)),
    hg
  );
}
var dg = {},
  Hb;
function nO() {
  return (
    Hb || ((Hb = 1), Object.defineProperty(dg, '__esModule', { value: !0 })),
    dg
  );
}
var Yr = {},
  Sa = {},
  Pc = {},
  Gb;
function dy() {
  if (Gb) return Pc;
  ((Gb = 1),
    Object.defineProperty(Pc, '__esModule', { value: !0 }),
    (Pc.getUUID = void 0));
  function n() {
    if (typeof crypto < 'u' && typeof crypto.randomUUID == 'function')
      return crypto.randomUUID();
    let e = new Date().getTime(),
      t =
        (typeof performance < 'u' &&
          performance.now &&
          performance.now() * 1e3) ||
        0;
    return `xxxxxxxx-xxxx-4xxx-${'89ab'[Math.floor(Math.random() * 4)]}xxx-xxxxxxxxxxxx`.replace(
      /[xy]/g,
      (r) => {
        let s = Math.random() * 16;
        return (
          e > 0
            ? ((s = (e + s) % 16 | 0), (e = Math.floor(e / 16)))
            : ((s = (t + s) % 16 | 0), (t = Math.floor(t / 16))),
          (r === 'x' ? s : (s & 7) | 8).toString(16)
        );
      }
    );
  }
  return ((Pc.getUUID = n), Pc);
}
var Wb;
function Zp() {
  if (Wb) return Sa;
  ((Wb = 1),
    Object.defineProperty(Sa, '__esModule', { value: !0 }),
    (Sa.getCookieName = Sa.StableID = void 0));
  const n = Kp(),
    e = fi(),
    t = Bo(),
    i = Ys(),
    r = dy(),
    s = {},
    a = {},
    o = {};
  Sa.StableID = {
    cookiesEnabled: !1,
    randomID: Math.random().toString(36),
    get: (p) => {
      if (o[p]) return null;
      if (s[p] != null) return s[p];
      let m = null;
      return (
        (m = h(p)),
        m != null
          ? ((s[p] = m), c(m, p), m)
          : ((m = u(p)),
            m == null && (m = (0, r.getUUID)()),
            c(m, p),
            d(m, p),
            (s[p] = m),
            m)
      );
    },
    setOverride: (p, m) => {
      ((s[m] = p), c(p, m), d(p, m));
    },
    _setCookiesEnabled: (p, m) => {
      a[p] = m;
    },
    _setDisabled: (p, m) => {
      o[p] = m;
    },
  };
  function l(p) {
    return `statsig.stable_id.${(0, n._getStorageKey)(p)}`;
  }
  function c(p, m) {
    const g = l(m);
    try {
      (0, i._setObjectInStorage)(g, p);
    } catch {
      e.Log.warn('Failed to save StableID to storage');
    }
  }
  function u(p) {
    const m = l(p);
    return (0, i._getObjectFromStorage)(m);
  }
  function h(p) {
    if (!a[p] || (0, t._getDocumentSafe)() == null) return null;
    const m = document.cookie.split(';');
    for (const g of m) {
      const [v, y] = g.trim().split('=');
      if (v === f(p)) return decodeURIComponent(y);
    }
    return null;
  }
  function d(p, m) {
    if (!a[m] || (0, t._getDocumentSafe)() == null) return;
    const g = new Date();
    (g.setFullYear(g.getFullYear() + 1),
      (document.cookie = `${f(m)}=${encodeURIComponent(p)}; expires=${g.toUTCString()}; path=/`));
  }
  function f(p) {
    return `statsig.stable_id.${(0, n._getStorageKey)(p)}`;
  }
  return ((Sa.getCookieName = f), Sa);
}
var wa = {},
  jb;
function yT() {
  if (jb) return wa;
  ((jb = 1),
    Object.defineProperty(wa, '__esModule', { value: !0 }),
    (wa._getFullUserHash = wa._normalizeUser = void 0));
  const n = cc(),
    e = fi();
  function t(r, s, a) {
    try {
      const o = JSON.parse(JSON.stringify(r));
      return (
        s != null && s.environment != null
          ? (o.statsigEnvironment = s.environment)
          : a != null && (o.statsigEnvironment = { tier: a }),
        o
      );
    } catch {
      return (
        e.Log.error('Failed to JSON.stringify user'),
        { statsigEnvironment: void 0 }
      );
    }
  }
  wa._normalizeUser = t;
  function i(r) {
    return r ? (0, n._DJB2Object)(r) : null;
  }
  return ((wa._getFullUserHash = i), wa);
}
var Dc = {},
  Xb;
function xT() {
  if (Xb) return Dc;
  ((Xb = 1),
    Object.defineProperty(Dc, '__esModule', { value: !0 }),
    (Dc._typedJsonParse = void 0));
  const n = fi();
  function e(t, i, r) {
    try {
      const s = JSON.parse(t);
      if (s && typeof s == 'object' && i in s) return s;
    } catch {}
    return (n.Log.error(`Failed to parse ${r}`), null);
  }
  return ((Dc._typedJsonParse = e), Dc);
}
var qb;
function iO() {
  if (qb) return Yr;
  qb = 1;
  var n =
    (Yr && Yr.__awaiter) ||
    function (d, f, p, m) {
      function g(v) {
        return v instanceof p
          ? v
          : new p(function (y) {
              y(v);
            });
      }
      return new (p || (p = Promise))(function (v, y) {
        function _(b) {
          try {
            S(m.next(b));
          } catch (A) {
            y(A);
          }
        }
        function x(b) {
          try {
            S(m.throw(b));
          } catch (A) {
            y(A);
          }
        }
        function S(b) {
          b.done ? v(b.value) : g(b.value).then(_, x);
        }
        S((m = m.apply(d, f || [])).next());
      });
    };
  (Object.defineProperty(Yr, '__esModule', { value: !0 }),
    (Yr._makeDataAdapterResult = Yr.DataAdapterCore = void 0));
  const e = fi(),
    t = Zp(),
    i = yT(),
    r = Ys(),
    s = xT(),
    a = 10,
    o = 8;
  let l = class {
    constructor(f, p) {
      ((this._adapterName = f),
        (this._cacheSuffix = p),
        (this._options = null),
        (this._sdkKey = null),
        (this._cacheLimit = a),
        (this._lastModifiedStoreKey = `statsig.last_modified_time.${p}`),
        (this._inMemoryCache = new u()));
    }
    attach(f, p, m) {
      ((this._sdkKey = f), (this._options = p));
    }
    getDataSync(f) {
      const p = f && (0, i._normalizeUser)(f, this._options),
        m = this._getCacheKey(p),
        g = this._inMemoryCache.get(m, p);
      if (g && this._getIsCacheValueValid(g)) return g;
      const v = this._loadFromCache(m);
      return v && this._getIsCacheValueValid(v)
        ? (this._inMemoryCache.add(m, v, this._cacheLimit),
          this._inMemoryCache.get(m, p))
        : null;
    }
    setData(f, p) {
      const m = p && (0, i._normalizeUser)(p, this._options),
        g = this._getCacheKey(m);
      this._inMemoryCache.add(g, c('Bootstrap', f, null, m), this._cacheLimit);
    }
    _getIsCacheValueValid(f) {
      return (
        f.stableID == null || f.stableID === t.StableID.get(this._getSdkKey())
      );
    }
    _getDataAsyncImpl(f, p, m) {
      return n(this, void 0, void 0, function* () {
        r.Storage.isReady() || (yield r.Storage.isReadyResolver());
        const g = f ?? this.getDataSync(p),
          v = [this._fetchAndPrepFromNetwork(g, p, m)];
        return (
          m?.timeoutMs &&
            v.push(
              new Promise((y) => setTimeout(y, m.timeoutMs)).then(
                () => (e.Log.debug('Fetching latest value timed out'), null)
              )
            ),
          yield Promise.race(v)
        );
      });
    }
    _prefetchDataImpl(f, p) {
      return n(this, void 0, void 0, function* () {
        const m = f && (0, i._normalizeUser)(f, this._options),
          g = this._getCacheKey(m),
          v = yield this._getDataAsyncImpl(null, m, p);
        v &&
          this._inMemoryCache.add(
            g,
            Object.assign(Object.assign({}, v), { source: 'Prefetch' }),
            this._cacheLimit
          );
      });
    }
    _fetchAndPrepFromNetwork(f, p, m) {
      return n(this, void 0, void 0, function* () {
        var g;
        const v = (g = f?.data) !== null && g !== void 0 ? g : null,
          y = f != null && this._isCachedResultValidFor204(f, p),
          _ = yield this._fetchFromNetwork(v, p, m, y);
        if (!_)
          return (e.Log.debug('No response returned for latest value'), null);
        const x = (0, s._typedJsonParse)(_, 'has_updates', 'Response'),
          S = this._getSdkKey(),
          b = t.StableID.get(S);
        let A = null;
        if (x?.has_updates === !0) A = c('Network', _, b, p);
        else if (v && x?.has_updates === !1)
          A = c('NetworkNotModified', v, b, p);
        else return null;
        const E = this._getCacheKey(p);
        return (
          this._inMemoryCache.add(E, A, this._cacheLimit),
          this._writeToCache(E, A),
          A
        );
      });
    }
    _getSdkKey() {
      return this._sdkKey != null
        ? this._sdkKey
        : (e.Log.error(`${this._adapterName} is not attached to a Client`), '');
    }
    _loadFromCache(f) {
      var p;
      const m =
        (p = r.Storage.getItem) === null || p === void 0
          ? void 0
          : p.call(r.Storage, f);
      if (m == null) return null;
      const g = (0, s._typedJsonParse)(m, 'source', 'Cached Result');
      return g
        ? Object.assign(Object.assign({}, g), { source: 'Cache' })
        : null;
    }
    _writeToCache(f, p) {
      const m = JSON.stringify(p);
      for (let g = 0; g < o; g++)
        try {
          r.Storage.setItem(f, m);
          break;
        } catch (v) {
          if (
            !(v instanceof Error) ||
            !(
              v.toString().includes('QuotaExceededError') ||
              v.toString().includes('QUOTA_EXCEEDED_ERR')
            ) ||
            this._cacheLimit <= 1
          )
            throw v;
          ((this._cacheLimit = Math.ceil(this._cacheLimit / 2)),
            this._runLocalStorageCacheEviction(f, this._cacheLimit - 1));
        }
      this._runLocalStorageCacheEviction(f);
    }
    _runLocalStorageCacheEviction(f, p = this._cacheLimit) {
      var m;
      const g =
        (m = (0, r._getObjectFromStorage)(this._lastModifiedStoreKey)) !==
          null && m !== void 0
          ? m
          : {};
      g[f] = Date.now();
      const v = h(g, p);
      for (const y of v) (delete g[y], r.Storage.removeItem(y));
      (0, r._setObjectInStorage)(this._lastModifiedStoreKey, g);
    }
  };
  Yr.DataAdapterCore = l;
  function c(d, f, p, m) {
    return {
      source: d,
      data: f,
      receivedAt: Date.now(),
      stableID: p,
      fullUserHash: (0, i._getFullUserHash)(m),
    };
  }
  Yr._makeDataAdapterResult = c;
  class u {
    constructor() {
      this._data = {};
    }
    get(f, p) {
      var m;
      const g = this._data[f],
        v = g?.stableID,
        y = (m = p?.customIDs) === null || m === void 0 ? void 0 : m.stableID;
      return y && v && y !== v
        ? (e.Log.warn("'StatsigUser.customIDs.stableID' mismatch"), null)
        : g;
    }
    add(f, p, m) {
      const g = h(this._data, m - 1);
      for (const v of g) delete this._data[v];
      this._data[f] = p;
    }
    merge(f) {
      this._data = Object.assign(Object.assign({}, this._data), f);
    }
  }
  function h(d, f) {
    const p = Object.keys(d);
    return p.length <= f
      ? []
      : f === 0
        ? p
        : p
            .sort((m, g) => {
              const v = d[m],
                y = d[g];
              return typeof v == 'object' && typeof y == 'object'
                ? v.receivedAt - y.receivedAt
                : v - y;
            })
            .slice(0, p.length - f);
  }
  return Yr;
}
var fg = {},
  Yb;
function rO() {
  return (
    Yb || ((Yb = 1), Object.defineProperty(fg, '__esModule', { value: !0 })),
    fg
  );
}
var Oc = {},
  Lc = {},
  Kb;
function fy() {
  if (Kb) return Lc;
  ((Kb = 1),
    Object.defineProperty(Lc, '__esModule', { value: !0 }),
    (Lc.SDKType = void 0));
  const n = {};
  let e;
  return (
    (Lc.SDKType = {
      _get: (t) => {
        var i;
        return (
          ((i = n[t]) !== null && i !== void 0 ? i : 'js-mono') + (e ?? '')
        );
      },
      _setClientType(t, i) {
        n[t] = i;
      },
      _setBindingType(t) {
        (!e || e === '-react') && (e = '-' + t);
      },
    }),
    Lc
  );
}
var Jb;
function bT() {
  return (
    Jb ||
      ((Jb = 1),
      (function (n) {
        var e =
          (Oc && Oc.__awaiter) ||
          function (h, d, f, p) {
            function m(g) {
              return g instanceof f
                ? g
                : new f(function (v) {
                    v(g);
                  });
            }
            return new (f || (f = Promise))(function (g, v) {
              function y(S) {
                try {
                  x(p.next(S));
                } catch (b) {
                  v(b);
                }
              }
              function _(S) {
                try {
                  x(p.throw(S));
                } catch (b) {
                  v(b);
                }
              }
              function x(S) {
                S.done ? g(S.value) : m(S.value).then(y, _);
              }
              x((p = p.apply(h, d || [])).next());
            });
          };
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.ErrorBoundary = n.EXCEPTION_ENDPOINT = void 0));
        const t = fi(),
          i = fy(),
          r = Ff();
        n.EXCEPTION_ENDPOINT = 'https://statsigapi.net/v1/sdk_exception';
        const s = '[Statsig] UnknownError';
        let a = class {
          constructor(d, f, p, m) {
            ((this._sdkKey = d),
              (this._options = f),
              (this._emitter = p),
              (this._lastSeenError = m),
              (this._seen = new Set()));
          }
          wrap(d, f) {
            try {
              const p = d;
              c(p).forEach((m) => {
                const g = p[m];
                '$EB' in g ||
                  ((p[m] = (...v) =>
                    this._capture(f ? `${f}:${m}` : m, () => g.apply(d, v))),
                  (p[m].$EB = !0));
              });
            } catch (p) {
              this._onError('eb:wrap', p);
            }
          }
          logError(d, f) {
            this._onError(d, f);
          }
          getLastSeenErrorAndReset() {
            const d = this._lastSeenError;
            return ((this._lastSeenError = void 0), d ?? null);
          }
          attachErrorIfNoneExists(d) {
            this._lastSeenError || (this._lastSeenError = o(d));
          }
          _capture(d, f) {
            try {
              const p = f();
              return p && p instanceof Promise
                ? p.catch((m) => this._onError(d, m))
                : p;
            } catch (p) {
              return (this._onError(d, p), null);
            }
          }
          _onError(d, f) {
            try {
              (t.Log.warn(`Caught error in ${d}`, { error: f }),
                e(this, void 0, void 0, function* () {
                  var m, g, v, y, _, x, S;
                  const b = f || Error(s),
                    A = b instanceof Error,
                    E = A ? b.name : 'No Name',
                    w = o(b);
                  if (((this._lastSeenError = w), this._seen.has(E))) return;
                  if (
                    (this._seen.add(E),
                    !(
                      (g =
                        (m = this._options) === null || m === void 0
                          ? void 0
                          : m.networkConfig) === null || g === void 0
                    ) && g.preventAllNetworkTraffic)
                  ) {
                    (v = this._emitter) === null ||
                      v === void 0 ||
                      v.call(this, { name: 'error', error: f, tag: d });
                    return;
                  }
                  const M = i.SDKType._get(this._sdkKey),
                    T = r.StatsigMetadataProvider.get(),
                    D = A ? b.stack : l(b),
                    L = Object.assign(
                      {
                        tag: d,
                        exception: E,
                        info: D,
                        statsigOptions: u(this._options),
                      },
                      Object.assign(Object.assign({}, T), { sdkType: M })
                    );
                  (yield (
                    (x =
                      (_ =
                        (y = this._options) === null || y === void 0
                          ? void 0
                          : y.networkConfig) === null || _ === void 0
                        ? void 0
                        : _.networkOverrideFunc) !== null && x !== void 0
                      ? x
                      : fetch
                  )(n.EXCEPTION_ENDPOINT, {
                    method: 'POST',
                    headers: {
                      'STATSIG-API-KEY': this._sdkKey,
                      'STATSIG-SDK-TYPE': String(M),
                      'STATSIG-SDK-VERSION': String(T.sdkVersion),
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(L),
                  }),
                    (S = this._emitter) === null ||
                      S === void 0 ||
                      S.call(this, { name: 'error', error: f, tag: d }));
                })
                  .then(() => {})
                  .catch(() => {}));
            } catch {}
          }
        };
        n.ErrorBoundary = a;
        function o(h) {
          return h instanceof Error
            ? h
            : typeof h == 'string'
              ? new Error(h)
              : new Error('An unknown error occurred.');
        }
        function l(h) {
          try {
            return JSON.stringify(h);
          } catch {
            return s;
          }
        }
        function c(h) {
          const d = new Set();
          let f = Object.getPrototypeOf(h);
          for (; f && f !== Object.prototype; )
            (Object.getOwnPropertyNames(f)
              .filter((p) => typeof f?.[p] == 'function')
              .forEach((p) => d.add(p)),
              (f = Object.getPrototypeOf(f)));
          return Array.from(d);
        }
        function u(h) {
          if (!h) return {};
          const d = {};
          return (
            Object.keys(h).forEach((f) => {
              const p = f,
                m = h[p];
              switch (typeof m) {
                case 'number':
                case 'bigint':
                case 'boolean':
                  d[String(p)] = m;
                  break;
                case 'string':
                  m.length < 50 ? (d[String(p)] = m) : (d[String(p)] = 'set');
                  break;
                case 'object':
                  p === 'environment'
                    ? (d.environment = m)
                    : p === 'networkConfig'
                      ? (d.networkConfig = m)
                      : (d[String(p)] = m != null ? 'set' : 'unset');
                  break;
              }
            }),
            d
          );
        }
      })(Oc)),
    Oc
  );
}
var pg = {},
  Qb;
function sO() {
  return (
    Qb || ((Qb = 1), Object.defineProperty(pg, '__esModule', { value: !0 })),
    pg
  );
}
var mg = {},
  Zb;
function aO() {
  return (
    Zb || ((Zb = 1), Object.defineProperty(mg, '__esModule', { value: !0 })),
    mg
  );
}
var gg = {},
  $b;
function oO() {
  return (
    $b || (($b = 1), Object.defineProperty(gg, '__esModule', { value: !0 })),
    gg
  );
}
var Ea = {},
  eS;
function ST() {
  if (eS) return Ea;
  ((eS = 1),
    Object.defineProperty(Ea, '__esModule', { value: !0 }),
    (Ea.createMemoKey = Ea.MemoPrefix = void 0),
    (Ea.MemoPrefix = {
      _gate: 'g',
      _dynamicConfig: 'c',
      _experiment: 'e',
      _configList: 'cl',
      _layer: 'l',
      _paramStore: 'p',
    }));
  const n = new Set([]),
    e = new Set(['userPersistedValues']);
  function t(i, r, s) {
    let a = `${i}|${r}`;
    if (!s) return a;
    for (const o of Object.keys(s)) {
      if (e.has(o)) return;
      n.has(o) ? (a += `|${o}=true`) : (a += `|${o}=${s[o]}`);
    }
    return a;
  }
  return ((Ea.createMemoKey = t), Ea);
}
var Aa = {},
  Kr = {},
  Ma = {},
  tS;
function lO() {
  if (tS) return Ma;
  tS = 1;
  var n =
    (Ma && Ma.__awaiter) ||
    function (o, l, c, u) {
      function h(d) {
        return d instanceof c
          ? d
          : new c(function (f) {
              f(d);
            });
      }
      return new (c || (c = Promise))(function (d, f) {
        function p(v) {
          try {
            g(u.next(v));
          } catch (y) {
            f(y);
          }
        }
        function m(v) {
          try {
            g(u.throw(v));
          } catch (y) {
            f(y);
          }
        }
        function g(v) {
          v.done ? d(v.value) : h(v.value).then(p, m);
        }
        g((u = u.apply(o, l || [])).next());
      });
    };
  (Object.defineProperty(Ma, '__esModule', { value: !0 }),
    (Ma._fetchTxtRecords = void 0));
  const e = new Uint8Array([
      0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 13, 102, 101, 97, 116, 117, 114, 101,
      97, 115, 115, 101, 116, 115, 3, 111, 114, 103, 0, 0, 16, 0, 1,
    ]),
    t = 'https://cloudflare-dns.com/dns-query',
    i = ['i', 'e', 'd'],
    r = 200;
  function s(o) {
    return n(this, void 0, void 0, function* () {
      const l = yield o(t, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/dns-message',
          Accept: 'application/dns-message',
        },
        body: e,
      });
      if (!l.ok) {
        const h = new Error('Failed to fetch TXT records from DNS');
        throw ((h.name = 'DnsTxtFetchError'), h);
      }
      const c = yield l.arrayBuffer(),
        u = new Uint8Array(c);
      return a(u);
    });
  }
  Ma._fetchTxtRecords = s;
  function a(o) {
    const l = o.findIndex(
      (u, h) =>
        h < r &&
        String.fromCharCode(u) === '=' &&
        i.includes(String.fromCharCode(o[h - 1]))
    );
    if (l === -1) {
      const u = new Error('Failed to parse TXT records from DNS');
      throw ((u.name = 'DnsTxtParseError'), u);
    }
    let c = '';
    for (let u = l - 1; u < o.length; u++) c += String.fromCharCode(o[u]);
    return c.split(',');
  }
  return Ma;
}
var nS;
function cO() {
  if (nS) return Kr;
  nS = 1;
  var n =
    (Kr && Kr.__awaiter) ||
    function (f, p, m, g) {
      function v(y) {
        return y instanceof m
          ? y
          : new m(function (_) {
              _(y);
            });
      }
      return new (m || (m = Promise))(function (y, _) {
        function x(A) {
          try {
            b(g.next(A));
          } catch (E) {
            _(E);
          }
        }
        function S(A) {
          try {
            b(g.throw(A));
          } catch (E) {
            _(E);
          }
        }
        function b(A) {
          A.done ? y(A.value) : v(A.value).then(x, S);
        }
        b((g = g.apply(f, p || [])).next());
      });
    };
  (Object.defineProperty(Kr, '__esModule', { value: !0 }),
    (Kr._isDomainFailure = Kr.NetworkFallbackResolver = void 0));
  const e = lO(),
    t = cc(),
    i = fi(),
    r = Ys(),
    s = 10080 * 60 * 1e3,
    a = 14400 * 1e3;
  let o = class {
    constructor(p) {
      var m;
      ((this._fallbackInfo = null),
        (this._errorBoundary = null),
        (this._dnsQueryCooldowns = {}),
        (this._networkOverrideFunc =
          (m = p.networkConfig) === null || m === void 0
            ? void 0
            : m.networkOverrideFunc));
    }
    setErrorBoundary(p) {
      this._errorBoundary = p;
    }
    tryBumpExpiryTime(p, m) {
      var g;
      const v =
        (g = this._fallbackInfo) === null || g === void 0
          ? void 0
          : g[m.endpoint];
      v &&
        ((v.expiryTime = Date.now() + s),
        u(
          p,
          Object.assign(Object.assign({}, this._fallbackInfo), {
            [m.endpoint]: v,
          })
        ));
    }
    getActiveFallbackUrl(p, m) {
      var g, v;
      if (m.customUrl != null && m.fallbackUrls != null) return null;
      let y = this._fallbackInfo;
      y == null &&
        ((y = (g = h(p)) !== null && g !== void 0 ? g : {}),
        (this._fallbackInfo = y));
      const _ = y[m.endpoint];
      return !_ ||
        Date.now() > ((v = _.expiryTime) !== null && v !== void 0 ? v : 0) ||
        m.getChecksum() !== _.urlConfigChecksum
        ? (delete y[m.endpoint],
          (this._fallbackInfo = y),
          u(p, this._fallbackInfo),
          null)
        : _.url
          ? _.url
          : null;
    }
    tryFetchUpdatedFallbackInfo(p, m, g, v) {
      return n(this, void 0, void 0, function* () {
        var y, _;
        try {
          if (!l(g, v)) return !1;
          const S =
              m.customUrl == null && m.fallbackUrls == null
                ? yield this._tryFetchFallbackUrlsFromNetwork(m)
                : m.fallbackUrls,
            b = this._pickNewFallbackUrl(
              (y = this._fallbackInfo) === null || y === void 0
                ? void 0
                : y[m.endpoint],
              S
            );
          return b ? (this._updateFallbackInfoWithNewUrl(p, m, b), !0) : !1;
        } catch (x) {
          return (
            (_ = this._errorBoundary) === null ||
              _ === void 0 ||
              _.logError('tryFetchUpdatedFallbackInfo', x),
            !1
          );
        }
      });
    }
    _updateFallbackInfoWithNewUrl(p, m, g) {
      var v, y, _;
      const x = {
          urlConfigChecksum: m.getChecksum(),
          url: g,
          expiryTime: Date.now() + s,
          previous: [],
        },
        S = m.endpoint,
        b = (v = this._fallbackInfo) === null || v === void 0 ? void 0 : v[S];
      (b && x.previous.push(...b.previous),
        x.previous.length > 10 && (x.previous = []));
      const A =
        (_ =
          (y = this._fallbackInfo) === null || y === void 0 ? void 0 : y[S]) ===
          null || _ === void 0
          ? void 0
          : _.url;
      (A != null && x.previous.push(A),
        (this._fallbackInfo = Object.assign(
          Object.assign({}, this._fallbackInfo),
          { [S]: x }
        )),
        u(p, this._fallbackInfo));
    }
    _tryFetchFallbackUrlsFromNetwork(p) {
      return n(this, void 0, void 0, function* () {
        var m;
        const g = this._dnsQueryCooldowns[p.endpoint];
        if (g && Date.now() < g) return null;
        this._dnsQueryCooldowns[p.endpoint] = Date.now() + a;
        const v = [],
          y = yield (0, e._fetchTxtRecords)(
            (m = this._networkOverrideFunc) !== null && m !== void 0 ? m : fetch
          ),
          _ = d(p.defaultUrl);
        for (const x of y) {
          if (!x.startsWith(p.endpointDnsKey + '=')) continue;
          const S = x.split('=');
          if (S.length > 1) {
            let b = S[1];
            (b.endsWith('/') && (b = b.slice(0, -1)),
              v.push(`https://${b}${_}`));
          }
        }
        return v;
      });
    }
    _pickNewFallbackUrl(p, m) {
      var g;
      if (m == null) return null;
      const v = new Set((g = p?.previous) !== null && g !== void 0 ? g : []),
        y = p?.url;
      let _ = null;
      for (const x of m) {
        const S = x.endsWith('/') ? x.slice(0, -1) : x;
        if (!v.has(x) && S !== y) {
          _ = S;
          break;
        }
      }
      return _;
    }
  };
  Kr.NetworkFallbackResolver = o;
  function l(f, p) {
    var m;
    const g = (m = f?.toLowerCase()) !== null && m !== void 0 ? m : '';
    return (
      p ||
      g.includes('uncaught exception') ||
      g.includes('failed to fetch') ||
      g.includes('networkerror when attempting to fetch resource')
    );
  }
  Kr._isDomainFailure = l;
  function c(f) {
    return `statsig.network_fallback.${(0, t._DJB2)(f)}`;
  }
  function u(f, p) {
    const m = c(f);
    if (!p || Object.keys(p).length === 0) {
      r.Storage.removeItem(m);
      return;
    }
    r.Storage.setItem(m, JSON.stringify(p));
  }
  function h(f) {
    const p = c(f),
      m = r.Storage.getItem(p);
    if (!m) return null;
    try {
      return JSON.parse(m);
    } catch {
      return (i.Log.error('Failed to parse FallbackInfo'), null);
    }
  }
  function d(f) {
    try {
      return new URL(f).pathname;
    } catch {
      return null;
    }
  }
  return Kr;
}
var Uc = {},
  iS;
function wT() {
  if (iS) return Uc;
  ((iS = 1),
    Object.defineProperty(Uc, '__esModule', { value: !0 }),
    (Uc.SDKFlags = void 0));
  const n = {};
  return (
    (Uc.SDKFlags = {
      setFlags: (e, t) => {
        n[e] = t;
      },
      get: (e, t) => {
        var i, r;
        return (r = (i = n[e]) === null || i === void 0 ? void 0 : i[t]) !==
          null && r !== void 0
          ? r
          : !1;
      },
    }),
    Uc
  );
}
var vg = {},
  rS;
function py() {
  return (
    rS ||
      ((rS = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.StatsigSession = n.SessionID = void 0));
        const e = Ws(),
          t = Kp(),
          i = fi(),
          r = Ys(),
          s = dy(),
          a = 1800 * 1e3,
          o = 14400 * 1e3,
          l = {};
        ((n.SessionID = { get: (y) => n.StatsigSession.get(y).data.sessionID }),
          (n.StatsigSession = {
            get: (y) => {
              l[y] == null && (l[y] = c(y));
              const _ = l[y];
              return h(_);
            },
            overrideInitialSessionID: (y, _) => {
              l[_] = u(y, _);
            },
          }));
        function c(y) {
          let _ = v(y);
          const x = Date.now();
          return (
            _ ||
              (_ = {
                sessionID: (0, s.getUUID)(),
                startTime: x,
                lastUpdate: x,
              }),
            { data: _, sdkKey: y }
          );
        }
        function u(y, _) {
          const x = Date.now();
          return {
            data: { sessionID: y, startTime: x, lastUpdate: x },
            sdkKey: _,
          };
        }
        function h(y) {
          const _ = Date.now(),
            x = y.data,
            S = y.sdkKey;
          if (f(x) || p(x)) {
            ((x.sessionID = (0, s.getUUID)()), (x.startTime = _));
            const A = __STATSIG__ == null ? void 0 : __STATSIG__.instance(S);
            A && A.$emt({ name: 'session_expired' });
          }
          ((x.lastUpdate = _),
            g(x, y.sdkKey),
            clearTimeout(y.idleTimeoutID),
            clearTimeout(y.ageTimeoutID));
          const b = _ - x.startTime;
          return (
            (y.idleTimeoutID = d(S, a)),
            (y.ageTimeoutID = d(S, o - b)),
            y
          );
        }
        function d(y, _) {
          return setTimeout(() => {
            var x;
            const S =
              (x = (0, e._getStatsigGlobal)()) === null || x === void 0
                ? void 0
                : x.instance(y);
            S && S.$emt({ name: 'session_expired' });
          }, _);
        }
        function f({ lastUpdate: y }) {
          return Date.now() - y > a;
        }
        function p({ startTime: y }) {
          return Date.now() - y > o;
        }
        function m(y) {
          return `statsig.session_id.${(0, t._getStorageKey)(y)}`;
        }
        function g(y, _) {
          const x = m(_);
          try {
            (0, r._setObjectInStorage)(x, y);
          } catch {
            i.Log.warn('Failed to save SessionID');
          }
        }
        function v(y) {
          const _ = m(y);
          return (0, r._getObjectFromStorage)(_);
        }
      })(vg)),
    vg
  );
}
var kc = {},
  sS;
function ET() {
  return (
    sS ||
      ((sS = 1),
      Object.defineProperty(kc, '__esModule', { value: !0 }),
      (kc.ErrorTag = void 0),
      (kc.ErrorTag = { NetworkError: 'NetworkError' })),
    kc
  );
}
var aS;
function uO() {
  if (aS) return Aa;
  aS = 1;
  var n =
    (Aa && Aa.__awaiter) ||
    function (z, C, N, U) {
      function W(G) {
        return G instanceof N
          ? G
          : new N(function (ne) {
              ne(G);
            });
      }
      return new (N || (N = Promise))(function (G, ne) {
        function ve(Oe) {
          try {
            Ae(U.next(Oe));
          } catch (Z) {
            ne(Z);
          }
        }
        function Se(Oe) {
          try {
            Ae(U.throw(Oe));
          } catch (Z) {
            ne(Z);
          }
        }
        function Ae(Oe) {
          Oe.done ? G(Oe.value) : W(Oe.value).then(ve, Se);
        }
        Ae((U = U.apply(z, C || [])).next());
      });
    };
  (Object.defineProperty(Aa, '__esModule', { value: !0 }),
    (Aa.NetworkCore = void 0),
    Ws());
  const e = Ws(),
    t = Sv(),
    i = fi(),
    r = Jp(),
    s = cO(),
    a = wT(),
    o = fy(),
    l = Bo(),
    c = py(),
    u = Zp(),
    h = ET(),
    d = Ff(),
    f = Qp(),
    p = hy(),
    m = 1e4,
    g = 500,
    v = 3e4,
    y = 1e3,
    _ = 50,
    x = _ / y,
    S = new Set([408, 500, 502, 503, 504, 522, 524, 599]);
  let b = class {
    constructor(C, N) {
      ((this._emitter = N),
        (this._errorBoundary = null),
        (this._timeout = m),
        (this._netConfig = {}),
        (this._options = {}),
        (this._leakyBucket = {}),
        (this._lastUsedInitUrl = null),
        C && (this._options = C),
        this._options.networkConfig &&
          (this._netConfig = this._options.networkConfig),
        this._netConfig.networkTimeoutMs &&
          (this._timeout = this._netConfig.networkTimeoutMs),
        (this._fallbackResolver = new s.NetworkFallbackResolver(this._options)),
        this.setLogEventCompressionMode(this._getLogEventCompressionMode(C)));
    }
    setLogEventCompressionMode(C) {
      this._options.logEventCompressionMode = C;
    }
    setErrorBoundary(C) {
      ((this._errorBoundary = C),
        this._errorBoundary.wrap(this),
        this._errorBoundary.wrap(this._fallbackResolver),
        this._fallbackResolver.setErrorBoundary(C));
    }
    isBeaconSupported() {
      return (
        typeof navigator < 'u' && typeof navigator.sendBeacon == 'function'
      );
    }
    getLastUsedInitUrlAndReset() {
      const C = this._lastUsedInitUrl;
      return ((this._lastUsedInitUrl = null), C);
    }
    beacon(C) {
      if (!A(C)) return !1;
      const N = this._getInternalRequestArgs('POST', C),
        U = this._getPopulatedURL(N),
        W = navigator;
      return W.sendBeacon.bind(W)(U, N.body);
    }
    post(C) {
      return n(this, void 0, void 0, function* () {
        const N = this._getInternalRequestArgs('POST', C);
        return (
          this._tryEncodeBody(N),
          yield this._tryToCompressBody(N),
          this._sendRequest(N)
        );
      });
    }
    get(C) {
      const N = this._getInternalRequestArgs('GET', C);
      return this._sendRequest(N);
    }
    _sendRequest(C) {
      return n(this, void 0, void 0, function* () {
        var N, U, W, G;
        if (!A(C) || this._netConfig.preventAllNetworkTraffic) return null;
        const { method: ne, body: ve, retries: Se, attempt: Ae } = C,
          Oe = C.urlConfig.endpoint;
        if (this._isRateLimited(Oe))
          return (
            i.Log.warn(
              `Request to ${Oe} was blocked because you are making requests too frequently.`
            ),
            null
          );
        const Z = Ae ?? 1;
        let J = !1;
        const de = this._getPopulatedURL(C);
        let fe = null;
        const K = (0, p._isUnloading)();
        try {
          const oe = {
            method: ne,
            body: ve,
            headers: Object.assign({}, C.headers),
            priority: C.priority,
            keepalive: K,
          };
          D(C, Z);
          const he = this._leakyBucket[Oe];
          he &&
            ((he.lastRequestTime = Date.now()), (this._leakyBucket[Oe] = he));
          const xe =
            (N = this._netConfig.networkOverrideFunc) !== null && N !== void 0
              ? N
              : fetch;
          let ee;
          if (
            ((fe = yield Promise.race([
              xe(de, oe).finally(() => clearTimeout(ee)),
              new Promise((me, ye) => {
                ee = setTimeout(() => {
                  ((J = !0),
                    ye(new Error(`Timeout of ${this._timeout}ms expired.`)));
                }, this._timeout);
              }),
            ])),
            !fe.ok)
          ) {
            const me = yield fe.text().catch(() => 'No Text'),
              ye = new Error(`NetworkError: ${de} ${me}`);
            throw ((ye.name = 'NetworkError'), ye);
          }
          const B = yield fe.text();
          return (
            L(C, fe, Z, B),
            this._fallbackResolver.tryBumpExpiryTime(C.sdkKey, C.urlConfig),
            { body: B, code: fe.status }
          );
        } catch (oe) {
          const he = M(oe),
            xe = T(he ?? '', J);
          if (
            (L(C, fe, Z, '', oe),
            (yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(
              C.sdkKey,
              C.urlConfig,
              he,
              xe
            )) &&
              (C.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(
                C.sdkKey,
                C.urlConfig
              )),
            !Se ||
              Z > Se ||
              !S.has((U = fe?.status) !== null && U !== void 0 ? U : 500))
          ) {
            (W = this._emitter) === null ||
              W === void 0 ||
              W.call(this, {
                name: 'error',
                error: oe,
                tag: h.ErrorTag.NetworkError,
                requestArgs: C,
              });
            const B = `A networking error occurred during ${ne} request to ${de}.`;
            return (
              i.Log.error(B, he, oe),
              (G = this._errorBoundary) === null ||
                G === void 0 ||
                G.attachErrorIfNoneExists(B),
              null
            );
          }
          return (
            yield O(Z),
            this._sendRequest(
              Object.assign(Object.assign({}, C), {
                retries: Se,
                attempt: Z + 1,
              })
            )
          );
        }
      });
    }
    _getLogEventCompressionMode(C) {
      let N = C?.logEventCompressionMode;
      return (
        !N &&
          C?.disableCompression === !0 &&
          (N = f.LogEventCompressionMode.Disabled),
        N || (N = f.LogEventCompressionMode.Enabled),
        N
      );
    }
    _isRateLimited(C) {
      var N;
      const U = Date.now(),
        W =
          (N = this._leakyBucket[C]) !== null && N !== void 0
            ? N
            : { count: 0, lastRequestTime: U },
        G = U - W.lastRequestTime,
        ne = Math.floor(G * x);
      return (
        (W.count = Math.max(0, W.count - ne)),
        W.count >= _
          ? !0
          : ((W.count += 1),
            (W.lastRequestTime = U),
            (this._leakyBucket[C] = W),
            !1)
      );
    }
    _getPopulatedURL(C) {
      var N;
      const U =
        (N = C.fallbackUrl) !== null && N !== void 0 ? N : C.urlConfig.getUrl();
      (C.urlConfig.endpoint === r.Endpoint._initialize ||
        C.urlConfig.endpoint === r.Endpoint._download_config_specs) &&
        (this._lastUsedInitUrl = U);
      const W = Object.assign(
          {
            [r.NetworkParam.SdkKey]: C.sdkKey,
            [r.NetworkParam.SdkType]: o.SDKType._get(C.sdkKey),
            [r.NetworkParam.SdkVersion]: d.SDK_VERSION,
            [r.NetworkParam.Time]: String(Date.now()),
            [r.NetworkParam.SessionID]: c.SessionID.get(C.sdkKey),
          },
          C.params
        ),
        G = Object.keys(W)
          .map((ne) => `${encodeURIComponent(ne)}=${encodeURIComponent(W[ne])}`)
          .join('&');
      return `${U}${G ? `?${G}` : ''}`;
    }
    _tryEncodeBody(C) {
      var N;
      const U = (0, l._getWindowSafe)(),
        W = C.body;
      if (
        !(
          !C.isStatsigEncodable ||
          this._options.disableStatsigEncoding ||
          typeof W != 'string' ||
          (0, e._getStatsigGlobalFlag)('no-encode') != null ||
          !U?.btoa
        )
      )
        try {
          ((C.body = U.btoa(W).split('').reverse().join('')),
            (C.params = Object.assign(
              Object.assign(
                {},
                (N = C.params) !== null && N !== void 0 ? N : {}
              ),
              { [r.NetworkParam.StatsigEncoded]: '1' }
            )));
        } catch (G) {
          i.Log.warn(`Request encoding failed for ${C.urlConfig.getUrl()}`, G);
        }
    }
    _tryToCompressBody(C) {
      return n(this, void 0, void 0, function* () {
        var N;
        const U = C.body;
        if (!(typeof U != 'string' || !w(C, this._options)))
          try {
            const W = new TextEncoder().encode(U),
              G = new CompressionStream('gzip'),
              ne = G.writable.getWriter();
            (ne.write(W).catch(i.Log.error), ne.close().catch(i.Log.error));
            const ve = G.readable.getReader(),
              Se = [];
            let Ae;
            for (; !(Ae = yield ve.read()).done; ) Se.push(Ae.value);
            const Oe = Se.reduce((de, fe) => de + fe.length, 0),
              Z = new Uint8Array(Oe);
            let J = 0;
            for (const de of Se) (Z.set(de, J), (J += de.length));
            ((C.body = Z),
              (C.params = Object.assign(
                Object.assign(
                  {},
                  (N = C.params) !== null && N !== void 0 ? N : {}
                ),
                { [r.NetworkParam.IsGzipped]: '1' }
              )));
          } catch (W) {
            i.Log.warn(
              `Request compression failed for ${C.urlConfig.getUrl()}`,
              W
            );
          }
      });
    }
    _getInternalRequestArgs(C, N) {
      const U = this._fallbackResolver.getActiveFallbackUrl(
          N.sdkKey,
          N.urlConfig
        ),
        W = Object.assign(Object.assign({}, N), { method: C, fallbackUrl: U });
      return ('data' in N && E(W, N.data), W);
    }
  };
  Aa.NetworkCore = b;
  const A = (z) =>
      z.sdkKey
        ? !0
        : (i.Log.warn('Unable to make request without an SDK key'), !1),
    E = (z, C) => {
      const { sdkKey: N, fallbackUrl: U } = z,
        W = u.StableID.get(N),
        G = c.SessionID.get(N),
        ne = o.SDKType._get(N);
      z.body = JSON.stringify(
        Object.assign(Object.assign({}, C), {
          statsigMetadata: Object.assign(
            Object.assign({}, d.StatsigMetadataProvider.get()),
            { stableID: W, sessionID: G, sdkType: ne, fallbackUrl: U }
          ),
        })
      );
    };
  function w(z, C) {
    if (
      !z.isCompressable ||
      (0, e._getStatsigGlobalFlag)('no-compress') != null ||
      typeof CompressionStream > 'u' ||
      typeof TextEncoder > 'u'
    )
      return !1;
    const N = z.urlConfig.customUrl != null || z.urlConfig.fallbackUrls != null,
      U = a.SDKFlags.get(z.sdkKey, 'enable_log_event_compression') === !0;
    switch (C.logEventCompressionMode) {
      case f.LogEventCompressionMode.Disabled:
        return !1;
      case f.LogEventCompressionMode.Enabled:
        return !(N && !U);
      case f.LogEventCompressionMode.Forced:
        return !0;
      default:
        return !1;
    }
  }
  function M(z) {
    return typeof z == 'string'
      ? z
      : z instanceof Error
        ? `${z.name}: ${z.message}`
        : 'Unknown Error';
  }
  function T(z, C) {
    return z.includes('Timeout') || C;
  }
  function D(z, C) {
    z.urlConfig.endpoint === r.Endpoint._initialize &&
      t.Diagnostics._markInitNetworkReqStart(z.sdkKey, { attempt: C });
  }
  function L(z, C, N, U, W) {
    z.urlConfig.endpoint === r.Endpoint._initialize &&
      t.Diagnostics._markInitNetworkReqEnd(
        z.sdkKey,
        t.Diagnostics._getDiagnosticsData(C, N, U, W)
      );
  }
  function O(z) {
    return n(this, void 0, void 0, function* () {
      yield new Promise((C) => setTimeout(C, Math.min(g * (z * z), v)));
    });
  }
  return Aa;
}
var _g = {},
  oS;
function hO() {
  return (
    oS || ((oS = 1), Object.defineProperty(_g, '__esModule', { value: !0 })),
    _g
  );
}
var yg = {},
  lS;
function dO() {
  return (
    lS || ((lS = 1), Object.defineProperty(yg, '__esModule', { value: !0 })),
    yg
  );
}
var xg = {},
  cS;
function fO() {
  return (
    cS ||
      ((cS = 1),
      (function (n) {
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n._fastApproxSizeOf = void 0));
        const e = 2,
          t = 1,
          i = (r, s) => {
            let a = 0;
            const o = Object.keys(r);
            for (let l = 0; l < o.length; l++) {
              const c = o[l],
                u = r[c];
              if (
                ((a += c.length),
                typeof u == 'object' && u !== null
                  ? (a += (0, n._fastApproxSizeOf)(u, s) + e)
                  : (a += String(u).length + t),
                a >= s)
              )
                return a;
            }
            return a;
          };
        n._fastApproxSizeOf = i;
      })(xg)),
    xg
  );
}
var Ta = {},
  uS;
function pO() {
  if (uS) return Ta;
  uS = 1;
  var n =
    (Ta && Ta.__awaiter) ||
    function (p, m, g, v) {
      function y(_) {
        return _ instanceof g
          ? _
          : new g(function (x) {
              x(_);
            });
      }
      return new (g || (g = Promise))(function (_, x) {
        function S(E) {
          try {
            A(v.next(E));
          } catch (w) {
            x(w);
          }
        }
        function b(E) {
          try {
            A(v.throw(E));
          } catch (w) {
            x(w);
          }
        }
        function A(E) {
          E.done ? _(E.value) : y(E.value).then(S, b);
        }
        A((v = v.apply(p, m || [])).next());
      });
    };
  (Object.defineProperty(Ta, '__esModule', { value: !0 }),
    (Ta.StatsigClientBase = void 0),
    Ws());
  const e = Ws(),
    t = bT(),
    i = _T(),
    r = fi(),
    s = ST(),
    a = Bo(),
    o = py(),
    l = Zp(),
    c = Qp(),
    u = Ys(),
    h = 3e3;
  let d = class {
    constructor(m, g, v, y) {
      var _, x, S, b;
      ((this.loadingStatus = 'Uninitialized'),
        (this._initializePromise = null),
        (this._listeners = {}));
      const A = this.$emt.bind(this);
      (y?.logLevel != null && (r.Log.level = y.logLevel),
        y?.disableStorage && u.Storage._setDisabled(!0),
        y?.initialSessionID &&
          o.StatsigSession.overrideInitialSessionID(y.initialSessionID, m),
        y?.storageProvider && u.Storage._setProvider(y.storageProvider),
        y?.enableCookies && l.StableID._setCookiesEnabled(m, y.enableCookies),
        y?.disableStableID && l.StableID._setDisabled(m, !0),
        (this._sdkKey = m),
        (this._options = y ?? {}),
        (this._memoCache = {}),
        (this.overrideAdapter =
          (_ = y?.overrideAdapter) !== null && _ !== void 0 ? _ : null),
        (this._logger = new i.EventLogger(m, A, v, y)),
        (this._errorBoundary = new t.ErrorBoundary(m, y, A)),
        this._errorBoundary.wrap(this),
        this._errorBoundary.wrap(g),
        this._errorBoundary.wrap(this._logger),
        v.setErrorBoundary(this._errorBoundary),
        (this.dataAdapter = g),
        this.dataAdapter.attach(m, y, v),
        (this.storageProvider = u.Storage),
        (b =
          (S =
            (x = this.overrideAdapter) === null || x === void 0
              ? void 0
              : x.loadFromStorage) === null || S === void 0
            ? void 0
            : S.call(x)) === null ||
          b === void 0 ||
          b.catch((E) =>
            this._errorBoundary.logError('OA::loadFromStorage', E)
          ),
        this._primeReadyRipcord(),
        f(m, this));
    }
    updateRuntimeOptions(m) {
      (m.loggingEnabled
        ? ((this._options.loggingEnabled = m.loggingEnabled),
          this._logger.setLoggingEnabled(m.loggingEnabled))
        : m.disableLogging != null &&
          ((this._options.disableLogging = m.disableLogging),
          this._logger.setLoggingEnabled(
            m.disableLogging ? 'disabled' : 'browser-only'
          )),
        m.disableStorage != null &&
          ((this._options.disableStorage = m.disableStorage),
          u.Storage._setDisabled(m.disableStorage)),
        m.enableCookies != null &&
          ((this._options.enableCookies = m.enableCookies),
          l.StableID._setCookiesEnabled(this._sdkKey, m.enableCookies)),
        m.logEventCompressionMode
          ? this._logger.setLogEventCompressionMode(m.logEventCompressionMode)
          : m.disableCompression &&
            this._logger.setLogEventCompressionMode(
              c.LogEventCompressionMode.Disabled
            ));
    }
    flush() {
      return this._logger.flush();
    }
    shutdown() {
      return n(this, void 0, void 0, function* () {
        (this.$emt({ name: 'pre_shutdown' }),
          this._setStatus('Uninitialized', null),
          (this._initializePromise = null),
          yield this._logger.stop());
      });
    }
    on(m, g) {
      (this._listeners[m] || (this._listeners[m] = []),
        this._listeners[m].push(g));
    }
    off(m, g) {
      if (this._listeners[m]) {
        const v = this._listeners[m].indexOf(g);
        v !== -1 && this._listeners[m].splice(v, 1);
      }
    }
    $on(m, g) {
      ((g.__isInternal = !0), this.on(m, g));
    }
    $emt(m) {
      var g;
      const v = (y) => {
        try {
          y(m);
        } catch (_) {
          if (y.__isInternal === !0) {
            this._errorBoundary.logError(`__emit:${m.name}`, _);
            return;
          }
          r.Log.error(
            'An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.',
            m
          );
        }
      };
      (this._listeners[m.name] && this._listeners[m.name].forEach((y) => v(y)),
        (g = this._listeners['*']) === null || g === void 0 || g.forEach(v));
    }
    _setStatus(m, g) {
      ((this.loadingStatus = m),
        (this._memoCache = {}),
        this.$emt({ name: 'values_updated', status: m, values: g }));
    }
    _enqueueExposure(m, g, v) {
      if (v?.disableExposureLog === !0) {
        this._logger.incrementNonExposureCount(m);
        return;
      }
      this._logger.enqueue(g);
    }
    _memoize(m, g) {
      return (v, y) => {
        if (this._options.disableEvaluationMemoization) return g(v, y);
        const _ = (0, s.createMemoKey)(m, v, y);
        return _
          ? (_ in this._memoCache ||
              (Object.keys(this._memoCache).length >= h &&
                (this._memoCache = {}),
              (this._memoCache[_] = g(v, y))),
            this._memoCache[_])
          : g(v, y);
      };
    }
  };
  Ta.StatsigClientBase = d;
  function f(p, m) {
    var g;
    if ((0, a._isServerEnv)()) return;
    const v = (0, e._getStatsigGlobal)(),
      y = (g = v.instances) !== null && g !== void 0 ? g : {},
      _ = m;
    (y[p] != null &&
      r.Log.warn(
        'Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.'
      ),
      (y[p] = _),
      v.firstInstance || (v.firstInstance = _),
      (v.instances = y),
      (__STATSIG__ = v));
  }
  return Ta;
}
var Bc = {},
  hS;
function mO() {
  return (
    hS ||
      ((hS = 1),
      Object.defineProperty(Bc, '__esModule', { value: !0 }),
      (Bc.DataAdapterCachePrefix = void 0),
      (Bc.DataAdapterCachePrefix = 'statsig.cached')),
    Bc
  );
}
var bg = {},
  dS;
function gO() {
  return (
    dS || ((dS = 1), Object.defineProperty(bg, '__esModule', { value: !0 })),
    bg
  );
}
var si = {},
  fS;
function vO() {
  if (fS) return si;
  ((fS = 1),
    Object.defineProperty(si, '__esModule', { value: !0 }),
    (si._makeTypedGet =
      si._mergeOverride =
      si._makeLayer =
      si._makeExperiment =
      si._makeDynamicConfig =
      si._makeFeatureGate =
        void 0));
  const n = fi(),
    e = uy();
  function t(c, u, h, d) {
    var f;
    return {
      name: c,
      details: u,
      ruleID: (f = h?.rule_id) !== null && f !== void 0 ? f : '',
      __evaluation: h,
      value: d,
    };
  }
  function i(c, u, h) {
    var d;
    return Object.assign(Object.assign({}, t(c, u, h, h?.value === !0)), {
      idType: (d = h?.id_type) !== null && d !== void 0 ? d : null,
    });
  }
  si._makeFeatureGate = i;
  function r(c, u, h) {
    var d, f;
    const p = (d = h?.value) !== null && d !== void 0 ? d : {};
    return Object.assign(Object.assign({}, t(c, u, h, p)), {
      idType: (f = h?.id_type) !== null && f !== void 0 ? f : null,
      get: l(c, h?.value),
    });
  }
  si._makeDynamicConfig = r;
  function s(c, u, h) {
    var d;
    const f = r(c, u, h);
    return Object.assign(Object.assign({}, f), {
      groupName: (d = h?.group_name) !== null && d !== void 0 ? d : null,
    });
  }
  si._makeExperiment = s;
  function a(c, u, h, d) {
    var f, p;
    return Object.assign(Object.assign({}, t(c, u, h, void 0)), {
      get: l(c, h?.value, d),
      groupName: (f = h?.group_name) !== null && f !== void 0 ? f : null,
      __value: (p = h?.value) !== null && p !== void 0 ? p : {},
    });
  }
  si._makeLayer = a;
  function o(c, u, h, d) {
    return Object.assign(Object.assign(Object.assign({}, c), u), {
      get: l(c.name, h, d),
    });
  }
  si._mergeOverride = o;
  function l(c, u, h) {
    return (d, f) => {
      var p;
      const m = (p = u?.[d]) !== null && p !== void 0 ? p : null;
      return m == null
        ? (f ?? null)
        : f != null && !(0, e._isTypeMatch)(m, f)
          ? (n.Log.warn(
              `Parameter type mismatch. '${c}.${d}' was found to be type '${typeof m}' but fallback/return type is '${typeof f}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`
            ),
            f ?? null)
          : (h?.(d), m);
    };
  }
  return ((si._makeTypedGet = l), si);
}
var Sg = {},
  pS;
function _O() {
  return (
    pS || ((pS = 1), Object.defineProperty(Sg, '__esModule', { value: !0 })),
    Sg
  );
}
var Ca = {},
  mS;
function yO() {
  if (mS) return Ca;
  ((mS = 1),
    Object.defineProperty(Ca, '__esModule', { value: !0 }),
    (Ca.UPDATE_DETAIL_ERROR_MESSAGES = Ca.createUpdateDetails = void 0));
  const n = (e, t, i, r, s, a) => ({
    duration: i,
    source: t,
    success: e,
    error: r,
    sourceUrl: s,
    warnings: a,
  });
  return (
    (Ca.createUpdateDetails = n),
    (Ca.UPDATE_DETAIL_ERROR_MESSAGES = {
      NO_NETWORK_DATA:
        'No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error.',
    }),
    Ca
  );
}
var gS;
function Vr() {
  return (
    gS ||
      ((gS = 1),
      (function (n) {
        var e =
            (va && va.__createBinding) ||
            (Object.create
              ? function (c, u, h, d) {
                  d === void 0 && (d = h);
                  var f = Object.getOwnPropertyDescriptor(u, h);
                  ((!f ||
                    ('get' in f
                      ? !u.__esModule
                      : f.writable || f.configurable)) &&
                    (f = {
                      enumerable: !0,
                      get: function () {
                        return u[h];
                      },
                    }),
                    Object.defineProperty(c, d, f));
                }
              : function (c, u, h, d) {
                  (d === void 0 && (d = h), (c[d] = u[h]));
                }),
          t =
            (va && va.__exportStar) ||
            function (c, u) {
              for (var h in c)
                h !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(u, h) &&
                  e(u, c, h);
            };
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.Storage = n.Log = n.EventLogger = n.Diagnostics = void 0),
          Ws());
        const i = Ws(),
          r = Sv();
        Object.defineProperty(n, 'Diagnostics', {
          enumerable: !0,
          get: function () {
            return r.Diagnostics;
          },
        });
        const s = _T();
        Object.defineProperty(n, 'EventLogger', {
          enumerable: !0,
          get: function () {
            return s.EventLogger;
          },
        });
        const a = fi();
        Object.defineProperty(n, 'Log', {
          enumerable: !0,
          get: function () {
            return a.Log;
          },
        });
        const o = Ff(),
          l = Ys();
        (Object.defineProperty(n, 'Storage', {
          enumerable: !0,
          get: function () {
            return l.Storage;
          },
        }),
          t(Ws(), n),
          t(Kp(), n),
          t(nO(), n),
          t(iO(), n),
          t(Sv(), n),
          t(rO(), n),
          t(bT(), n),
          t(sO(), n),
          t(aO(), n),
          t(cc(), n),
          t(oO(), n),
          t(fi(), n),
          t(ST(), n),
          t(Jp(), n),
          t(uO(), n),
          t(hO(), n),
          t(dO(), n),
          t(Bo(), n),
          t(fy(), n),
          t(py(), n),
          t(fO(), n),
          t(Zp(), n),
          t(pO(), n),
          t(ET(), n),
          t(mO(), n),
          t(gT(), n),
          t(Ff(), n),
          t(Qp(), n),
          t(gO(), n),
          t(vO(), n),
          t(_O(), n),
          t(yT(), n),
          t(Ys(), n),
          t(xT(), n),
          t(uy(), n),
          t(vT(), n),
          t(dy(), n),
          t(hy(), n),
          t(yO(), n),
          t(wT(), n),
          Object.assign((0, i._getStatsigGlobal)(), {
            Log: a.Log,
            SDK_VERSION: o.SDK_VERSION,
          }));
      })(va)),
    va
  );
}
var Ra = {},
  Wo = {},
  ed = {},
  Nc = {},
  vS;
function xO() {
  if (vS) return Nc;
  ((vS = 1),
    Object.defineProperty(Nc, '__esModule', { value: !0 }),
    (Nc.V1InitializeContainer = void 0));
  const n = Vr();
  let e = class {
    constructor(i) {
      this._values = i;
    }
    getGate(i) {
      return this._getResultFromLookup(this._values.feature_gates, i);
    }
    getConfig(i) {
      return this._getResultFromLookup(this._values.dynamic_configs, i);
    }
    getLayer(i) {
      return this._getResultFromLookup(this._values.layer_configs, i);
    }
    getParamStore(i) {
      return this._getResultFromLookup(this._values.param_stores, i);
    }
    getConfigList() {
      return Object.keys(this._values.dynamic_configs);
    }
    getExposureMapping() {
      return this._values.exposures;
    }
    _getResultFromLookup(i, r) {
      var s, a;
      return i &&
        (a = (s = i[r]) !== null && s !== void 0 ? s : i[(0, n._DJB2)(r)]) !==
          null &&
        a !== void 0
        ? a
        : null;
    }
  };
  return ((Nc.V1InitializeContainer = e), Nc);
}
var Fc = {},
  _S;
function bO() {
  if (_S) return Fc;
  ((_S = 1),
    Object.defineProperty(Fc, '__esModule', { value: !0 }),
    (Fc.V2InitializeContainer = void 0));
  const n = Vr();
  let e = class {
    constructor(i) {
      this._values = i;
    }
    getGate(i) {
      var r, s, a;
      const o = this._getResultFromLookup(this._values.feature_gates, i);
      return o
        ? {
            name: i,
            value: o.v === !0,
            rule_id: (r = o.r) !== null && r !== void 0 ? r : 'default',
            secondary_exposures: (s = o.s) !== null && s !== void 0 ? s : [],
            id_type: (a = o.i) !== null && a !== void 0 ? a : '',
          }
        : null;
    }
    getConfig(i) {
      var r, s, a, o;
      const l = this._getResultFromLookup(this._values.dynamic_configs, i);
      return l
        ? {
            name: i,
            value:
              (r = this._values.values[l.v]) !== null && r !== void 0 ? r : {},
            rule_id: l.r,
            secondary_exposures: (s = l.s) !== null && s !== void 0 ? s : [],
            id_type: (a = l.i) !== null && a !== void 0 ? a : '',
            is_user_in_experiment: l.ue === !0,
            passed: l.p === !0,
            group_name: (o = l.gn) !== null && o !== void 0 ? o : void 0,
            is_experiment_active: l.ea === !0,
            group: l.r,
            is_device_based: l.i === 'stableID',
          }
        : null;
    }
    getLayer(i) {
      var r, s, a, o, l, c;
      const u = this._getResultFromLookup(this._values.layer_configs, i);
      return u
        ? {
            name: i,
            value:
              (r = this._values.values[u.v]) !== null && r !== void 0 ? r : {},
            rule_id: u.r,
            secondary_exposures: (s = u.s) !== null && s !== void 0 ? s : [],
            is_user_in_experiment: u.ue === !0,
            group_name: (a = u.gn) !== null && a !== void 0 ? a : void 0,
            is_experiment_active: u.ea === !0,
            group: u.r,
            is_device_based: u.i === 'stableID',
            allocated_experiment_name:
              (o = u.ae) !== null && o !== void 0 ? o : '',
            explicit_parameters: (l = u.ep) !== null && l !== void 0 ? l : [],
            undelegated_secondary_exposures:
              (c = u.us) !== null && c !== void 0 ? c : [],
            parameter_rule_ids: u.pr,
          }
        : null;
    }
    getParamStore(i) {
      return this._getResultFromLookup(this._values.param_stores, i);
    }
    getConfigList() {
      return Object.keys(this._values.dynamic_configs);
    }
    getExposureMapping() {
      return this._values.exposures;
    }
    _getResultFromLookup(i, r) {
      var s, a;
      return i &&
        (a = (s = i[r]) !== null && s !== void 0 ? s : i[(0, n._DJB2)(r)]) !==
          null &&
        a !== void 0
        ? a
        : null;
    }
  };
  return ((Fc.V2InitializeContainer = e), Fc);
}
var yS;
function SO() {
  if (yS) return ed;
  ((yS = 1), Object.defineProperty(ed, '__esModule', { value: !0 }));
  const n = Vr(),
    e = xO(),
    t = bO();
  let i = class {
    constructor(s) {
      ((this._sdkKey = s),
        (this._rawValues = null),
        (this._values = null),
        (this._source = 'Uninitialized'),
        (this._lcut = 0),
        (this._receivedAt = 0),
        (this._bootstrapMetadata = null),
        (this._warnings = new Set()));
    }
    reset() {
      ((this._values = null),
        (this._rawValues = null),
        (this._source = 'Loading'),
        (this._lcut = 0),
        (this._receivedAt = 0),
        (this._bootstrapMetadata = null),
        this._warnings.clear());
    }
    finalize() {
      this._values || (this._source = 'NoValues');
    }
    getValues() {
      return this._rawValues
        ? (0, n._typedJsonParse)(
            this._rawValues,
            'has_updates',
            'EvaluationStoreValues'
          )
        : null;
    }
    setValues(s, a) {
      var o, l;
      if (!s) return !1;
      const c = (0, n._typedJsonParse)(
        s.data,
        'has_updates',
        'EvaluationResponse'
      );
      return c == null
        ? !1
        : ((this._source = s.source),
          c?.has_updates !== !0 ||
            ((o = c.time) !== null && o !== void 0 ? o : 0) < this._lcut ||
            ((this._rawValues = s.data),
            (this._lcut = c.time),
            (this._receivedAt = s.receivedAt),
            c.response_format === 'init-v2'
              ? (this._values = new t.V2InitializeContainer(c))
              : (this._values = new e.V1InitializeContainer(c)),
            (this._bootstrapMetadata = this._extractBootstrapMetadata(
              s.source,
              c
            )),
            s.source && c.user && this._setWarningState(a, c),
            n.SDKFlags.setFlags(
              this._sdkKey,
              (l = c.sdk_flags) !== null && l !== void 0 ? l : {}
            )),
          !0);
    }
    getWarnings() {
      if (this._warnings.size !== 0) return Array.from(this._warnings);
    }
    getGate(s) {
      const a = this._values ? this._values.getGate(s) : null;
      return this._getDetailedStoreResult(a);
    }
    getConfig(s) {
      const a = this._values ? this._values.getConfig(s) : null;
      return this._getDetailedStoreResult(a);
    }
    getConfigList() {
      return this._values ? this._values.getConfigList() : [];
    }
    getLayer(s) {
      const a = this._values ? this._values.getLayer(s) : null;
      return this._getDetailedStoreResult(a);
    }
    getParamStore(s) {
      const a = this._values ? this._values.getParamStore(s) : null;
      return this._getDetailedStoreResult(a);
    }
    getSource() {
      return this._source;
    }
    getExposureMapping() {
      var s;
      return (s = this._values) === null || s === void 0
        ? void 0
        : s.getExposureMapping();
    }
    _extractBootstrapMetadata(s, a) {
      if (s !== 'Bootstrap') return null;
      const o = {};
      return (
        a.user && (o.user = a.user),
        a.sdkInfo && (o.generatorSDKInfo = a.sdkInfo),
        (o.lcut = a.time),
        o
      );
    }
    _getDetailedStoreResult(s) {
      return { result: s, details: this._getDetails(s == null) };
    }
    _setWarningState(s, a) {
      var o, l;
      const c = n.StableID.get(this._sdkKey);
      if (
        ((o = s.customIDs) === null || o === void 0 ? void 0 : o.stableID) !==
          c &&
        ((!((l = s.customIDs) === null || l === void 0) && l.stableID) || c)
      ) {
        this._warnings.add('StableIDMismatch');
        return;
      }
      if ('user' in a) {
        const u = a.user,
          h = Object.assign(Object.assign({}, s), {
            analyticsOnlyMetadata: void 0,
            privateAttributes: void 0,
          });
        (0, n._getFullUserHash)(h) !== (0, n._getFullUserHash)(u) &&
          this._warnings.add('PartialUserMatch');
      }
    }
    getCurrentSourceDetails() {
      if (this._source === 'Uninitialized' || this._source === 'NoValues')
        return { reason: this._source };
      const s = {
        reason: this._source,
        lcut: this._lcut,
        receivedAt: this._receivedAt,
      };
      return (
        this._warnings.size > 0 && (s.warnings = Array.from(this._warnings)),
        s
      );
    }
    _getDetails(s) {
      var a, o;
      const l = this.getCurrentSourceDetails();
      let c = l.reason;
      const u = (a = l.warnings) !== null && a !== void 0 ? a : [];
      (this._source === 'Bootstrap' && u.length > 0 && (c = c + u[0]),
        c !== 'Uninitialized' &&
          c !== 'NoValues' &&
          (c = `${c}:${s ? 'Unrecognized' : 'Recognized'}`));
      const h =
        this._source === 'Bootstrap' &&
        (o = this._bootstrapMetadata) !== null &&
        o !== void 0
          ? o
          : void 0;
      return (
        h && (l.bootstrapMetadata = h),
        Object.assign(Object.assign({}, l), { reason: c })
      );
    }
  };
  return ((ed.default = i), ed);
}
var jo = {},
  zc = {},
  xS;
function wO() {
  if (xS) return zc;
  ((xS = 1),
    Object.defineProperty(zc, '__esModule', { value: !0 }),
    (zc._resolveDeltasResponse = void 0));
  const n = Vr(),
    e = 2;
  function t(a, o) {
    const l = (0, n._typedJsonParse)(o, 'checksum', 'DeltasEvaluationResponse');
    if (!l) return { hadBadDeltaChecksum: !0 };
    const c = i(a, l),
      u = r(c),
      h = (0, n._DJB2Object)(
        {
          feature_gates: u.feature_gates,
          dynamic_configs: u.dynamic_configs,
          layer_configs: u.layer_configs,
        },
        e
      );
    return h === l.checksumV2
      ? JSON.stringify(u)
      : {
          hadBadDeltaChecksum: !0,
          badChecksum: h,
          badMergedConfigs: u,
          badFullResponse: l.deltas_full_response,
        };
  }
  zc._resolveDeltasResponse = t;
  function i(a, o) {
    return Object.assign(Object.assign(Object.assign({}, a), o), {
      feature_gates: Object.assign(
        Object.assign({}, a.feature_gates),
        o.feature_gates
      ),
      layer_configs: Object.assign(
        Object.assign({}, a.layer_configs),
        o.layer_configs
      ),
      dynamic_configs: Object.assign(
        Object.assign({}, a.dynamic_configs),
        o.dynamic_configs
      ),
    });
  }
  function r(a) {
    const o = a;
    return (
      s(a.deleted_gates, o.feature_gates),
      delete o.deleted_gates,
      s(a.deleted_configs, o.dynamic_configs),
      delete o.deleted_configs,
      s(a.deleted_layers, o.layer_configs),
      delete o.deleted_layers,
      o
    );
  }
  function s(a, o) {
    a?.forEach((l) => {
      delete o[l];
    });
  }
  return zc;
}
var bS;
function AT() {
  if (bS) return jo;
  bS = 1;
  var n =
    (jo && jo.__awaiter) ||
    function (r, s, a, o) {
      function l(c) {
        return c instanceof a
          ? c
          : new a(function (u) {
              u(c);
            });
      }
      return new (a || (a = Promise))(function (c, u) {
        function h(p) {
          try {
            f(o.next(p));
          } catch (m) {
            u(m);
          }
        }
        function d(p) {
          try {
            f(o.throw(p));
          } catch (m) {
            u(m);
          }
        }
        function f(p) {
          p.done ? c(p.value) : l(p.value).then(h, d);
        }
        f((o = o.apply(r, s || [])).next());
      });
    };
  Object.defineProperty(jo, '__esModule', { value: !0 });
  const e = Vr(),
    t = wO();
  class i extends e.NetworkCore {
    constructor(s, a) {
      super(s, a);
      const o = s?.networkConfig;
      ((this._option = s),
        (this._initializeUrlConfig = new e.UrlConfiguration(
          e.Endpoint._initialize,
          o?.initializeUrl,
          o?.api,
          o?.initializeFallbackUrls
        )));
    }
    fetchEvaluations(s, a, o, l, c) {
      return n(this, void 0, void 0, function* () {
        var u, h, d, f, p, m;
        const g = a
          ? (0, e._typedJsonParse)(a, 'has_updates', 'InitializeResponse')
          : null;
        let v = {
          user: l,
          hash:
            (d =
              (h =
                (u = this._option) === null || u === void 0
                  ? void 0
                  : u.networkConfig) === null || h === void 0
                ? void 0
                : h.initializeHashAlgorithm) !== null && d !== void 0
              ? d
              : 'djb2',
          deltasResponseRequested: !1,
          full_checksum: null,
        };
        if (g?.has_updates) {
          const y =
            g?.hash_used !==
            ((m =
              (p =
                (f = this._option) === null || f === void 0
                  ? void 0
                  : f.networkConfig) === null || p === void 0
                ? void 0
                : p.initializeHashAlgorithm) !== null && m !== void 0
              ? m
              : 'djb2');
          v = Object.assign(Object.assign({}, v), {
            sinceTime: c && !y ? g.time : 0,
            previousDerivedFields:
              'derived_fields' in g && c ? g.derived_fields : {},
            deltasResponseRequested: !0,
            full_checksum: g.full_checksum,
            partialUserMatchSinceTime: y ? 0 : g.time,
          });
        }
        return this._fetchEvaluations(s, g, v, o);
      });
    }
    _fetchEvaluations(s, a, o, l) {
      return n(this, void 0, void 0, function* () {
        var c, u;
        const h = yield this.post({
          sdkKey: s,
          urlConfig: this._initializeUrlConfig,
          data: o,
          retries: 2,
          isStatsigEncodable: !0,
          priority: l,
        });
        if (h?.code === 204) return '{"has_updates": false}';
        if (h?.code !== 200)
          return (c = h?.body) !== null && c !== void 0 ? c : null;
        if (
          a?.has_updates !== !0 ||
          ((u = h.body) === null || u === void 0
            ? void 0
            : u.includes('"is_delta":true')) !== !0 ||
          o.deltasResponseRequested !== !0
        )
          return h.body;
        const d = (0, t._resolveDeltasResponse)(a, h.body);
        return typeof d == 'string'
          ? d
          : this._fetchEvaluations(
              s,
              a,
              Object.assign(Object.assign(Object.assign({}, o), d), {
                deltasResponseRequested: !1,
              }),
              l
            );
      });
    }
  }
  return ((jo.default = i), jo);
}
var Vc = {},
  SS;
function EO() {
  if (SS) return Vc;
  ((SS = 1),
    Object.defineProperty(Vc, '__esModule', { value: !0 }),
    (Vc._makeParamStoreGetter = void 0));
  const n = Vr(),
    e = { disableExposureLog: !0 };
  function t(u) {
    return u == null || u.disableExposureLog === !1;
  }
  function i(u, h) {
    return h != null && !(0, n._isTypeMatch)(u, h);
  }
  function r(u, h) {
    return u.value;
  }
  function s(u, h, d) {
    return u.getFeatureGate(h.gate_name, t(d) ? void 0 : e).value
      ? h.pass_value
      : h.fail_value;
  }
  function a(u, h, d, f) {
    const m = u
      .getDynamicConfig(h.config_name, t(f) ? void 0 : e)
      .get(h.param_name);
    return i(m, d) ? d : m;
  }
  function o(u, h, d, f) {
    const m = u
      .getExperiment(h.experiment_name, t(f) ? void 0 : e)
      .get(h.param_name);
    return i(m, d) ? d : m;
  }
  function l(u, h, d, f) {
    const m = u.getLayer(h.layer_name, t(f) ? void 0 : e).get(h.param_name);
    return i(m, d) ? d : m;
  }
  function c(u, h, d) {
    return (f, p) => {
      if (h == null) return p;
      const m = h[f];
      if (m == null || (p != null && (0, n._typeOf)(p) !== m.param_type))
        return p;
      switch (m.ref_type) {
        case 'static':
          return r(m);
        case 'gate':
          return s(u, m, d);
        case 'dynamic_config':
          return a(u, m, p, d);
        case 'experiment':
          return o(u, m, p, d);
        case 'layer':
          return l(u, m, p, d);
        default:
          return p;
      }
    };
  }
  return ((Vc._makeParamStoreGetter = c), Vc);
}
var Ia = {},
  wS;
function AO() {
  if (wS) return Ia;
  wS = 1;
  var n =
    (Ia && Ia.__awaiter) ||
    function (r, s, a, o) {
      function l(c) {
        return c instanceof a
          ? c
          : new a(function (u) {
              u(c);
            });
      }
      return new (a || (a = Promise))(function (c, u) {
        function h(p) {
          try {
            f(o.next(p));
          } catch (m) {
            u(m);
          }
        }
        function d(p) {
          try {
            f(o.throw(p));
          } catch (m) {
            u(m);
          }
        }
        function f(p) {
          p.done ? c(p.value) : l(p.value).then(h, d);
        }
        f((o = o.apply(r, s || [])).next());
      });
    };
  (Object.defineProperty(Ia, '__esModule', { value: !0 }),
    (Ia.StatsigEvaluationsDataAdapter = void 0));
  const e = Vr(),
    t = AT();
  let i = class extends e.DataAdapterCore {
    constructor() {
      (super('EvaluationsDataAdapter', 'evaluations'),
        (this._network = null),
        (this._options = null));
    }
    attach(s, a, o) {
      (super.attach(s, a, o),
        o !== null && o instanceof t.default
          ? (this._network = o)
          : (this._network = new t.default(a ?? {})));
    }
    getDataAsync(s, a, o) {
      return this._getDataAsyncImpl(
        s,
        (0, e._normalizeUser)(a, this._options),
        o
      );
    }
    prefetchData(s, a) {
      return this._prefetchDataImpl(s, a);
    }
    setData(s) {
      const a = (0, e._typedJsonParse)(s, 'has_updates', 'data');
      a && 'user' in a
        ? super.setData(s, a.user)
        : e.Log.error(
            'StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.'
          );
    }
    setDataLegacy(s, a) {
      super.setData(s, a);
    }
    _fetchFromNetwork(s, a, o, l) {
      return n(this, void 0, void 0, function* () {
        var c;
        const u = yield (c = this._network) === null || c === void 0
          ? void 0
          : c.fetchEvaluations(this._getSdkKey(), s, o?.priority, a, l);
        return u ?? null;
      });
    }
    _getCacheKey(s) {
      var a;
      const o = (0, e._getStorageKey)(
        this._getSdkKey(),
        s,
        (a = this._options) === null || a === void 0
          ? void 0
          : a.customUserCacheKeyFunc
      );
      return `${e.DataAdapterCachePrefix}.${this._cacheSuffix}.${o}`;
    }
    _isCachedResultValidFor204(s, a) {
      return (
        s.fullUserHash != null && s.fullUserHash === (0, e._getFullUserHash)(a)
      );
    }
  };
  return ((Ia.StatsigEvaluationsDataAdapter = i), Ia);
}
var ES;
function MO() {
  if (ES) return Wo;
  ES = 1;
  var n =
    (Wo && Wo.__awaiter) ||
    function (o, l, c, u) {
      function h(d) {
        return d instanceof c
          ? d
          : new c(function (f) {
              f(d);
            });
      }
      return new (c || (c = Promise))(function (d, f) {
        function p(v) {
          try {
            g(u.next(v));
          } catch (y) {
            f(y);
          }
        }
        function m(v) {
          try {
            g(u.throw(v));
          } catch (y) {
            f(y);
          }
        }
        function g(v) {
          v.done ? d(v.value) : h(v.value).then(p, m);
        }
        g((u = u.apply(o, l || [])).next());
      });
    };
  Object.defineProperty(Wo, '__esModule', { value: !0 });
  const e = Vr(),
    t = SO(),
    i = AT(),
    r = EO(),
    s = AO();
  let a = class wv extends e.StatsigClientBase {
    static instance(l) {
      const c = (0, e._getStatsigGlobal)().instance(l);
      return c instanceof wv
        ? c
        : (e.Log.warn(
            (0, e._isServerEnv)()
              ? 'StatsigClient.instance is not supported in server environments'
              : 'Unable to find StatsigClient instance'
          ),
          new wv(l ?? '', {}));
    }
    constructor(l, c, u = null) {
      var h, d;
      e.SDKType._setClientType(l, 'javascript-client');
      const f = new i.default(u, (m) => {
        this.$emt(m);
      });
      (super(
        l,
        (h = u?.dataAdapter) !== null && h !== void 0
          ? h
          : new s.StatsigEvaluationsDataAdapter(),
        f,
        u
      ),
        (this._possibleFirstTouchMetadata = {}),
        (this.getFeatureGate = this._memoize(
          e.MemoPrefix._gate,
          this._getFeatureGateImpl.bind(this)
        )),
        (this.getDynamicConfig = this._memoize(
          e.MemoPrefix._dynamicConfig,
          this._getDynamicConfigImpl.bind(this)
        )),
        (this.getExperiment = this._memoize(
          e.MemoPrefix._experiment,
          this._getExperimentImpl.bind(this)
        )),
        (this.getConfigList = this._memoize(
          e.MemoPrefix._configList,
          this._getConfigListImpl.bind(this)
        )),
        (this.getLayer = this._memoize(
          e.MemoPrefix._layer,
          this._getLayerImpl.bind(this)
        )),
        (this.getParameterStore = this._memoize(
          e.MemoPrefix._paramStore,
          this._getParameterStoreImpl.bind(this)
        )),
        (this._store = new t.default(l)),
        (this._network = f),
        (this._user = this._configureUser(c, u)),
        (this._sdkInstanceID = (0, e.getUUID)()));
      const p = (d = u?.plugins) !== null && d !== void 0 ? d : [];
      for (const m of p) m.bind(this);
    }
    initializeSync(l) {
      var c;
      return this.loadingStatus !== 'Uninitialized'
        ? (0, e.createUpdateDetails)(
            !0,
            this._store.getSource(),
            -1,
            null,
            null,
            [
              'MultipleInitializations',
              ...((c = this._store.getWarnings()) !== null && c !== void 0
                ? c
                : []),
            ]
          )
        : (this._logger.start(), this.updateUserSync(this._user, l));
    }
    initializeAsync(l) {
      return n(this, void 0, void 0, function* () {
        return this._initializePromise
          ? this._initializePromise
          : ((this._initializePromise = this._initializeAsyncImpl(l)),
            this._initializePromise);
      });
    }
    updateUserSync(l, c) {
      const u = performance.now();
      try {
        return this._updateUserSyncImpl(l, c, u);
      } catch (h) {
        const d = h instanceof Error ? h : new Error(String(h));
        return this._createErrorUpdateDetails(d, u);
      }
    }
    _updateUserSyncImpl(l, c, u) {
      var h;
      const d = [
        ...((h = this._store.getWarnings()) !== null && h !== void 0 ? h : []),
      ];
      this._resetForUser(l);
      const f = this.dataAdapter.getDataSync(this._user);
      (f == null && d.push('NoCachedValues'),
        this._store.setValues(f, this._user),
        this._finalizeUpdate(f));
      const p = c?.disableBackgroundCacheRefresh;
      return p === !0 || (p == null && f?.source === 'Bootstrap')
        ? (0, e.createUpdateDetails)(
            !0,
            this._store.getSource(),
            performance.now() - u,
            this._errorBoundary.getLastSeenErrorAndReset(),
            this._network.getLastUsedInitUrlAndReset(),
            d
          )
        : (this._runPostUpdate(f ?? null, this._user),
          (0, e.createUpdateDetails)(
            !0,
            this._store.getSource(),
            performance.now() - u,
            this._errorBoundary.getLastSeenErrorAndReset(),
            this._network.getLastUsedInitUrlAndReset(),
            d
          ));
    }
    updateUserAsync(l, c) {
      return n(this, void 0, void 0, function* () {
        const u = performance.now();
        try {
          return yield this._updateUserAsyncImpl(l, c);
        } catch (h) {
          const d = h instanceof Error ? h : new Error(String(h));
          return this._createErrorUpdateDetails(d, u);
        }
      });
    }
    _updateUserAsyncImpl(l, c) {
      return n(this, void 0, void 0, function* () {
        this._resetForUser(l);
        const u = this._user;
        e.Diagnostics._markInitOverallStart(this._sdkKey);
        let h = this.dataAdapter.getDataSync(u);
        if (
          (this._store.setValues(h, this._user),
          this._setStatus('Loading', h),
          (h = yield this.dataAdapter.getDataAsync(h, u, c)),
          u !== this._user)
        )
          return (0, e.createUpdateDetails)(
            !1,
            this._store.getSource(),
            -1,
            new Error('User changed during update'),
            this._network.getLastUsedInitUrlAndReset()
          );
        let d = !1;
        (h != null &&
          (e.Diagnostics._markInitProcessStart(this._sdkKey),
          (d = this._store.setValues(h, this._user)),
          e.Diagnostics._markInitProcessEnd(this._sdkKey, { success: d })),
          this._finalizeUpdate(h),
          d ||
            (this._errorBoundary.attachErrorIfNoneExists(
              e.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA
            ),
            this.$emt({ name: 'initialization_failure' })),
          e.Diagnostics._markInitOverallEnd(
            this._sdkKey,
            d,
            this._store.getCurrentSourceDetails()
          ));
        const f = e.Diagnostics._enqueueDiagnosticsEvent(
          this._user,
          this._logger,
          this._sdkKey,
          this._options
        );
        return (0, e.createUpdateDetails)(
          d,
          this._store.getSource(),
          f,
          this._errorBoundary.getLastSeenErrorAndReset(),
          this._network.getLastUsedInitUrlAndReset(),
          this._store.getWarnings()
        );
      });
    }
    getContext() {
      return {
        sdkKey: this._sdkKey,
        options: this._options,
        values: this._store.getValues(),
        user: JSON.parse(JSON.stringify(this._user)),
        errorBoundary: this._errorBoundary,
        session: e.StatsigSession.get(this._sdkKey),
        stableID: e.StableID.get(this._sdkKey),
        sdkInstanceID: this._sdkInstanceID,
      };
    }
    checkGate(l, c) {
      return this.getFeatureGate(l, c).value;
    }
    logEvent(l, c, u) {
      const h =
        typeof l == 'string' ? { eventName: l, value: c, metadata: u } : l;
      (this.$emt({ name: 'log_event_called', event: h }),
        this._logger.enqueue(
          Object.assign(Object.assign({}, h), {
            user: this._user,
            time: Date.now(),
          })
        ));
    }
    updateUserWithAnalyticsOnlyMetadata(l) {
      this._user = this._configureUser(
        Object.assign(Object.assign({}, this._user), {
          analyticsOnlyMetadata: l,
        }),
        this._options
      );
    }
    _primeReadyRipcord() {
      this.$on('error', () => {
        this.loadingStatus === 'Loading' && this._finalizeUpdate(null);
      });
    }
    _initializeAsyncImpl(l) {
      return n(this, void 0, void 0, function* () {
        return (
          e.Storage.isReady() || (yield e.Storage.isReadyResolver()),
          this._logger.start(),
          this.updateUserAsync(this._user, l)
        );
      });
    }
    _createErrorUpdateDetails(l, c) {
      var u;
      return (0, e.createUpdateDetails)(
        !1,
        this._store.getSource(),
        performance.now() - c,
        l,
        null,
        [...((u = this._store.getWarnings()) !== null && u !== void 0 ? u : [])]
      );
    }
    _finalizeUpdate(l) {
      (this._store.finalize(), this._setStatus('Ready', l));
    }
    _runPostUpdate(l, c) {
      this.dataAdapter.getDataAsync(l, c, { priority: 'low' }).catch((u) => {
        e.Log.error('An error occurred after update.', u);
      });
    }
    _resetForUser(l) {
      (this._logger.reset(),
        this._store.reset(),
        (this._user = this._configureUser(l, this._options)));
    }
    _configureUser(l, c) {
      var u, h, d;
      const f = (0, e._normalizeUser)(l, c),
        p = (u = f.customIDs) === null || u === void 0 ? void 0 : u.stableID;
      if (p) {
        const m =
          (d = (h = this.storageProvider).isReadyResolver) === null ||
          d === void 0
            ? void 0
            : d.call(h);
        m
          ? m.then(
              () => e.StableID.setOverride(p, this._sdkKey),
              () => e.StableID.setOverride(p, this._sdkKey)
            )
          : e.StableID.setOverride(p, this._sdkKey);
      }
      return (
        Object.keys(this._possibleFirstTouchMetadata).length > 0 &&
          (f.analyticsOnlyMetadata = Object.assign(
            Object.assign({}, f.analyticsOnlyMetadata),
            this._possibleFirstTouchMetadata
          )),
        f
      );
    }
    _getFeatureGateImpl(l, c) {
      var u, h;
      const { result: d, details: f } = this._store.getGate(l),
        p = (0, e._makeFeatureGate)(l, f, d),
        m =
          (h =
            (u = this.overrideAdapter) === null || u === void 0
              ? void 0
              : u.getGateOverride) === null || h === void 0
            ? void 0
            : h.call(u, p, this._user, c),
        g = m ?? p;
      return (
        this._enqueueExposure(
          l,
          (0, e._createGateExposure)(
            this._user,
            g,
            this._store.getExposureMapping()
          ),
          c
        ),
        this.$emt({ name: 'gate_evaluation', gate: g }),
        g
      );
    }
    _getDynamicConfigImpl(l, c) {
      var u, h;
      const { result: d, details: f } = this._store.getConfig(l),
        p = (0, e._makeDynamicConfig)(l, f, d),
        m =
          (h =
            (u = this.overrideAdapter) === null || u === void 0
              ? void 0
              : u.getDynamicConfigOverride) === null || h === void 0
            ? void 0
            : h.call(u, p, this._user, c),
        g = m ?? p;
      return (
        this._enqueueExposure(
          l,
          (0, e._createConfigExposure)(
            this._user,
            g,
            this._store.getExposureMapping()
          ),
          c
        ),
        this.$emt({ name: 'dynamic_config_evaluation', dynamicConfig: g }),
        g
      );
    }
    _getExperimentImpl(l, c) {
      var u, h, d, f;
      const { result: p, details: m } = this._store.getConfig(l),
        g = (0, e._makeExperiment)(l, m, p);
      g.__evaluation != null &&
        (g.__evaluation.secondary_exposures = (0, e._mapExposures)(
          (h =
            (u = g.__evaluation) === null || u === void 0
              ? void 0
              : u.secondary_exposures) !== null && h !== void 0
            ? h
            : [],
          this._store.getExposureMapping()
        ));
      const v =
          (f =
            (d = this.overrideAdapter) === null || d === void 0
              ? void 0
              : d.getExperimentOverride) === null || f === void 0
            ? void 0
            : f.call(d, g, this._user, c),
        y = v ?? g;
      return (
        this._enqueueExposure(
          l,
          (0, e._createConfigExposure)(
            this._user,
            y,
            this._store.getExposureMapping()
          ),
          c
        ),
        this.$emt({ name: 'experiment_evaluation', experiment: y }),
        y
      );
    }
    _getConfigListImpl() {
      return this._store.getConfigList();
    }
    _getLayerImpl(l, c) {
      var u, h, d;
      const { result: f, details: p } = this._store.getLayer(l),
        m = (0, e._makeLayer)(l, p, f),
        g =
          (h =
            (u = this.overrideAdapter) === null || u === void 0
              ? void 0
              : u.getLayerOverride) === null || h === void 0
            ? void 0
            : h.call(u, m, this._user, c);
      c?.disableExposureLog && this._logger.incrementNonExposureCount(l);
      const v = (0, e._mergeOverride)(
        m,
        g,
        (d = g?.__value) !== null && d !== void 0 ? d : m.__value,
        (y) => {
          c?.disableExposureLog ||
            this._enqueueExposure(
              l,
              (0, e._createLayerParameterExposure)(
                this._user,
                v,
                y,
                this._store.getExposureMapping()
              ),
              c
            );
        }
      );
      return (this.$emt({ name: 'layer_evaluation', layer: v }), v);
    }
    _getParameterStoreImpl(l, c) {
      var u, h;
      const { result: d, details: f } = this._store.getParamStore(l);
      this._logger.incrementNonExposureCount(l);
      const p = {
          name: l,
          details: f,
          __configuration: d,
          get: (0, r._makeParamStoreGetter)(this, d, c),
        },
        m =
          (h =
            (u = this.overrideAdapter) === null || u === void 0
              ? void 0
              : u.getParamStoreOverride) === null || h === void 0
            ? void 0
            : h.call(u, p, c);
      return (
        m != null &&
          ((p.__configuration = m.config),
          (p.details = m.details),
          (p.get = (0, r._makeParamStoreGetter)(this, m.config, c))),
        p
      );
    }
  };
  return ((Wo.default = a), Wo);
}
var AS;
function Gte() {
  return (
    AS ||
      ((AS = 1),
      (function (n) {
        var e =
            (Ra && Ra.__createBinding) ||
            (Object.create
              ? function (a, o, l, c) {
                  c === void 0 && (c = l);
                  var u = Object.getOwnPropertyDescriptor(o, l);
                  ((!u ||
                    ('get' in u
                      ? !o.__esModule
                      : u.writable || u.configurable)) &&
                    (u = {
                      enumerable: !0,
                      get: function () {
                        return o[l];
                      },
                    }),
                    Object.defineProperty(a, c, u));
                }
              : function (a, o, l, c) {
                  (c === void 0 && (c = l), (a[c] = o[l]));
                }),
          t =
            (Ra && Ra.__exportStar) ||
            function (a, o) {
              for (var l in a)
                l !== 'default' &&
                  !Object.prototype.hasOwnProperty.call(o, l) &&
                  e(o, a, l);
            };
        (Object.defineProperty(n, '__esModule', { value: !0 }),
          (n.StatsigClient = void 0));
        const i = Vr(),
          r = MO();
        ((n.StatsigClient = r.default), t(Vr(), n));
        const s = Object.assign((0, i._getStatsigGlobal)(), {
          StatsigClient: r.default,
        });
        n.default = s;
      })(Ra)),
    Ra
  );
}
function rs(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function MT(n, e) {
  ((n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    (n.__proto__ = e));
}
var Gi = {
    autoSleep: 120,
    force3D: 'auto',
    nullTargetWarn: 1,
    units: { lineHeight: '' },
  },
  Vl = { duration: 0.5, overwrite: !1, delay: 0 },
  my,
  qn,
  nn,
  nr = 1e8,
  $t = 1 / nr,
  Ev = Math.PI * 2,
  TO = Ev / 4,
  CO = 0,
  TT = Math.sqrt,
  RO = Math.cos,
  IO = Math.sin,
  Wn = function (e) {
    return typeof e == 'string';
  },
  pn = function (e) {
    return typeof e == 'function';
  },
  ms = function (e) {
    return typeof e == 'number';
  },
  gy = function (e) {
    return typeof e > 'u';
  },
  Hr = function (e) {
    return typeof e == 'object';
  },
  wi = function (e) {
    return e !== !1;
  },
  vy = function () {
    return typeof window < 'u';
  },
  td = function (e) {
    return pn(e) || Wn(e);
  },
  CT =
    (typeof ArrayBuffer == 'function' && ArrayBuffer.isView) || function () {},
  ni = Array.isArray,
  Av = /(?:-?\.?\d|\.)+/gi,
  RT = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  El = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  wg = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  IT = /[+-]=-?[.\d]+/,
  PT = /[^,'"\[\]\s]+/gi,
  PO = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  an,
  Or,
  Mv,
  _y,
  Xi = {},
  zf = {},
  DT,
  OT = function (e) {
    return (zf = Hl(e, Xi)) && Pi;
  },
  yy = function (e, t) {
    return console.warn(
      'Invalid property',
      e,
      'set to',
      t,
      'Missing plugin? gsap.registerPlugin()'
    );
  },
  Fu = function (e, t) {
    return !t && console.warn(e);
  },
  LT = function (e, t) {
    return (e && (Xi[e] = t) && zf && (zf[e] = t)) || Xi;
  },
  zu = function () {
    return 0;
  },
  DO = { suppressEvents: !0, isStart: !0, kill: !1 },
  _f = { suppressEvents: !0, kill: !1 },
  OO = { suppressEvents: !0 },
  xy = {},
  js = [],
  Tv = {},
  UT,
  ki = {},
  Eg = {},
  MS = 30,
  yf = [],
  by = '',
  Sy = function (e) {
    var t = e[0],
      i,
      r;
    if ((Hr(t) || pn(t) || (e = [e]), !(i = (t._gsap || {}).harness))) {
      for (r = yf.length; r-- && !yf[r].targetTest(t); );
      i = yf[r];
    }
    for (r = e.length; r--; )
      (e[r] && (e[r]._gsap || (e[r]._gsap = new sC(e[r], i)))) ||
        e.splice(r, 1);
    return e;
  },
  go = function (e) {
    return e._gsap || Sy(ir(e))[0]._gsap;
  },
  kT = function (e, t, i) {
    return (i = e[t]) && pn(i)
      ? e[t]()
      : (gy(i) && e.getAttribute && e.getAttribute(t)) || i;
  },
  Ei = function (e, t) {
    return (e = e.split(',')).forEach(t) || e;
  },
  xn = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  Tn = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  Ul = function (e, t) {
    var i = t.charAt(0),
      r = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      i === '+' ? e + r : i === '-' ? e - r : i === '*' ? e * r : e / r
    );
  },
  LO = function (e, t) {
    for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; );
    return r < i;
  },
  Vf = function () {
    var e = js.length,
      t = js.slice(0),
      i,
      r;
    for (Tv = {}, js.length = 0, i = 0; i < e; i++)
      ((r = t[i]),
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0));
  },
  wy = function (e) {
    return !!(e._initted || e._startAt || e.add);
  },
  BT = function (e, t, i, r) {
    (js.length && !qn && Vf(),
      e.render(t, i, !!(qn && t < 0 && wy(e))),
      js.length && !qn && Vf());
  },
  NT = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + '').match(PT).length < 2
      ? t
      : Wn(e)
        ? e.trim()
        : e;
  },
  FT = function (e) {
    return e;
  },
  qi = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  UO = function (e) {
    return function (t, i) {
      for (var r in i)
        r in t || (r === 'duration' && e) || r === 'ease' || (t[r] = i[r]);
    };
  },
  Hl = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  TS = function n(e, t) {
    for (var i in t)
      i !== '__proto__' &&
        i !== 'constructor' &&
        i !== 'prototype' &&
        (e[i] = Hr(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e;
  },
  Hf = function (e, t) {
    var i = {},
      r;
    for (r in e) r in t || (i[r] = e[r]);
    return i;
  },
  vu = function (e) {
    var t = e.parent || an,
      i = e.keyframes ? UO(ni(e.keyframes)) : qi;
    if (wi(e.inherit))
      for (; t; ) (i(e, t.vars.defaults), (t = t.parent || t._dp));
    return e;
  },
  kO = function (e, t) {
    for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; );
    return i < 0;
  },
  zT = function (e, t, i, r, s) {
    var a = e[r],
      o;
    if (s) for (o = t[s]; a && a[s] > o; ) a = a._prev;
    return (
      a ? ((t._next = a._next), (a._next = t)) : ((t._next = e[i]), (e[i] = t)),
      t._next ? (t._next._prev = t) : (e[r] = t),
      (t._prev = a),
      (t.parent = t._dp = e),
      t
    );
  },
  $p = function (e, t, i, r) {
    (i === void 0 && (i = '_first'), r === void 0 && (r = '_last'));
    var s = t._prev,
      a = t._next;
    (s ? (s._next = a) : e[i] === t && (e[i] = a),
      a ? (a._prev = s) : e[r] === t && (e[r] = s),
      (t._next = t._prev = t.parent = null));
  },
  Ks = function (e, t) {
    (e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0));
  },
  vo = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var i = e; i; ) ((i._dirty = 1), (i = i.parent));
    return e;
  },
  BO = function (e) {
    for (var t = e.parent; t && t.parent; )
      ((t._dirty = 1), t.totalDuration(), (t = t.parent));
    return e;
  },
  Cv = function (e, t, i, r) {
    return (
      e._startAt &&
      (qn
        ? e._startAt.revert(_f)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, r))
    );
  },
  NO = function n(e) {
    return !e || (e._ts && n(e.parent));
  },
  CS = function (e) {
    return e._repeat ? Gl(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  Gl = function (e, t) {
    var i = Math.floor((e = Tn(e / t)));
    return e && i === e ? i - 1 : i;
  },
  Gf = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  em = function (e) {
    return (e._end = Tn(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || $t) || 0)
    ));
  },
  tm = function (e, t) {
    var i = e._dp;
    return (
      i &&
        i.smoothChildTiming &&
        e._ts &&
        ((e._start = Tn(
          i._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        em(e),
        i._dirty || vo(i, e)),
      e
    );
  },
  VT = function (e, t) {
    var i;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((i = Gf(e.rawTime(), t)),
        (!t._dur || Sh(0, t.totalDuration(), i) - t._tTime > $t) &&
          t.render(i, !0)),
      vo(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (i = e; i._dp; )
          (i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp));
      e._zTime = -$t;
    }
  },
  Lr = function (e, t, i, r) {
    return (
      t.parent && Ks(t),
      (t._start = Tn(
        (ms(i) ? i : i || e !== an ? $i(e, i, t) : e._time) + t._delay
      )),
      (t._end = Tn(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      zT(e, t, '_first', '_last', e._sort ? '_start' : 0),
      Rv(t) || (e._recent = t),
      r || VT(e, t),
      e._ts < 0 && tm(e, e._tTime),
      e
    );
  },
  HT = function (e, t) {
    return (
      (Xi.ScrollTrigger || yy('scrollTrigger', t)) &&
      Xi.ScrollTrigger.create(t, e)
    );
  },
  GT = function (e, t, i, r, s) {
    if ((Ay(e, t, s), !e._initted)) return 1;
    if (
      !i &&
      e._pt &&
      !qn &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      UT !== Bi.frame
    )
      return (js.push(e), (e._lazy = [s, r]), 1);
  },
  FO = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
  },
  Rv = function (e) {
    var t = e.data;
    return t === 'isFromStart' || t === 'isStart';
  },
  zO = function (e, t, i, r) {
    var s = e.ratio,
      a =
        t < 0 ||
        (!t &&
          ((!e._start && FO(e) && !(!e._initted && Rv(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !Rv(e))))
          ? 0
          : 1,
      o = e._rDelay,
      l = 0,
      c,
      u,
      h;
    if (
      (o &&
        e._repeat &&
        ((l = Sh(0, e._tDur, t)),
        (u = Gl(l, o)),
        e._yoyo && u & 1 && (a = 1 - a),
        u !== Gl(e._tTime, o) &&
          ((s = 1 - a), e.vars.repeatRefresh && e._initted && e.invalidate())),
      a !== s || qn || r || e._zTime === $t || (!t && e._zTime))
    ) {
      if (!e._initted && GT(e, t, r, i, l)) return;
      for (
        h = e._zTime,
          e._zTime = t || (i ? $t : 0),
          i || (i = t && !h),
          e.ratio = a,
          e._from && (a = 1 - a),
          e._time = 0,
          e._tTime = l,
          c = e._pt;
        c;

      )
        (c.r(a, c.d), (c = c._next));
      (t < 0 && Cv(e, t, i, !0),
        e._onUpdate && !i && zi(e, 'onUpdate'),
        l && e._repeat && !i && e.parent && zi(e, 'onRepeat'),
        (t >= e._tDur || t < 0) &&
          e.ratio === a &&
          (a && Ks(e, 1),
          !i &&
            !qn &&
            (zi(e, a ? 'onComplete' : 'onReverseComplete', !0),
            e._prom && e._prom())));
    } else e._zTime || (e._zTime = t);
  },
  VO = function (e, t, i) {
    var r;
    if (i > t)
      for (r = e._first; r && r._start <= i; ) {
        if (r.data === 'isPause' && r._start > t) return r;
        r = r._next;
      }
    else
      for (r = e._last; r && r._start >= i; ) {
        if (r.data === 'isPause' && r._start < t) return r;
        r = r._prev;
      }
  },
  Wl = function (e, t, i, r) {
    var s = e._repeat,
      a = Tn(t) || 0,
      o = e._tTime / e._tDur;
    return (
      o && !r && (e._time *= a / e._dur),
      (e._dur = a),
      (e._tDur = s ? (s < 0 ? 1e10 : Tn(a * (s + 1) + e._rDelay * s)) : a),
      o > 0 && !r && tm(e, (e._tTime = e._tDur * o)),
      e.parent && em(e),
      i || vo(e.parent, e),
      e
    );
  },
  RS = function (e) {
    return e instanceof li ? vo(e) : Wl(e, e._dur);
  },
  HO = { _start: 0, endTime: zu, totalDuration: zu },
  $i = function n(e, t, i) {
    var r = e.labels,
      s = e._recent || HO,
      a = e.duration() >= nr ? s.endTime(!1) : e._dur,
      o,
      l,
      c;
    return Wn(t) && (isNaN(t) || t in r)
      ? ((l = t.charAt(0)),
        (c = t.substr(-1) === '%'),
        (o = t.indexOf('=')),
        l === '<' || l === '>'
          ? (o >= 0 && (t = t.replace(/=/, '')),
            (l === '<' ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (c ? (o < 0 ? s : i).totalDuration() / 100 : 1))
          : o < 0
            ? (t in r || (r[t] = a), r[t])
            : ((l = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
              c && i && (l = (l / 100) * (ni(i) ? i[0] : i).totalDuration()),
              o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l))
      : t == null
        ? a
        : +t;
  },
  _u = function (e, t, i) {
    var r = ms(t[1]),
      s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
      a = t[s],
      o,
      l;
    if ((r && (a.duration = t[1]), (a.parent = i), e)) {
      for (o = a, l = i; l && !('immediateRender' in o); )
        ((o = l.vars.defaults || {}), (l = wi(l.vars.inherit) && l.parent));
      ((a.immediateRender = wi(o.immediateRender)),
        e < 2 ? (a.runBackwards = 1) : (a.startAt = t[s - 1]));
    }
    return new Mn(t[0], a, t[s + 1]);
  },
  ra = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  Sh = function (e, t, i) {
    return i < e ? e : i > t ? t : i;
  },
  ei = function (e, t) {
    return !Wn(e) || !(t = PO.exec(e)) ? '' : t[1];
  },
  GO = function (e, t, i) {
    return ra(i, function (r) {
      return Sh(e, t, r);
    });
  },
  Iv = [].slice,
  WT = function (e, t) {
    return (
      e &&
      Hr(e) &&
      'length' in e &&
      ((!t && !e.length) || (e.length - 1 in e && Hr(e[0]))) &&
      !e.nodeType &&
      e !== Or
    );
  },
  WO = function (e, t, i) {
    return (
      i === void 0 && (i = []),
      e.forEach(function (r) {
        var s;
        return (Wn(r) && !t) || WT(r, 1)
          ? (s = i).push.apply(s, ir(r))
          : i.push(r);
      }) || i
    );
  },
  ir = function (e, t, i) {
    return nn && !t && nn.selector
      ? nn.selector(e)
      : Wn(e) && !i && (Mv || !jl())
        ? Iv.call((t || _y).querySelectorAll(e), 0)
        : ni(e)
          ? WO(e, i)
          : WT(e)
            ? Iv.call(e, 0)
            : e
              ? [e]
              : [];
  },
  Pv = function (e) {
    return (
      (e = ir(e)[0] || Fu('Invalid scope') || {}),
      function (t) {
        var i = e.current || e.nativeElement || e;
        return ir(
          t,
          i.querySelectorAll
            ? i
            : i === e
              ? Fu('Invalid scope') || _y.createElement('div')
              : e
        );
      }
    );
  },
  jT = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  XT = function (e) {
    if (pn(e)) return e;
    var t = Hr(e) ? e : { each: e },
      i = _o(t.ease),
      r = t.from || 0,
      s = parseFloat(t.base) || 0,
      a = {},
      o = r > 0 && r < 1,
      l = isNaN(r) || o,
      c = t.axis,
      u = r,
      h = r;
    return (
      Wn(r)
        ? (u = h = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
        : !o && l && ((u = r[0]), (h = r[1])),
      function (d, f, p) {
        var m = (p || t).length,
          g = a[m],
          v,
          y,
          _,
          x,
          S,
          b,
          A,
          E,
          w;
        if (!g) {
          if (((w = t.grid === 'auto' ? 0 : (t.grid || [1, nr])[1]), !w)) {
            for (
              A = -nr;
              A < (A = p[w++].getBoundingClientRect().left) && w < m;

            );
            w < m && w--;
          }
          for (
            g = a[m] = [],
              v = l ? Math.min(w, m) * u - 0.5 : r % w,
              y = w === nr ? 0 : l ? (m * h) / w - 0.5 : (r / w) | 0,
              A = 0,
              E = nr,
              b = 0;
            b < m;
            b++
          )
            ((_ = (b % w) - v),
              (x = y - ((b / w) | 0)),
              (g[b] = S = c ? Math.abs(c === 'y' ? x : _) : TT(_ * _ + x * x)),
              S > A && (A = S),
              S < E && (E = S));
          (r === 'random' && jT(g),
            (g.max = A - E),
            (g.min = E),
            (g.v = m =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (w > m
                    ? m - 1
                    : c
                      ? c === 'y'
                        ? m / w
                        : w
                      : Math.max(w, m / w)) ||
                0) * (r === 'edges' ? -1 : 1)),
            (g.b = m < 0 ? s - m : s),
            (g.u = ei(t.amount || t.each) || 0),
            (i = i && m < 0 ? nC(i) : i));
        }
        return (
          (m = (g[d] - g.min) / g.max || 0),
          Tn(g.b + (i ? i(m) : m) * g.v) + g.u
        );
      }
    );
  },
  Dv = function (e) {
    var t = Math.pow(10, ((e + '').split('.')[1] || '').length);
    return function (i) {
      var r = Tn(Math.round(parseFloat(i) / e) * e * t);
      return (r - (r % 1)) / t + (ms(i) ? 0 : ei(i));
    };
  },
  qT = function (e, t) {
    var i = ni(e),
      r,
      s;
    return (
      !i &&
        Hr(e) &&
        ((r = i = e.radius || nr),
        e.values
          ? ((e = ir(e.values)), (s = !ms(e[0])) && (r *= r))
          : (e = Dv(e.increment))),
      ra(
        t,
        i
          ? pn(e)
            ? function (a) {
                return ((s = e(a)), Math.abs(s - a) <= r ? s : a);
              }
            : function (a) {
                for (
                  var o = parseFloat(s ? a.x : a),
                    l = parseFloat(s ? a.y : 0),
                    c = nr,
                    u = 0,
                    h = e.length,
                    d,
                    f;
                  h--;

                )
                  (s
                    ? ((d = e[h].x - o), (f = e[h].y - l), (d = d * d + f * f))
                    : (d = Math.abs(e[h] - o)),
                    d < c && ((c = d), (u = h)));
                return (
                  (u = !r || c <= r ? e[u] : a),
                  s || u === a || ms(a) ? u : u + ei(a)
                );
              }
          : Dv(e)
      )
    );
  },
  YT = function (e, t, i, r) {
    return ra(ni(e) ? !t : i === !0 ? !!(i = 0) : !r, function () {
      return ni(e)
        ? e[~~(Math.random() * e.length)]
        : (i = i || 1e-5) &&
            (r = i < 1 ? Math.pow(10, (i + '').length - 2) : 1) &&
            Math.floor(
              Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) *
                i *
                r
            ) / r;
    });
  },
  jO = function () {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return function (r) {
      return t.reduce(function (s, a) {
        return a(s);
      }, r);
    };
  },
  XO = function (e, t) {
    return function (i) {
      return e(parseFloat(i)) + (t || ei(i));
    };
  },
  qO = function (e, t, i) {
    return JT(e, t, 0, 1, i);
  },
  KT = function (e, t, i) {
    return ra(i, function (r) {
      return e[~~t(r)];
    });
  },
  YO = function n(e, t, i) {
    var r = t - e;
    return ni(e)
      ? KT(e, n(0, e.length), t)
      : ra(i, function (s) {
          return ((r + ((s - e) % r)) % r) + e;
        });
  },
  KO = function n(e, t, i) {
    var r = t - e,
      s = r * 2;
    return ni(e)
      ? KT(e, n(0, e.length - 1), t)
      : ra(i, function (a) {
          return ((a = (s + ((a - e) % s)) % s || 0), e + (a > r ? s - a : a));
        });
  },
  Vu = function (e) {
    for (var t = 0, i = '', r, s, a, o; ~(r = e.indexOf('random(', t)); )
      ((a = e.indexOf(')', r)),
        (o = e.charAt(r + 7) === '['),
        (s = e.substr(r + 7, a - r - 7).match(o ? PT : Av)),
        (i +=
          e.substr(t, r - t) + YT(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5)),
        (t = a + 1));
    return i + e.substr(t, e.length - t);
  },
  JT = function (e, t, i, r, s) {
    var a = t - e,
      o = r - i;
    return ra(s, function (l) {
      return i + (((l - e) / a) * o || 0);
    });
  },
  JO = function n(e, t, i, r) {
    var s = isNaN(e + t)
      ? 0
      : function (f) {
          return (1 - f) * e + f * t;
        };
    if (!s) {
      var a = Wn(e),
        o = {},
        l,
        c,
        u,
        h,
        d;
      if ((i === !0 && (r = 1) && (i = null), a))
        ((e = { p: e }), (t = { p: t }));
      else if (ni(e) && !ni(t)) {
        for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++)
          u.push(n(e[c - 1], e[c]));
        (h--,
          (s = function (p) {
            p *= h;
            var m = Math.min(d, ~~p);
            return u[m](p - m);
          }),
          (i = t));
      } else r || (e = Hl(ni(e) ? [] : {}, e));
      if (!u) {
        for (l in t) Ey.call(o, e, l, 'get', t[l]);
        s = function (p) {
          return Cy(p, o) || (a ? e.p : e);
        };
      }
    }
    return ra(i, s);
  },
  IS = function (e, t, i) {
    var r = e.labels,
      s = nr,
      a,
      o,
      l;
    for (a in r)
      ((o = r[a] - t),
        o < 0 == !!i && o && s > (o = Math.abs(o)) && ((l = a), (s = o)));
    return l;
  },
  zi = function (e, t, i) {
    var r = e.vars,
      s = r[t],
      a = nn,
      o = e._ctx,
      l,
      c,
      u;
    if (s)
      return (
        (l = r[t + 'Params']),
        (c = r.callbackScope || e),
        i && js.length && Vf(),
        o && (nn = o),
        (u = l ? s.apply(c, l) : s.call(c)),
        (nn = a),
        u
      );
  },
  cu = function (e) {
    return (
      Ks(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!qn),
      e.progress() < 1 && zi(e, 'onInterrupt'),
      e
    );
  },
  Al,
  QT = [],
  ZT = function (e) {
    if (e)
      if (((e = (!e.name && e.default) || e), vy() || e.headless)) {
        var t = e.name,
          i = pn(e),
          r =
            t && !i && e.init
              ? function () {
                  this._props = [];
                }
              : e,
          s = {
            init: zu,
            render: Cy,
            add: Ey,
            kill: dL,
            modifier: hL,
            rawVars: 0,
          },
          a = {
            targetTest: 0,
            get: 0,
            getSetter: Ty,
            aliases: {},
            register: 0,
          };
        if ((jl(), e !== r)) {
          if (ki[t]) return;
          (qi(r, qi(Hf(e, s), a)),
            Hl(r.prototype, Hl(s, Hf(e, a))),
            (ki[(r.prop = t)] = r),
            e.targetTest && (yf.push(r), (xy[t] = 1)),
            (t =
              (t === 'css' ? 'CSS' : t.charAt(0).toUpperCase() + t.substr(1)) +
              'Plugin'));
        }
        (LT(t, r), e.register && e.register(Pi, r, Ai));
      } else QT.push(e);
  },
  Zt = 255,
  uu = {
    aqua: [0, Zt, Zt],
    lime: [0, Zt, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Zt],
    navy: [0, 0, 128],
    white: [Zt, Zt, Zt],
    olive: [128, 128, 0],
    yellow: [Zt, Zt, 0],
    orange: [Zt, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Zt, 0, 0],
    pink: [Zt, 192, 203],
    cyan: [0, Zt, Zt],
    transparent: [Zt, Zt, Zt, 0],
  },
  Ag = function (e, t, i) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (i - t) * e * 6
        : e < 0.5
          ? i
          : e * 3 < 2
            ? t + (i - t) * (2 / 3 - e) * 6
            : t) *
        Zt +
        0.5) |
        0
    );
  },
  $T = function (e, t, i) {
    var r = e ? (ms(e) ? [e >> 16, (e >> 8) & Zt, e & Zt] : 0) : uu.black,
      s,
      a,
      o,
      l,
      c,
      u,
      h,
      d,
      f,
      p;
    if (!r) {
      if ((e.substr(-1) === ',' && (e = e.substr(0, e.length - 1)), uu[e]))
        r = uu[e];
      else if (e.charAt(0) === '#') {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (a = e.charAt(2)),
            (o = e.charAt(3)),
            (e =
              '#' +
              s +
              s +
              a +
              a +
              o +
              o +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ''))),
          e.length === 9)
        )
          return (
            (r = parseInt(e.substr(1, 6), 16)),
            [r >> 16, (r >> 8) & Zt, r & Zt, parseInt(e.substr(7), 16) / 255]
          );
        ((e = parseInt(e.substr(1), 16)),
          (r = [e >> 16, (e >> 8) & Zt, e & Zt]));
      } else if (e.substr(0, 3) === 'hsl') {
        if (((r = p = e.match(Av)), !t))
          ((l = (+r[0] % 360) / 360),
            (c = +r[1] / 100),
            (u = +r[2] / 100),
            (a = u <= 0.5 ? u * (c + 1) : u + c - u * c),
            (s = u * 2 - a),
            r.length > 3 && (r[3] *= 1),
            (r[0] = Ag(l + 1 / 3, s, a)),
            (r[1] = Ag(l, s, a)),
            (r[2] = Ag(l - 1 / 3, s, a)));
        else if (~e.indexOf('='))
          return ((r = e.match(RT)), i && r.length < 4 && (r[3] = 1), r);
      } else r = e.match(Av) || uu.transparent;
      r = r.map(Number);
    }
    return (
      t &&
        !p &&
        ((s = r[0] / Zt),
        (a = r[1] / Zt),
        (o = r[2] / Zt),
        (h = Math.max(s, a, o)),
        (d = Math.min(s, a, o)),
        (u = (h + d) / 2),
        h === d
          ? (l = c = 0)
          : ((f = h - d),
            (c = u > 0.5 ? f / (2 - h - d) : f / (h + d)),
            (l =
              h === s
                ? (a - o) / f + (a < o ? 6 : 0)
                : h === a
                  ? (o - s) / f + 2
                  : (s - a) / f + 4),
            (l *= 60)),
        (r[0] = ~~(l + 0.5)),
        (r[1] = ~~(c * 100 + 0.5)),
        (r[2] = ~~(u * 100 + 0.5))),
      i && r.length < 4 && (r[3] = 1),
      r
    );
  },
  eC = function (e) {
    var t = [],
      i = [],
      r = -1;
    return (
      e.split(Xs).forEach(function (s) {
        var a = s.match(El) || [];
        (t.push.apply(t, a), i.push((r += a.length + 1)));
      }),
      (t.c = i),
      t
    );
  },
  PS = function (e, t, i) {
    var r = '',
      s = (e + r).match(Xs),
      a = t ? 'hsla(' : 'rgba(',
      o = 0,
      l,
      c,
      u,
      h;
    if (!s) return e;
    if (
      ((s = s.map(function (d) {
        return (
          (d = $T(d, t, 1)) &&
          a +
            (t ? d[0] + ',' + d[1] + '%,' + d[2] + '%,' + d[3] : d.join(',')) +
            ')'
        );
      })),
      i && ((u = eC(e)), (l = i.c), l.join(r) !== u.c.join(r)))
    )
      for (c = e.replace(Xs, '1').split(El), h = c.length - 1; o < h; o++)
        r +=
          c[o] +
          (~l.indexOf(o)
            ? s.shift() || a + '0,0,0,0)'
            : (u.length ? u : s.length ? s : i).shift());
    if (!c)
      for (c = e.split(Xs), h = c.length - 1; o < h; o++) r += c[o] + s[o];
    return r + c[h];
  },
  Xs = (function () {
    var n =
        '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b',
      e;
    for (e in uu) n += '|' + e + '\\b';
    return new RegExp(n + ')', 'gi');
  })(),
  QO = /hsl[a]?\(/,
  tC = function (e) {
    var t = e.join(' '),
      i;
    if (((Xs.lastIndex = 0), Xs.test(t)))
      return (
        (i = QO.test(t)),
        (e[1] = PS(e[1], i)),
        (e[0] = PS(e[0], i, eC(e[1]))),
        !0
      );
  },
  Hu,
  Bi = (function () {
    var n = Date.now,
      e = 500,
      t = 33,
      i = n(),
      r = i,
      s = 1e3 / 240,
      a = s,
      o = [],
      l,
      c,
      u,
      h,
      d,
      f,
      p = function m(g) {
        var v = n() - r,
          y = g === !0,
          _,
          x,
          S,
          b;
        if (
          ((v > e || v < 0) && (i += v - t),
          (r += v),
          (S = r - i),
          (_ = S - a),
          (_ > 0 || y) &&
            ((b = ++h.frame),
            (d = S - h.time * 1e3),
            (h.time = S = S / 1e3),
            (a += _ + (_ >= s ? 4 : s - _)),
            (x = 1)),
          y || (l = c(m)),
          x)
        )
          for (f = 0; f < o.length; f++) o[f](S, d, b, g);
      };
    return (
      (h = {
        time: 0,
        frame: 0,
        tick: function () {
          p(!0);
        },
        deltaRatio: function (g) {
          return d / (1e3 / (g || 60));
        },
        wake: function () {
          DT &&
            (!Mv &&
              vy() &&
              ((Or = Mv = window),
              (_y = Or.document || {}),
              (Xi.gsap = Pi),
              (Or.gsapVersions || (Or.gsapVersions = [])).push(Pi.version),
              OT(zf || Or.GreenSockGlobals || (!Or.gsap && Or) || {}),
              QT.forEach(ZT)),
            (u = typeof requestAnimationFrame < 'u' && requestAnimationFrame),
            l && h.sleep(),
            (c =
              u ||
              function (g) {
                return setTimeout(g, (a - h.time * 1e3 + 1) | 0);
              }),
            (Hu = 1),
            p(2));
        },
        sleep: function () {
          ((u ? cancelAnimationFrame : clearTimeout)(l), (Hu = 0), (c = zu));
        },
        lagSmoothing: function (g, v) {
          ((e = g || 1 / 0), (t = Math.min(v || 33, e)));
        },
        fps: function (g) {
          ((s = 1e3 / (g || 240)), (a = h.time * 1e3 + s));
        },
        add: function (g, v, y) {
          var _ = v
            ? function (x, S, b, A) {
                (g(x, S, b, A), h.remove(_));
              }
            : g;
          return (h.remove(g), o[y ? 'unshift' : 'push'](_), jl(), _);
        },
        remove: function (g, v) {
          ~(v = o.indexOf(g)) && o.splice(v, 1) && f >= v && f--;
        },
        _listeners: o,
      }),
      h
    );
  })(),
  jl = function () {
    return !Hu && Bi.wake();
  },
  Ut = {},
  ZO = /^[\d.\-M][\d.\-,\s]/,
  $O = /["']/g,
  eL = function (e) {
    for (
      var t = {},
        i = e.substr(1, e.length - 3).split(':'),
        r = i[0],
        s = 1,
        a = i.length,
        o,
        l,
        c;
      s < a;
      s++
    )
      ((l = i[s]),
        (o = s !== a - 1 ? l.lastIndexOf(',') : l.length),
        (c = l.substr(0, o)),
        (t[r] = isNaN(c) ? c.replace($O, '').trim() : +c),
        (r = l.substr(o + 1).trim()));
    return t;
  },
  tL = function (e) {
    var t = e.indexOf('(') + 1,
      i = e.indexOf(')'),
      r = e.indexOf('(', t);
    return e.substring(t, ~r && r < i ? e.indexOf(')', i + 1) : i);
  },
  nL = function (e) {
    var t = (e + '').split('('),
      i = Ut[t[0]];
    return i && t.length > 1 && i.config
      ? i.config.apply(
          null,
          ~e.indexOf('{') ? [eL(t[1])] : tL(e).split(',').map(NT)
        )
      : Ut._CE && ZO.test(e)
        ? Ut._CE('', e)
        : i;
  },
  nC = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  iC = function n(e, t) {
    for (var i = e._first, r; i; )
      (i instanceof li
        ? n(i, t)
        : i.vars.yoyoEase &&
          (!i._yoyo || !i._repeat) &&
          i._yoyo !== t &&
          (i.timeline
            ? n(i.timeline, t)
            : ((r = i._ease),
              (i._ease = i._yEase),
              (i._yEase = r),
              (i._yoyo = t))),
        (i = i._next));
  },
  _o = function (e, t) {
    return (e && (pn(e) ? e : Ut[e] || nL(e))) || t;
  },
  No = function (e, t, i, r) {
    (i === void 0 &&
      (i = function (l) {
        return 1 - t(1 - l);
      }),
      r === void 0 &&
        (r = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        }));
    var s = { easeIn: t, easeOut: i, easeInOut: r },
      a;
    return (
      Ei(e, function (o) {
        ((Ut[o] = Xi[o] = s), (Ut[(a = o.toLowerCase())] = i));
        for (var l in s)
          Ut[
            a + (l === 'easeIn' ? '.in' : l === 'easeOut' ? '.out' : '.inOut')
          ] = Ut[o + '.' + l] = s[l];
      }),
      s
    );
  },
  rC = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  Mg = function n(e, t, i) {
    var r = t >= 1 ? t : 1,
      s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      a = (s / Ev) * (Math.asin(1 / r) || 0),
      o = function (u) {
        return u === 1 ? 1 : r * Math.pow(2, -10 * u) * IO((u - a) * s) + 1;
      },
      l =
        e === 'out'
          ? o
          : e === 'in'
            ? function (c) {
                return 1 - o(1 - c);
              }
            : rC(o);
    return (
      (s = Ev / s),
      (l.config = function (c, u) {
        return n(e, c, u);
      }),
      l
    );
  },
  Tg = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function (a) {
        return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
      },
      r =
        e === 'out'
          ? i
          : e === 'in'
            ? function (s) {
                return 1 - i(1 - s);
              }
            : rC(i);
    return (
      (r.config = function (s) {
        return n(e, s);
      }),
      r
    );
  };
Ei('Linear,Quad,Cubic,Quart,Quint,Strong', function (n, e) {
  var t = e < 5 ? e + 1 : e;
  No(
    n + ',Power' + (t - 1),
    e
      ? function (i) {
          return Math.pow(i, t);
        }
      : function (i) {
          return i;
        },
    function (i) {
      return 1 - Math.pow(1 - i, t);
    },
    function (i) {
      return i < 0.5
        ? Math.pow(i * 2, t) / 2
        : 1 - Math.pow((1 - i) * 2, t) / 2;
    }
  );
});
Ut.Linear.easeNone = Ut.none = Ut.Linear.easeIn;
No('Elastic', Mg('in'), Mg('out'), Mg());
(function (n, e) {
  var t = 1 / e,
    i = 2 * t,
    r = 2.5 * t,
    s = function (o) {
      return o < t
        ? n * o * o
        : o < i
          ? n * Math.pow(o - 1.5 / e, 2) + 0.75
          : o < r
            ? n * (o -= 2.25 / e) * o + 0.9375
            : n * Math.pow(o - 2.625 / e, 2) + 0.984375;
    };
  No(
    'Bounce',
    function (a) {
      return 1 - s(1 - a);
    },
    s
  );
})(7.5625, 2.75);
No('Expo', function (n) {
  return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
});
No('Circ', function (n) {
  return -(TT(1 - n * n) - 1);
});
No('Sine', function (n) {
  return n === 1 ? 1 : -RO(n * TO) + 1;
});
No('Back', Tg('in'), Tg('out'), Tg());
Ut.SteppedEase =
  Ut.steps =
  Xi.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e,
          r = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          a = 1 - $t;
        return function (o) {
          return (((r * Sh(0, a, o)) | 0) + s) * i;
        };
      },
    };
Vl.ease = Ut['quad.out'];
Ei(
  'onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt',
  function (n) {
    return (by += n + ',' + n + 'Params,');
  }
);
var sC = function (e, t) {
    ((this.id = CO++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : kT),
      (this.set = t ? t.getSetter : Ty));
  },
  Gu = (function () {
    function n(t) {
      ((this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        Wl(this, +t.duration, 1, 1),
        (this.data = t.data),
        nn && ((this._ctx = nn), nn.data.push(this)),
        Hu || Bi.wake());
    }
    var e = n.prototype;
    return (
      (e.delay = function (i) {
        return i || i === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + i - this._delay),
            (this._delay = i),
            this)
          : this._delay;
      }),
      (e.duration = function (i) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (i) {
        return arguments.length
          ? ((this._dirty = 0),
            Wl(
              this,
              this._repeat < 0
                ? i
                : (i - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (i, r) {
        if ((jl(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (tm(this, i), !s._dp || s.parent || VT(s, this); s && s.parent; )
            (s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent));
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && i < this._tDur) ||
              (this._ts < 0 && i > 0) ||
              (!this._tDur && !i)) &&
            Lr(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== i ||
            (!this._dur && !r) ||
            (this._initted && Math.abs(this._zTime) === $t) ||
            (!i && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = i), BT(this, i, r)),
          this
        );
      }),
      (e.time = function (i, r) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), i + CS(this)) %
                (this._dur + this._rDelay) || (i ? this._dur : 0),
              r
            )
          : this._time;
      }),
      (e.totalProgress = function (i, r) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * i, r)
          : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.rawTime() >= 0 && this._initted
              ? 1
              : 0;
      }),
      (e.progress = function (i, r) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                CS(this),
              r
            )
          : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.rawTime() > 0
              ? 1
              : 0;
      }),
      (e.iteration = function (i, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (i - 1) * s, r)
          : this._repeat
            ? Gl(this._tTime, s) + 1
            : 1;
      }),
      (e.timeScale = function (i, r) {
        if (!arguments.length) return this._rts === -$t ? 0 : this._rts;
        if (this._rts === i) return this;
        var s =
          this.parent && this._ts ? Gf(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +i || 0),
          (this._ts = this._ps || i === -$t ? 0 : this._rts),
          this.totalTime(
            Sh(-Math.abs(this._delay), this.totalDuration(), s),
            r !== !1
          ),
          em(this),
          BO(this)
        );
      }),
      (e.paused = function (i) {
        return arguments.length
          ? (this._ps !== i &&
              ((this._ps = i),
              i
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (jl(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== $t &&
                      (this._tTime -= $t)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (i) {
        if (arguments.length) {
          this._start = i;
          var r = this.parent || this._dp;
          return (
            r && (r._sort || !this.parent) && Lr(r, this, i - this._delay),
            this
          );
        }
        return this._start;
      }),
      (e.endTime = function (i) {
        return (
          this._start +
          (wi(i) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (i) {
        var r = this.parent || this._dp;
        return r
          ? i &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
              ? Gf(r.rawTime(i), this)
              : this._tTime
          : this._tTime;
      }),
      (e.revert = function (i) {
        i === void 0 && (i = OO);
        var r = qn;
        return (
          (qn = i),
          wy(this) &&
            (this.timeline && this.timeline.revert(i),
            this.totalTime(-0.01, i.suppressEvents)),
          this.data !== 'nested' && i.kill !== !1 && this.kill(),
          (qn = r),
          this
        );
      }),
      (e.globalTime = function (i) {
        for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
          ((s = r._start + s / (Math.abs(r._ts) || 1)), (r = r._dp));
        return !this.parent && this._sat ? this._sat.globalTime(i) : s;
      }),
      (e.repeat = function (i) {
        return arguments.length
          ? ((this._repeat = i === 1 / 0 ? -2 : i), RS(this))
          : this._repeat === -2
            ? 1 / 0
            : this._repeat;
      }),
      (e.repeatDelay = function (i) {
        if (arguments.length) {
          var r = this._time;
          return ((this._rDelay = i), RS(this), r ? this.time(r) : this);
        }
        return this._rDelay;
      }),
      (e.yoyo = function (i) {
        return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
      }),
      (e.seek = function (i, r) {
        return this.totalTime($i(this, i), wi(r));
      }),
      (e.restart = function (i, r) {
        return (
          this.play().totalTime(i ? -this._delay : 0, wi(r)),
          this._dur || (this._zTime = -$t),
          this
        );
      }),
      (e.play = function (i, r) {
        return (i != null && this.seek(i, r), this.reversed(!1).paused(!1));
      }),
      (e.reverse = function (i, r) {
        return (
          i != null && this.seek(i || this.totalDuration(), r),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (i, r) {
        return (i != null && this.seek(i, r), this.paused(!0));
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (i) {
        return arguments.length
          ? (!!i !== this.reversed() &&
              this.timeScale(-this._rts || (i ? -$t : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return ((this._initted = this._act = 0), (this._zTime = -$t), this);
      }),
      (e.isActive = function () {
        var i = this.parent || this._dp,
          r = this._start,
          s;
        return !!(
          !i ||
          (this._ts &&
            this._initted &&
            i.isActive() &&
            (s = i.rawTime(!0)) >= r &&
            s < this.endTime(!0) - $t)
        );
      }),
      (e.eventCallback = function (i, r, s) {
        var a = this.vars;
        return arguments.length > 1
          ? (r
              ? ((a[i] = r),
                s && (a[i + 'Params'] = s),
                i === 'onUpdate' && (this._onUpdate = r))
              : delete a[i],
            this)
          : a[i];
      }),
      (e.then = function (i) {
        var r = this;
        return new Promise(function (s) {
          var a = pn(i) ? i : FT,
            o = function () {
              var c = r.then;
              ((r.then = null),
                pn(a) && (a = a(r)) && (a.then || a === r) && (r.then = c),
                s(a),
                (r.then = c));
            };
          (r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
          (!r._tTime && r._ts < 0)
            ? o()
            : (r._prom = o);
        });
      }),
      (e.kill = function () {
        cu(this);
      }),
      n
    );
  })();
qi(Gu.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -$t,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var li = (function (n) {
  MT(e, n);
  function e(i, r) {
    var s;
    return (
      i === void 0 && (i = {}),
      (s = n.call(this, i) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!i.smoothChildTiming),
      (s.autoRemoveChildren = !!i.autoRemoveChildren),
      (s._sort = wi(i.sortChildren)),
      an && Lr(i.parent || an, rs(s), r),
      i.reversed && s.reverse(),
      i.paused && s.paused(!0),
      i.scrollTrigger && HT(rs(s), i.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (r, s, a) {
      return (_u(0, arguments, this), this);
    }),
    (t.from = function (r, s, a) {
      return (_u(1, arguments, this), this);
    }),
    (t.fromTo = function (r, s, a, o) {
      return (_u(2, arguments, this), this);
    }),
    (t.set = function (r, s, a) {
      return (
        (s.duration = 0),
        (s.parent = this),
        vu(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new Mn(r, s, $i(this, a), 1),
        this
      );
    }),
    (t.call = function (r, s, a) {
      return Lr(this, Mn.delayedCall(0, r, s), a);
    }),
    (t.staggerTo = function (r, s, a, o, l, c, u) {
      return (
        (a.duration = s),
        (a.stagger = a.stagger || o),
        (a.onComplete = c),
        (a.onCompleteParams = u),
        (a.parent = this),
        new Mn(r, a, $i(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (r, s, a, o, l, c, u) {
      return (
        (a.runBackwards = 1),
        (vu(a).immediateRender = wi(a.immediateRender)),
        this.staggerTo(r, s, a, o, l, c, u)
      );
    }),
    (t.staggerFromTo = function (r, s, a, o, l, c, u, h) {
      return (
        (o.startAt = a),
        (vu(o).immediateRender = wi(o.immediateRender)),
        this.staggerTo(r, s, o, l, c, u, h)
      );
    }),
    (t.render = function (r, s, a) {
      var o = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        u = r <= 0 ? 0 : Tn(r),
        h = this._zTime < 0 != r < 0 && (this._initted || !c),
        d,
        f,
        p,
        m,
        g,
        v,
        y,
        _,
        x,
        S,
        b,
        A;
      if (
        (this !== an && u > l && r >= 0 && (u = l), u !== this._tTime || a || h)
      ) {
        if (
          (o !== this._time &&
            c &&
            ((u += this._time - o), (r += this._time - o)),
          (d = u),
          (x = this._start),
          (_ = this._ts),
          (v = !_),
          h && (c || (o = this._zTime), (r || !s) && (this._zTime = r)),
          this._repeat)
        ) {
          if (
            ((b = this._yoyo),
            (g = c + this._rDelay),
            this._repeat < -1 && r < 0)
          )
            return this.totalTime(g * 100 + r, s, a);
          if (
            ((d = Tn(u % g)),
            u === l
              ? ((m = this._repeat), (d = c))
              : ((S = Tn(u / g)),
                (m = ~~S),
                m && m === S && ((d = c), m--),
                d > c && (d = c)),
            (S = Gl(this._tTime, g)),
            !o &&
              this._tTime &&
              S !== m &&
              this._tTime - S * g - this._dur <= 0 &&
              (S = m),
            b && m & 1 && ((d = c - d), (A = 1)),
            m !== S && !this._lock)
          ) {
            var E = b && S & 1,
              w = E === (b && m & 1);
            if (
              (m < S && (E = !E),
              (o = E ? 0 : u % c ? c : u),
              (this._lock = 1),
              (this.render(o || (A ? 0 : Tn(m * g)), s, !c)._lock = 0),
              (this._tTime = u),
              !s && this.parent && zi(this, 'onRepeat'),
              this.vars.repeatRefresh && !A && (this.invalidate()._lock = 1),
              (o && o !== this._time) ||
                v !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((c = this._dur),
              (l = this._tDur),
              w &&
                ((this._lock = 2),
                (o = E ? c : -1e-4),
                this.render(o, !0),
                this.vars.repeatRefresh && !A && this.invalidate()),
              (this._lock = 0),
              !this._ts && !v)
            )
              return this;
            iC(this, A);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = VO(this, Tn(o), Tn(d))), y && (u -= d - (d = y._start))),
          (this._tTime = u),
          (this._time = d),
          (this._act = !_),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = r),
            (o = 0)),
          !o && u && !s && !S && (zi(this, 'onStart'), this._tTime !== u))
        )
          return this;
        if (d >= o && r >= 0)
          for (f = this._first; f; ) {
            if (
              ((p = f._next), (f._act || d >= f._start) && f._ts && y !== f)
            ) {
              if (f.parent !== this) return this.render(r, s, a);
              if (
                (f.render(
                  f._ts > 0
                    ? (d - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (d - f._start) * f._ts,
                  s,
                  a
                ),
                d !== this._time || (!this._ts && !v))
              ) {
                ((y = 0), p && (u += this._zTime = -$t));
                break;
              }
            }
            f = p;
          }
        else {
          f = this._last;
          for (var M = r < 0 ? r : d; f; ) {
            if (((p = f._prev), (f._act || M <= f._end) && f._ts && y !== f)) {
              if (f.parent !== this) return this.render(r, s, a);
              if (
                (f.render(
                  f._ts > 0
                    ? (M - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (M - f._start) * f._ts,
                  s,
                  a || (qn && wy(f))
                ),
                d !== this._time || (!this._ts && !v))
              ) {
                ((y = 0), p && (u += this._zTime = M ? -$t : $t));
                break;
              }
            }
            f = p;
          }
        }
        if (
          y &&
          !s &&
          (this.pause(),
          (y.render(d >= o ? 0 : -$t)._zTime = d >= o ? 1 : -1),
          this._ts)
        )
          return ((this._start = x), em(this), this.render(r, s, a));
        (this._onUpdate && !s && zi(this, 'onUpdate', !0),
          ((u === l && this._tTime >= this.totalDuration()) || (!u && o)) &&
            (x === this._start || Math.abs(_) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((r || !c) &&
                ((u === l && this._ts > 0) || (!u && this._ts < 0)) &&
                Ks(this, 1),
              !s &&
                !(r < 0 && !o) &&
                (u || o || !l) &&
                (zi(
                  this,
                  u === l && r >= 0 ? 'onComplete' : 'onReverseComplete',
                  !0
                ),
                this._prom &&
                  !(u < l && this.timeScale() > 0) &&
                  this._prom()))));
      }
      return this;
    }),
    (t.add = function (r, s) {
      var a = this;
      if ((ms(s) || (s = $i(this, s, r)), !(r instanceof Gu))) {
        if (ni(r))
          return (
            r.forEach(function (o) {
              return a.add(o, s);
            }),
            this
          );
        if (Wn(r)) return this.addLabel(r, s);
        if (pn(r)) r = Mn.delayedCall(0, r);
        else return this;
      }
      return this !== r ? Lr(this, r, s) : this;
    }),
    (t.getChildren = function (r, s, a, o) {
      (r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        a === void 0 && (a = !0),
        o === void 0 && (o = -nr));
      for (var l = [], c = this._first; c; )
        (c._start >= o &&
          (c instanceof Mn
            ? s && l.push(c)
            : (a && l.push(c), r && l.push.apply(l, c.getChildren(!0, s, a)))),
          (c = c._next));
      return l;
    }),
    (t.getById = function (r) {
      for (var s = this.getChildren(1, 1, 1), a = s.length; a--; )
        if (s[a].vars.id === r) return s[a];
    }),
    (t.remove = function (r) {
      return Wn(r)
        ? this.removeLabel(r)
        : pn(r)
          ? this.killTweensOf(r)
          : (r.parent === this && $p(this, r),
            r === this._recent && (this._recent = this._last),
            vo(this));
    }),
    (t.totalTime = function (r, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = Tn(
              Bi.time -
                (this._ts > 0
                  ? r / this._ts
                  : (this.totalDuration() - r) / -this._ts)
            )),
          n.prototype.totalTime.call(this, r, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (r, s) {
      return ((this.labels[r] = $i(this, s)), this);
    }),
    (t.removeLabel = function (r) {
      return (delete this.labels[r], this);
    }),
    (t.addPause = function (r, s, a) {
      var o = Mn.delayedCall(0, s || zu, a);
      return (
        (o.data = 'isPause'),
        (this._hasPause = 1),
        Lr(this, o, $i(this, r))
      );
    }),
    (t.removePause = function (r) {
      var s = this._first;
      for (r = $i(this, r); s; )
        (s._start === r && s.data === 'isPause' && Ks(s), (s = s._next));
    }),
    (t.killTweensOf = function (r, s, a) {
      for (var o = this.getTweensOf(r, a), l = o.length; l--; )
        Ns !== o[l] && o[l].kill(r, s);
      return this;
    }),
    (t.getTweensOf = function (r, s) {
      for (var a = [], o = ir(r), l = this._first, c = ms(s), u; l; )
        (l instanceof Mn
          ? LO(l._targets, o) &&
            (c
              ? (!Ns || (l._initted && l._ts)) &&
                l.globalTime(0) <= s &&
                l.globalTime(l.totalDuration()) > s
              : !s || l.isActive()) &&
            a.push(l)
          : (u = l.getTweensOf(o, s)).length && a.push.apply(a, u),
          (l = l._next));
      return a;
    }),
    (t.tweenTo = function (r, s) {
      s = s || {};
      var a = this,
        o = $i(a, r),
        l = s,
        c = l.startAt,
        u = l.onStart,
        h = l.onStartParams,
        d = l.immediateRender,
        f,
        p = Mn.to(
          a,
          qi(
            {
              ease: s.ease || 'none',
              lazy: !1,
              immediateRender: !1,
              time: o,
              overwrite: 'auto',
              duration:
                s.duration ||
                Math.abs(
                  (o - (c && 'time' in c ? c.time : a._time)) / a.timeScale()
                ) ||
                $t,
              onStart: function () {
                if ((a.pause(), !f)) {
                  var g =
                    s.duration ||
                    Math.abs(
                      (o - (c && 'time' in c ? c.time : a._time)) /
                        a.timeScale()
                    );
                  (p._dur !== g && Wl(p, g, 0, 1).render(p._time, !0, !0),
                    (f = 1));
                }
                u && u.apply(p, h || []);
              },
            },
            s
          )
        );
      return d ? p.render(0) : p;
    }),
    (t.tweenFromTo = function (r, s, a) {
      return this.tweenTo(s, qi({ startAt: { time: $i(this, r) } }, a));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (r) {
      return (r === void 0 && (r = this._time), IS(this, $i(this, r)));
    }),
    (t.previousLabel = function (r) {
      return (r === void 0 && (r = this._time), IS(this, $i(this, r), 1));
    }),
    (t.currentLabel = function (r) {
      return arguments.length
        ? this.seek(r, !0)
        : this.previousLabel(this._time + $t);
    }),
    (t.shiftChildren = function (r, s, a) {
      a === void 0 && (a = 0);
      for (var o = this._first, l = this.labels, c; o; )
        (o._start >= a && ((o._start += r), (o._end += r)), (o = o._next));
      if (s) for (c in l) l[c] >= a && (l[c] += r);
      return vo(this);
    }),
    (t.invalidate = function (r) {
      var s = this._first;
      for (this._lock = 0; s; ) (s.invalidate(r), (s = s._next));
      return n.prototype.invalidate.call(this, r);
    }),
    (t.clear = function (r) {
      r === void 0 && (r = !0);
      for (var s = this._first, a; s; )
        ((a = s._next), this.remove(s), (s = a));
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        vo(this)
      );
    }),
    (t.totalDuration = function (r) {
      var s = 0,
        a = this,
        o = a._last,
        l = nr,
        c,
        u,
        h;
      if (arguments.length)
        return a.timeScale(
          (a._repeat < 0 ? a.duration() : a.totalDuration()) /
            (a.reversed() ? -r : r)
        );
      if (a._dirty) {
        for (h = a.parent; o; )
          ((c = o._prev),
            o._dirty && o.totalDuration(),
            (u = o._start),
            u > l && a._sort && o._ts && !a._lock
              ? ((a._lock = 1), (Lr(a, o, u - o._delay, 1)._lock = 0))
              : (l = u),
            u < 0 &&
              o._ts &&
              ((s -= u),
              ((!h && !a._dp) || (h && h.smoothChildTiming)) &&
                ((a._start += u / a._ts), (a._time -= u), (a._tTime -= u)),
              a.shiftChildren(-u, !1, -1 / 0),
              (l = 0)),
            o._end > s && o._ts && (s = o._end),
            (o = c));
        (Wl(a, a === an && a._time > s ? a._time : s, 1, 1), (a._dirty = 0));
      }
      return a._tDur;
    }),
    (e.updateRoot = function (r) {
      if ((an._ts && (BT(an, Gf(r, an)), (UT = Bi.frame)), Bi.frame >= MS)) {
        MS += Gi.autoSleep || 120;
        var s = an._first;
        if ((!s || !s._ts) && Gi.autoSleep && Bi._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || Bi.sleep();
        }
      }
    }),
    e
  );
})(Gu);
qi(li.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var iL = function (e, t, i, r, s, a, o) {
    var l = new Ai(this._pt, e, t, 0, 1, hC, null, s),
      c = 0,
      u = 0,
      h,
      d,
      f,
      p,
      m,
      g,
      v,
      y;
    for (
      l.b = i,
        l.e = r,
        i += '',
        r += '',
        (v = ~r.indexOf('random(')) && (r = Vu(r)),
        a && ((y = [i, r]), a(y, e, t), (i = y[0]), (r = y[1])),
        d = i.match(wg) || [];
      (h = wg.exec(r));

    )
      ((p = h[0]),
        (m = r.substring(c, h.index)),
        f ? (f = (f + 1) % 5) : m.substr(-5) === 'rgba(' && (f = 1),
        p !== d[u++] &&
          ((g = parseFloat(d[u - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: m || u === 1 ? m : ',',
            s: g,
            c: p.charAt(1) === '=' ? Ul(g, p) - g : parseFloat(p) - g,
            m: f && f < 4 ? Math.round : 0,
          }),
          (c = wg.lastIndex)));
    return (
      (l.c = c < r.length ? r.substring(c, r.length) : ''),
      (l.fp = o),
      (IT.test(r) || v) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  Ey = function (e, t, i, r, s, a, o, l, c, u) {
    pn(r) && (r = r(s || 0, e, a));
    var h = e[t],
      d =
        i !== 'get'
          ? i
          : pn(h)
            ? c
              ? e[
                  t.indexOf('set') || !pn(e['get' + t.substr(3)])
                    ? t
                    : 'get' + t.substr(3)
                ](c)
              : e[t]()
            : h,
      f = pn(h) ? (c ? lL : cC) : My,
      p;
    if (
      (Wn(r) &&
        (~r.indexOf('random(') && (r = Vu(r)),
        r.charAt(1) === '=' &&
          ((p = Ul(d, r) + (ei(d) || 0)), (p || p === 0) && (r = p))),
      !u || d !== r || Ov)
    )
      return !isNaN(d * r) && r !== ''
        ? ((p = new Ai(
            this._pt,
            e,
            t,
            +d || 0,
            r - (d || 0),
            typeof h == 'boolean' ? uL : uC,
            0,
            f
          )),
          c && (p.fp = c),
          o && p.modifier(o, this, e),
          (this._pt = p))
        : (!h && !(t in e) && yy(t, r),
          iL.call(this, e, t, d, r, f, l || Gi.stringFilter, c));
  },
  rL = function (e, t, i, r, s) {
    if (
      (pn(e) && (e = yu(e, s, t, i, r)),
      !Hr(e) || (e.style && e.nodeType) || ni(e) || CT(e))
    )
      return Wn(e) ? yu(e, s, t, i, r) : e;
    var a = {},
      o;
    for (o in e) a[o] = yu(e[o], s, t, i, r);
    return a;
  },
  aC = function (e, t, i, r, s, a) {
    var o, l, c, u;
    if (
      ki[e] &&
      (o = new ki[e]()).init(
        s,
        o.rawVars ? t[e] : rL(t[e], r, s, a, i),
        i,
        r,
        a
      ) !== !1 &&
      ((i._pt = l = new Ai(i._pt, s, e, 0, 1, o.render, o, 0, o.priority)),
      i !== Al)
    )
      for (c = i._ptLookup[i._targets.indexOf(s)], u = o._props.length; u--; )
        c[o._props[u]] = l;
    return o;
  },
  Ns,
  Ov,
  Ay = function n(e, t, i) {
    var r = e.vars,
      s = r.ease,
      a = r.startAt,
      o = r.immediateRender,
      l = r.lazy,
      c = r.onUpdate,
      u = r.runBackwards,
      h = r.yoyoEase,
      d = r.keyframes,
      f = r.autoRevert,
      p = e._dur,
      m = e._startAt,
      g = e._targets,
      v = e.parent,
      y = v && v.data === 'nested' ? v.vars.targets : g,
      _ = e._overwrite === 'auto' && !my,
      x = e.timeline,
      S,
      b,
      A,
      E,
      w,
      M,
      T,
      D,
      L,
      O,
      z,
      C,
      N;
    if (
      (x && (!d || !s) && (s = 'none'),
      (e._ease = _o(s, Vl.ease)),
      (e._yEase = h ? nC(_o(h === !0 ? s : h, Vl.ease)) : 0),
      h &&
        e._yoyo &&
        !e._repeat &&
        ((h = e._yEase), (e._yEase = e._ease), (e._ease = h)),
      (e._from = !x && !!r.runBackwards),
      !x || (d && !r.stagger))
    ) {
      if (
        ((D = g[0] ? go(g[0]).harness : 0),
        (C = D && r[D.prop]),
        (S = Hf(r, xy)),
        m &&
          (m._zTime < 0 && m.progress(1),
          t < 0 && u && o && !f ? m.render(-1, !0) : m.revert(u && p ? _f : DO),
          (m._lazy = 0)),
        a)
      ) {
        if (
          (Ks(
            (e._startAt = Mn.set(
              g,
              qi(
                {
                  data: 'isStart',
                  overwrite: !1,
                  parent: v,
                  immediateRender: !0,
                  lazy: !m && wi(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    c &&
                    function () {
                      return zi(e, 'onUpdate');
                    },
                  stagger: 0,
                },
                a
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (qn || (!o && !f)) && e._startAt.revert(_f),
          o && p && t <= 0 && i <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (u && p && !m) {
        if (
          (t && (o = !1),
          (A = qi(
            {
              overwrite: !1,
              data: 'isFromStart',
              lazy: o && !m && wi(l),
              immediateRender: o,
              stagger: 0,
              parent: v,
            },
            S
          )),
          C && (A[D.prop] = C),
          Ks((e._startAt = Mn.set(g, A))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (qn ? e._startAt.revert(_f) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !o)
        )
          n(e._startAt, $t, $t);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (p && wi(l)) || (l && !p), b = 0;
        b < g.length;
        b++
      ) {
        if (
          ((w = g[b]),
          (T = w._gsap || Sy(g)[b]._gsap),
          (e._ptLookup[b] = O = {}),
          Tv[T.id] && js.length && Vf(),
          (z = y === g ? b : y.indexOf(w)),
          D &&
            (L = new D()).init(w, C || S, e, z, y) !== !1 &&
            ((e._pt = E =
              new Ai(e._pt, w, L.name, 0, 1, L.render, L, 0, L.priority)),
            L._props.forEach(function (U) {
              O[U] = E;
            }),
            L.priority && (M = 1)),
          !D || C)
        )
          for (A in S)
            ki[A] && (L = aC(A, S, e, z, w, y))
              ? L.priority && (M = 1)
              : (O[A] = E =
                  Ey.call(e, w, A, 'get', S[A], z, y, 0, r.stringFilter));
        (e._op && e._op[b] && e.kill(w, e._op[b]),
          _ &&
            e._pt &&
            ((Ns = e),
            an.killTweensOf(w, O, e.globalTime(t)),
            (N = !e.parent),
            (Ns = 0)),
          e._pt && l && (Tv[T.id] = 1));
      }
      (M && dC(e), e._onInit && e._onInit(e));
    }
    ((e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !N),
      d && t <= 0 && x.render(nr, !0, !0));
  },
  sL = function (e, t, i, r, s, a, o, l) {
    var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      u,
      h,
      d,
      f;
    if (!c)
      for (
        c = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length;
        f--;

      ) {
        if (((u = d[f][t]), u && u.d && u.d._pt))
          for (u = u.d._pt; u && u.p !== t && u.fp !== t; ) u = u._next;
        if (!u)
          return (
            (Ov = 1),
            (e.vars[t] = '+=0'),
            Ay(e, o),
            (Ov = 0),
            l ? Fu(t + ' not eligible for reset') : 1
          );
        c.push(u);
      }
    for (f = c.length; f--; )
      ((h = c[f]),
        (u = h._pt || h),
        (u.s = (r || r === 0) && !s ? r : u.s + (r || 0) + a * u.c),
        (u.c = i - u.s),
        h.e && (h.e = xn(i) + ei(h.e)),
        h.b && (h.b = u.s + ei(h.b)));
  },
  aL = function (e, t) {
    var i = e[0] ? go(e[0]).harness : 0,
      r = i && i.aliases,
      s,
      a,
      o,
      l;
    if (!r) return t;
    s = Hl({}, t);
    for (a in r)
      if (a in s) for (l = r[a].split(','), o = l.length; o--; ) s[l[o]] = s[a];
    return s;
  },
  oL = function (e, t, i, r) {
    var s = t.ease || r || 'power1.inOut',
      a,
      o;
    if (ni(t))
      ((o = i[e] || (i[e] = [])),
        t.forEach(function (l, c) {
          return o.push({ t: (c / (t.length - 1)) * 100, v: l, e: s });
        }));
    else
      for (a in t)
        ((o = i[a] || (i[a] = [])),
          a === 'ease' || o.push({ t: parseFloat(e), v: t[a], e: s }));
  },
  yu = function (e, t, i, r, s) {
    return pn(e)
      ? e.call(t, i, r, s)
      : Wn(e) && ~e.indexOf('random(')
        ? Vu(e)
        : e;
  },
  oC = by + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
  lC = {};
Ei(oC + ',id,stagger,delay,duration,paused,scrollTrigger', function (n) {
  return (lC[n] = 1);
});
var Mn = (function (n) {
  MT(e, n);
  function e(i, r, s, a) {
    var o;
    (typeof r == 'number' && ((s.duration = r), (r = s), (s = null)),
      (o = n.call(this, a ? r : vu(r)) || this));
    var l = o.vars,
      c = l.duration,
      u = l.delay,
      h = l.immediateRender,
      d = l.stagger,
      f = l.overwrite,
      p = l.keyframes,
      m = l.defaults,
      g = l.scrollTrigger,
      v = l.yoyoEase,
      y = r.parent || an,
      _ = (ni(i) || CT(i) ? ms(i[0]) : 'length' in r) ? [i] : ir(i),
      x,
      S,
      b,
      A,
      E,
      w,
      M,
      T;
    if (
      ((o._targets = _.length
        ? Sy(_)
        : Fu(
            'GSAP target ' + i + ' not found. https://gsap.com',
            !Gi.nullTargetWarn
          ) || []),
      (o._ptLookup = []),
      (o._overwrite = f),
      p || d || td(c) || td(u))
    ) {
      if (
        ((r = o.vars),
        (x = o.timeline =
          new li({
            data: 'nested',
            defaults: m || {},
            targets: y && y.data === 'nested' ? y.vars.targets : _,
          })),
        x.kill(),
        (x.parent = x._dp = rs(o)),
        (x._start = 0),
        d || td(c) || td(u))
      ) {
        if (((A = _.length), (M = d && XT(d)), Hr(d)))
          for (E in d) ~oC.indexOf(E) && (T || (T = {}), (T[E] = d[E]));
        for (S = 0; S < A; S++)
          ((b = Hf(r, lC)),
            (b.stagger = 0),
            v && (b.yoyoEase = v),
            T && Hl(b, T),
            (w = _[S]),
            (b.duration = +yu(c, rs(o), S, w, _)),
            (b.delay = (+yu(u, rs(o), S, w, _) || 0) - o._delay),
            !d &&
              A === 1 &&
              b.delay &&
              ((o._delay = u = b.delay), (o._start += u), (b.delay = 0)),
            x.to(w, b, M ? M(S, w, _) : 0),
            (x._ease = Ut.none));
        x.duration() ? (c = u = 0) : (o.timeline = 0);
      } else if (p) {
        (vu(qi(x.vars.defaults, { ease: 'none' })),
          (x._ease = _o(p.ease || r.ease || 'none')));
        var D = 0,
          L,
          O,
          z;
        if (ni(p))
          (p.forEach(function (C) {
            return x.to(_, C, '>');
          }),
            x.duration());
        else {
          b = {};
          for (E in p)
            E === 'ease' || E === 'easeEach' || oL(E, p[E], b, p.easeEach);
          for (E in b)
            for (
              L = b[E].sort(function (C, N) {
                return C.t - N.t;
              }),
                D = 0,
                S = 0;
              S < L.length;
              S++
            )
              ((O = L[S]),
                (z = {
                  ease: O.e,
                  duration: ((O.t - (S ? L[S - 1].t : 0)) / 100) * c,
                }),
                (z[E] = O.v),
                x.to(_, z, D),
                (D += z.duration));
          x.duration() < c && x.to({}, { duration: c - x.duration() });
        }
      }
      c || o.duration((c = x.duration()));
    } else o.timeline = 0;
    return (
      f === !0 && !my && ((Ns = rs(o)), an.killTweensOf(_), (Ns = 0)),
      Lr(y, rs(o), s),
      r.reversed && o.reverse(),
      r.paused && o.paused(!0),
      (h ||
        (!c &&
          !p &&
          o._start === Tn(y._time) &&
          wi(h) &&
          NO(rs(o)) &&
          y.data !== 'nested')) &&
        ((o._tTime = -$t), o.render(Math.max(0, -u) || 0)),
      g && HT(rs(o), g),
      o
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (r, s, a) {
      var o = this._time,
        l = this._tDur,
        c = this._dur,
        u = r < 0,
        h = r > l - $t && !u ? l : r < $t ? 0 : r,
        d,
        f,
        p,
        m,
        g,
        v,
        y,
        _,
        x;
      if (!c) zO(this, r, s, a);
      else if (
        h !== this._tTime ||
        !r ||
        a ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== u) ||
        this._lazy
      ) {
        if (((d = h), (_ = this.timeline), this._repeat)) {
          if (((m = c + this._rDelay), this._repeat < -1 && u))
            return this.totalTime(m * 100 + r, s, a);
          if (
            ((d = Tn(h % m)),
            h === l
              ? ((p = this._repeat), (d = c))
              : ((g = Tn(h / m)),
                (p = ~~g),
                p && p === g ? ((d = c), p--) : d > c && (d = c)),
            (v = this._yoyo && p & 1),
            v && ((x = this._yEase), (d = c - d)),
            (g = Gl(this._tTime, m)),
            d === o && !a && this._initted && p === g)
          )
            return ((this._tTime = h), this);
          p !== g &&
            (_ && this._yEase && iC(_, v),
            this.vars.repeatRefresh &&
              !v &&
              !this._lock &&
              d !== m &&
              this._initted &&
              ((this._lock = a = 1),
              (this.render(Tn(m * p), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (GT(this, u ? r : d, a, s, h)) return ((this._tTime = 0), this);
          if (o !== this._time && !(a && this.vars.repeatRefresh && p !== g))
            return this;
          if (c !== this._dur) return this.render(r, s, a);
        }
        if (
          ((this._tTime = h),
          (this._time = d),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = y = (x || this._ease)(d / c)),
          this._from && (this.ratio = y = 1 - y),
          !o && h && !s && !g && (zi(this, 'onStart'), this._tTime !== h))
        )
          return this;
        for (f = this._pt; f; ) (f.r(y, f.d), (f = f._next));
        ((_ && _.render(r < 0 ? r : _._dur * _._ease(d / this._dur), s, a)) ||
          (this._startAt && (this._zTime = r)),
          this._onUpdate &&
            !s &&
            (u && Cv(this, r, s, a), zi(this, 'onUpdate')),
          this._repeat &&
            p !== g &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            zi(this, 'onRepeat'),
          (h === this._tDur || !h) &&
            this._tTime === h &&
            (u && !this._onUpdate && Cv(this, r, !0, !0),
            (r || !c) &&
              ((h === this._tDur && this._ts > 0) || (!h && this._ts < 0)) &&
              Ks(this, 1),
            !s &&
              !(u && !o) &&
              (h || o || v) &&
              (zi(this, h === l ? 'onComplete' : 'onReverseComplete', !0),
              this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (r) {
      return (
        (!r || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(r),
        n.prototype.invalidate.call(this, r)
      );
    }),
    (t.resetTo = function (r, s, a, o, l) {
      (Hu || Bi.wake(), this._ts || this.play());
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        u;
      return (
        this._initted || Ay(this, c),
        (u = this._ease(c / this._dur)),
        sL(this, r, s, a, o, u, c, l)
          ? this.resetTo(r, s, a, o, 1)
          : (tm(this, 0),
            this.parent ||
              zT(
                this._dp,
                this,
                '_first',
                '_last',
                this._dp._sort ? '_start' : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (r, s) {
      if ((s === void 0 && (s = 'all'), !r && (!s || s === 'all')))
        return (
          (this._lazy = this._pt = 0),
          this.parent
            ? cu(this)
            : this.scrollTrigger && this.scrollTrigger.kill(!!qn),
          this
        );
      if (this.timeline) {
        var a = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(r, s, Ns && Ns.vars.overwrite !== !0)
            ._first || cu(this),
          this.parent &&
            a !== this.timeline.totalDuration() &&
            Wl(this, (this._dur * this.timeline._tDur) / a, 0, 1),
          this
        );
      }
      var o = this._targets,
        l = r ? ir(r) : o,
        c = this._ptLookup,
        u = this._pt,
        h,
        d,
        f,
        p,
        m,
        g,
        v;
      if ((!s || s === 'all') && kO(o, l))
        return (s === 'all' && (this._pt = 0), cu(this));
      for (
        h = this._op = this._op || [],
          s !== 'all' &&
            (Wn(s) &&
              ((m = {}),
              Ei(s, function (y) {
                return (m[y] = 1);
              }),
              (s = m)),
            (s = aL(o, s))),
          v = o.length;
        v--;

      )
        if (~l.indexOf(o[v])) {
          ((d = c[v]),
            s === 'all'
              ? ((h[v] = s), (p = d), (f = {}))
              : ((f = h[v] = h[v] || {}), (p = s)));
          for (m in p)
            ((g = d && d[m]),
              g &&
                ((!('kill' in g.d) || g.d.kill(m) === !0) && $p(this, g, '_pt'),
                delete d[m]),
              f !== 'all' && (f[m] = 1));
        }
      return (this._initted && !this._pt && u && cu(this), this);
    }),
    (e.to = function (r, s) {
      return new e(r, s, arguments[2]);
    }),
    (e.from = function (r, s) {
      return _u(1, arguments);
    }),
    (e.delayedCall = function (r, s, a, o) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: r,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: a,
        onReverseCompleteParams: a,
        callbackScope: o,
      });
    }),
    (e.fromTo = function (r, s, a) {
      return _u(2, arguments);
    }),
    (e.set = function (r, s) {
      return ((s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(r, s));
    }),
    (e.killTweensOf = function (r, s, a) {
      return an.killTweensOf(r, s, a);
    }),
    e
  );
})(Gu);
qi(Mn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Ei('staggerTo,staggerFrom,staggerFromTo', function (n) {
  Mn[n] = function () {
    var e = new li(),
      t = Iv.call(arguments, 0);
    return (t.splice(n === 'staggerFromTo' ? 5 : 4, 0, 0), e[n].apply(e, t));
  };
});
var My = function (e, t, i) {
    return (e[t] = i);
  },
  cC = function (e, t, i) {
    return e[t](i);
  },
  lL = function (e, t, i, r) {
    return e[t](r.fp, i);
  },
  cL = function (e, t, i) {
    return e.setAttribute(t, i);
  },
  Ty = function (e, t) {
    return pn(e[t]) ? cC : gy(e[t]) && e.setAttribute ? cL : My;
  },
  uC = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  uL = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  hC = function (e, t) {
    var i = t._pt,
      r = '';
    if (!e && t.b) r = t.b;
    else if (e === 1 && t.e) r = t.e;
    else {
      for (; i; )
        ((r =
          i.p +
          (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
          r),
          (i = i._next));
      r += t.c;
    }
    t.set(t.t, t.p, r, t);
  },
  Cy = function (e, t) {
    for (var i = t._pt; i; ) (i.r(e, i.d), (i = i._next));
  },
  hL = function (e, t, i, r) {
    for (var s = this._pt, a; s; )
      ((a = s._next), s.p === r && s.modifier(e, t, i), (s = a));
  },
  dL = function (e) {
    for (var t = this._pt, i, r; t; )
      ((r = t._next),
        (t.p === e && !t.op) || t.op === e
          ? $p(this, t, '_pt')
          : t.dep || (i = 1),
        (t = r));
    return !i;
  },
  fL = function (e, t, i, r) {
    r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
  },
  dC = function (e) {
    for (var t = e._pt, i, r, s, a; t; ) {
      for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
      ((t._prev = r ? r._prev : a) ? (t._prev._next = t) : (s = t),
        (t._next = r) ? (r._prev = t) : (a = t),
        (t = i));
    }
    e._pt = s;
  },
  Ai = (function () {
    function n(t, i, r, s, a, o, l, c, u) {
      ((this.t = i),
        (this.s = s),
        (this.c = a),
        (this.p = r),
        (this.r = o || uC),
        (this.d = l || this),
        (this.set = c || My),
        (this.pr = u || 0),
        (this._next = t),
        t && (t._prev = this));
    }
    var e = n.prototype;
    return (
      (e.modifier = function (i, r, s) {
        ((this.mSet = this.mSet || this.set),
          (this.set = fL),
          (this.m = i),
          (this.mt = s),
          (this.tween = r));
      }),
      n
    );
  })();
Ei(
  by +
    'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
  function (n) {
    return (xy[n] = 1);
  }
);
Xi.TweenMax = Xi.TweenLite = Mn;
Xi.TimelineLite = Xi.TimelineMax = li;
an = new li({
  sortChildren: !1,
  defaults: Vl,
  autoRemoveChildren: !0,
  id: 'root',
  smoothChildTiming: !0,
});
Gi.stringFilter = tC;
var yo = [],
  xf = {},
  pL = [],
  DS = 0,
  mL = 0,
  Cg = function (e) {
    return (xf[e] || pL).map(function (t) {
      return t();
    });
  },
  Lv = function () {
    var e = Date.now(),
      t = [];
    e - DS > 2 &&
      (Cg('matchMediaInit'),
      yo.forEach(function (i) {
        var r = i.queries,
          s = i.conditions,
          a,
          o,
          l,
          c;
        for (o in r)
          ((a = Or.matchMedia(r[o]).matches),
            a && (l = 1),
            a !== s[o] && ((s[o] = a), (c = 1)));
        c && (i.revert(), l && t.push(i));
      }),
      Cg('matchMediaRevert'),
      t.forEach(function (i) {
        return i.onMatch(i, function (r) {
          return i.add(null, r);
        });
      }),
      (DS = e),
      Cg('matchMedia'));
  },
  fC = (function () {
    function n(t, i) {
      ((this.selector = i && Pv(i)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = mL++),
        t && this.add(t));
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        pn(i) && ((s = r), (r = i), (i = pn));
        var a = this,
          o = function () {
            var c = nn,
              u = a.selector,
              h;
            return (
              c && c !== a && c.data.push(a),
              s && (a.selector = Pv(s)),
              (nn = a),
              (h = r.apply(a, arguments)),
              pn(h) && a._r.push(h),
              (nn = c),
              (a.selector = u),
              (a.isReverted = !1),
              h
            );
          };
        return (
          (a.last = o),
          i === pn
            ? o(a, function (l) {
                return a.add(null, l);
              })
            : i
              ? (a[i] = o)
              : o
        );
      }),
      (e.ignore = function (i) {
        var r = nn;
        ((nn = null), i(this), (nn = r));
      }),
      (e.getTweens = function () {
        var i = [];
        return (
          this.data.forEach(function (r) {
            return r instanceof n
              ? i.push.apply(i, r.getTweens())
              : r instanceof Mn &&
                  !(r.parent && r.parent.data === 'nested') &&
                  i.push(r);
          }),
          i
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (i, r) {
        var s = this;
        if (
          (i
            ? (function () {
                for (var o = s.getTweens(), l = s.data.length, c; l--; )
                  ((c = s.data[l]),
                    c.data === 'isFlip' &&
                      (c.revert(),
                      c.getChildren(!0, !0, !1).forEach(function (u) {
                        return o.splice(o.indexOf(u), 1);
                      })));
                for (
                  o
                    .map(function (u) {
                      return {
                        g:
                          u._dur ||
                          u._delay ||
                          (u._sat && !u._sat.vars.immediateRender)
                            ? u.globalTime(0)
                            : -1 / 0,
                        t: u,
                      };
                    })
                    .sort(function (u, h) {
                      return h.g - u.g || -1 / 0;
                    })
                    .forEach(function (u) {
                      return u.t.revert(i);
                    }),
                    l = s.data.length;
                  l--;

                )
                  ((c = s.data[l]),
                    c instanceof li
                      ? c.data !== 'nested' &&
                        (c.scrollTrigger && c.scrollTrigger.revert(), c.kill())
                      : !(c instanceof Mn) && c.revert && c.revert(i));
                (s._r.forEach(function (u) {
                  return u(i, s);
                }),
                  (s.isReverted = !0));
              })()
            : this.data.forEach(function (o) {
                return o.kill && o.kill();
              }),
          this.clear(),
          r)
        )
          for (var a = yo.length; a--; )
            yo[a].id === this.id && yo.splice(a, 1);
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      n
    );
  })(),
  gL = (function () {
    function n(t) {
      ((this.contexts = []), (this.scope = t), nn && nn.data.push(this));
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        Hr(i) || (i = { matches: i });
        var a = new fC(0, s || this.scope),
          o = (a.conditions = {}),
          l,
          c,
          u;
        (nn && !a.selector && (a.selector = nn.selector),
          this.contexts.push(a),
          (r = a.add('onMatch', r)),
          (a.queries = i));
        for (c in i)
          c === 'all'
            ? (u = 1)
            : ((l = Or.matchMedia(i[c])),
              l &&
                (yo.indexOf(a) < 0 && yo.push(a),
                (o[c] = l.matches) && (u = 1),
                l.addListener
                  ? l.addListener(Lv)
                  : l.addEventListener('change', Lv)));
        return (
          u &&
            r(a, function (h) {
              return a.add(null, h);
            }),
          this
        );
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      (e.kill = function (i) {
        this.contexts.forEach(function (r) {
          return r.kill(i, !0);
        });
      }),
      n
    );
  })(),
  Wf = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      t.forEach(function (r) {
        return ZT(r);
      });
    },
    timeline: function (e) {
      return new li(e);
    },
    getTweensOf: function (e, t) {
      return an.getTweensOf(e, t);
    },
    getProperty: function (e, t, i, r) {
      Wn(e) && (e = ir(e)[0]);
      var s = go(e || {}).get,
        a = i ? FT : NT;
      return (
        i === 'native' && (i = ''),
        e &&
          (t
            ? a(((ki[t] && ki[t].get) || s)(e, t, i, r))
            : function (o, l, c) {
                return a(((ki[o] && ki[o].get) || s)(e, o, l, c));
              })
      );
    },
    quickSetter: function (e, t, i) {
      if (((e = ir(e)), e.length > 1)) {
        var r = e.map(function (u) {
            return Pi.quickSetter(u, t, i);
          }),
          s = r.length;
        return function (u) {
          for (var h = s; h--; ) r[h](u);
        };
      }
      e = e[0] || {};
      var a = ki[t],
        o = go(e),
        l = (o.harness && (o.harness.aliases || {})[t]) || t,
        c = a
          ? function (u) {
              var h = new a();
              ((Al._pt = 0),
                h.init(e, i ? u + i : u, Al, 0, [e]),
                h.render(1, h),
                Al._pt && Cy(1, Al));
            }
          : o.set(e, l);
      return a
        ? c
        : function (u) {
            return c(e, l, i ? u + i : u, o, 1);
          };
    },
    quickTo: function (e, t, i) {
      var r,
        s = Pi.to(
          e,
          qi(
            ((r = {}), (r[t] = '+=0.1'), (r.paused = !0), (r.stagger = 0), r),
            i || {}
          )
        ),
        a = function (l, c, u) {
          return s.resetTo(t, l, c, u);
        };
      return ((a.tween = s), a);
    },
    isTweening: function (e) {
      return an.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return (e && e.ease && (e.ease = _o(e.ease, Vl.ease)), TS(Vl, e || {}));
    },
    config: function (e) {
      return TS(Gi, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        i = e.effect,
        r = e.plugins,
        s = e.defaults,
        a = e.extendTimeline;
      ((r || '').split(',').forEach(function (o) {
        return (
          o && !ki[o] && !Xi[o] && Fu(t + ' effect requires ' + o + ' plugin.')
        );
      }),
        (Eg[t] = function (o, l, c) {
          return i(ir(o), qi(l || {}, s), c);
        }),
        a &&
          (li.prototype[t] = function (o, l, c) {
            return this.add(Eg[t](o, Hr(l) ? l : (c = l) && {}, this), c);
          }));
    },
    registerEase: function (e, t) {
      Ut[e] = _o(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? _o(e, t) : Ut;
    },
    getById: function (e) {
      return an.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var i = new li(e),
        r,
        s;
      for (
        i.smoothChildTiming = wi(e.smoothChildTiming),
          an.remove(i),
          i._dp = 0,
          i._time = i._tTime = an._time,
          r = an._first;
        r;

      )
        ((s = r._next),
          (t ||
            !(
              !r._dur &&
              r instanceof Mn &&
              r.vars.onComplete === r._targets[0]
            )) &&
            Lr(i, r, r._start - r._delay),
          (r = s));
      return (Lr(an, i, 0), i);
    },
    context: function (e, t) {
      return e ? new fC(e, t) : nn;
    },
    matchMedia: function (e) {
      return new gL(e);
    },
    matchMediaRefresh: function () {
      return (
        yo.forEach(function (e) {
          var t = e.conditions,
            i,
            r;
          for (r in t) t[r] && ((t[r] = !1), (i = 1));
          i && e.revert();
        }) || Lv()
      );
    },
    addEventListener: function (e, t) {
      var i = xf[e] || (xf[e] = []);
      ~i.indexOf(t) || i.push(t);
    },
    removeEventListener: function (e, t) {
      var i = xf[e],
        r = i && i.indexOf(t);
      r >= 0 && i.splice(r, 1);
    },
    utils: {
      wrap: YO,
      wrapYoyo: KO,
      distribute: XT,
      random: YT,
      snap: qT,
      normalize: qO,
      getUnit: ei,
      clamp: GO,
      splitColor: $T,
      toArray: ir,
      selector: Pv,
      mapRange: JT,
      pipe: jO,
      unitize: XO,
      interpolate: JO,
      shuffle: jT,
    },
    install: OT,
    effects: Eg,
    ticker: Bi,
    updateRoot: li.updateRoot,
    plugins: ki,
    globalTimeline: an,
    core: {
      PropTween: Ai,
      globals: LT,
      Tween: Mn,
      Timeline: li,
      Animation: Gu,
      getCache: go,
      _removeLinkedListItem: $p,
      reverting: function () {
        return qn;
      },
      context: function (e) {
        return (e && nn && (nn.data.push(e), (e._ctx = nn)), nn);
      },
      suppressOverwrites: function (e) {
        return (my = e);
      },
    },
  };
Ei('to,from,fromTo,delayedCall,set,killTweensOf', function (n) {
  return (Wf[n] = Mn[n]);
});
Bi.add(li.updateRoot);
Al = Wf.to({}, { duration: 0 });
var vL = function (e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
      i = i._next;
    return i;
  },
  _L = function (e, t) {
    var i = e._targets,
      r,
      s,
      a;
    for (r in t)
      for (s = i.length; s--; )
        ((a = e._ptLookup[s][r]),
          a &&
            (a = a.d) &&
            (a._pt && (a = vL(a, r)),
            a && a.modifier && a.modifier(t[r], e, i[s], r)));
  },
  Rg = function (e, t) {
    return {
      name: e,
      headless: 1,
      rawVars: 1,
      init: function (r, s, a) {
        a._onInit = function (o) {
          var l, c;
          if (
            (Wn(s) &&
              ((l = {}),
              Ei(s, function (u) {
                return (l[u] = 1);
              }),
              (s = l)),
            t)
          ) {
            l = {};
            for (c in s) l[c] = t(s[c]);
            s = l;
          }
          _L(o, s);
        };
      },
    };
  },
  Pi =
    Wf.registerPlugin(
      {
        name: 'attr',
        init: function (e, t, i, r, s) {
          var a, o, l;
          this.tween = i;
          for (a in t)
            ((l = e.getAttribute(a) || ''),
              (o = this.add(
                e,
                'setAttribute',
                (l || 0) + '',
                t[a],
                r,
                s,
                0,
                0,
                a
              )),
              (o.op = a),
              (o.b = l),
              this._props.push(a));
        },
        render: function (e, t) {
          for (var i = t._pt; i; )
            (qn ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), (i = i._next));
        },
      },
      {
        name: 'endArray',
        headless: 1,
        init: function (e, t) {
          for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
        },
      },
      Rg('roundProps', Dv),
      Rg('modifiers'),
      Rg('snap', qT)
    ) || Wf;
Mn.version = li.version = Pi.version = '3.13.0';
DT = 1;
vy() && jl();
Ut.Power0;
Ut.Power1;
Ut.Power2;
Ut.Power3;
Ut.Power4;
Ut.Linear;
Ut.Quad;
Ut.Cubic;
Ut.Quart;
Ut.Quint;
Ut.Strong;
Ut.Elastic;
Ut.Back;
Ut.SteppedEase;
Ut.Bounce;
Ut.Sine;
Ut.Expo;
Ut.Circ;
var OS,
  Fs,
  kl,
  Ry,
  ao,
  LS,
  Iy,
  yL = function () {
    return typeof window < 'u';
  },
  gs = {},
  Za = 180 / Math.PI,
  Bl = Math.PI / 180,
  Xo = Math.atan2,
  US = 1e8,
  Py = /([A-Z])/g,
  xL = /(left|right|width|margin|padding|x)/i,
  bL = /[\s,\(]\S/,
  Ur = {
    autoAlpha: 'opacity,visibility',
    scale: 'scaleX,scaleY',
    alpha: 'opacity',
  },
  Uv = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  SL = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  wL = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  EL = function (e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  pC = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  mC = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  AL = function (e, t, i) {
    return (e.style[t] = i);
  },
  ML = function (e, t, i) {
    return e.style.setProperty(t, i);
  },
  TL = function (e, t, i) {
    return (e._gsap[t] = i);
  },
  CL = function (e, t, i) {
    return (e._gsap.scaleX = e._gsap.scaleY = i);
  },
  RL = function (e, t, i, r, s) {
    var a = e._gsap;
    ((a.scaleX = a.scaleY = i), a.renderTransform(s, a));
  },
  IL = function (e, t, i, r, s) {
    var a = e._gsap;
    ((a[t] = i), a.renderTransform(s, a));
  },
  on = 'transform',
  Mi = on + 'Origin',
  PL = function n(e, t) {
    var i = this,
      r = this.target,
      s = r.style,
      a = r._gsap;
    if (e in gs && s) {
      if (((this.tfm = this.tfm || {}), e !== 'transform'))
        ((e = Ur[e] || e),
          ~e.indexOf(',')
            ? e.split(',').forEach(function (o) {
                return (i.tfm[o] = os(r, o));
              })
            : (this.tfm[e] = a.x ? a[e] : os(r, e)),
          e === Mi && (this.tfm.zOrigin = a.zOrigin));
      else
        return Ur.transform.split(',').forEach(function (o) {
          return n.call(i, o, t);
        });
      if (this.props.indexOf(on) >= 0) return;
      (a.svg &&
        ((this.svgo = r.getAttribute('data-svg-origin')),
        this.props.push(Mi, t, '')),
        (e = on));
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  gC = function (e) {
    e.translate &&
      (e.removeProperty('translate'),
      e.removeProperty('scale'),
      e.removeProperty('rotate'));
  },
  DL = function () {
    var e = this.props,
      t = this.target,
      i = t.style,
      r = t._gsap,
      s,
      a;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? e[s + 1] === 2
          ? t[e[s]](e[s + 2])
          : (t[e[s]] = e[s + 2])
        : e[s + 2]
          ? (i[e[s]] = e[s + 2])
          : i.removeProperty(
              e[s].substr(0, 2) === '--'
                ? e[s]
                : e[s].replace(Py, '-$1').toLowerCase()
            );
    if (this.tfm) {
      for (a in this.tfm) r[a] = this.tfm[a];
      (r.svg &&
        (r.renderTransform(),
        t.setAttribute('data-svg-origin', this.svgo || '')),
        (s = Iy()),
        (!s || !s.isStart) &&
          !i[on] &&
          (gC(i),
          r.zOrigin &&
            i[Mi] &&
            ((i[Mi] += ' ' + r.zOrigin + 'px'),
            (r.zOrigin = 0),
            r.renderTransform()),
          (r.uncache = 1)));
    }
  },
  vC = function (e, t) {
    var i = { target: e, props: [], revert: DL, save: PL };
    return (
      e._gsap || Pi.core.getCache(e),
      t &&
        e.style &&
        e.nodeType &&
        t.split(',').forEach(function (r) {
          return i.save(r);
        }),
      i
    );
  },
  _C,
  kv = function (e, t) {
    var i = Fs.createElementNS
      ? Fs.createElementNS(
          (t || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'),
          e
        )
      : Fs.createElement(e);
    return i && i.style ? i : Fs.createElement(e);
  },
  rr = function n(e, t, i) {
    var r = getComputedStyle(e);
    return (
      r[t] ||
      r.getPropertyValue(t.replace(Py, '-$1').toLowerCase()) ||
      r.getPropertyValue(t) ||
      (!i && n(e, Xl(t) || t, 1)) ||
      ''
    );
  },
  kS = 'O,Moz,ms,Ms,Webkit'.split(','),
  Xl = function (e, t, i) {
    var r = t || ao,
      s = r.style,
      a = 5;
    if (e in s && !i) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      a-- && !(kS[a] + e in s);

    );
    return a < 0 ? null : (a === 3 ? 'ms' : a >= 0 ? kS[a] : '') + e;
  },
  Bv = function () {
    yL() &&
      window.document &&
      ((OS = window),
      (Fs = OS.document),
      (kl = Fs.documentElement),
      (ao = kv('div') || { style: {} }),
      kv('div'),
      (on = Xl(on)),
      (Mi = on + 'Origin'),
      (ao.style.cssText =
        'border-width:0;line-height:0;position:absolute;padding:0'),
      (_C = !!Xl('perspective')),
      (Iy = Pi.core.reverting),
      (Ry = 1));
  },
  BS = function (e) {
    var t = e.ownerSVGElement,
      i = kv(
        'svg',
        (t && t.getAttribute('xmlns')) || 'http://www.w3.org/2000/svg'
      ),
      r = e.cloneNode(!0),
      s;
    ((r.style.display = 'block'), i.appendChild(r), kl.appendChild(i));
    try {
      s = r.getBBox();
    } catch {}
    return (i.removeChild(r), kl.removeChild(i), s);
  },
  NS = function (e, t) {
    for (var i = t.length; i--; )
      if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
  },
  yC = function (e) {
    var t, i;
    try {
      t = e.getBBox();
    } catch {
      ((t = BS(e)), (i = 1));
    }
    return (
      (t && (t.width || t.height)) || i || (t = BS(e)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +NS(e, ['x', 'cx', 'x1']) || 0,
            y: +NS(e, ['y', 'cy', 'y1']) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  xC = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && yC(e));
  },
  To = function (e, t) {
    if (t) {
      var i = e.style,
        r;
      (t in gs && t !== Mi && (t = on),
        i.removeProperty
          ? ((r = t.substr(0, 2)),
            (r === 'ms' || t.substr(0, 6) === 'webkit') && (t = '-' + t),
            i.removeProperty(
              r === '--' ? t : t.replace(Py, '-$1').toLowerCase()
            ))
          : i.removeAttribute(t));
    }
  },
  zs = function (e, t, i, r, s, a) {
    var o = new Ai(e._pt, t, i, 0, 1, a ? mC : pC);
    return ((e._pt = o), (o.b = r), (o.e = s), e._props.push(i), o);
  },
  FS = { deg: 1, rad: 1, turn: 1 },
  OL = { grid: 1, flex: 1 },
  Js = function n(e, t, i, r) {
    var s = parseFloat(i) || 0,
      a = (i + '').trim().substr((s + '').length) || 'px',
      o = ao.style,
      l = xL.test(t),
      c = e.tagName.toLowerCase() === 'svg',
      u = (c ? 'client' : 'offset') + (l ? 'Width' : 'Height'),
      h = 100,
      d = r === 'px',
      f = r === '%',
      p,
      m,
      g,
      v;
    if (r === a || !s || FS[r] || FS[a]) return s;
    if (
      (a !== 'px' && !d && (s = n(e, t, i, 'px')),
      (v = e.getCTM && xC(e)),
      (f || a === '%') && (gs[t] || ~t.indexOf('adius')))
    )
      return (
        (p = v ? e.getBBox()[l ? 'width' : 'height'] : e[u]),
        xn(f ? (s / p) * h : (s / 100) * p)
      );
    if (
      ((o[l ? 'width' : 'height'] = h + (d ? a : r)),
      (m =
        (r !== 'rem' && ~t.indexOf('adius')) ||
        (r === 'em' && e.appendChild && !c)
          ? e
          : e.parentNode),
      v && (m = (e.ownerSVGElement || {}).parentNode),
      (!m || m === Fs || !m.appendChild) && (m = Fs.body),
      (g = m._gsap),
      g && f && g.width && l && g.time === Bi.time && !g.uncache)
    )
      return xn((s / g.width) * h);
    if (f && (t === 'height' || t === 'width')) {
      var y = e.style[t];
      ((e.style[t] = h + r), (p = e[u]), y ? (e.style[t] = y) : To(e, t));
    } else
      ((f || a === '%') &&
        !OL[rr(m, 'display')] &&
        (o.position = rr(e, 'position')),
        m === e && (o.position = 'static'),
        m.appendChild(ao),
        (p = ao[u]),
        m.removeChild(ao),
        (o.position = 'absolute'));
    return (
      l && f && ((g = go(m)), (g.time = Bi.time), (g.width = m[u])),
      xn(d ? (p * s) / h : p && s ? (h / p) * s : 0)
    );
  },
  os = function (e, t, i, r) {
    var s;
    return (
      Ry || Bv(),
      t in Ur &&
        t !== 'transform' &&
        ((t = Ur[t]), ~t.indexOf(',') && (t = t.split(',')[0])),
      gs[t] && t !== 'transform'
        ? ((s = ju(e, r)),
          (s =
            t !== 'transformOrigin'
              ? s[t]
              : s.svg
                ? s.origin
                : Xf(rr(e, Mi)) + ' ' + s.zOrigin + 'px'))
        : ((s = e.style[t]),
          (!s || s === 'auto' || r || ~(s + '').indexOf('calc(')) &&
            (s =
              (jf[t] && jf[t](e, t, i)) ||
              rr(e, t) ||
              kT(e, t) ||
              (t === 'opacity' ? 1 : 0))),
      i && !~(s + '').trim().indexOf(' ') ? Js(e, t, s, i) + i : s
    );
  },
  LL = function (e, t, i, r) {
    if (!i || i === 'none') {
      var s = Xl(t, e, 1),
        a = s && rr(e, s, 1);
      a && a !== i
        ? ((t = s), (i = a))
        : t === 'borderColor' && (i = rr(e, 'borderTopColor'));
    }
    var o = new Ai(this._pt, e.style, t, 0, 1, hC),
      l = 0,
      c = 0,
      u,
      h,
      d,
      f,
      p,
      m,
      g,
      v,
      y,
      _,
      x,
      S;
    if (
      ((o.b = i),
      (o.e = r),
      (i += ''),
      (r += ''),
      r.substring(0, 6) === 'var(--' &&
        (r = rr(e, r.substring(4, r.indexOf(')')))),
      r === 'auto' &&
        ((m = e.style[t]),
        (e.style[t] = r),
        (r = rr(e, t) || r),
        m ? (e.style[t] = m) : To(e, t)),
      (u = [i, r]),
      tC(u),
      (i = u[0]),
      (r = u[1]),
      (d = i.match(El) || []),
      (S = r.match(El) || []),
      S.length)
    ) {
      for (; (h = El.exec(r)); )
        ((g = h[0]),
          (y = r.substring(l, h.index)),
          p
            ? (p = (p + 1) % 5)
            : (y.substr(-5) === 'rgba(' || y.substr(-5) === 'hsla(') && (p = 1),
          g !== (m = d[c++] || '') &&
            ((f = parseFloat(m) || 0),
            (x = m.substr((f + '').length)),
            g.charAt(1) === '=' && (g = Ul(f, g) + x),
            (v = parseFloat(g)),
            (_ = g.substr((v + '').length)),
            (l = El.lastIndex - _.length),
            _ ||
              ((_ = _ || Gi.units[t] || x),
              l === r.length && ((r += _), (o.e += _))),
            x !== _ && (f = Js(e, t, m, _) || 0),
            (o._pt = {
              _next: o._pt,
              p: y || c === 1 ? y : ',',
              s: f,
              c: v - f,
              m: (p && p < 4) || t === 'zIndex' ? Math.round : 0,
            })));
      o.c = l < r.length ? r.substring(l, r.length) : '';
    } else o.r = t === 'display' && r === 'none' ? mC : pC;
    return (IT.test(r) && (o.e = 0), (this._pt = o), o);
  },
  zS = { top: '0%', bottom: '100%', left: '0%', right: '100%', center: '50%' },
  UL = function (e) {
    var t = e.split(' '),
      i = t[0],
      r = t[1] || '50%';
    return (
      (i === 'top' || i === 'bottom' || r === 'left' || r === 'right') &&
        ((e = i), (i = r), (r = e)),
      (t[0] = zS[i] || i),
      (t[1] = zS[r] || r),
      t.join(' ')
    );
  },
  kL = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var i = t.t,
        r = i.style,
        s = t.u,
        a = i._gsap,
        o,
        l,
        c;
      if (s === 'all' || s === !0) ((r.cssText = ''), (l = 1));
      else
        for (s = s.split(','), c = s.length; --c > -1; )
          ((o = s[c]),
            gs[o] && ((l = 1), (o = o === 'transformOrigin' ? Mi : on)),
            To(i, o));
      l &&
        (To(i, on),
        a &&
          (a.svg && i.removeAttribute('transform'),
          (r.scale = r.rotate = r.translate = 'none'),
          ju(i, 1),
          (a.uncache = 1),
          gC(r)));
    }
  },
  jf = {
    clearProps: function (e, t, i, r, s) {
      if (s.data !== 'isFromStart') {
        var a = (e._pt = new Ai(e._pt, t, i, 0, 0, kL));
        return ((a.u = r), (a.pr = -10), (a.tween = s), e._props.push(i), 1);
      }
    },
  },
  Wu = [1, 0, 0, 1, 0, 0],
  bC = {},
  SC = function (e) {
    return e === 'matrix(1, 0, 0, 1, 0, 0)' || e === 'none' || !e;
  },
  VS = function (e) {
    var t = rr(e, on);
    return SC(t) ? Wu : t.substr(7).match(RT).map(xn);
  },
  Dy = function (e, t) {
    var i = e._gsap || go(e),
      r = e.style,
      s = VS(e),
      a,
      o,
      l,
      c;
    return i.svg && e.getAttribute('transform')
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
        s.join(',') === '1,0,0,1,0,0' ? Wu : s)
      : (s === Wu &&
          !e.offsetParent &&
          e !== kl &&
          !i.svg &&
          ((l = r.display),
          (r.display = 'block'),
          (a = e.parentNode),
          (!a || (!e.offsetParent && !e.getBoundingClientRect().width)) &&
            ((c = 1), (o = e.nextElementSibling), kl.appendChild(e)),
          (s = VS(e)),
          l ? (r.display = l) : To(e, 'display'),
          c &&
            (o
              ? a.insertBefore(e, o)
              : a
                ? a.appendChild(e)
                : kl.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  Nv = function (e, t, i, r, s, a) {
    var o = e._gsap,
      l = s || Dy(e, !0),
      c = o.xOrigin || 0,
      u = o.yOrigin || 0,
      h = o.xOffset || 0,
      d = o.yOffset || 0,
      f = l[0],
      p = l[1],
      m = l[2],
      g = l[3],
      v = l[4],
      y = l[5],
      _ = t.split(' '),
      x = parseFloat(_[0]) || 0,
      S = parseFloat(_[1]) || 0,
      b,
      A,
      E,
      w;
    (i
      ? l !== Wu &&
        (A = f * g - p * m) &&
        ((E = x * (g / A) + S * (-m / A) + (m * y - g * v) / A),
        (w = x * (-p / A) + S * (f / A) - (f * y - p * v) / A),
        (x = E),
        (S = w))
      : ((b = yC(e)),
        (x = b.x + (~_[0].indexOf('%') ? (x / 100) * b.width : x)),
        (S = b.y + (~(_[1] || _[0]).indexOf('%') ? (S / 100) * b.height : S))),
      r || (r !== !1 && o.smooth)
        ? ((v = x - c),
          (y = S - u),
          (o.xOffset = h + (v * f + y * m) - v),
          (o.yOffset = d + (v * p + y * g) - y))
        : (o.xOffset = o.yOffset = 0),
      (o.xOrigin = x),
      (o.yOrigin = S),
      (o.smooth = !!r),
      (o.origin = t),
      (o.originIsAbsolute = !!i),
      (e.style[Mi] = '0px 0px'),
      a &&
        (zs(a, o, 'xOrigin', c, x),
        zs(a, o, 'yOrigin', u, S),
        zs(a, o, 'xOffset', h, o.xOffset),
        zs(a, o, 'yOffset', d, o.yOffset)),
      e.setAttribute('data-svg-origin', x + ' ' + S));
  },
  ju = function (e, t) {
    var i = e._gsap || new sC(e);
    if ('x' in i && !t && !i.uncache) return i;
    var r = e.style,
      s = i.scaleX < 0,
      a = 'px',
      o = 'deg',
      l = getComputedStyle(e),
      c = rr(e, Mi) || '0',
      u,
      h,
      d,
      f,
      p,
      m,
      g,
      v,
      y,
      _,
      x,
      S,
      b,
      A,
      E,
      w,
      M,
      T,
      D,
      L,
      O,
      z,
      C,
      N,
      U,
      W,
      G,
      ne,
      ve,
      Se,
      Ae,
      Oe;
    return (
      (u = h = d = m = g = v = y = _ = x = 0),
      (f = p = 1),
      (i.svg = !!(e.getCTM && xC(e))),
      l.translate &&
        ((l.translate !== 'none' ||
          l.scale !== 'none' ||
          l.rotate !== 'none') &&
          (r[on] =
            (l.translate !== 'none'
              ? 'translate3d(' +
                (l.translate + ' 0 0').split(' ').slice(0, 3).join(', ') +
                ') '
              : '') +
            (l.rotate !== 'none' ? 'rotate(' + l.rotate + ') ' : '') +
            (l.scale !== 'none'
              ? 'scale(' + l.scale.split(' ').join(',') + ') '
              : '') +
            (l[on] !== 'none' ? l[on] : '')),
        (r.scale = r.rotate = r.translate = 'none')),
      (A = Dy(e, i.svg)),
      i.svg &&
        (i.uncache
          ? ((U = e.getBBox()),
            (c = i.xOrigin - U.x + 'px ' + (i.yOrigin - U.y) + 'px'),
            (N = ''))
          : (N = !t && e.getAttribute('data-svg-origin')),
        Nv(e, N || c, !!N || i.originIsAbsolute, i.smooth !== !1, A)),
      (S = i.xOrigin || 0),
      (b = i.yOrigin || 0),
      A !== Wu &&
        ((T = A[0]),
        (D = A[1]),
        (L = A[2]),
        (O = A[3]),
        (u = z = A[4]),
        (h = C = A[5]),
        A.length === 6
          ? ((f = Math.sqrt(T * T + D * D)),
            (p = Math.sqrt(O * O + L * L)),
            (m = T || D ? Xo(D, T) * Za : 0),
            (y = L || O ? Xo(L, O) * Za + m : 0),
            y && (p *= Math.abs(Math.cos(y * Bl))),
            i.svg && ((u -= S - (S * T + b * L)), (h -= b - (S * D + b * O))))
          : ((Oe = A[6]),
            (Se = A[7]),
            (G = A[8]),
            (ne = A[9]),
            (ve = A[10]),
            (Ae = A[11]),
            (u = A[12]),
            (h = A[13]),
            (d = A[14]),
            (E = Xo(Oe, ve)),
            (g = E * Za),
            E &&
              ((w = Math.cos(-E)),
              (M = Math.sin(-E)),
              (N = z * w + G * M),
              (U = C * w + ne * M),
              (W = Oe * w + ve * M),
              (G = z * -M + G * w),
              (ne = C * -M + ne * w),
              (ve = Oe * -M + ve * w),
              (Ae = Se * -M + Ae * w),
              (z = N),
              (C = U),
              (Oe = W)),
            (E = Xo(-L, ve)),
            (v = E * Za),
            E &&
              ((w = Math.cos(-E)),
              (M = Math.sin(-E)),
              (N = T * w - G * M),
              (U = D * w - ne * M),
              (W = L * w - ve * M),
              (Ae = O * M + Ae * w),
              (T = N),
              (D = U),
              (L = W)),
            (E = Xo(D, T)),
            (m = E * Za),
            E &&
              ((w = Math.cos(E)),
              (M = Math.sin(E)),
              (N = T * w + D * M),
              (U = z * w + C * M),
              (D = D * w - T * M),
              (C = C * w - z * M),
              (T = N),
              (z = U)),
            g &&
              Math.abs(g) + Math.abs(m) > 359.9 &&
              ((g = m = 0), (v = 180 - v)),
            (f = xn(Math.sqrt(T * T + D * D + L * L))),
            (p = xn(Math.sqrt(C * C + Oe * Oe))),
            (E = Xo(z, C)),
            (y = Math.abs(E) > 2e-4 ? E * Za : 0),
            (x = Ae ? 1 / (Ae < 0 ? -Ae : Ae) : 0)),
        i.svg &&
          ((N = e.getAttribute('transform')),
          (i.forceCSS = e.setAttribute('transform', '') || !SC(rr(e, on))),
          N && e.setAttribute('transform', N))),
      Math.abs(y) > 90 &&
        Math.abs(y) < 270 &&
        (s
          ? ((f *= -1), (y += m <= 0 ? 180 : -180), (m += m <= 0 ? 180 : -180))
          : ((p *= -1), (y += y <= 0 ? 180 : -180))),
      (t = t || i.uncache),
      (i.x =
        u -
        ((i.xPercent =
          u &&
          ((!t && i.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0)))
          ? (e.offsetWidth * i.xPercent) / 100
          : 0) +
        a),
      (i.y =
        h -
        ((i.yPercent =
          h &&
          ((!t && i.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetHeight * i.yPercent) / 100
          : 0) +
        a),
      (i.z = d + a),
      (i.scaleX = xn(f)),
      (i.scaleY = xn(p)),
      (i.rotation = xn(m) + o),
      (i.rotationX = xn(g) + o),
      (i.rotationY = xn(v) + o),
      (i.skewX = y + o),
      (i.skewY = _ + o),
      (i.transformPerspective = x + a),
      (i.zOrigin = parseFloat(c.split(' ')[2]) || (!t && i.zOrigin) || 0) &&
        (r[Mi] = Xf(c)),
      (i.xOffset = i.yOffset = 0),
      (i.force3D = Gi.force3D),
      (i.renderTransform = i.svg ? NL : _C ? wC : BL),
      (i.uncache = 0),
      i
    );
  },
  Xf = function (e) {
    return (e = e.split(' '))[0] + ' ' + e[1];
  },
  Ig = function (e, t, i) {
    var r = ei(t);
    return xn(parseFloat(t) + parseFloat(Js(e, 'x', i + 'px', r))) + r;
  },
  BL = function (e, t) {
    ((t.z = '0px'),
      (t.rotationY = t.rotationX = '0deg'),
      (t.force3D = 0),
      wC(e, t));
  },
  Pa = '0deg',
  Hc = '0px',
  Da = ') ',
  wC = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      a = i.x,
      o = i.y,
      l = i.z,
      c = i.rotation,
      u = i.rotationY,
      h = i.rotationX,
      d = i.skewX,
      f = i.skewY,
      p = i.scaleX,
      m = i.scaleY,
      g = i.transformPerspective,
      v = i.force3D,
      y = i.target,
      _ = i.zOrigin,
      x = '',
      S = (v === 'auto' && e && e !== 1) || v === !0;
    if (_ && (h !== Pa || u !== Pa)) {
      var b = parseFloat(u) * Bl,
        A = Math.sin(b),
        E = Math.cos(b),
        w;
      ((b = parseFloat(h) * Bl),
        (w = Math.cos(b)),
        (a = Ig(y, a, A * w * -_)),
        (o = Ig(y, o, -Math.sin(b) * -_)),
        (l = Ig(y, l, E * w * -_ + _)));
    }
    (g !== Hc && (x += 'perspective(' + g + Da),
      (r || s) && (x += 'translate(' + r + '%, ' + s + '%) '),
      (S || a !== Hc || o !== Hc || l !== Hc) &&
        (x +=
          l !== Hc || S
            ? 'translate3d(' + a + ', ' + o + ', ' + l + ') '
            : 'translate(' + a + ', ' + o + Da),
      c !== Pa && (x += 'rotate(' + c + Da),
      u !== Pa && (x += 'rotateY(' + u + Da),
      h !== Pa && (x += 'rotateX(' + h + Da),
      (d !== Pa || f !== Pa) && (x += 'skew(' + d + ', ' + f + Da),
      (p !== 1 || m !== 1) && (x += 'scale(' + p + ', ' + m + Da),
      (y.style[on] = x || 'translate(0, 0)'));
  },
  NL = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      a = i.x,
      o = i.y,
      l = i.rotation,
      c = i.skewX,
      u = i.skewY,
      h = i.scaleX,
      d = i.scaleY,
      f = i.target,
      p = i.xOrigin,
      m = i.yOrigin,
      g = i.xOffset,
      v = i.yOffset,
      y = i.forceCSS,
      _ = parseFloat(a),
      x = parseFloat(o),
      S,
      b,
      A,
      E,
      w;
    ((l = parseFloat(l)),
      (c = parseFloat(c)),
      (u = parseFloat(u)),
      u && ((u = parseFloat(u)), (c += u), (l += u)),
      l || c
        ? ((l *= Bl),
          (c *= Bl),
          (S = Math.cos(l) * h),
          (b = Math.sin(l) * h),
          (A = Math.sin(l - c) * -d),
          (E = Math.cos(l - c) * d),
          c &&
            ((u *= Bl),
            (w = Math.tan(c - u)),
            (w = Math.sqrt(1 + w * w)),
            (A *= w),
            (E *= w),
            u &&
              ((w = Math.tan(u)),
              (w = Math.sqrt(1 + w * w)),
              (S *= w),
              (b *= w))),
          (S = xn(S)),
          (b = xn(b)),
          (A = xn(A)),
          (E = xn(E)))
        : ((S = h), (E = d), (b = A = 0)),
      ((_ && !~(a + '').indexOf('px')) || (x && !~(o + '').indexOf('px'))) &&
        ((_ = Js(f, 'x', a, 'px')), (x = Js(f, 'y', o, 'px'))),
      (p || m || g || v) &&
        ((_ = xn(_ + p - (p * S + m * A) + g)),
        (x = xn(x + m - (p * b + m * E) + v))),
      (r || s) &&
        ((w = f.getBBox()),
        (_ = xn(_ + (r / 100) * w.width)),
        (x = xn(x + (s / 100) * w.height))),
      (w =
        'matrix(' + S + ',' + b + ',' + A + ',' + E + ',' + _ + ',' + x + ')'),
      f.setAttribute('transform', w),
      y && (f.style[on] = w));
  },
  FL = function (e, t, i, r, s) {
    var a = 360,
      o = Wn(s),
      l = parseFloat(s) * (o && ~s.indexOf('rad') ? Za : 1),
      c = l - r,
      u = r + c + 'deg',
      h,
      d;
    return (
      o &&
        ((h = s.split('_')[1]),
        h === 'short' && ((c %= a), c !== c % (a / 2) && (c += c < 0 ? a : -a)),
        h === 'cw' && c < 0
          ? (c = ((c + a * US) % a) - ~~(c / a) * a)
          : h === 'ccw' && c > 0 && (c = ((c - a * US) % a) - ~~(c / a) * a)),
      (e._pt = d = new Ai(e._pt, t, i, r, c, SL)),
      (d.e = u),
      (d.u = 'deg'),
      e._props.push(i),
      d
    );
  },
  HS = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  zL = function (e, t, i) {
    var r = HS({}, i._gsap),
      s = 'perspective,force3D,transformOrigin,svgOrigin',
      a = i.style,
      o,
      l,
      c,
      u,
      h,
      d,
      f,
      p;
    r.svg
      ? ((c = i.getAttribute('transform')),
        i.setAttribute('transform', ''),
        (a[on] = t),
        (o = ju(i, 1)),
        To(i, on),
        i.setAttribute('transform', c))
      : ((c = getComputedStyle(i)[on]),
        (a[on] = t),
        (o = ju(i, 1)),
        (a[on] = c));
    for (l in gs)
      ((c = r[l]),
        (u = o[l]),
        c !== u &&
          s.indexOf(l) < 0 &&
          ((f = ei(c)),
          (p = ei(u)),
          (h = f !== p ? Js(i, l, c, p) : parseFloat(c)),
          (d = parseFloat(u)),
          (e._pt = new Ai(e._pt, o, l, h, d - h, Uv)),
          (e._pt.u = p || 0),
          e._props.push(l)));
    HS(o, r);
  };
Ei('padding,margin,Width,Radius', function (n, e) {
  var t = 'Top',
    i = 'Right',
    r = 'Bottom',
    s = 'Left',
    a = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (o) {
      return e < 2 ? n + o : 'border' + o + n;
    });
  jf[e > 1 ? 'border' + n : n] = function (o, l, c, u, h) {
    var d, f;
    if (arguments.length < 4)
      return (
        (d = a.map(function (p) {
          return os(o, p, c);
        })),
        (f = d.join(' ')),
        f.split(d[0]).length === 5 ? d[0] : f
      );
    ((d = (u + '').split(' ')),
      (f = {}),
      a.forEach(function (p, m) {
        return (f[p] = d[m] = d[m] || d[((m - 1) / 2) | 0]);
      }),
      o.init(l, f, h));
  };
});
var EC = {
  name: 'css',
  register: Bv,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, i, r, s) {
    var a = this._props,
      o = e.style,
      l = i.vars.startAt,
      c,
      u,
      h,
      d,
      f,
      p,
      m,
      g,
      v,
      y,
      _,
      x,
      S,
      b,
      A,
      E;
    (Ry || Bv(),
      (this.styles = this.styles || vC(e)),
      (E = this.styles.props),
      (this.tween = i));
    for (m in t)
      if (m !== 'autoRound' && ((u = t[m]), !(ki[m] && aC(m, t, i, r, e, s)))) {
        if (
          ((f = typeof u),
          (p = jf[m]),
          f === 'function' && ((u = u.call(i, r, e, s)), (f = typeof u)),
          f === 'string' && ~u.indexOf('random(') && (u = Vu(u)),
          p)
        )
          p(this, e, m, u, i) && (A = 1);
        else if (m.substr(0, 2) === '--')
          ((c = (getComputedStyle(e).getPropertyValue(m) + '').trim()),
            (u += ''),
            (Xs.lastIndex = 0),
            Xs.test(c) || ((g = ei(c)), (v = ei(u))),
            v ? g !== v && (c = Js(e, m, c, v) + v) : g && (u += g),
            this.add(o, 'setProperty', c, u, r, s, 0, 0, m),
            a.push(m),
            E.push(m, 0, o[m]));
        else if (f !== 'undefined') {
          if (
            (l && m in l
              ? ((c = typeof l[m] == 'function' ? l[m].call(i, r, e, s) : l[m]),
                Wn(c) && ~c.indexOf('random(') && (c = Vu(c)),
                ei(c + '') ||
                  c === 'auto' ||
                  (c += Gi.units[m] || ei(os(e, m)) || ''),
                (c + '').charAt(1) === '=' && (c = os(e, m)))
              : (c = os(e, m)),
            (d = parseFloat(c)),
            (y = f === 'string' && u.charAt(1) === '=' && u.substr(0, 2)),
            y && (u = u.substr(2)),
            (h = parseFloat(u)),
            m in Ur &&
              (m === 'autoAlpha' &&
                (d === 1 && os(e, 'visibility') === 'hidden' && h && (d = 0),
                E.push('visibility', 0, o.visibility),
                zs(
                  this,
                  o,
                  'visibility',
                  d ? 'inherit' : 'hidden',
                  h ? 'inherit' : 'hidden',
                  !h
                )),
              m !== 'scale' &&
                m !== 'transform' &&
                ((m = Ur[m]), ~m.indexOf(',') && (m = m.split(',')[0]))),
            (_ = m in gs),
            _)
          ) {
            if (
              (this.styles.save(m),
              f === 'string' &&
                u.substring(0, 6) === 'var(--' &&
                ((u = rr(e, u.substring(4, u.indexOf(')')))),
                (h = parseFloat(u))),
              x ||
                ((S = e._gsap),
                (S.renderTransform && !t.parseTransform) ||
                  ju(e, t.parseTransform),
                (b = t.smoothOrigin !== !1 && S.smooth),
                (x = this._pt =
                  new Ai(this._pt, o, on, 0, 1, S.renderTransform, S, 0, -1)),
                (x.dep = 1)),
              m === 'scale')
            )
              ((this._pt = new Ai(
                this._pt,
                S,
                'scaleY',
                S.scaleY,
                (y ? Ul(S.scaleY, y + h) : h) - S.scaleY || 0,
                Uv
              )),
                (this._pt.u = 0),
                a.push('scaleY', m),
                (m += 'X'));
            else if (m === 'transformOrigin') {
              (E.push(Mi, 0, o[Mi]),
                (u = UL(u)),
                S.svg
                  ? Nv(e, u, 0, b, 0, this)
                  : ((v = parseFloat(u.split(' ')[2]) || 0),
                    v !== S.zOrigin && zs(this, S, 'zOrigin', S.zOrigin, v),
                    zs(this, o, m, Xf(c), Xf(u))));
              continue;
            } else if (m === 'svgOrigin') {
              Nv(e, u, 1, b, 0, this);
              continue;
            } else if (m in bC) {
              FL(this, S, m, d, y ? Ul(d, y + u) : u);
              continue;
            } else if (m === 'smoothOrigin') {
              zs(this, S, 'smooth', S.smooth, u);
              continue;
            } else if (m === 'force3D') {
              S[m] = u;
              continue;
            } else if (m === 'transform') {
              zL(this, u, e);
              continue;
            }
          } else m in o || (m = Xl(m) || m);
          if (_ || ((h || h === 0) && (d || d === 0) && !bL.test(u) && m in o))
            ((g = (c + '').substr((d + '').length)),
              h || (h = 0),
              (v = ei(u) || (m in Gi.units ? Gi.units[m] : g)),
              g !== v && (d = Js(e, m, c, v)),
              (this._pt = new Ai(
                this._pt,
                _ ? S : o,
                m,
                d,
                (y ? Ul(d, y + h) : h) - d,
                !_ && (v === 'px' || m === 'zIndex') && t.autoRound !== !1
                  ? EL
                  : Uv
              )),
              (this._pt.u = v || 0),
              g !== v && v !== '%' && ((this._pt.b = c), (this._pt.r = wL)));
          else if (m in o) LL.call(this, e, m, c, y ? y + u : u);
          else if (m in e) this.add(e, m, c || e[m], y ? y + u : u, r, s);
          else if (m !== 'parseTransform') {
            yy(m, u);
            continue;
          }
          (_ ||
            (m in o
              ? E.push(m, 0, o[m])
              : typeof e[m] == 'function'
                ? E.push(m, 2, e[m]())
                : E.push(m, 1, c || e[m])),
            a.push(m));
        }
      }
    A && dC(this);
  },
  render: function (e, t) {
    if (t.tween._time || !Iy())
      for (var i = t._pt; i; ) (i.r(e, i.d), (i = i._next));
    else t.styles.revert();
  },
  get: os,
  aliases: Ur,
  getSetter: function (e, t, i) {
    var r = Ur[t];
    return (
      r && r.indexOf(',') < 0 && (t = r),
      t in gs && t !== Mi && (e._gsap.x || os(e, 'x'))
        ? i && LS === i
          ? t === 'scale'
            ? CL
            : TL
          : (LS = i || {}) && (t === 'scale' ? RL : IL)
        : e.style && !gy(e.style[t])
          ? AL
          : ~t.indexOf('-')
            ? ML
            : Ty(e, t)
    );
  },
  core: { _removeProperty: To, _getMatrix: Dy },
};
Pi.utils.checkPrefix = Xl;
Pi.core.getStyleSaver = vC;
(function (n, e, t, i) {
  var r = Ei(n + ',' + e + ',' + t, function (s) {
    gs[s] = 1;
  });
  (Ei(e, function (s) {
    ((Gi.units[s] = 'deg'), (bC[s] = 1));
  }),
    (Ur[r[13]] = n + ',' + e),
    Ei(i, function (s) {
      var a = s.split(':');
      Ur[a[1]] = r[a[0]];
    }));
})(
  'x,y,z,scale,scaleX,scaleY,xPercent,yPercent',
  'rotation,rotationX,rotationY,skewX,skewY',
  'transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
  '0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY'
);
Ei(
  'x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective',
  function (n) {
    Gi.units[n] = 'px';
  }
);
Pi.registerPlugin(EC);
var VL = Pi.registerPlugin(EC) || Pi;
VL.core.Tween;
const Oy = Ue.createContext({});
function uc(n) {
  const e = Ue.useRef(null);
  return (e.current === null && (e.current = n()), e.current);
}
const Ly = typeof window < 'u',
  nm = Ly ? Ue.useLayoutEffect : Ue.useEffect,
  im = Ue.createContext(null);
function Uy(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function ky(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
const Gr = (n, e, t) => (t > e ? e : t < n ? n : t);
let Xu = () => {};
const vs = {},
  AC = (n) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);
function MC(n) {
  return typeof n == 'object' && n !== null;
}
const TC = (n) => /^0[^.\s]+$/u.test(n);
function By(n) {
  let e;
  return () => (e === void 0 && (e = n()), e);
}
const Ti = (n) => n,
  HL = (n, e) => (t) => e(n(t)),
  wh = (...n) => n.reduce(HL),
  ql = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  };
class Ny {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return (Uy(this.subscriptions, e), () => ky(this.subscriptions, e));
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const a = this.subscriptions[s];
          a && a(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Fr = (n) => n * 1e3,
  sr = (n) => n / 1e3;
function Fy(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const CC = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  GL = 1e-7,
  WL = 12;
function jL(n, e, t, i, r) {
  let s,
    a,
    o = 0;
  do ((a = e + (t - e) / 2), (s = CC(a, i, r) - n), s > 0 ? (t = a) : (e = a));
  while (Math.abs(s) > GL && ++o < WL);
  return a;
}
function Eh(n, e, t, i) {
  if (n === e && t === i) return Ti;
  const r = (s) => jL(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : CC(r(s), e, i));
}
const RC = (n) => (e) => (e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2),
  IC = (n) => (e) => 1 - n(1 - e),
  PC = Eh(0.33, 1.53, 0.69, 0.99),
  zy = IC(PC),
  DC = RC(zy),
  OC = (n) =>
    (n *= 2) < 1 ? 0.5 * zy(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  Vy = (n) => 1 - Math.sin(Math.acos(n)),
  LC = IC(Vy),
  UC = RC(Vy),
  XL = Eh(0.42, 0, 1, 1),
  qL = Eh(0, 0, 0.58, 1),
  kC = Eh(0.42, 0, 0.58, 1),
  YL = (n) => Array.isArray(n) && typeof n[0] != 'number',
  BC = (n) => Array.isArray(n) && typeof n[0] == 'number',
  KL = {
    linear: Ti,
    easeIn: XL,
    easeInOut: kC,
    easeOut: qL,
    circIn: Vy,
    circInOut: UC,
    circOut: LC,
    backIn: zy,
    backInOut: DC,
    backOut: PC,
    anticipate: OC,
  },
  JL = (n) => typeof n == 'string',
  GS = (n) => {
    if (BC(n)) {
      Xu(n.length === 4);
      const [e, t, i, r] = n;
      return Eh(e, t, i, r);
    } else if (JL(n)) return KL[n];
    return n;
  },
  nd = [
    'setup',
    'read',
    'resolveKeyframes',
    'preUpdate',
    'update',
    'preRender',
    'render',
    'postRender',
  ];
function QL(n, e) {
  let t = new Set(),
    i = new Set(),
    r = !1,
    s = !1;
  const a = new WeakSet();
  let o = { delta: 0, timestamp: 0, isProcessing: !1 };
  function l(u) {
    (a.has(u) && (c.schedule(u), n()), u(o));
  }
  const c = {
    schedule: (u, h = !1, d = !1) => {
      const p = d && r ? t : i;
      return (h && a.add(u), p.has(u) || p.add(u), u);
    },
    cancel: (u) => {
      (i.delete(u), a.delete(u));
    },
    process: (u) => {
      if (((o = u), r)) {
        s = !0;
        return;
      }
      ((r = !0),
        ([t, i] = [i, t]),
        t.forEach(l),
        t.clear(),
        (r = !1),
        s && ((s = !1), c.process(u)));
    },
  };
  return c;
}
const ZL = 40;
function NC(n, e) {
  let t = !1,
    i = !0;
  const r = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    a = nd.reduce((_, x) => ((_[x] = QL(s)), _), {}),
    {
      setup: o,
      read: l,
      resolveKeyframes: c,
      preUpdate: u,
      update: h,
      preRender: d,
      render: f,
      postRender: p,
    } = a,
    m = () => {
      const _ = vs.useManualTiming ? r.timestamp : performance.now();
      ((t = !1),
        vs.useManualTiming ||
          (r.delta = i ? 1e3 / 60 : Math.max(Math.min(_ - r.timestamp, ZL), 1)),
        (r.timestamp = _),
        (r.isProcessing = !0),
        o.process(r),
        l.process(r),
        c.process(r),
        u.process(r),
        h.process(r),
        d.process(r),
        f.process(r),
        p.process(r),
        (r.isProcessing = !1),
        t && e && ((i = !1), n(m)));
    },
    g = () => {
      ((t = !0), (i = !0), r.isProcessing || n(m));
    };
  return {
    schedule: nd.reduce((_, x) => {
      const S = a[x];
      return (
        (_[x] = (b, A = !1, E = !1) => (t || g(), S.schedule(b, A, E))),
        _
      );
    }, {}),
    cancel: (_) => {
      for (let x = 0; x < nd.length; x++) a[nd[x]].cancel(_);
    },
    state: r,
    steps: a,
  };
}
const {
  schedule: Nt,
  cancel: lr,
  state: zn,
  steps: Pg,
} = NC(typeof requestAnimationFrame < 'u' ? requestAnimationFrame : Ti, !0);
let bf;
function $L() {
  bf = void 0;
}
const Si = {
    now: () => (
      bf === void 0 &&
        Si.set(
          zn.isProcessing || vs.useManualTiming
            ? zn.timestamp
            : performance.now()
        ),
      bf
    ),
    set: (n) => {
      ((bf = n), queueMicrotask($L));
    },
  },
  FC = (n) => (e) => typeof e == 'string' && e.startsWith(n),
  Hy = FC('--'),
  eU = FC('var(--'),
  Gy = (n) => (eU(n) ? tU.test(n.split('/*')[0].trim()) : !1),
  tU =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  hc = {
    test: (n) => typeof n == 'number',
    parse: parseFloat,
    transform: (n) => n,
  },
  qu = { ...hc, transform: (n) => Gr(0, 1, n) },
  id = { ...hc, default: 1 },
  xu = (n) => Math.round(n * 1e5) / 1e5,
  Wy = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function nU(n) {
  return n == null;
}
const iU =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  jy = (n, e) => (t) =>
    !!(
      (typeof t == 'string' && iU.test(t) && t.startsWith(n)) ||
      (e && !nU(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  zC = (n, e, t) => (i) => {
    if (typeof i != 'string') return i;
    const [r, s, a, o] = i.match(Wy);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(a),
      alpha: o !== void 0 ? parseFloat(o) : 1,
    };
  },
  rU = (n) => Gr(0, 255, n),
  Dg = { ...hc, transform: (n) => Math.round(rU(n)) },
  oo = {
    test: jy('rgb', 'red'),
    parse: zC('red', 'green', 'blue'),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      'rgba(' +
      Dg.transform(n) +
      ', ' +
      Dg.transform(e) +
      ', ' +
      Dg.transform(t) +
      ', ' +
      xu(qu.transform(i)) +
      ')',
  };
function sU(n) {
  let e = '',
    t = '',
    i = '',
    r = '';
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const Fv = { test: jy('#'), parse: sU, transform: oo.transform },
  Ah = (n) => ({
    test: (e) =>
      typeof e == 'string' && e.endsWith(n) && e.split(' ').length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  Ls = Ah('deg'),
  zr = Ah('%'),
  ft = Ah('px'),
  aU = Ah('vh'),
  oU = Ah('vw'),
  WS = {
    ...zr,
    parse: (n) => zr.parse(n) / 100,
    transform: (n) => zr.transform(n * 100),
  },
  Ml = {
    test: jy('hsl', 'hue'),
    parse: zC('hue', 'saturation', 'lightness'),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      'hsla(' +
      Math.round(n) +
      ', ' +
      zr.transform(xu(e)) +
      ', ' +
      zr.transform(xu(t)) +
      ', ' +
      xu(qu.transform(i)) +
      ')',
  },
  An = {
    test: (n) => oo.test(n) || Fv.test(n) || Ml.test(n),
    parse: (n) =>
      oo.test(n) ? oo.parse(n) : Ml.test(n) ? Ml.parse(n) : Fv.parse(n),
    transform: (n) =>
      typeof n == 'string'
        ? n
        : n.hasOwnProperty('red')
          ? oo.transform(n)
          : Ml.transform(n),
    getAnimatableNone: (n) => {
      const e = An.parse(n);
      return ((e.alpha = 0), An.transform(e));
    },
  },
  lU =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function cU(n) {
  return (
    isNaN(n) &&
    typeof n == 'string' &&
    (n.match(Wy)?.length || 0) + (n.match(lU)?.length || 0) > 0
  );
}
const VC = 'number',
  HC = 'color',
  uU = 'var',
  hU = 'var(',
  jS = '${}',
  dU =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Yu(n) {
  const e = n.toString(),
    t = [],
    i = { color: [], number: [], var: [] },
    r = [];
  let s = 0;
  const o = e
    .replace(
      dU,
      (l) => (
        An.test(l)
          ? (i.color.push(s), r.push(HC), t.push(An.parse(l)))
          : l.startsWith(hU)
            ? (i.var.push(s), r.push(uU), t.push(l))
            : (i.number.push(s), r.push(VC), t.push(parseFloat(l))),
        ++s,
        jS
      )
    )
    .split(jS);
  return { values: t, split: o, indexes: i, types: r };
}
function GC(n) {
  return Yu(n).values;
}
function WC(n) {
  const { split: e, types: t } = Yu(n),
    i = e.length;
  return (r) => {
    let s = '';
    for (let a = 0; a < i; a++)
      if (((s += e[a]), r[a] !== void 0)) {
        const o = t[a];
        o === VC
          ? (s += xu(r[a]))
          : o === HC
            ? (s += An.transform(r[a]))
            : (s += r[a]);
      }
    return s;
  };
}
const fU = (n) =>
  typeof n == 'number' ? 0 : An.test(n) ? An.getAnimatableNone(n) : n;
function pU(n) {
  const e = GC(n);
  return WC(n)(e.map(fU));
}
const Qs = {
  test: cU,
  parse: GC,
  createTransformer: WC,
  getAnimatableNone: pU,
};
function Og(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * (2 / 3 - t) * 6
          : n
  );
}
function mU({ hue: n, saturation: e, lightness: t, alpha: i }) {
  ((n /= 360), (e /= 100), (t /= 100));
  let r = 0,
    s = 0,
    a = 0;
  if (!e) r = s = a = t;
  else {
    const o = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - o;
    ((r = Og(l, o, n + 1 / 3)), (s = Og(l, o, n)), (a = Og(l, o, n - 1 / 3)));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(a * 255),
    alpha: i,
  };
}
function qf(n, e) {
  return (t) => (t > 0 ? e : n);
}
const ln = (n, e, t) => n + (e - n) * t,
  Lg = (n, e, t) => {
    const i = n * n,
      r = t * (e * e - i) + i;
    return r < 0 ? 0 : Math.sqrt(r);
  },
  gU = [Fv, oo, Ml],
  vU = (n) => gU.find((e) => e.test(n));
function XS(n) {
  const e = vU(n);
  if (!e) return !1;
  let t = e.parse(n);
  return (e === Ml && (t = mU(t)), t);
}
const qS = (n, e) => {
    const t = XS(n),
      i = XS(e);
    if (!t || !i) return qf(n, e);
    const r = { ...t };
    return (s) => (
      (r.red = Lg(t.red, i.red, s)),
      (r.green = Lg(t.green, i.green, s)),
      (r.blue = Lg(t.blue, i.blue, s)),
      (r.alpha = ln(t.alpha, i.alpha, s)),
      oo.transform(r)
    );
  },
  zv = new Set(['none', 'hidden']);
function _U(n, e) {
  return zv.has(n) ? (t) => (t <= 0 ? n : e) : (t) => (t >= 1 ? e : n);
}
function yU(n, e) {
  return (t) => ln(n, e, t);
}
function Xy(n) {
  return typeof n == 'number'
    ? yU
    : typeof n == 'string'
      ? Gy(n)
        ? qf
        : An.test(n)
          ? qS
          : SU
      : Array.isArray(n)
        ? jC
        : typeof n == 'object'
          ? An.test(n)
            ? qS
            : xU
          : qf;
}
function jC(n, e) {
  const t = [...n],
    i = t.length,
    r = n.map((s, a) => Xy(s)(s, e[a]));
  return (s) => {
    for (let a = 0; a < i; a++) t[a] = r[a](s);
    return t;
  };
}
function xU(n, e) {
  const t = { ...n, ...e },
    i = {};
  for (const r in t)
    n[r] !== void 0 && e[r] !== void 0 && (i[r] = Xy(n[r])(n[r], e[r]));
  return (r) => {
    for (const s in i) t[s] = i[s](r);
    return t;
  };
}
function bU(n, e) {
  const t = [],
    i = { color: 0, var: 0, number: 0 };
  for (let r = 0; r < e.values.length; r++) {
    const s = e.types[r],
      a = n.indexes[s][i[s]],
      o = n.values[a] ?? 0;
    ((t[r] = o), i[s]++);
  }
  return t;
}
const SU = (n, e) => {
  const t = Qs.createTransformer(e),
    i = Yu(n),
    r = Yu(e);
  return i.indexes.var.length === r.indexes.var.length &&
    i.indexes.color.length === r.indexes.color.length &&
    i.indexes.number.length >= r.indexes.number.length
    ? (zv.has(n) && !r.values.length) || (zv.has(e) && !i.values.length)
      ? _U(n, e)
      : wh(jC(bU(i, r), r.values), t)
    : qf(n, e);
};
function XC(n, e, t) {
  return typeof n == 'number' && typeof e == 'number' && typeof t == 'number'
    ? ln(n, e, t)
    : Xy(n)(n, e);
}
const wU = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: (t = !0) => Nt.update(e, t),
      stop: () => lr(e),
      now: () => (zn.isProcessing ? zn.timestamp : Si.now()),
    };
  },
  qC = (n, e, t = 10) => {
    let i = '';
    const r = Math.max(Math.round(e / t), 2);
    for (let s = 0; s < r; s++)
      i += Math.round(n(s / (r - 1)) * 1e4) / 1e4 + ', ';
    return `linear(${i.substring(0, i.length - 2)})`;
  },
  Yf = 2e4;
function qy(n) {
  let e = 0;
  const t = 50;
  let i = n.next(e);
  for (; !i.done && e < Yf; ) ((e += t), (i = n.next(e)));
  return e >= Yf ? 1 / 0 : e;
}
function EU(n, e = 100, t) {
  const i = t({ ...n, keyframes: [0, e] }),
    r = Math.min(qy(i), Yf);
  return {
    type: 'keyframes',
    ease: (s) => i.next(r * s).value / e,
    duration: sr(r),
  };
}
const AU = 5;
function YC(n, e, t) {
  const i = Math.max(e - AU, 0);
  return Fy(t - n(i), e - i);
}
const fn = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  Ug = 0.001;
function MU({
  duration: n = fn.duration,
  bounce: e = fn.bounce,
  velocity: t = fn.velocity,
  mass: i = fn.mass,
}) {
  let r,
    s,
    a = 1 - e;
  ((a = Gr(fn.minDamping, fn.maxDamping, a)),
    (n = Gr(fn.minDuration, fn.maxDuration, sr(n))),
    a < 1
      ? ((r = (c) => {
          const u = c * a,
            h = u * n,
            d = u - t,
            f = Vv(c, a),
            p = Math.exp(-h);
          return Ug - (d / f) * p;
        }),
        (s = (c) => {
          const h = c * a * n,
            d = h * t + t,
            f = Math.pow(a, 2) * Math.pow(c, 2) * n,
            p = Math.exp(-h),
            m = Vv(Math.pow(c, 2), a);
          return ((-r(c) + Ug > 0 ? -1 : 1) * ((d - f) * p)) / m;
        }))
      : ((r = (c) => {
          const u = Math.exp(-c * n),
            h = (c - t) * n + 1;
          return -Ug + u * h;
        }),
        (s = (c) => {
          const u = Math.exp(-c * n),
            h = (t - c) * (n * n);
          return u * h;
        })));
  const o = 5 / n,
    l = CU(r, s, o);
  if (((n = Fr(n)), isNaN(l)))
    return { stiffness: fn.stiffness, damping: fn.damping, duration: n };
  {
    const c = Math.pow(l, 2) * i;
    return { stiffness: c, damping: a * 2 * Math.sqrt(i * c), duration: n };
  }
}
const TU = 12;
function CU(n, e, t) {
  let i = t;
  for (let r = 1; r < TU; r++) i = i - n(i) / e(i);
  return i;
}
function Vv(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const RU = ['duration', 'bounce'],
  IU = ['stiffness', 'damping', 'mass'];
function YS(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function PU(n) {
  let e = {
    velocity: fn.velocity,
    stiffness: fn.stiffness,
    damping: fn.damping,
    mass: fn.mass,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!YS(n, IU) && YS(n, RU))
    if (n.visualDuration) {
      const t = n.visualDuration,
        i = (2 * Math.PI) / (t * 1.2),
        r = i * i,
        s = 2 * Gr(0.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(r);
      e = { ...e, mass: fn.mass, stiffness: r, damping: s };
    } else {
      const t = MU(n);
      ((e = { ...e, ...t, mass: fn.mass }), (e.isResolvedFromDuration = !0));
    }
  return e;
}
function Kf(n = fn.visualDuration, e = fn.bounce) {
  const t =
    typeof n != 'object'
      ? { visualDuration: n, keyframes: [0, 1], bounce: e }
      : n;
  let { restSpeed: i, restDelta: r } = t;
  const s = t.keyframes[0],
    a = t.keyframes[t.keyframes.length - 1],
    o = { done: !1, value: s },
    {
      stiffness: l,
      damping: c,
      mass: u,
      duration: h,
      velocity: d,
      isResolvedFromDuration: f,
    } = PU({ ...t, velocity: -sr(t.velocity || 0) }),
    p = d || 0,
    m = c / (2 * Math.sqrt(l * u)),
    g = a - s,
    v = sr(Math.sqrt(l / u)),
    y = Math.abs(g) < 5;
  (i || (i = y ? fn.restSpeed.granular : fn.restSpeed.default),
    r || (r = y ? fn.restDelta.granular : fn.restDelta.default));
  let _;
  if (m < 1) {
    const S = Vv(v, m);
    _ = (b) => {
      const A = Math.exp(-m * v * b);
      return (
        a - A * (((p + m * v * g) / S) * Math.sin(S * b) + g * Math.cos(S * b))
      );
    };
  } else if (m === 1) _ = (S) => a - Math.exp(-v * S) * (g + (p + v * g) * S);
  else {
    const S = v * Math.sqrt(m * m - 1);
    _ = (b) => {
      const A = Math.exp(-m * v * b),
        E = Math.min(S * b, 300);
      return (
        a - (A * ((p + m * v * g) * Math.sinh(E) + S * g * Math.cosh(E))) / S
      );
    };
  }
  const x = {
    calculatedDuration: (f && h) || null,
    next: (S) => {
      const b = _(S);
      if (f) o.done = S >= h;
      else {
        let A = S === 0 ? p : 0;
        m < 1 && (A = S === 0 ? Fr(p) : YC(_, S, b));
        const E = Math.abs(A) <= i,
          w = Math.abs(a - b) <= r;
        o.done = E && w;
      }
      return ((o.value = o.done ? a : b), o);
    },
    toString: () => {
      const S = Math.min(qy(x), Yf),
        b = qC((A) => x.next(S * A).value, S, 30);
      return S + 'ms ' + b;
    },
    toTransition: () => {},
  };
  return x;
}
Kf.applyToOptions = (n) => {
  const e = EU(n, 100, Kf);
  return (
    (n.ease = e.ease),
    (n.duration = Fr(e.duration)),
    (n.type = 'keyframes'),
    n
  );
};
function Hv({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: a,
  min: o,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const h = n[0],
    d = { done: !1, value: h },
    f = (E) => (o !== void 0 && E < o) || (l !== void 0 && E > l),
    p = (E) =>
      o === void 0
        ? l
        : l === void 0 || Math.abs(o - E) < Math.abs(l - E)
          ? o
          : l;
  let m = t * e;
  const g = h + m,
    v = a === void 0 ? g : a(g);
  v !== g && (m = v - h);
  const y = (E) => -m * Math.exp(-E / i),
    _ = (E) => v + y(E),
    x = (E) => {
      const w = y(E),
        M = _(E);
      ((d.done = Math.abs(w) <= c), (d.value = d.done ? v : M));
    };
  let S, b;
  const A = (E) => {
    f(d.value) &&
      ((S = E),
      (b = Kf({
        keyframes: [d.value, p(d.value)],
        velocity: YC(_, E, d.value),
        damping: r,
        stiffness: s,
        restDelta: c,
        restSpeed: u,
      })));
  };
  return (
    A(0),
    {
      calculatedDuration: null,
      next: (E) => {
        let w = !1;
        return (
          !b && S === void 0 && ((w = !0), x(E), A(E)),
          S !== void 0 && E >= S ? b.next(E - S) : (!w && x(E), d)
        );
      },
    }
  );
}
function DU(n, e, t) {
  const i = [],
    r = t || vs.mix || XC,
    s = n.length - 1;
  for (let a = 0; a < s; a++) {
    let o = r(n[a], n[a + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[a] || Ti : e;
      o = wh(l, o);
    }
    i.push(o);
  }
  return i;
}
function Yy(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  if ((Xu(s === e.length), s === 1)) return () => e[0];
  if (s === 2 && e[0] === e[1]) return () => e[1];
  const a = n[0] === n[1];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = DU(e, i, r),
    l = o.length,
    c = (u) => {
      if (a && u < n[0]) return e[0];
      let h = 0;
      if (l > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++);
      const d = ql(n[h], n[h + 1], u);
      return o[h](d);
    };
  return t ? (u) => c(Gr(n[0], n[s - 1], u)) : c;
}
function OU(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = ql(0, e, i);
    n.push(ln(t, 1, r));
  }
}
function KC(n) {
  const e = [0];
  return (OU(e, n.length - 1), e);
}
function LU(n, e) {
  return n.map((t) => t * e);
}
function UU(n, e) {
  return n.map(() => e || kC).splice(0, n.length - 1);
}
function bu({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = 'easeInOut',
}) {
  const r = YL(i) ? i.map(GS) : GS(i),
    s = { done: !1, value: e[0] },
    a = LU(t && t.length === e.length ? t : KC(e), n),
    o = Yy(a, e, { ease: Array.isArray(r) ? r : UU(e, r) });
  return {
    calculatedDuration: n,
    next: (l) => ((s.value = o(l)), (s.done = l >= n), s),
  };
}
const kU = (n) => n !== null;
function Ky(n, { repeat: e, repeatType: t = 'loop' }, i, r = 1) {
  const s = n.filter(kU),
    o = r < 0 || (e && t !== 'loop' && e % 2 === 1) ? 0 : s.length - 1;
  return !o || i === void 0 ? s[o] : i;
}
const BU = { decay: Hv, inertia: Hv, tween: bu, keyframes: bu, spring: Kf };
function JC(n) {
  typeof n.type == 'string' && (n.type = BU[n.type]);
}
class Jy {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((e) => {
      this.resolve = e;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
}
const NU = (n) => n / 100;
class rm extends Jy {
  constructor(e) {
    (super(),
      (this.state = 'idle'),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        const { motionValue: t } = this.options;
        (t && t.updatedAt !== Si.now() && this.tick(Si.now()),
          (this.isStopped = !0),
          this.state !== 'idle' && (this.teardown(), this.options.onStop?.()));
      }),
      (this.options = e),
      this.initAnimation(),
      this.play(),
      e.autoplay === !1 && this.pause());
  }
  initAnimation() {
    const { options: e } = this;
    JC(e);
    const {
      type: t = bu,
      repeat: i = 0,
      repeatDelay: r = 0,
      repeatType: s,
      velocity: a = 0,
    } = e;
    let { keyframes: o } = e;
    const l = t || bu;
    l !== bu &&
      typeof o[0] != 'number' &&
      ((this.mixKeyframes = wh(NU, XC(o[0], o[1]))), (o = [0, 100]));
    const c = l({ ...e, keyframes: o });
    (s === 'mirror' &&
      (this.mirroredGenerator = l({
        ...e,
        keyframes: [...o].reverse(),
        velocity: -a,
      })),
      c.calculatedDuration === null && (c.calculatedDuration = qy(c)));
    const { calculatedDuration: u } = c;
    ((this.calculatedDuration = u),
      (this.resolvedDuration = u + r),
      (this.totalDuration = this.resolvedDuration * (i + 1) - r),
      (this.generator = c));
  }
  updateTime(e) {
    const t = Math.round(e - this.startTime) * this.playbackSpeed;
    this.holdTime !== null
      ? (this.currentTime = this.holdTime)
      : (this.currentTime = t);
  }
  tick(e, t = !1) {
    const {
      generator: i,
      totalDuration: r,
      mixKeyframes: s,
      mirroredGenerator: a,
      resolvedDuration: o,
      calculatedDuration: l,
    } = this;
    if (this.startTime === null) return i.next(0);
    const {
      delay: c = 0,
      keyframes: u,
      repeat: h,
      repeatType: d,
      repeatDelay: f,
      type: p,
      onUpdate: m,
      finalKeyframe: g,
    } = this.options;
    (this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - r / this.speed, this.startTime)),
      t ? (this.currentTime = e) : this.updateTime(e));
    const v = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
      y = this.playbackSpeed >= 0 ? v < 0 : v > r;
    ((this.currentTime = Math.max(v, 0)),
      this.state === 'finished' &&
        this.holdTime === null &&
        (this.currentTime = r));
    let _ = this.currentTime,
      x = i;
    if (h) {
      const E = Math.min(this.currentTime, r) / o;
      let w = Math.floor(E),
        M = E % 1;
      (!M && E >= 1 && (M = 1),
        M === 1 && w--,
        (w = Math.min(w, h + 1)),
        !!(w % 2) &&
          (d === 'reverse'
            ? ((M = 1 - M), f && (M -= f / o))
            : d === 'mirror' && (x = a)),
        (_ = Gr(0, 1, M) * o));
    }
    const S = y ? { done: !1, value: u[0] } : x.next(_);
    s && (S.value = s(S.value));
    let { done: b } = S;
    !y &&
      l !== null &&
      (b =
        this.playbackSpeed >= 0
          ? this.currentTime >= r
          : this.currentTime <= 0);
    const A =
      this.holdTime === null &&
      (this.state === 'finished' || (this.state === 'running' && b));
    return (
      A && p !== Hv && (S.value = Ky(u, this.options, g, this.speed)),
      m && m(S.value),
      A && this.finish(),
      S
    );
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
  get duration() {
    return sr(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + sr(e);
  }
  get time() {
    return sr(this.currentTime);
  }
  set time(e) {
    ((e = Fr(e)),
      (this.currentTime = e),
      this.startTime === null ||
      this.holdTime !== null ||
      this.playbackSpeed === 0
        ? (this.holdTime = e)
        : this.driver &&
          (this.startTime = this.driver.now() - e / this.playbackSpeed),
      this.driver?.start(!1));
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    this.updateTime(Si.now());
    const t = this.playbackSpeed !== e;
    ((this.playbackSpeed = e), t && (this.time = sr(this.currentTime)));
  }
  play() {
    if (this.isStopped) return;
    const { driver: e = wU, startTime: t } = this.options;
    (this.driver || (this.driver = e((r) => this.tick(r))),
      this.options.onPlay?.());
    const i = this.driver.now();
    (this.state === 'finished'
      ? (this.updateFinished(), (this.startTime = i))
      : this.holdTime !== null
        ? (this.startTime = i - this.holdTime)
        : this.startTime || (this.startTime = t ?? i),
      this.state === 'finished' &&
        this.speed < 0 &&
        (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = 'running'),
      this.driver.start());
  }
  pause() {
    ((this.state = 'paused'),
      this.updateTime(Si.now()),
      (this.holdTime = this.currentTime));
  }
  complete() {
    (this.state !== 'running' && this.play(),
      (this.state = 'finished'),
      (this.holdTime = null));
  }
  finish() {
    (this.notifyFinished(),
      this.teardown(),
      (this.state = 'finished'),
      this.options.onComplete?.());
  }
  cancel() {
    ((this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      this.options.onCancel?.());
  }
  teardown() {
    ((this.state = 'idle'),
      this.stopDriver(),
      (this.startTime = this.holdTime = null));
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return ((this.startTime = 0), this.tick(e, !0));
  }
  attachTimeline(e) {
    return (
      this.options.allowFlatten &&
        ((this.options.type = 'keyframes'),
        (this.options.ease = 'linear'),
        this.initAnimation()),
      this.driver?.stop(),
      e.observe(this)
    );
  }
}
function FU(n) {
  for (let e = 1; e < n.length; e++) n[e] ?? (n[e] = n[e - 1]);
}
const lo = (n) => (n * 180) / Math.PI,
  Gv = (n) => {
    const e = lo(Math.atan2(n[1], n[0]));
    return Wv(e);
  },
  zU = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (n) => (Math.abs(n[0]) + Math.abs(n[3])) / 2,
    rotate: Gv,
    rotateZ: Gv,
    skewX: (n) => lo(Math.atan(n[1])),
    skewY: (n) => lo(Math.atan(n[2])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[2])) / 2,
  },
  Wv = (n) => ((n = n % 360), n < 0 && (n += 360), n),
  KS = Gv,
  JS = (n) => Math.sqrt(n[0] * n[0] + n[1] * n[1]),
  QS = (n) => Math.sqrt(n[4] * n[4] + n[5] * n[5]),
  VU = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: JS,
    scaleY: QS,
    scale: (n) => (JS(n) + QS(n)) / 2,
    rotateX: (n) => Wv(lo(Math.atan2(n[6], n[5]))),
    rotateY: (n) => Wv(lo(Math.atan2(-n[2], n[0]))),
    rotateZ: KS,
    rotate: KS,
    skewX: (n) => lo(Math.atan(n[4])),
    skewY: (n) => lo(Math.atan(n[1])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[4])) / 2,
  };
function jv(n) {
  return n.includes('scale') ? 1 : 0;
}
function Xv(n, e) {
  if (!n || n === 'none') return jv(e);
  const t = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let i, r;
  if (t) ((i = VU), (r = t));
  else {
    const o = n.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    ((i = zU), (r = o));
  }
  if (!r) return jv(e);
  const s = i[e],
    a = r[1].split(',').map(GU);
  return typeof s == 'function' ? s(a) : a[s];
}
const HU = (n, e) => {
  const { transform: t = 'none' } = getComputedStyle(n);
  return Xv(t, e);
};
function GU(n) {
  return parseFloat(n.trim());
}
const dc = [
    'transformPerspective',
    'x',
    'y',
    'z',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
  ],
  fc = new Set(dc),
  ZS = (n) => n === hc || n === ft,
  WU = new Set(['x', 'y', 'z']),
  jU = dc.filter((n) => !WU.has(n));
function XU(n) {
  const e = [];
  return (
    jU.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith('scale') ? 1 : 0));
    }),
    e
  );
}
const xo = {
  width: ({ x: n }, { paddingLeft: e = '0', paddingRight: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = '0', paddingBottom: t = '0' }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: (n, { transform: e }) => Xv(e, 'x'),
  y: (n, { transform: e }) => Xv(e, 'y'),
};
xo.translateX = xo.x;
xo.translateY = xo.y;
const bo = new Set();
let qv = !1,
  Yv = !1,
  Kv = !1;
function QC() {
  if (Yv) {
    const n = Array.from(bo).filter((i) => i.needsMeasurement),
      e = new Set(n.map((i) => i.element)),
      t = new Map();
    (e.forEach((i) => {
      const r = XU(i);
      r.length && (t.set(i, r), i.render());
    }),
      n.forEach((i) => i.measureInitialState()),
      e.forEach((i) => {
        i.render();
        const r = t.get(i);
        r &&
          r.forEach(([s, a]) => {
            i.getValue(s)?.set(a);
          });
      }),
      n.forEach((i) => i.measureEndState()),
      n.forEach((i) => {
        i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY);
      }));
  }
  ((Yv = !1), (qv = !1), bo.forEach((n) => n.complete(Kv)), bo.clear());
}
function ZC() {
  bo.forEach((n) => {
    (n.readKeyframes(), n.needsMeasurement && (Yv = !0));
  });
}
function qU() {
  ((Kv = !0), ZC(), QC(), (Kv = !1));
}
class Qy {
  constructor(e, t, i, r, s, a = !1) {
    ((this.state = 'pending'),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = i),
      (this.motionValue = r),
      (this.element = s),
      (this.isAsync = a));
  }
  scheduleResolve() {
    ((this.state = 'scheduled'),
      this.isAsync
        ? (bo.add(this),
          qv || ((qv = !0), Nt.read(ZC), Nt.resolveKeyframes(QC)))
        : (this.readKeyframes(), this.complete()));
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: t,
      element: i,
      motionValue: r,
    } = this;
    if (e[0] === null) {
      const s = r?.get(),
        a = e[e.length - 1];
      if (s !== void 0) e[0] = s;
      else if (i && t) {
        const o = i.readValue(t, a);
        o != null && (e[0] = o);
      }
      (e[0] === void 0 && (e[0] = a), r && s === void 0 && r.set(e[0]));
    }
    FU(e);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(e = !1) {
    ((this.state = 'complete'),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
      bo.delete(this));
  }
  cancel() {
    this.state === 'scheduled' && (bo.delete(this), (this.state = 'pending'));
  }
  resume() {
    this.state === 'pending' && this.scheduleResolve();
  }
}
const YU = (n) => n.startsWith('--');
function KU(n, e, t) {
  YU(e) ? n.style.setProperty(e, t) : (n.style[e] = t);
}
const $C = By(() => window.ScrollTimeline !== void 0),
  JU = {};
function QU(n, e) {
  const t = By(n);
  return () => JU[e] ?? t();
}
const eR = QU(() => {
    try {
      document
        .createElement('div')
        .animate({ opacity: 0 }, { easing: 'linear(0, 1)' });
    } catch {
      return !1;
    }
    return !0;
  }, 'linearEasing'),
  hu = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  $S = {
    linear: 'linear',
    ease: 'ease',
    easeIn: 'ease-in',
    easeOut: 'ease-out',
    easeInOut: 'ease-in-out',
    circIn: hu([0, 0.65, 0.55, 1]),
    circOut: hu([0.55, 0, 1, 0.45]),
    backIn: hu([0.31, 0.01, 0.66, -0.59]),
    backOut: hu([0.33, 1.53, 0.69, 0.99]),
  };
function tR(n, e) {
  if (n)
    return typeof n == 'function'
      ? eR()
        ? qC(n, e)
        : 'ease-out'
      : BC(n)
        ? hu(n)
        : Array.isArray(n)
          ? n.map((t) => tR(t, e) || $S.easeOut)
          : $S[n];
}
function ZU(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: a = 'loop',
    ease: o = 'easeOut',
    times: l,
  } = {},
  c = void 0
) {
  const u = { [e]: t };
  l && (u.offset = l);
  const h = tR(o, r);
  Array.isArray(h) && (u.easing = h);
  const d = {
    delay: i,
    duration: r,
    easing: Array.isArray(h) ? 'linear' : h,
    fill: 'both',
    iterations: s + 1,
    direction: a === 'reverse' ? 'alternate' : 'normal',
  };
  return (c && (d.pseudoElement = c), n.animate(u, d));
}
function nR(n) {
  return typeof n == 'function' && 'applyToOptions' in n;
}
function $U({ type: n, ...e }) {
  return nR(n) && eR()
    ? n.applyToOptions(e)
    : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = 'easeOut'), e);
}
class ek extends Jy {
  constructor(e) {
    if ((super(), (this.finishedTime = null), (this.isStopped = !1), !e))
      return;
    const {
      element: t,
      name: i,
      keyframes: r,
      pseudoElement: s,
      allowFlatten: a = !1,
      finalKeyframe: o,
      onComplete: l,
    } = e;
    ((this.isPseudoElement = !!s),
      (this.allowFlatten = a),
      (this.options = e),
      Xu(typeof e.type != 'string'));
    const c = $U(e);
    ((this.animation = ZU(t, i, r, c, s)),
      c.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !s)) {
          const u = Ky(r, this.options, o, this.speed);
          (this.updateMotionValue ? this.updateMotionValue(u) : KU(t, i, u),
            this.animation.cancel());
        }
        (l?.(), this.notifyFinished());
      }));
  }
  play() {
    this.isStopped ||
      (this.animation.play(),
      this.state === 'finished' && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: e } = this;
    e === 'idle' ||
      e === 'finished' ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    this.isPseudoElement || this.animation.commitStyles?.();
  }
  get duration() {
    const e = this.animation.effect?.getComputedTiming?.().duration || 0;
    return sr(Number(e));
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + sr(e);
  }
  get time() {
    return sr(Number(this.animation.currentTime) || 0);
  }
  set time(e) {
    ((this.finishedTime = null), (this.animation.currentTime = Fr(e)));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(e) {
    (e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e));
  }
  get state() {
    return this.finishedTime !== null ? 'finished' : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(e) {
    this.animation.startTime = e;
  }
  attachTimeline({ timeline: e, observe: t }) {
    return (
      this.allowFlatten &&
        this.animation.effect?.updateTiming({ easing: 'linear' }),
      (this.animation.onfinish = null),
      e && $C() ? ((this.animation.timeline = e), Ti) : t(this)
    );
  }
}
const iR = { anticipate: OC, backInOut: DC, circInOut: UC };
function tk(n) {
  return n in iR;
}
function nk(n) {
  typeof n.ease == 'string' && tk(n.ease) && (n.ease = iR[n.ease]);
}
const ew = 10;
class ik extends ek {
  constructor(e) {
    (nk(e),
      JC(e),
      super(e),
      e.startTime && (this.startTime = e.startTime),
      (this.options = e));
  }
  updateMotionValue(e) {
    const {
      motionValue: t,
      onUpdate: i,
      onComplete: r,
      element: s,
      ...a
    } = this.options;
    if (!t) return;
    if (e !== void 0) {
      t.set(e);
      return;
    }
    const o = new rm({ ...a, autoplay: !1 }),
      l = Fr(this.finishedTime ?? this.time);
    (t.setWithVelocity(o.sample(l - ew).value, o.sample(l).value, ew),
      o.stop());
  }
}
const tw = (n, e) =>
  e === 'zIndex'
    ? !1
    : !!(
        typeof n == 'number' ||
        Array.isArray(n) ||
        (typeof n == 'string' &&
          (Qs.test(n) || n === '0') &&
          !n.startsWith('url('))
      );
function rk(n) {
  const e = n[0];
  if (n.length === 1) return !0;
  for (let t = 0; t < n.length; t++) if (n[t] !== e) return !0;
}
function sk(n, e, t, i) {
  const r = n[0];
  if (r === null) return !1;
  if (e === 'display' || e === 'visibility') return !0;
  const s = n[n.length - 1],
    a = tw(r, e),
    o = tw(s, e);
  return !a || !o ? !1 : rk(n) || ((t === 'spring' || nR(t)) && i);
}
function Jv(n) {
  ((n.duration = 0), (n.type = 'keyframes'));
}
const ak = new Set(['opacity', 'clipPath', 'filter', 'transform']),
  ok = By(() => Object.hasOwnProperty.call(Element.prototype, 'animate'));
function lk(n) {
  const {
    motionValue: e,
    name: t,
    repeatDelay: i,
    repeatType: r,
    damping: s,
    type: a,
  } = n;
  if (!(e?.owner?.current instanceof HTMLElement)) return !1;
  const { onUpdate: l, transformTemplate: c } = e.owner.getProps();
  return (
    ok() &&
    t &&
    ak.has(t) &&
    (t !== 'transform' || !c) &&
    !l &&
    !i &&
    r !== 'mirror' &&
    s !== 0 &&
    a !== 'inertia'
  );
}
const ck = 40;
class uk extends Jy {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: i = 'keyframes',
    repeat: r = 0,
    repeatDelay: s = 0,
    repeatType: a = 'loop',
    keyframes: o,
    name: l,
    motionValue: c,
    element: u,
    ...h
  }) {
    (super(),
      (this.stop = () => {
        (this._animation && (this._animation.stop(), this.stopTimeline?.()),
          this.keyframeResolver?.cancel());
      }),
      (this.createdAt = Si.now()));
    const d = {
        autoplay: e,
        delay: t,
        type: i,
        repeat: r,
        repeatDelay: s,
        repeatType: a,
        name: l,
        motionValue: c,
        element: u,
        ...h,
      },
      f = u?.KeyframeResolver || Qy;
    ((this.keyframeResolver = new f(
      o,
      (p, m, g) => this.onKeyframesResolved(p, m, d, !g),
      l,
      c,
      u
    )),
      this.keyframeResolver?.scheduleResolve());
  }
  onKeyframesResolved(e, t, i, r) {
    this.keyframeResolver = void 0;
    const {
      name: s,
      type: a,
      velocity: o,
      delay: l,
      isHandoff: c,
      onUpdate: u,
    } = i;
    ((this.resolvedAt = Si.now()),
      sk(e, s, a, o) ||
        ((vs.instantAnimations || !l) && u?.(Ky(e, i, t)),
        (e[0] = e[e.length - 1]),
        Jv(i),
        (i.repeat = 0)));
    const d = {
        startTime: r
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > ck
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: t,
        ...i,
        keyframes: e,
      },
      f =
        !c && lk(d)
          ? new ik({ ...d, element: d.motionValue.owner.current })
          : new rm(d);
    (f.finished.then(() => this.notifyFinished()).catch(Ti),
      this.pendingTimeline &&
        ((this.stopTimeline = f.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = f));
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(e, t) {
    return this.finished.finally(e).then(() => {});
  }
  get animation() {
    return (
      this._animation || (this.keyframeResolver?.resume(), qU()),
      this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(e) {
    this.animation.time = e;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(e) {
    this.animation.speed = e;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(e) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(e))
        : (this.pendingTimeline = e),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    (this._animation && this.animation.cancel(),
      this.keyframeResolver?.cancel());
  }
}
const hk = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function dk(n) {
  const e = hk.exec(n);
  if (!e) return [,];
  const [, t, i, r] = e;
  return [`--${t ?? i}`, r];
}
function rR(n, e, t = 1) {
  const [i, r] = dk(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  if (s) {
    const a = s.trim();
    return AC(a) ? parseFloat(a) : a;
  }
  return Gy(r) ? rR(r, e, t + 1) : r;
}
function Zy(n, e) {
  return n?.[e] ?? n?.default ?? n;
}
const sR = new Set([
    'width',
    'height',
    'top',
    'left',
    'right',
    'bottom',
    ...dc,
  ]),
  fk = { test: (n) => n === 'auto', parse: (n) => n },
  aR = (n) => (e) => e.test(n),
  oR = [hc, ft, zr, Ls, oU, aU, fk],
  nw = (n) => oR.find(aR(n));
function pk(n) {
  return typeof n == 'number'
    ? n === 0
    : n !== null
      ? n === 'none' || n === '0' || TC(n)
      : !0;
}
const mk = new Set(['brightness', 'contrast', 'saturate', 'opacity']);
function gk(n) {
  const [e, t] = n.slice(0, -1).split('(');
  if (e === 'drop-shadow') return n;
  const [i] = t.match(Wy) || [];
  if (!i) return n;
  const r = t.replace(i, '');
  let s = mk.has(e) ? 1 : 0;
  return (i !== t && (s *= 100), e + '(' + s + r + ')');
}
const vk = /\b([a-z-]*)\(.*?\)/gu,
  Qv = {
    ...Qs,
    getAnimatableNone: (n) => {
      const e = n.match(vk);
      return e ? e.map(gk).join(' ') : n;
    },
  },
  iw = { ...hc, transform: Math.round },
  _k = {
    rotate: Ls,
    rotateX: Ls,
    rotateY: Ls,
    rotateZ: Ls,
    scale: id,
    scaleX: id,
    scaleY: id,
    scaleZ: id,
    skew: Ls,
    skewX: Ls,
    skewY: Ls,
    distance: ft,
    translateX: ft,
    translateY: ft,
    translateZ: ft,
    x: ft,
    y: ft,
    z: ft,
    perspective: ft,
    transformPerspective: ft,
    opacity: qu,
    originX: WS,
    originY: WS,
    originZ: ft,
  },
  $y = {
    borderWidth: ft,
    borderTopWidth: ft,
    borderRightWidth: ft,
    borderBottomWidth: ft,
    borderLeftWidth: ft,
    borderRadius: ft,
    radius: ft,
    borderTopLeftRadius: ft,
    borderTopRightRadius: ft,
    borderBottomRightRadius: ft,
    borderBottomLeftRadius: ft,
    width: ft,
    maxWidth: ft,
    height: ft,
    maxHeight: ft,
    top: ft,
    right: ft,
    bottom: ft,
    left: ft,
    padding: ft,
    paddingTop: ft,
    paddingRight: ft,
    paddingBottom: ft,
    paddingLeft: ft,
    margin: ft,
    marginTop: ft,
    marginRight: ft,
    marginBottom: ft,
    marginLeft: ft,
    backgroundPositionX: ft,
    backgroundPositionY: ft,
    ..._k,
    zIndex: iw,
    fillOpacity: qu,
    strokeOpacity: qu,
    numOctaves: iw,
  },
  yk = {
    ...$y,
    color: An,
    backgroundColor: An,
    outlineColor: An,
    fill: An,
    stroke: An,
    borderColor: An,
    borderTopColor: An,
    borderRightColor: An,
    borderBottomColor: An,
    borderLeftColor: An,
    filter: Qv,
    WebkitFilter: Qv,
  },
  lR = (n) => yk[n];
function cR(n, e) {
  let t = lR(n);
  return (
    t !== Qv && (t = Qs),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const xk = new Set(['auto', 'none', '0']);
function bk(n, e, t) {
  let i = 0,
    r;
  for (; i < n.length && !r; ) {
    const s = n[i];
    (typeof s == 'string' && !xk.has(s) && Yu(s).values.length && (r = n[i]),
      i++);
  }
  if (r && t) for (const s of e) n[s] = cR(t, r);
}
class Sk extends Qy {
  constructor(e, t, i, r, s) {
    super(e, t, i, r, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: i } = this;
    if (!t || !t.current) return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == 'string' && ((c = c.trim()), Gy(c))) {
        const u = rR(c, t.current);
        (u !== void 0 && (e[l] = u),
          l === e.length - 1 && (this.finalKeyframe = c));
      }
    }
    if ((this.resolveNoneKeyframes(), !sR.has(i) || e.length !== 2)) return;
    const [r, s] = e,
      a = nw(r),
      o = nw(s);
    if (a !== o)
      if (ZS(a) && ZS(o))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == 'string' && (e[l] = parseFloat(c));
        }
      else xo[i] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      i = [];
    for (let r = 0; r < e.length; r++) (e[r] === null || pk(e[r])) && i.push(r);
    i.length && bk(e, i, t);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: i } = this;
    if (!e || !e.current) return;
    (i === 'height' && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = xo[i](
        e.measureViewportBox(),
        window.getComputedStyle(e.current)
      )),
      (t[0] = this.measuredOrigin));
    const r = t[t.length - 1];
    r !== void 0 && e.getValue(i, r).jump(r, !1);
  }
  measureEndState() {
    const { element: e, name: t, unresolvedKeyframes: i } = this;
    if (!e || !e.current) return;
    const r = e.getValue(t);
    r && r.jump(this.measuredOrigin, !1);
    const s = i.length - 1,
      a = i[s];
    ((i[s] = xo[t](e.measureViewportBox(), window.getComputedStyle(e.current))),
      a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
      this.removedTransforms?.length &&
        this.removedTransforms.forEach(([o, l]) => {
          e.getValue(o).set(l);
        }),
      this.resolveNoneKeyframes());
  }
}
function uR(n, e, t) {
  if (n instanceof EventTarget) return [n];
  if (typeof n == 'string') {
    const r = document.querySelectorAll(n);
    return r ? Array.from(r) : [];
  }
  return Array.from(n);
}
const hR = (n, e) => (e && typeof n == 'number' ? e.transform(n) : n);
function ex(n) {
  return MC(n) && 'offsetHeight' in n;
}
const rw = 30,
  wk = (n) => !isNaN(parseFloat(n)),
  Su = { current: void 0 };
class Ek {
  constructor(e, t = {}) {
    ((this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (i) => {
        const r = Si.now();
        if (
          (this.updatedAt !== r && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(i),
          this.current !== this.prev &&
            (this.events.change?.notify(this.current), this.dependents))
        )
          for (const s of this.dependents) s.dirty();
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner));
  }
  setCurrent(e) {
    ((this.current = e),
      (this.updatedAt = Si.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = wk(this.current)));
  }
  setPrevFrameValue(e = this.current) {
    ((this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt));
  }
  onChange(e) {
    return this.on('change', e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new Ny());
    const i = this.events[e].add(t);
    return e === 'change'
      ? () => {
          (i(),
            Nt.read(() => {
              this.events.change.getSize() || this.stop();
            }));
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    ((this.passiveEffect = e), (this.stopPassiveEffect = t));
  }
  set(e) {
    this.passiveEffect
      ? this.passiveEffect(e, this.updateAndNotify)
      : this.updateAndNotify(e);
  }
  setWithVelocity(e, t, i) {
    (this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - i));
  }
  jump(e, t = !0) {
    (this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(e) {
    (this.dependents || (this.dependents = new Set()), this.dependents.add(e));
  }
  removeDependent(e) {
    this.dependents && this.dependents.delete(e);
  }
  get() {
    return (Su.current && Su.current.push(this), this.current);
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = Si.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > rw
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, rw);
    return Fy(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        ((this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify());
      }).then(() => {
        (this.events.animationComplete &&
          this.events.animationComplete.notify(),
          this.clearAnimation());
      })
    );
  }
  stop() {
    (this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation());
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    (this.dependents?.clear(),
      this.events.destroy?.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
}
function wr(n, e) {
  return new Ek(n, e);
}
const { schedule: tx } = NC(queueMicrotask, !1),
  _r = { x: !1, y: !1 };
function dR() {
  return _r.x || _r.y;
}
function Ak(n) {
  return n === 'x' || n === 'y'
    ? _r[n]
      ? null
      : ((_r[n] = !0),
        () => {
          _r[n] = !1;
        })
    : _r.x || _r.y
      ? null
      : ((_r.x = _r.y = !0),
        () => {
          _r.x = _r.y = !1;
        });
}
function fR(n, e) {
  const t = uR(n),
    i = new AbortController(),
    r = { passive: !0, ...e, signal: i.signal };
  return [t, r, () => i.abort()];
}
function sw(n) {
  return !(n.pointerType === 'touch' || dR());
}
function Mk(n, e, t = {}) {
  const [i, r, s] = fR(n, t),
    a = (o) => {
      if (!sw(o)) return;
      const { target: l } = o,
        c = e(l, o);
      if (typeof c != 'function' || !l) return;
      const u = (h) => {
        sw(h) && (c(h), l.removeEventListener('pointerleave', u));
      };
      l.addEventListener('pointerleave', u, r);
    };
  return (
    i.forEach((o) => {
      o.addEventListener('pointerenter', a, r);
    }),
    s
  );
}
const pR = (n, e) => (e ? (n === e ? !0 : pR(n, e.parentElement)) : !1),
  nx = (n) =>
    n.pointerType === 'mouse'
      ? typeof n.button != 'number' || n.button <= 0
      : n.isPrimary !== !1,
  Tk = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'A']);
function Ck(n) {
  return Tk.has(n.tagName) || n.tabIndex !== -1;
}
const Sf = new WeakSet();
function aw(n) {
  return (e) => {
    e.key === 'Enter' && n(e);
  };
}
function kg(n, e) {
  n.dispatchEvent(
    new PointerEvent('pointer' + e, { isPrimary: !0, bubbles: !0 })
  );
}
const Rk = (n, e) => {
  const t = n.currentTarget;
  if (!t) return;
  const i = aw(() => {
    if (Sf.has(t)) return;
    kg(t, 'down');
    const r = aw(() => {
        kg(t, 'up');
      }),
      s = () => kg(t, 'cancel');
    (t.addEventListener('keyup', r, e), t.addEventListener('blur', s, e));
  });
  (t.addEventListener('keydown', i, e),
    t.addEventListener('blur', () => t.removeEventListener('keydown', i), e));
};
function ow(n) {
  return nx(n) && !dR();
}
function Ik(n, e, t = {}) {
  const [i, r, s] = fR(n, t),
    a = (o) => {
      const l = o.currentTarget;
      if (!ow(o)) return;
      Sf.add(l);
      const c = e(l, o),
        u = (f, p) => {
          (window.removeEventListener('pointerup', h),
            window.removeEventListener('pointercancel', d),
            Sf.has(l) && Sf.delete(l),
            ow(f) && typeof c == 'function' && c(f, { success: p }));
        },
        h = (f) => {
          u(
            f,
            l === window ||
              l === document ||
              t.useGlobalTarget ||
              pR(l, f.target)
          );
        },
        d = (f) => {
          u(f, !1);
        };
      (window.addEventListener('pointerup', h, r),
        window.addEventListener('pointercancel', d, r));
    };
  return (
    i.forEach((o) => {
      ((t.useGlobalTarget ? window : o).addEventListener('pointerdown', a, r),
        ex(o) &&
          (o.addEventListener('focus', (c) => Rk(c, r)),
          !Ck(o) && !o.hasAttribute('tabindex') && (o.tabIndex = 0)));
    }),
    s
  );
}
function ix(n) {
  return MC(n) && 'ownerSVGElement' in n;
}
const wf = new WeakMap();
let Ef;
const mR = (n, e, t) => (i, r) =>
    r && r[0]
      ? r[0][n + 'Size']
      : ix(i) && 'getBBox' in i
        ? i.getBBox()[e]
        : i[t],
  Pk = mR('inline', 'width', 'offsetWidth'),
  Dk = mR('block', 'height', 'offsetHeight');
function Ok({ target: n, borderBoxSize: e }) {
  wf.get(n)?.forEach((t) => {
    t(n, {
      get width() {
        return Pk(n, e);
      },
      get height() {
        return Dk(n, e);
      },
    });
  });
}
function Lk(n) {
  n.forEach(Ok);
}
function Uk() {
  typeof ResizeObserver > 'u' || (Ef = new ResizeObserver(Lk));
}
function kk(n, e) {
  Ef || Uk();
  const t = uR(n);
  return (
    t.forEach((i) => {
      let r = wf.get(i);
      (r || ((r = new Set()), wf.set(i, r)), r.add(e), Ef?.observe(i));
    }),
    () => {
      t.forEach((i) => {
        const r = wf.get(i);
        (r?.delete(e), r?.size || Ef?.unobserve(i));
      });
    }
  );
}
const Af = new Set();
let Tl;
function Bk() {
  ((Tl = () => {
    const n = {
      get width() {
        return window.innerWidth;
      },
      get height() {
        return window.innerHeight;
      },
    };
    Af.forEach((e) => e(n));
  }),
    window.addEventListener('resize', Tl));
}
function Nk(n) {
  return (
    Af.add(n),
    Tl || Bk(),
    () => {
      (Af.delete(n),
        !Af.size &&
          typeof Tl == 'function' &&
          (window.removeEventListener('resize', Tl), (Tl = void 0)));
    }
  );
}
function Fk(n, e) {
  return typeof n == 'function' ? Nk(n) : kk(n, e);
}
function gR(n, e) {
  let t;
  const i = () => {
    const { currentTime: r } = e,
      a = (r === null ? 0 : r.value) / 100;
    (t !== a && n(a), (t = a));
  };
  return (Nt.preUpdate(i, !0), () => lr(i));
}
function zk(n) {
  return ix(n) && n.tagName === 'svg';
}
function Vk(...n) {
  const e = !Array.isArray(n[0]),
    t = e ? 0 : -1,
    i = n[0 + t],
    r = n[1 + t],
    s = n[2 + t],
    a = n[3 + t],
    o = Yy(r, s, a);
  return e ? o(i) : o;
}
const Hn = (n) => !!(n && n.getVelocity);
function Hk(n, e, t) {
  const i = n.get();
  let r = null,
    s = i,
    a;
  const o = typeof i == 'string' ? i.replace(/[\d.-]/g, '') : void 0,
    l = () => {
      r && (r.stop(), (r = null));
    },
    c = () => {
      (l(),
        (r = new rm({
          keyframes: [cw(n.get()), cw(s)],
          velocity: n.getVelocity(),
          type: 'spring',
          restDelta: 0.001,
          restSpeed: 0.01,
          ...t,
          onUpdate: a,
        })));
    };
  if (
    (n.attach((u, h) => {
      ((s = u), (a = (d) => h(lw(d, o))), Nt.postRender(c));
    }, l),
    Hn(e))
  ) {
    const u = e.on('change', (d) => n.set(lw(d, o))),
      h = n.on('destroy', u);
    return () => {
      (u(), h());
    };
  }
  return l;
}
function lw(n, e) {
  return e ? n + e : n;
}
function cw(n) {
  return typeof n == 'number' ? n : parseFloat(n);
}
const Gk = [...oR, An, Qs],
  Wk = (n) => Gk.find(aR(n)),
  pc = Ue.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: 'never',
  });
function uw(n, e) {
  if (typeof n == 'function') return n(e);
  n != null && (n.current = e);
}
function jk(...n) {
  return (e) => {
    let t = !1;
    const i = n.map((r) => {
      const s = uw(r, e);
      return (!t && typeof s == 'function' && (t = !0), s);
    });
    if (t)
      return () => {
        for (let r = 0; r < i.length; r++) {
          const s = i[r];
          typeof s == 'function' ? s() : uw(n[r], null);
        }
      };
  };
}
function Xk(...n) {
  return Ue.useCallback(jk(...n), n);
}
class qk extends Ue.Component {
  getSnapshotBeforeUpdate(e) {
    const t = this.props.childRef.current;
    if (t && e.isPresent && !this.props.isPresent) {
      const i = t.offsetParent,
        r = (ex(i) && i.offsetWidth) || 0,
        s = this.props.sizeRef.current;
      ((s.height = t.offsetHeight || 0),
        (s.width = t.offsetWidth || 0),
        (s.top = t.offsetTop),
        (s.left = t.offsetLeft),
        (s.right = r - s.width - s.left));
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function Yk({ children: n, isPresent: e, anchorX: t, root: i }) {
  const r = Ue.useId(),
    s = Ue.useRef(null),
    a = Ue.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }),
    { nonce: o } = Ue.useContext(pc),
    l = Xk(s, n?.ref);
  return (
    Ue.useInsertionEffect(() => {
      const { width: c, height: u, top: h, left: d, right: f } = a.current;
      if (e || !s.current || !c || !u) return;
      const p = t === 'left' ? `left: ${d}` : `right: ${f}`;
      s.current.dataset.motionPopId = r;
      const m = document.createElement('style');
      o && (m.nonce = o);
      const g = i ?? document.head;
      return (
        g.appendChild(m),
        m.sheet &&
          m.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${c}px !important;
            height: ${u}px !important;
            ${p}px !important;
            top: ${h}px !important;
          }
        `),
        () => {
          g.contains(m) && g.removeChild(m);
        }
      );
    }, [e]),
    cs.jsx(qk, {
      isPresent: e,
      childRef: s,
      sizeRef: a,
      children: Ue.cloneElement(n, { ref: l }),
    })
  );
}
const Kk = ({
  children: n,
  initial: e,
  isPresent: t,
  onExitComplete: i,
  custom: r,
  presenceAffectsLayout: s,
  mode: a,
  anchorX: o,
  root: l,
}) => {
  const c = uc(Jk),
    u = Ue.useId();
  let h = !0,
    d = Ue.useMemo(
      () => (
        (h = !1),
        {
          id: u,
          initial: e,
          isPresent: t,
          custom: r,
          onExitComplete: (f) => {
            c.set(f, !0);
            for (const p of c.values()) if (!p) return;
            i && i();
          },
          register: (f) => (c.set(f, !1), () => c.delete(f)),
        }
      ),
      [t, c, i]
    );
  return (
    s && h && (d = { ...d }),
    Ue.useMemo(() => {
      c.forEach((f, p) => c.set(p, !1));
    }, [t]),
    Ue.useEffect(() => {
      !t && !c.size && i && i();
    }, [t]),
    a === 'popLayout' &&
      (n = cs.jsx(Yk, { isPresent: t, anchorX: o, root: l, children: n })),
    cs.jsx(im.Provider, { value: d, children: n })
  );
};
function Jk() {
  return new Map();
}
function vR(n = !0) {
  const e = Ue.useContext(im);
  if (e === null) return [!0, null];
  const { isPresent: t, onExitComplete: i, register: r } = e,
    s = Ue.useId();
  Ue.useEffect(() => {
    if (n) return r(s);
  }, [n]);
  const a = Ue.useCallback(() => n && i && i(s), [s, i, n]);
  return !t && i ? [!1, a] : [!0];
}
const rd = (n) => n.key || '';
function hw(n) {
  const e = [];
  return (
    Ue.Children.forEach(n, (t) => {
      Ue.isValidElement(t) && e.push(t);
    }),
    e
  );
}
const Wte = ({
    children: n,
    custom: e,
    initial: t = !0,
    onExitComplete: i,
    presenceAffectsLayout: r = !0,
    mode: s = 'sync',
    propagate: a = !1,
    anchorX: o = 'left',
    root: l,
  }) => {
    const [c, u] = vR(a),
      h = Ue.useMemo(() => hw(n), [n]),
      d = a && !c ? [] : h.map(rd),
      f = Ue.useRef(!0),
      p = Ue.useRef(h),
      m = uc(() => new Map()),
      [g, v] = Ue.useState(h),
      [y, _] = Ue.useState(h);
    nm(() => {
      ((f.current = !1), (p.current = h));
      for (let b = 0; b < y.length; b++) {
        const A = rd(y[b]);
        d.includes(A) ? m.delete(A) : m.get(A) !== !0 && m.set(A, !1);
      }
    }, [y, d.length, d.join('-')]);
    const x = [];
    if (h !== g) {
      let b = [...h];
      for (let A = 0; A < y.length; A++) {
        const E = y[A],
          w = rd(E);
        d.includes(w) || (b.splice(A, 0, E), x.push(E));
      }
      return (s === 'wait' && x.length && (b = x), _(hw(b)), v(h), null);
    }
    const { forceRender: S } = Ue.useContext(Oy);
    return cs.jsx(cs.Fragment, {
      children: y.map((b) => {
        const A = rd(b),
          E = a && !c ? !1 : h === y || d.includes(A),
          w = () => {
            if (m.has(A)) m.set(A, !0);
            else return;
            let M = !0;
            (m.forEach((T) => {
              T || (M = !1);
            }),
              M && (S?.(), _(p.current), a && u?.(), i && i()));
          };
        return cs.jsx(
          Kk,
          {
            isPresent: E,
            initial: !f.current || t ? void 0 : !1,
            custom: e,
            presenceAffectsLayout: r,
            mode: s,
            root: l,
            onExitComplete: E ? void 0 : w,
            anchorX: o,
            children: b,
          },
          A
        );
      }),
    });
  },
  _R = Ue.createContext({ strict: !1 }),
  dw = {
    animation: [
      'animate',
      'variants',
      'whileHover',
      'whileTap',
      'exit',
      'whileInView',
      'whileFocus',
      'whileDrag',
    ],
    exit: ['exit'],
    drag: ['drag', 'dragControls'],
    focus: ['whileFocus'],
    hover: ['whileHover', 'onHoverStart', 'onHoverEnd'],
    tap: ['whileTap', 'onTap', 'onTapStart', 'onTapCancel'],
    pan: ['onPan', 'onPanStart', 'onPanSessionStart', 'onPanEnd'],
    inView: ['whileInView', 'onViewportEnter', 'onViewportLeave'],
    layout: ['layout', 'layoutId'],
  },
  Yl = {};
for (const n in dw) Yl[n] = { isEnabled: (e) => dw[n].some((t) => !!e[t]) };
function Qk(n) {
  for (const e in n) Yl[e] = { ...Yl[e], ...n[e] };
}
const Zk = new Set([
  'animate',
  'exit',
  'variants',
  'initial',
  'style',
  'values',
  'variants',
  'transition',
  'transformTemplate',
  'custom',
  'inherit',
  'onBeforeLayoutMeasure',
  'onAnimationStart',
  'onAnimationComplete',
  'onUpdate',
  'onDragStart',
  'onDrag',
  'onDragEnd',
  'onMeasureDragConstraints',
  'onDirectionLock',
  'onDragTransitionEnd',
  '_dragX',
  '_dragY',
  'onHoverStart',
  'onHoverEnd',
  'onViewportEnter',
  'onViewportLeave',
  'globalTapTarget',
  'ignoreStrict',
  'viewport',
]);
function Jf(n) {
  return (
    n.startsWith('while') ||
    (n.startsWith('drag') && n !== 'draggable') ||
    n.startsWith('layout') ||
    n.startsWith('onTap') ||
    n.startsWith('onPan') ||
    n.startsWith('onLayout') ||
    Zk.has(n)
  );
}
let yR = (n) => !Jf(n);
function $k(n) {
  typeof n == 'function' && (yR = (e) => (e.startsWith('on') ? !Jf(e) : n(e)));
}
try {
  $k(require('@emotion/is-prop-valid').default);
} catch {}
function eB(n, e, t) {
  const i = {};
  for (const r in n)
    (r === 'values' && typeof n.values == 'object') ||
      ((yR(r) ||
        (t === !0 && Jf(r)) ||
        (!e && !Jf(r)) ||
        (n.draggable && r.startsWith('onDrag'))) &&
        (i[r] = n[r]));
  return i;
}
const sm = Ue.createContext({});
function am(n) {
  return n !== null && typeof n == 'object' && typeof n.start == 'function';
}
function Ku(n) {
  return typeof n == 'string' || Array.isArray(n);
}
const rx = [
    'animate',
    'whileInView',
    'whileFocus',
    'whileHover',
    'whileTap',
    'whileDrag',
    'exit',
  ],
  sx = ['initial', ...rx];
function om(n) {
  return am(n.animate) || sx.some((e) => Ku(n[e]));
}
function xR(n) {
  return !!(om(n) || n.variants);
}
function tB(n, e) {
  if (om(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || Ku(t) ? t : void 0,
      animate: Ku(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function nB(n) {
  const { initial: e, animate: t } = tB(n, Ue.useContext(sm));
  return Ue.useMemo(() => ({ initial: e, animate: t }), [fw(e), fw(t)]);
}
function fw(n) {
  return Array.isArray(n) ? n.join(' ') : n;
}
const Ju = {};
function iB(n) {
  for (const e in n) ((Ju[e] = n[e]), Hy(e) && (Ju[e].isCSSVariable = !0));
}
function bR(n, { layout: e, layoutId: t }) {
  return (
    fc.has(n) ||
    n.startsWith('origin') ||
    ((e || t !== void 0) && (!!Ju[n] || n === 'opacity'))
  );
}
const rB = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    transformPerspective: 'perspective',
  },
  sB = dc.length;
function aB(n, e, t) {
  let i = '',
    r = !0;
  for (let s = 0; s < sB; s++) {
    const a = dc[s],
      o = n[a];
    if (o === void 0) continue;
    let l = !0;
    if (
      (typeof o == 'number'
        ? (l = o === (a.startsWith('scale') ? 1 : 0))
        : (l = parseFloat(o) === 0),
      !l || t)
    ) {
      const c = hR(o, $y[a]);
      if (!l) {
        r = !1;
        const u = rB[a] || a;
        i += `${u}(${c}) `;
      }
      t && (e[a] = c);
    }
  }
  return ((i = i.trim()), t ? (i = t(e, r ? '' : i)) : r && (i = 'none'), i);
}
function ax(n, e, t) {
  const { style: i, vars: r, transformOrigin: s } = n;
  let a = !1,
    o = !1;
  for (const l in e) {
    const c = e[l];
    if (fc.has(l)) {
      a = !0;
      continue;
    } else if (Hy(l)) {
      r[l] = c;
      continue;
    } else {
      const u = hR(c, $y[l]);
      l.startsWith('origin') ? ((o = !0), (s[l] = u)) : (i[l] = u);
    }
  }
  if (
    (e.transform ||
      (a || t
        ? (i.transform = aB(e, n.transform, t))
        : i.transform && (i.transform = 'none')),
    o)
  ) {
    const { originX: l = '50%', originY: c = '50%', originZ: u = 0 } = s;
    i.transformOrigin = `${l} ${c} ${u}`;
  }
}
const ox = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function SR(n, e, t) {
  for (const i in e) !Hn(e[i]) && !bR(i, t) && (n[i] = e[i]);
}
function oB({ transformTemplate: n }, e) {
  return Ue.useMemo(() => {
    const t = ox();
    return (ax(t, e, n), Object.assign({}, t.vars, t.style));
  }, [e]);
}
function lB(n, e) {
  const t = n.style || {},
    i = {};
  return (SR(i, t, n), Object.assign(i, oB(n, e)), i);
}
function cB(n, e) {
  const t = {},
    i = lB(n, e);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((t.draggable = !1),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = 'none'),
      (i.touchAction =
        n.drag === !0 ? 'none' : `pan-${n.drag === 'x' ? 'y' : 'x'}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (t.tabIndex = 0),
    (t.style = i),
    t
  );
}
const uB = { offset: 'stroke-dashoffset', array: 'stroke-dasharray' },
  hB = { offset: 'strokeDashoffset', array: 'strokeDasharray' };
function dB(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? uB : hB;
  n[s.offset] = ft.transform(-i);
  const a = ft.transform(e),
    o = ft.transform(t);
  n[s.array] = `${a} ${o}`;
}
function wR(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    pathLength: r,
    pathSpacing: s = 1,
    pathOffset: a = 0,
    ...o
  },
  l,
  c,
  u
) {
  if ((ax(n, o, c), l)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  ((n.attrs = n.style), (n.style = {}));
  const { attrs: h, style: d } = n;
  (h.transform && ((d.transform = h.transform), delete h.transform),
    (d.transform || h.transformOrigin) &&
      ((d.transformOrigin = h.transformOrigin ?? '50% 50%'),
      delete h.transformOrigin),
    d.transform &&
      ((d.transformBox = u?.transformBox ?? 'fill-box'), delete h.transformBox),
    e !== void 0 && (h.x = e),
    t !== void 0 && (h.y = t),
    i !== void 0 && (h.scale = i),
    r !== void 0 && dB(h, r, s, a, !1));
}
const ER = () => ({ ...ox(), attrs: {} }),
  AR = (n) => typeof n == 'string' && n.toLowerCase() === 'svg';
function fB(n, e, t, i) {
  const r = Ue.useMemo(() => {
    const s = ER();
    return (
      wR(s, e, AR(i), n.transformTemplate, n.style),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    (SR(s, n.style, n), (r.style = { ...s, ...r.style }));
  }
  return r;
}
const pB = [
  'animate',
  'circle',
  'defs',
  'desc',
  'ellipse',
  'g',
  'image',
  'line',
  'filter',
  'marker',
  'mask',
  'metadata',
  'path',
  'pattern',
  'polygon',
  'polyline',
  'rect',
  'stop',
  'switch',
  'symbol',
  'svg',
  'text',
  'tspan',
  'use',
  'view',
];
function lx(n) {
  return typeof n != 'string' || n.includes('-')
    ? !1
    : !!(pB.indexOf(n) > -1 || /[A-Z]/u.test(n));
}
function mB(n, e, t, { latestValues: i }, r, s = !1) {
  const o = (lx(n) ? fB : cB)(e, i, r, n),
    l = eB(e, typeof n == 'string', s),
    c = n !== Ue.Fragment ? { ...l, ...o, ref: t } : {},
    { children: u } = e,
    h = Ue.useMemo(() => (Hn(u) ? u.get() : u), [u]);
  return Ue.createElement(n, { ...c, children: h });
}
function pw(n) {
  const e = [{}, {}];
  return (
    n?.values.forEach((t, i) => {
      ((e[0][i] = t.get()), (e[1][i] = t.getVelocity()));
    }),
    e
  );
}
function cx(n, e, t, i) {
  if (typeof e == 'function') {
    const [r, s] = pw(i);
    e = e(t !== void 0 ? t : n.custom, r, s);
  }
  if (
    (typeof e == 'string' && (e = n.variants && n.variants[e]),
    typeof e == 'function')
  ) {
    const [r, s] = pw(i);
    e = e(t !== void 0 ? t : n.custom, r, s);
  }
  return e;
}
function Mf(n) {
  return Hn(n) ? n.get() : n;
}
function gB({ scrapeMotionValuesFromProps: n, createRenderState: e }, t, i, r) {
  return { latestValues: vB(t, i, r, n), renderState: e() };
}
function vB(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const d in s) r[d] = Mf(s[d]);
  let { initial: a, animate: o } = n;
  const l = om(n),
    c = xR(n);
  e &&
    c &&
    !l &&
    n.inherit !== !1 &&
    (a === void 0 && (a = e.initial), o === void 0 && (o = e.animate));
  let u = t ? t.initial === !1 : !1;
  u = u || a === !1;
  const h = u ? o : a;
  if (h && typeof h != 'boolean' && !am(h)) {
    const d = Array.isArray(h) ? h : [h];
    for (let f = 0; f < d.length; f++) {
      const p = cx(n, d[f]);
      if (p) {
        const { transitionEnd: m, transition: g, ...v } = p;
        for (const y in v) {
          let _ = v[y];
          if (Array.isArray(_)) {
            const x = u ? _.length - 1 : 0;
            _ = _[x];
          }
          _ !== null && (r[y] = _);
        }
        for (const y in m) r[y] = m[y];
      }
    }
  }
  return r;
}
const MR = (n) => (e, t) => {
  const i = Ue.useContext(sm),
    r = Ue.useContext(im),
    s = () => gB(n, e, i, r);
  return t ? s() : uc(s);
};
function ux(n, e, t) {
  const { style: i } = n,
    r = {};
  for (const s in i)
    (Hn(i[s]) ||
      (e.style && Hn(e.style[s])) ||
      bR(s, n) ||
      t?.getValue(s)?.liveStyle !== void 0) &&
      (r[s] = i[s]);
  return r;
}
const _B = MR({ scrapeMotionValuesFromProps: ux, createRenderState: ox });
function TR(n, e, t) {
  const i = ux(n, e, t);
  for (const r in n)
    if (Hn(n[r]) || Hn(e[r])) {
      const s =
        dc.indexOf(r) !== -1
          ? 'attr' + r.charAt(0).toUpperCase() + r.substring(1)
          : r;
      i[s] = n[r];
    }
  return i;
}
const yB = MR({ scrapeMotionValuesFromProps: TR, createRenderState: ER }),
  xB = Symbol.for('motionComponentSymbol');
function Cl(n) {
  return (
    n &&
    typeof n == 'object' &&
    Object.prototype.hasOwnProperty.call(n, 'current')
  );
}
function bB(n, e, t) {
  return Ue.useCallback(
    (i) => {
      (i && n.onMount && n.onMount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == 'function' ? t(i) : Cl(t) && (t.current = i)));
    },
    [e]
  );
}
const hx = (n) => n.replace(/([a-z])([A-Z])/gu, '$1-$2').toLowerCase(),
  SB = 'framerAppearId',
  CR = 'data-' + hx(SB),
  RR = Ue.createContext({});
function wB(n, e, t, i, r) {
  const { visualElement: s } = Ue.useContext(sm),
    a = Ue.useContext(_R),
    o = Ue.useContext(im),
    l = Ue.useContext(pc).reducedMotion,
    c = Ue.useRef(null);
  ((i = i || a.renderer),
    !c.current &&
      i &&
      (c.current = i(n, {
        visualState: e,
        parent: s,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: l,
      })));
  const u = c.current,
    h = Ue.useContext(RR);
  u &&
    !u.projection &&
    r &&
    (u.type === 'html' || u.type === 'svg') &&
    EB(c.current, t, r, h);
  const d = Ue.useRef(!1);
  Ue.useInsertionEffect(() => {
    u && d.current && u.update(t, o);
  });
  const f = t[CR],
    p = Ue.useRef(
      !!f &&
        !window.MotionHandoffIsComplete?.(f) &&
        window.MotionHasOptimisedAnimation?.(f)
    );
  return (
    nm(() => {
      u &&
        ((d.current = !0),
        (window.MotionIsMounted = !0),
        u.updateFeatures(),
        u.scheduleRenderMicrotask(),
        p.current && u.animationState && u.animationState.animateChanges());
    }),
    Ue.useEffect(() => {
      u &&
        (!p.current && u.animationState && u.animationState.animateChanges(),
        p.current &&
          (queueMicrotask(() => {
            window.MotionHandoffMarkAsComplete?.(f);
          }),
          (p.current = !1)),
        (u.enteringChildren = void 0));
    }),
    u
  );
}
function EB(n, e, t, i) {
  const {
    layoutId: r,
    layout: s,
    drag: a,
    dragConstraints: o,
    layoutScroll: l,
    layoutRoot: c,
    layoutCrossfade: u,
  } = e;
  ((n.projection = new t(
    n.latestValues,
    e['data-framer-portal-id'] ? void 0 : IR(n.parent)
  )),
    n.projection.setOptions({
      layoutId: r,
      layout: s,
      alwaysMeasureLayout: !!a || (o && Cl(o)),
      visualElement: n,
      animationType: typeof s == 'string' ? s : 'both',
      initialPromotionConfig: i,
      crossfade: u,
      layoutScroll: l,
      layoutRoot: c,
    }));
}
function IR(n) {
  if (n) return n.options.allowProjection !== !1 ? n.projection : IR(n.parent);
}
function Bg(n, { forwardMotionProps: e = !1 } = {}, t, i) {
  t && Qk(t);
  const r = lx(n) ? yB : _B;
  function s(o, l) {
    let c;
    const u = { ...Ue.useContext(pc), ...o, layoutId: AB(o) },
      { isStatic: h } = u,
      d = nB(o),
      f = r(o, h);
    if (!h && Ly) {
      MB();
      const p = TB(u);
      ((c = p.MeasureLayout),
        (d.visualElement = wB(n, f, u, i, p.ProjectionNode)));
    }
    return cs.jsxs(sm.Provider, {
      value: d,
      children: [
        c && d.visualElement
          ? cs.jsx(c, { visualElement: d.visualElement, ...u })
          : null,
        mB(n, o, bB(f, d.visualElement, l), f, h, e),
      ],
    });
  }
  s.displayName = `motion.${typeof n == 'string' ? n : `create(${n.displayName ?? n.name ?? ''})`}`;
  const a = Ue.forwardRef(s);
  return ((a[xB] = n), a);
}
function AB({ layoutId: n }) {
  const e = Ue.useContext(Oy).id;
  return e && n !== void 0 ? e + '-' + n : n;
}
function MB(n, e) {
  Ue.useContext(_R).strict;
}
function TB(n) {
  const { drag: e, layout: t } = Yl;
  if (!e && !t) return {};
  const i = { ...e, ...t };
  return {
    MeasureLayout:
      e?.isEnabled(n) || t?.isEnabled(n) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode,
  };
}
function CB(n, e) {
  if (typeof Proxy > 'u') return Bg;
  const t = new Map(),
    i = (s, a) => Bg(s, a, n, e),
    r = (s, a) => i(s, a);
  return new Proxy(r, {
    get: (s, a) =>
      a === 'create'
        ? i
        : (t.has(a) || t.set(a, Bg(a, void 0, n, e)), t.get(a)),
  });
}
function PR({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function RB({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function IB(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function Ng(n) {
  return n === void 0 || n === 1;
}
function Zv({ scale: n, scaleX: e, scaleY: t }) {
  return !Ng(n) || !Ng(e) || !Ng(t);
}
function $a(n) {
  return (
    Zv(n) ||
    DR(n) ||
    n.z ||
    n.rotate ||
    n.rotateX ||
    n.rotateY ||
    n.skewX ||
    n.skewY
  );
}
function DR(n) {
  return mw(n.x) || mw(n.y);
}
function mw(n) {
  return n && n !== '0%';
}
function Qf(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function gw(n, e, t, i, r) {
  return (r !== void 0 && (n = Qf(n, r, i)), Qf(n, t, i) + e);
}
function $v(n, e = 0, t = 1, i, r) {
  ((n.min = gw(n.min, e, t, i, r)), (n.max = gw(n.max, e, t, i, r)));
}
function OR(n, { x: e, y: t }) {
  ($v(n.x, e.translate, e.scale, e.originPoint),
    $v(n.y, t.translate, t.scale, t.originPoint));
}
const vw = 0.999999999999,
  _w = 1.0000000000001;
function PB(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, a;
  for (let o = 0; o < r; o++) {
    ((s = t[o]), (a = s.projectionDelta));
    const { visualElement: l } = s.options;
    (l && l.props.style && l.props.style.display === 'contents') ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        Il(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      a && ((e.x *= a.x.scale), (e.y *= a.y.scale), OR(n, a)),
      i && $a(s.latestValues) && Il(n, s.latestValues));
  }
  (e.x < _w && e.x > vw && (e.x = 1), e.y < _w && e.y > vw && (e.y = 1));
}
function Rl(n, e) {
  ((n.min = n.min + e), (n.max = n.max + e));
}
function yw(n, e, t, i, r = 0.5) {
  const s = ln(n.min, n.max, r);
  $v(n, e, t, s, i);
}
function Il(n, e) {
  (yw(n.x, e.x, e.scaleX, e.scale, e.originX),
    yw(n.y, e.y, e.scaleY, e.scale, e.originY));
}
function LR(n, e) {
  return PR(IB(n.getBoundingClientRect(), e));
}
function DB(n, e, t) {
  const i = LR(n, t),
    { scroll: r } = e;
  return (r && (Rl(i.x, r.offset.x), Rl(i.y, r.offset.y)), i);
}
const xw = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Pl = () => ({ x: xw(), y: xw() }),
  bw = () => ({ min: 0, max: 0 }),
  yn = () => ({ x: bw(), y: bw() }),
  e_ = { current: null },
  UR = { current: !1 };
function OB() {
  if (((UR.current = !0), !!Ly))
    if (window.matchMedia) {
      const n = window.matchMedia('(prefers-reduced-motion)'),
        e = () => (e_.current = n.matches);
      (n.addEventListener('change', e), e());
    } else e_.current = !1;
}
const LB = new WeakMap();
function UB(n, e, t) {
  for (const i in e) {
    const r = e[i],
      s = t[i];
    if (Hn(r)) n.addValue(i, r);
    else if (Hn(s)) n.addValue(i, wr(r, { owner: n }));
    else if (s !== r)
      if (n.hasValue(i)) {
        const a = n.getValue(i);
        a.liveStyle === !0 ? a.jump(r) : a.hasAnimated || a.set(r);
      } else {
        const a = n.getStaticValue(i);
        n.addValue(i, wr(a !== void 0 ? a : r, { owner: n }));
      }
  }
  for (const i in t) e[i] === void 0 && n.removeValue(i);
  return e;
}
const Sw = [
  'AnimationStart',
  'AnimationComplete',
  'Update',
  'BeforeLayoutMeasure',
  'LayoutMeasure',
  'LayoutAnimationStart',
  'LayoutAnimationComplete',
];
class kB {
  scrapeMotionValuesFromProps(e, t, i) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      blockInitialAnimation: s,
      visualState: a,
    },
    o = {}
  ) {
    ((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = Qy),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify('Update', this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const d = Si.now();
        this.renderScheduledAt < d &&
          ((this.renderScheduledAt = d), Nt.render(this.render, !1, !0));
      }));
    const { latestValues: l, renderState: c } = a;
    ((this.latestValues = l),
      (this.baseTarget = { ...l }),
      (this.initialValues = t.initial ? { ...l } : {}),
      (this.renderState = c),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = om(t)),
      (this.isVariantNode = xR(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current)));
    const { willChange: u, ...h } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this
    );
    for (const d in h) {
      const f = h[d];
      l[d] !== void 0 && Hn(f) && f.set(l[d]);
    }
  }
  mount(e) {
    ((this.current = e),
      LB.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      UR.current || OB(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === 'never'
          ? !1
          : this.reducedMotionConfig === 'always'
            ? !0
            : e_.current),
      this.parent?.addChild(this),
      this.update(this.props, this.presenceContext));
  }
  unmount() {
    (this.projection && this.projection.unmount(),
      lr(this.notifyUpdate),
      lr(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent?.removeChild(this));
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const t = this.features[e];
      t && (t.unmount(), (t.isMounted = !1));
    }
    this.current = null;
  }
  addChild(e) {
    (this.children.add(e),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(e));
  }
  removeChild(e) {
    (this.children.delete(e),
      this.enteringChildren && this.enteringChildren.delete(e));
  }
  bindToMotionValue(e, t) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const i = fc.has(e);
    i && this.onBindTransform && this.onBindTransform();
    const r = t.on('change', (a) => {
      ((this.latestValues[e] = a),
        this.props.onUpdate && Nt.preRender(this.notifyUpdate),
        i && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender());
    });
    let s;
    (window.MotionCheckAppearSync &&
      (s = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        (r(), s && s(), t.owner && t.stop());
      }));
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = 'animation';
    for (e in Yl) {
      const t = Yl[e];
      if (!t) continue;
      const { isEnabled: i, Feature: r } = t;
      if (
        (!this.features[e] &&
          r &&
          i(this.props) &&
          (this.features[e] = new r(this)),
        this.features[e])
      ) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : yn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  update(e, t) {
    ((e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t));
    for (let i = 0; i < Sw.length; i++) {
      const r = Sw[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = 'on' + r,
        a = e[s];
      a && (this.propEventSubscriptions[r] = this.on(r, a));
    }
    ((this.prevMotionValues = UB(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue());
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    const i = this.values.get(e);
    t !== i &&
      (i && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    (t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState));
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = wr(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, i)),
      i
    );
  }
  readValue(e, t) {
    let i =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (this.getBaseTargetFromProps(this.props, e) ??
          this.readValueFromInstance(this.current, e, this.options));
    return (
      i != null &&
        (typeof i == 'string' && (AC(i) || TC(i))
          ? (i = parseFloat(i))
          : !Wk(i) && Qs.test(t) && (i = cR(e, t)),
        this.setBaseTarget(e, Hn(i) ? i.get() : i)),
      Hn(i) ? i.get() : i
    );
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    const { initial: t } = this.props;
    let i;
    if (typeof t == 'string' || typeof t == 'object') {
      const s = cx(this.props, t, this.presenceContext?.custom);
      s && (i = s[e]);
    }
    if (t && i !== void 0) return i;
    const r = this.getBaseTargetFromProps(this.props, e);
    return r !== void 0 && !Hn(r)
      ? r
      : this.initialValues[e] !== void 0 && i === void 0
        ? void 0
        : this.baseTarget[e];
  }
  on(e, t) {
    return (
      this.events[e] || (this.events[e] = new Ny()),
      this.events[e].add(t)
    );
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
  scheduleRenderMicrotask() {
    tx.render(this.render);
  }
}
class kR extends kB {
  constructor() {
    (super(...arguments), (this.KeyframeResolver = Sk));
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    (delete t[e], delete i[e]);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Hn(e) &&
      (this.childSubscription = e.on('change', (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
}
function BR(n, { style: e, vars: t }, i, r) {
  const s = n.style;
  let a;
  for (a in e) s[a] = e[a];
  r?.applyProjectionStyles(s, i);
  for (a in t) s.setProperty(a, t[a]);
}
function BB(n) {
  return window.getComputedStyle(n);
}
class NB extends kR {
  constructor() {
    (super(...arguments), (this.type = 'html'), (this.renderInstance = BR));
  }
  readValueFromInstance(e, t) {
    if (fc.has(t)) return this.projection?.isProjecting ? jv(t) : HU(e, t);
    {
      const i = BB(e),
        r = (Hy(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == 'string' ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return LR(e, t);
  }
  build(e, t, i) {
    ax(e, t, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t, i) {
    return ux(e, t, i);
  }
}
const NR = new Set([
  'baseFrequency',
  'diffuseConstant',
  'kernelMatrix',
  'kernelUnitLength',
  'keySplines',
  'keyTimes',
  'limitingConeAngle',
  'markerHeight',
  'markerWidth',
  'numOctaves',
  'targetX',
  'targetY',
  'surfaceScale',
  'specularConstant',
  'specularExponent',
  'stdDeviation',
  'tableValues',
  'viewBox',
  'gradientTransform',
  'pathLength',
  'startOffset',
  'textLength',
  'lengthAdjust',
]);
function FB(n, e, t, i) {
  BR(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute(NR.has(r) ? r : hx(r), e.attrs[r]);
}
class zB extends kR {
  constructor() {
    (super(...arguments),
      (this.type = 'svg'),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = yn));
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (fc.has(t)) {
      const i = lR(t);
      return (i && i.default) || 0;
    }
    return ((t = NR.has(t) ? t : hx(t)), e.getAttribute(t));
  }
  scrapeMotionValuesFromProps(e, t, i) {
    return TR(e, t, i);
  }
  build(e, t, i) {
    wR(e, t, this.isSVGTag, i.transformTemplate, i.style);
  }
  renderInstance(e, t, i, r) {
    FB(e, t, i, r);
  }
  mount(e) {
    ((this.isSVGTag = AR(e.tagName)), super.mount(e));
  }
}
const VB = (n, e) =>
  lx(n) ? new zB(e) : new NB(e, { allowProjection: n !== Ue.Fragment });
function Nl(n, e, t) {
  const i = n.getProps();
  return cx(i, e, t !== void 0 ? t : i.custom, n);
}
const t_ = (n) => Array.isArray(n);
function HB(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, wr(t));
}
function GB(n) {
  return t_(n) ? n[n.length - 1] || 0 : n;
}
function WB(n, e) {
  const t = Nl(n, e);
  let { transitionEnd: i = {}, transition: r = {}, ...s } = t || {};
  s = { ...s, ...i };
  for (const a in s) {
    const o = GB(s[a]);
    HB(n, a, o);
  }
}
function jB(n) {
  return !!(Hn(n) && n.add);
}
function n_(n, e) {
  const t = n.getValue('willChange');
  if (jB(t)) return t.add(e);
  if (!t && vs.WillChange) {
    const i = new vs.WillChange('auto');
    (n.addValue('willChange', i), i.add(e));
  }
}
function FR(n) {
  return n.props[CR];
}
const XB = (n) => n !== null;
function qB(n, { repeat: e, repeatType: t = 'loop' }, i) {
  const r = n.filter(XB),
    s = e && t !== 'loop' && e % 2 === 1 ? 0 : r.length - 1;
  return r[s];
}
const YB = { type: 'spring', stiffness: 500, damping: 25, restSpeed: 10 },
  KB = (n) => ({
    type: 'spring',
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  JB = { type: 'keyframes', duration: 0.8 },
  QB = { type: 'keyframes', ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  ZB = (n, { keyframes: e }) =>
    e.length > 2
      ? JB
      : fc.has(n)
        ? n.startsWith('scale')
          ? KB(e[1])
          : YB
        : QB;
function $B({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: a,
  repeatDelay: o,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length;
}
const dx =
  (n, e, t, i = {}, r, s) =>
  (a) => {
    const o = Zy(i, n) || {},
      l = o.delay || i.delay || 0;
    let { elapsed: c = 0 } = i;
    c = c - Fr(l);
    const u = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: 'easeOut',
      velocity: e.getVelocity(),
      ...o,
      delay: -c,
      onUpdate: (d) => {
        (e.set(d), o.onUpdate && o.onUpdate(d));
      },
      onComplete: () => {
        (a(), o.onComplete && o.onComplete());
      },
      name: n,
      motionValue: e,
      element: s ? void 0 : r,
    };
    ($B(o) || Object.assign(u, ZB(n, u)),
      u.duration && (u.duration = Fr(u.duration)),
      u.repeatDelay && (u.repeatDelay = Fr(u.repeatDelay)),
      u.from !== void 0 && (u.keyframes[0] = u.from));
    let h = !1;
    if (
      ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
        (Jv(u), u.delay === 0 && (h = !0)),
      (vs.instantAnimations || vs.skipAnimations) &&
        ((h = !0), Jv(u), (u.delay = 0)),
      (u.allowFlatten = !o.type && !o.ease),
      h && !s && e.get() !== void 0)
    ) {
      const d = qB(u.keyframes, o);
      if (d !== void 0) {
        Nt.update(() => {
          (u.onUpdate(d), u.onComplete());
        });
        return;
      }
    }
    return o.isSync ? new rm(u) : new uk(u);
  };
function eN({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return ((e[t] = !1), i);
}
function zR(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let { transition: s = n.getDefaultTransition(), transitionEnd: a, ...o } = e;
  i && (s = i);
  const l = [],
    c = r && n.animationState && n.animationState.getState()[r];
  for (const u in o) {
    const h = n.getValue(u, n.latestValues[u] ?? null),
      d = o[u];
    if (d === void 0 || (c && eN(c, u))) continue;
    const f = { delay: t, ...Zy(s || {}, u) },
      p = h.get();
    if (
      p !== void 0 &&
      !h.isAnimating &&
      !Array.isArray(d) &&
      d === p &&
      !f.velocity
    )
      continue;
    let m = !1;
    if (window.MotionHandoffAnimation) {
      const v = FR(n);
      if (v) {
        const y = window.MotionHandoffAnimation(v, u, Nt);
        y !== null && ((f.startTime = y), (m = !0));
      }
    }
    (n_(n, u),
      h.start(
        dx(u, h, d, n.shouldReduceMotion && sR.has(u) ? { type: !1 } : f, n, m)
      ));
    const g = h.animation;
    g && l.push(g);
  }
  return (
    a &&
      Promise.all(l).then(() => {
        Nt.update(() => {
          a && WB(n, a);
        });
      }),
    l
  );
}
function VR(n, e, t, i = 0, r = 1) {
  const s = Array.from(n)
      .sort((c, u) => c.sortNodePosition(u))
      .indexOf(e),
    a = n.size,
    o = (a - 1) * i;
  return typeof t == 'function' ? t(s, a) : r === 1 ? s * i : o - s * i;
}
function i_(n, e, t = {}) {
  const i = Nl(n, e, t.type === 'exit' ? n.presenceContext?.custom : void 0);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => Promise.all(zR(n, i, t)) : () => Promise.resolve(),
    a =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: c = 0,
              staggerChildren: u,
              staggerDirection: h,
            } = r;
            return tN(n, e, l, c, u, h, t);
          }
        : () => Promise.resolve(),
    { when: o } = r;
  if (o) {
    const [l, c] = o === 'beforeChildren' ? [s, a] : [a, s];
    return l().then(() => c());
  } else return Promise.all([s(), a(t.delay)]);
}
function tN(n, e, t = 0, i = 0, r = 0, s = 1, a) {
  const o = [];
  for (const l of n.variantChildren)
    (l.notify('AnimationStart', e),
      o.push(
        i_(l, e, {
          ...a,
          delay:
            t +
            (typeof i == 'function' ? 0 : i) +
            VR(n.variantChildren, l, i, r, s),
        }).then(() => l.notify('AnimationComplete', e))
      ));
  return Promise.all(o);
}
function nN(n, e, t = {}) {
  n.notify('AnimationStart', e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => i_(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == 'string') i = i_(n, e, t);
  else {
    const r = typeof e == 'function' ? Nl(n, e, t.custom) : e;
    i = Promise.all(zR(n, r, t));
  }
  return i.then(() => {
    n.notify('AnimationComplete', e);
  });
}
function HR(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
const iN = sx.length;
function GR(n) {
  if (!n) return;
  if (!n.isControllingVariants) {
    const t = n.parent ? GR(n.parent) || {} : {};
    return (n.props.initial !== void 0 && (t.initial = n.props.initial), t);
  }
  const e = {};
  for (let t = 0; t < iN; t++) {
    const i = sx[t],
      r = n.props[i];
    (Ku(r) || r === !1) && (e[i] = r);
  }
  return e;
}
const rN = [...rx].reverse(),
  sN = rx.length;
function aN(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => nN(n, t, i)));
}
function oN(n) {
  let e = aN(n),
    t = ww(),
    i = !0;
  const r = (l) => (c, u) => {
    const h = Nl(n, u, l === 'exit' ? n.presenceContext?.custom : void 0);
    if (h) {
      const { transition: d, transitionEnd: f, ...p } = h;
      c = { ...c, ...p, ...f };
    }
    return c;
  };
  function s(l) {
    e = l(n);
  }
  function a(l) {
    const { props: c } = n,
      u = GR(n.parent) || {},
      h = [],
      d = new Set();
    let f = {},
      p = 1 / 0;
    for (let g = 0; g < sN; g++) {
      const v = rN[g],
        y = t[v],
        _ = c[v] !== void 0 ? c[v] : u[v],
        x = Ku(_),
        S = v === l ? y.isActive : null;
      S === !1 && (p = g);
      let b = _ === u[v] && _ !== c[v] && x;
      if (
        (b && i && n.manuallyAnimateOnMount && (b = !1),
        (y.protectedKeys = { ...f }),
        (!y.isActive && S === null) ||
          (!_ && !y.prevProp) ||
          am(_) ||
          typeof _ == 'boolean')
      )
        continue;
      const A = lN(y.prevProp, _);
      let E = A || (v === l && y.isActive && !b && x) || (g > p && x),
        w = !1;
      const M = Array.isArray(_) ? _ : [_];
      let T = M.reduce(r(v), {});
      S === !1 && (T = {});
      const { prevResolvedValues: D = {} } = y,
        L = { ...D, ...T },
        O = (N) => {
          ((E = !0),
            d.has(N) && ((w = !0), d.delete(N)),
            (y.needsAnimating[N] = !0));
          const U = n.getValue(N);
          U && (U.liveStyle = !1);
        };
      for (const N in L) {
        const U = T[N],
          W = D[N];
        if (f.hasOwnProperty(N)) continue;
        let G = !1;
        (t_(U) && t_(W) ? (G = !HR(U, W)) : (G = U !== W),
          G
            ? U != null
              ? O(N)
              : d.add(N)
            : U !== void 0 && d.has(N)
              ? O(N)
              : (y.protectedKeys[N] = !0));
      }
      ((y.prevProp = _),
        (y.prevResolvedValues = T),
        y.isActive && (f = { ...f, ...T }),
        i && n.blockInitialAnimation && (E = !1));
      const z = b && A;
      E &&
        (!z || w) &&
        h.push(
          ...M.map((N) => {
            const U = { type: v };
            if (
              typeof N == 'string' &&
              i &&
              !z &&
              n.manuallyAnimateOnMount &&
              n.parent
            ) {
              const { parent: W } = n,
                G = Nl(W, N);
              if (W.enteringChildren && G) {
                const { delayChildren: ne } = G.transition || {};
                U.delay = VR(W.enteringChildren, n, ne);
              }
            }
            return { animation: N, options: U };
          })
        );
    }
    if (d.size) {
      const g = {};
      if (typeof c.initial != 'boolean') {
        const v = Nl(n, Array.isArray(c.initial) ? c.initial[0] : c.initial);
        v && v.transition && (g.transition = v.transition);
      }
      (d.forEach((v) => {
        const y = n.getBaseTarget(v),
          _ = n.getValue(v);
        (_ && (_.liveStyle = !0), (g[v] = y ?? null));
      }),
        h.push({ animation: g }));
    }
    let m = !!h.length;
    return (
      i &&
        (c.initial === !1 || c.initial === c.animate) &&
        !n.manuallyAnimateOnMount &&
        (m = !1),
      (i = !1),
      m ? e(h) : Promise.resolve()
    );
  }
  function o(l, c) {
    if (t[l].isActive === c) return Promise.resolve();
    (n.variantChildren?.forEach((h) => h.animationState?.setActive(l, c)),
      (t[l].isActive = c));
    const u = a(l);
    for (const h in t) t[h].protectedKeys = {};
    return u;
  }
  return {
    animateChanges: a,
    setActive: o,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      t = ww();
    },
  };
}
function lN(n, e) {
  return typeof e == 'string' ? e !== n : Array.isArray(e) ? !HR(e, n) : !1;
}
function Oa(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function ww() {
  return {
    animate: Oa(!0),
    whileInView: Oa(),
    whileHover: Oa(),
    whileTap: Oa(),
    whileDrag: Oa(),
    whileFocus: Oa(),
    exit: Oa(),
  };
}
class sa {
  constructor(e) {
    ((this.isMounted = !1), (this.node = e));
  }
  update() {}
}
class cN extends sa {
  constructor(e) {
    (super(e), e.animationState || (e.animationState = oN(e)));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    am(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
    (this.node.animationState.reset(), this.unmountControls?.());
  }
}
let uN = 0;
class hN extends sa {
  constructor() {
    (super(...arguments), (this.id = uN++));
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: i } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === i) return;
    const r = this.node.animationState.setActive('exit', !e);
    t &&
      !e &&
      r.then(() => {
        t(this.id);
      });
  }
  mount() {
    const { register: e, onExitComplete: t } = this.node.presenceContext || {};
    (t && t(this.id), e && (this.unmount = e(this.id)));
  }
  unmount() {}
}
const dN = { animation: { Feature: cN }, exit: { Feature: hN } };
function Qu(n, e, t, i = { passive: !0 }) {
  return (n.addEventListener(e, t, i), () => n.removeEventListener(e, t));
}
function Mh(n) {
  return { point: { x: n.pageX, y: n.pageY } };
}
const fN = (n) => (e) => nx(e) && n(e, Mh(e));
function wu(n, e, t, i) {
  return Qu(n, e, fN(t), i);
}
const WR = 1e-4,
  pN = 1 - WR,
  mN = 1 + WR,
  jR = 0.01,
  gN = 0 - jR,
  vN = 0 + jR;
function hi(n) {
  return n.max - n.min;
}
function _N(n, e, t) {
  return Math.abs(n - e) <= t;
}
function Ew(n, e, t, i = 0.5) {
  ((n.origin = i),
    (n.originPoint = ln(e.min, e.max, n.origin)),
    (n.scale = hi(t) / hi(e)),
    (n.translate = ln(t.min, t.max, n.origin) - n.originPoint),
    ((n.scale >= pN && n.scale <= mN) || isNaN(n.scale)) && (n.scale = 1),
    ((n.translate >= gN && n.translate <= vN) || isNaN(n.translate)) &&
      (n.translate = 0));
}
function Eu(n, e, t, i) {
  (Ew(n.x, e.x, t.x, i ? i.originX : void 0),
    Ew(n.y, e.y, t.y, i ? i.originY : void 0));
}
function Aw(n, e, t) {
  ((n.min = t.min + e.min), (n.max = n.min + hi(e)));
}
function yN(n, e, t) {
  (Aw(n.x, e.x, t.x), Aw(n.y, e.y, t.y));
}
function Mw(n, e, t) {
  ((n.min = e.min - t.min), (n.max = n.min + hi(e)));
}
function Au(n, e, t) {
  (Mw(n.x, e.x, t.x), Mw(n.y, e.y, t.y));
}
function er(n) {
  return [n('x'), n('y')];
}
const XR = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  Tw = (n, e) => Math.abs(n - e);
function xN(n, e) {
  const t = Tw(n.x, e.x),
    i = Tw(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class qR {
  constructor(
    e,
    t,
    {
      transformPagePoint: i,
      contextWindow: r = window,
      dragSnapToOrigin: s = !1,
      distanceThreshold: a = 3,
    } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const d = zg(this.lastMoveEventInfo, this.history),
          f = this.startEvent !== null,
          p = xN(d.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!f && !p) return;
        const { point: m } = d,
          { timestamp: g } = zn;
        this.history.push({ ...m, timestamp: g });
        const { onStart: v, onMove: y } = this.handlers;
        (f ||
          (v && v(this.lastMoveEvent, d),
          (this.startEvent = this.lastMoveEvent)),
          y && y(this.lastMoveEvent, d));
      }),
      (this.handlePointerMove = (d, f) => {
        ((this.lastMoveEvent = d),
          (this.lastMoveEventInfo = Fg(f, this.transformPagePoint)),
          Nt.update(this.updatePoint, !0));
      }),
      (this.handlePointerUp = (d, f) => {
        this.end();
        const { onEnd: p, onSessionEnd: m, resumeAnimation: g } = this.handlers;
        if (
          (this.dragSnapToOrigin && g && g(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const v = zg(
          d.type === 'pointercancel'
            ? this.lastMoveEventInfo
            : Fg(f, this.transformPagePoint),
          this.history
        );
        (this.startEvent && p && p(d, v), m && m(d, v));
      }),
      !nx(e))
    )
      return;
    ((this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = i),
      (this.distanceThreshold = a),
      (this.contextWindow = r || window));
    const o = Mh(e),
      l = Fg(o, this.transformPagePoint),
      { point: c } = l,
      { timestamp: u } = zn;
    this.history = [{ ...c, timestamp: u }];
    const { onSessionStart: h } = t;
    (h && h(e, zg(l, this.history)),
      (this.removeListeners = wh(
        wu(this.contextWindow, 'pointermove', this.handlePointerMove),
        wu(this.contextWindow, 'pointerup', this.handlePointerUp),
        wu(this.contextWindow, 'pointercancel', this.handlePointerUp)
      )));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    (this.removeListeners && this.removeListeners(), lr(this.updatePoint));
  }
}
function Fg(n, e) {
  return e ? { point: e(n.point) } : n;
}
function Cw(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function zg({ point: n }, e) {
  return {
    point: n,
    delta: Cw(n, YR(e)),
    offset: Cw(n, bN(e)),
    velocity: SN(e, 0.1),
  };
}
function bN(n) {
  return n[0];
}
function YR(n) {
  return n[n.length - 1];
}
function SN(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = YR(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Fr(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = sr(r.timestamp - i.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const a = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return (a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a);
}
function wN(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? ln(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? ln(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function Rw(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function EN(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: Rw(n.x, t, r), y: Rw(n.y, e, i) };
}
function Iw(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return (
    e.max - e.min < n.max - n.min && ([t, i] = [i, t]),
    { min: t, max: i }
  );
}
function AN(n, e) {
  return { x: Iw(n.x, e.x), y: Iw(n.y, e.y) };
}
function MN(n, e) {
  let t = 0.5;
  const i = hi(n),
    r = hi(e);
  return (
    r > i
      ? (t = ql(e.min, e.max - i, n.min))
      : i > r && (t = ql(n.min, n.max - r, e.min)),
    Gr(0, 1, t)
  );
}
function TN(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const r_ = 0.35;
function CN(n = r_) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = r_),
    { x: Pw(n, 'left', 'right'), y: Pw(n, 'top', 'bottom') }
  );
}
function Pw(n, e, t) {
  return { min: Dw(n, e), max: Dw(n, t) };
}
function Dw(n, e) {
  return typeof n == 'number' ? n : n[e] || 0;
}
const RN = new WeakMap();
class IN {
  constructor(e) {
    ((this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = yn()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = e));
  }
  start(e, { snapToCursor: t = !1, distanceThreshold: i } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1) return;
    const s = (h) => {
        const { dragSnapToOrigin: d } = this.getProps();
        (d ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Mh(h).point));
      },
      a = (h, d) => {
        const { drag: f, dragPropagation: p, onDragStart: m } = this.getProps();
        if (
          f &&
          !p &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = Ak(f)),
          !this.openDragLock)
        )
          return;
        ((this.latestPointerEvent = h),
          (this.latestPanInfo = d),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          er((v) => {
            let y = this.getAxisMotionValue(v).get() || 0;
            if (zr.test(y)) {
              const { projection: _ } = this.visualElement;
              if (_ && _.layout) {
                const x = _.layout.layoutBox[v];
                x && (y = hi(x) * (parseFloat(y) / 100));
              }
            }
            this.originPoint[v] = y;
          }),
          m && Nt.postRender(() => m(h, d)),
          n_(this.visualElement, 'transform'));
        const { animationState: g } = this.visualElement;
        g && g.setActive('whileDrag', !0);
      },
      o = (h, d) => {
        ((this.latestPointerEvent = h), (this.latestPanInfo = d));
        const {
          dragPropagation: f,
          dragDirectionLock: p,
          onDirectionLock: m,
          onDrag: g,
        } = this.getProps();
        if (!f && !this.openDragLock) return;
        const { offset: v } = d;
        if (p && this.currentDirection === null) {
          ((this.currentDirection = PN(v)),
            this.currentDirection !== null && m && m(this.currentDirection));
          return;
        }
        (this.updateAxis('x', d.point, v),
          this.updateAxis('y', d.point, v),
          this.visualElement.render(),
          g && g(h, d));
      },
      l = (h, d) => {
        ((this.latestPointerEvent = h),
          (this.latestPanInfo = d),
          this.stop(h, d),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null));
      },
      c = () =>
        er(
          (h) =>
            this.getAnimationState(h) === 'paused' &&
            this.getAxisMotionValue(h).animation?.play()
        ),
      { dragSnapToOrigin: u } = this.getProps();
    this.panSession = new qR(
      e,
      {
        onSessionStart: s,
        onStart: a,
        onMove: o,
        onSessionEnd: l,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        distanceThreshold: i,
        contextWindow: XR(this.visualElement),
      }
    );
  }
  stop(e, t) {
    const i = e || this.latestPointerEvent,
      r = t || this.latestPanInfo,
      s = this.isDragging;
    if ((this.cancel(), !s || !r || !i)) return;
    const { velocity: a } = r;
    this.startAnimation(a);
    const { onDragEnd: o } = this.getProps();
    o && Nt.postRender(() => o(i, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    (e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0));
    const { dragPropagation: i } = this.getProps();
    (!i &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive('whileDrag', !1));
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !sd(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let a = this.originPoint[e] + i[e];
    (this.constraints &&
      this.constraints[e] &&
      (a = wN(a, this.constraints[e], this.elastic[e])),
      s.set(a));
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      i =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : this.visualElement.projection?.layout,
      r = this.constraints;
    (e && Cl(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && i
        ? (this.constraints = EN(i.layoutBox, e))
        : (this.constraints = !1),
      (this.elastic = CN(t)),
      r !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        er((s) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(s) &&
            (this.constraints[s] = TN(i.layoutBox[s], this.constraints[s]));
        }));
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !Cl(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = DB(i, r.root, this.visualElement.getTransformPagePoint());
    let a = AN(r.layout.layoutBox, s);
    if (t) {
      const o = t(RB(a));
      ((this.hasMutatedConstraints = !!o), o && (a = PR(o)));
    }
    return a;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: a,
        onDragTransitionEnd: o,
      } = this.getProps(),
      l = this.constraints || {},
      c = er((u) => {
        if (!sd(u, t, this.currentDirection)) return;
        let h = (l && l[u]) || {};
        a && (h = { min: 0, max: 0 });
        const d = r ? 200 : 1e6,
          f = r ? 40 : 1e7,
          p = {
            type: 'inertia',
            velocity: i ? e[u] : 0,
            bounceStiffness: d,
            bounceDamping: f,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...h,
          };
        return this.startAxisValueAnimation(u, p);
      });
    return Promise.all(c).then(o);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return (
      n_(this.visualElement, e),
      i.start(dx(e, i, 0, t, this.visualElement, !1))
    );
  }
  stopAnimation() {
    er((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    er((e) => this.getAxisMotionValue(e).animation?.pause());
  }
  getAnimationState(e) {
    return this.getAxisMotionValue(e).animation?.state;
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    er((t) => {
      const { drag: i } = this.getProps();
      if (!sd(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: a, max: o } = r.layout.layoutBox[t];
        s.set(e[t] - ln(a, o, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!Cl(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    er((a) => {
      const o = this.getAxisMotionValue(a);
      if (o && this.constraints !== !1) {
        const l = o.get();
        r[a] = MN({ min: l, max: l }, this.constraints[a]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    ((this.visualElement.current.style.transform = s ? s({}, '') : 'none'),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      er((a) => {
        if (!sd(a, e, null)) return;
        const o = this.getAxisMotionValue(a),
          { min: l, max: c } = this.constraints[a];
        o.set(ln(l, c, r[a]));
      }));
  }
  addListeners() {
    if (!this.visualElement.current) return;
    RN.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = wu(e, 'pointerdown', (l) => {
        const { drag: c, dragListener: u = !0 } = this.getProps();
        c && u && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        Cl(l) && l.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener('measure', i);
    (r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      Nt.read(i));
    const a = Qu(window, 'resize', () => this.scalePositionWithinConstraints()),
      o = r.addEventListener(
        'didUpdate',
        ({ delta: l, hasLayoutChanged: c }) => {
          this.isDragging &&
            c &&
            (er((u) => {
              const h = this.getAxisMotionValue(u);
              h &&
                ((this.originPoint[u] += l[u].translate),
                h.set(h.get() + l[u].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      (a(), t(), s(), o && o());
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: a = r_,
        dragMomentum: o = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: a,
      dragMomentum: o,
    };
  }
}
function sd(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function PN(n, e = 10) {
  let t = null;
  return (Math.abs(n.y) > e ? (t = 'y') : Math.abs(n.x) > e && (t = 'x'), t);
}
class DN extends sa {
  constructor(e) {
    (super(e),
      (this.removeGroupControls = Ti),
      (this.removeListeners = Ti),
      (this.controls = new IN(e)));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    (e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Ti));
  }
  unmount() {
    (this.removeGroupControls(), this.removeListeners());
  }
}
const Ow = (n) => (e, t) => {
  n && Nt.postRender(() => n(e, t));
};
class ON extends sa {
  constructor() {
    (super(...arguments), (this.removePointerDownListener = Ti));
  }
  onPointerDown(e) {
    this.session = new qR(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: XR(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: Ow(e),
      onStart: Ow(t),
      onMove: i,
      onEnd: (s, a) => {
        (delete this.session, r && Nt.postRender(() => r(s, a)));
      },
    };
  }
  mount() {
    this.removePointerDownListener = wu(this.node.current, 'pointerdown', (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    (this.removePointerDownListener(), this.session && this.session.end());
  }
}
const Tf = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function Lw(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const Gc = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == 'string')
        if (ft.test(n)) n = parseFloat(n);
        else return n;
      const t = Lw(n, e.target.x),
        i = Lw(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  LN = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = Qs.parse(n);
      if (r.length > 5) return i;
      const s = Qs.createTransformer(n),
        a = typeof r[0] != 'number' ? 1 : 0,
        o = t.x.scale * e.x,
        l = t.y.scale * e.y;
      ((r[0 + a] /= o), (r[1 + a] /= l));
      const c = ln(o, l, 0.5);
      return (
        typeof r[2 + a] == 'number' && (r[2 + a] /= c),
        typeof r[3 + a] == 'number' && (r[3 + a] /= c),
        s(r)
      );
    },
  };
let Vg = !1;
class UN extends Ue.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    (iB(kN),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        Vg && s.root.didUpdate(),
        s.addEventListener('animationComplete', () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Tf.hasEverUpdated = !0));
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      { projection: a } = i;
    return (
      a &&
        ((a.isPresent = s),
        (Vg = !0),
        r || e.layoutDependency !== t || t === void 0 || e.isPresent !== s
          ? a.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? a.promote()
            : a.relegate() ||
              Nt.postRender(() => {
                const o = a.getStack();
                (!o || !o.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      tx.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    ((Vg = !0),
      r &&
        (r.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(r),
        i && i.deregister && i.deregister(r)));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function KR(n) {
  const [e, t] = vR(),
    i = Ue.useContext(Oy);
  return cs.jsx(UN, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: Ue.useContext(RR),
    isPresent: e,
    safeToRemove: t,
  });
}
const kN = {
  borderRadius: {
    ...Gc,
    applyTo: [
      'borderTopLeftRadius',
      'borderTopRightRadius',
      'borderBottomLeftRadius',
      'borderBottomRightRadius',
    ],
  },
  borderTopLeftRadius: Gc,
  borderTopRightRadius: Gc,
  borderBottomLeftRadius: Gc,
  borderBottomRightRadius: Gc,
  boxShadow: LN,
};
function BN(n, e, t) {
  const i = Hn(n) ? n : wr(n);
  return (i.start(dx('', i, e, t)), i.animation);
}
const NN = (n, e) => n.depth - e.depth;
class FN {
  constructor() {
    ((this.children = []), (this.isDirty = !1));
  }
  add(e) {
    (Uy(this.children, e), (this.isDirty = !0));
  }
  remove(e) {
    (ky(this.children, e), (this.isDirty = !0));
  }
  forEach(e) {
    (this.isDirty && this.children.sort(NN),
      (this.isDirty = !1),
      this.children.forEach(e));
  }
}
function zN(n, e) {
  const t = Si.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (lr(i), n(s - e));
    };
  return (Nt.setup(i, !0), () => lr(i));
}
const JR = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight'],
  VN = JR.length,
  Uw = (n) => (typeof n == 'string' ? parseFloat(n) : n),
  kw = (n) => typeof n == 'number' || ft.test(n);
function HN(n, e, t, i, r, s) {
  r
    ? ((n.opacity = ln(0, t.opacity ?? 1, GN(i))),
      (n.opacityExit = ln(e.opacity ?? 1, 0, WN(i))))
    : s && (n.opacity = ln(e.opacity ?? 1, t.opacity ?? 1, i));
  for (let a = 0; a < VN; a++) {
    const o = `border${JR[a]}Radius`;
    let l = Bw(e, o),
      c = Bw(t, o);
    if (l === void 0 && c === void 0) continue;
    (l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || kw(l) === kw(c)
        ? ((n[o] = Math.max(ln(Uw(l), Uw(c), i), 0)),
          (zr.test(c) || zr.test(l)) && (n[o] += '%'))
        : (n[o] = c));
  }
  (e.rotate || t.rotate) && (n.rotate = ln(e.rotate || 0, t.rotate || 0, i));
}
function Bw(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const GN = QR(0, 0.5, LC),
  WN = QR(0.5, 0.95, Ti);
function QR(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(ql(n, e, i)));
}
function Nw(n, e) {
  ((n.min = e.min), (n.max = e.max));
}
function Qi(n, e) {
  (Nw(n.x, e.x), Nw(n.y, e.y));
}
function Fw(n, e) {
  ((n.translate = e.translate),
    (n.scale = e.scale),
    (n.originPoint = e.originPoint),
    (n.origin = e.origin));
}
function zw(n, e, t, i, r) {
  return (
    (n -= e),
    (n = Qf(n, 1 / t, i)),
    r !== void 0 && (n = Qf(n, 1 / r, i)),
    n
  );
}
function jN(n, e = 0, t = 1, i = 0.5, r, s = n, a = n) {
  if (
    (zr.test(e) &&
      ((e = parseFloat(e)), (e = ln(a.min, a.max, e / 100) - a.min)),
    typeof e != 'number')
  )
    return;
  let o = ln(s.min, s.max, i);
  (n === s && (o -= e),
    (n.min = zw(n.min, e, t, o, r)),
    (n.max = zw(n.max, e, t, o, r)));
}
function Vw(n, e, [t, i, r], s, a) {
  jN(n, e[t], e[i], e[r], e.scale, s, a);
}
const XN = ['x', 'scaleX', 'originX'],
  qN = ['y', 'scaleY', 'originY'];
function Hw(n, e, t, i) {
  (Vw(n.x, e, XN, t ? t.x : void 0, i ? i.x : void 0),
    Vw(n.y, e, qN, t ? t.y : void 0, i ? i.y : void 0));
}
function Gw(n) {
  return n.translate === 0 && n.scale === 1;
}
function ZR(n) {
  return Gw(n.x) && Gw(n.y);
}
function Ww(n, e) {
  return n.min === e.min && n.max === e.max;
}
function YN(n, e) {
  return Ww(n.x, e.x) && Ww(n.y, e.y);
}
function jw(n, e) {
  return (
    Math.round(n.min) === Math.round(e.min) &&
    Math.round(n.max) === Math.round(e.max)
  );
}
function $R(n, e) {
  return jw(n.x, e.x) && jw(n.y, e.y);
}
function Xw(n) {
  return hi(n.x) / hi(n.y);
}
function qw(n, e) {
  return (
    n.translate === e.translate &&
    n.scale === e.scale &&
    n.originPoint === e.originPoint
  );
}
class KN {
  constructor() {
    this.members = [];
  }
  add(e) {
    (Uy(this.members, e), e.scheduleRender());
  }
  remove(e) {
    if (
      (ky(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      (i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      (t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete());
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function JN(n, e, t) {
  let i = '';
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y,
    a = t?.z || 0;
  if (
    ((r || s || a) && (i = `translate3d(${r}px, ${s}px, ${a}px) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: c,
      rotate: u,
      rotateX: h,
      rotateY: d,
      skewX: f,
      skewY: p,
    } = t;
    (c && (i = `perspective(${c}px) ${i}`),
      u && (i += `rotate(${u}deg) `),
      h && (i += `rotateX(${h}deg) `),
      d && (i += `rotateY(${d}deg) `),
      f && (i += `skewX(${f}deg) `),
      p && (i += `skewY(${p}deg) `));
  }
  const o = n.x.scale * e.x,
    l = n.y.scale * e.y;
  return ((o !== 1 || l !== 1) && (i += `scale(${o}, ${l})`), i || 'none');
}
const Hg = ['', 'X', 'Y', 'Z'],
  QN = 1e3;
let ZN = 0;
function Gg(n, e, t, i) {
  const { latestValues: r } = e;
  r[n] && ((t[n] = r[n]), e.setStaticValue(n, 0), i && (i[n] = 0));
}
function eI(n) {
  if (((n.hasCheckedOptimisedAppear = !0), n.root === n)) return;
  const { visualElement: e } = n.options;
  if (!e) return;
  const t = FR(e);
  if (window.MotionHasOptimisedAnimation(t, 'transform')) {
    const { layout: r, layoutId: s } = n.options;
    window.MotionCancelOptimisedAnimation(t, 'transform', Nt, !(r || s));
  }
  const { parent: i } = n;
  i && !i.hasCheckedOptimisedAppear && eI(i);
}
function tI({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(a = {}, o = e?.()) {
      ((this.id = ZN++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((this.projectionUpdateScheduled = !1),
            this.nodes.forEach(tF),
            this.nodes.forEach(sF),
            this.nodes.forEach(aF),
            this.nodes.forEach(nF));
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = a),
        (this.root = o ? o.root || o : this),
        (this.path = o ? [...o.path, o] : []),
        (this.parent = o),
        (this.depth = o ? o.depth + 1 : 0));
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FN());
    }
    addEventListener(a, o) {
      return (
        this.eventHandlers.has(a) || this.eventHandlers.set(a, new Ny()),
        this.eventHandlers.get(a).add(o)
      );
    }
    notifyListeners(a, ...o) {
      const l = this.eventHandlers.get(a);
      l && l.notify(...o);
    }
    hasListeners(a) {
      return this.eventHandlers.has(a);
    }
    mount(a) {
      if (this.instance) return;
      ((this.isSVG = ix(a) && !zk(a)), (this.instance = a));
      const { layoutId: o, layout: l, visualElement: c } = this.options;
      if (
        (c && !c.current && c.mount(a),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (l || o) && (this.isLayoutDirty = !0),
        n)
      ) {
        let u,
          h = 0;
        const d = () => (this.root.updateBlockedByResize = !1);
        (Nt.read(() => {
          h = window.innerWidth;
        }),
          n(a, () => {
            const f = window.innerWidth;
            f !== h &&
              ((h = f),
              (this.root.updateBlockedByResize = !0),
              u && u(),
              (u = zN(d, 250)),
              Tf.hasAnimatedSinceResize &&
                ((Tf.hasAnimatedSinceResize = !1), this.nodes.forEach(Jw)));
          }));
      }
      (o && this.root.registerSharedNode(o, this),
        this.options.animate !== !1 &&
          c &&
          (o || l) &&
          this.addEventListener(
            'didUpdate',
            ({
              delta: u,
              hasLayoutChanged: h,
              hasRelativeLayoutChanged: d,
              layout: f,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              const p =
                  this.options.transition || c.getDefaultTransition() || hF,
                { onLayoutAnimationStart: m, onLayoutAnimationComplete: g } =
                  c.getProps(),
                v = !this.targetLayout || !$R(this.targetLayout, f),
                y = !h && d;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                y ||
                (h && (v || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const _ = { ...Zy(p, 'layout'), onPlay: m, onComplete: g };
                ((c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((_.delay = 0), (_.type = !1)),
                  this.startAnimation(_),
                  this.setAnimationOrigin(u, y));
              } else
                (h || Jw(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete());
              this.targetLayout = f;
            }
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(),
        this.root.nodes.remove(this));
      const a = this.getStack();
      (a && a.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        lr(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(oF),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: a } = this.options;
      return a && a.getProps().transformTemplate;
    }
    willUpdate(a = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          eI(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u];
        ((h.shouldResetTransform = !0),
          h.updateScroll('snapshot'),
          h.options.layoutRoot && h.willUpdate(!1));
      }
      const { layoutId: o, layout: l } = this.options;
      if (o === void 0 && !l) return;
      const c = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = c
        ? c(this.latestValues, '')
        : void 0),
        this.updateSnapshot(),
        a && this.notifyListeners('willUpdate'));
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        (this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(Yw));
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(Kw);
        return;
      }
      ((this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(rF),
            this.nodes.forEach($N),
            this.nodes.forEach(eF))
          : this.nodes.forEach(Kw),
        this.clearAllSnapshots());
      const o = Si.now();
      ((zn.delta = Gr(0, 1e3 / 60, o - zn.timestamp)),
        (zn.timestamp = o),
        (zn.isProcessing = !0),
        Pg.update.process(zn),
        Pg.preRender.process(zn),
        Pg.render.process(zn),
        (zn.isProcessing = !1));
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), tx.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(iF), this.sharedNodes.forEach(lF));
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        Nt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Nt.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !hi(this.snapshot.measuredBox.x) &&
          !hi(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const a = this.layout;
      ((this.layout = this.measure(!1)),
        (this.layoutCorrected = yn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners('measure', this.layout.layoutBox));
      const { visualElement: o } = this.options;
      o &&
        o.notify(
          'LayoutMeasure',
          this.layout.layoutBox,
          a ? a.layoutBox : void 0
        );
    }
    updateScroll(a = 'measure') {
      let o = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === a &&
          (o = !1),
        o && this.instance)
      ) {
        const l = i(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: a,
          isRoot: l,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!r) return;
      const a =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        o = this.projectionDelta && !ZR(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, '') : void 0,
        u = c !== this.prevTransformTemplateValue;
      a &&
        this.instance &&
        (o || $a(this.latestValues) || u) &&
        (r(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(a = !0) {
      const o = this.measurePageBox();
      let l = this.removeElementScroll(o);
      return (
        a && (l = this.removeTransform(l)),
        dF(l),
        {
          animationId: this.root.animationId,
          measuredBox: o,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: a } = this.options;
      if (!a) return yn();
      const o = a.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(fF))) {
        const { scroll: c } = this.root;
        c && (Rl(o.x, c.offset.x), Rl(o.y, c.offset.y));
      }
      return o;
    }
    removeElementScroll(a) {
      const o = yn();
      if ((Qi(o, a), this.scroll?.wasRoot)) return o;
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l],
          { scroll: u, options: h } = c;
        c !== this.root &&
          u &&
          h.layoutScroll &&
          (u.wasRoot && Qi(o, a), Rl(o.x, u.offset.x), Rl(o.y, u.offset.y));
      }
      return o;
    }
    applyTransform(a, o = !1) {
      const l = yn();
      Qi(l, a);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        (!o &&
          u.options.layoutScroll &&
          u.scroll &&
          u !== u.root &&
          Il(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }),
          $a(u.latestValues) && Il(l, u.latestValues));
      }
      return ($a(this.latestValues) && Il(l, this.latestValues), l);
    }
    removeTransform(a) {
      const o = yn();
      Qi(o, a);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !$a(c.latestValues)) continue;
        Zv(c.latestValues) && c.updateSnapshot();
        const u = yn(),
          h = c.measurePageBox();
        (Qi(u, h),
          Hw(o, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u));
      }
      return ($a(this.latestValues) && Hw(o, this.latestValues), o);
    }
    setTargetDelta(a) {
      ((this.targetDelta = a),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0));
    }
    setOptions(a) {
      this.options = {
        ...this.options,
        ...a,
        crossfade: a.crossfade !== void 0 ? a.crossfade : !0,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== zn.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(a = !1) {
      const o = this.getLead();
      (this.isProjectionDirty || (this.isProjectionDirty = o.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = o.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = o.isSharedProjectionDirty));
      const l = !!this.resumingFrom || this !== o;
      if (
        !(
          a ||
          (l && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: u, layoutId: h } = this.options;
      if (!(!this.layout || !(u || h))) {
        if (
          ((this.resolvedRelativeTargetAt = zn.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const d = this.getClosestProjectingParent();
          d && d.layout && this.animationProgress !== 1
            ? ((this.relativeParent = d),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = yn()),
              (this.relativeTargetOrigin = yn()),
              Au(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                d.layout.layoutBox
              ),
              Qi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (
          !(!this.relativeTarget && !this.targetDelta) &&
          (this.target ||
            ((this.target = yn()), (this.targetWithTransforms = yn())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              yN(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : Qi(this.target, this.layout.layoutBox),
                OR(this.target, this.targetDelta))
              : Qi(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget)
        ) {
          this.attemptToResolveRelativeTarget = !1;
          const d = this.getClosestProjectingParent();
          d &&
          !!d.resumingFrom == !!this.resumingFrom &&
          !d.options.layoutScroll &&
          d.target &&
          this.animationProgress !== 1
            ? ((this.relativeParent = d),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = yn()),
              (this.relativeTargetOrigin = yn()),
              Au(this.relativeTargetOrigin, this.target, d.target),
              Qi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          Zv(this.parent.latestValues) ||
          DR(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      const a = this.getLead(),
        o = !!this.resumingFrom || this !== a;
      let l = !0;
      if (
        ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (l = !1),
        o &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (l = !1),
        this.resolvedRelativeTargetAt === zn.timestamp && (l = !1),
        l)
      )
        return;
      const { layout: c, layoutId: u } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || u))
      )
        return;
      Qi(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x,
        d = this.treeScale.y;
      (PB(this.layoutCorrected, this.treeScale, this.path, o),
        a.layout &&
          !a.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((a.target = a.layout.layoutBox), (a.targetWithTransforms = yn())));
      const { target: f } = a;
      if (!f) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      (!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Fw(this.prevProjectionDelta.x, this.projectionDelta.x),
          Fw(this.prevProjectionDelta.y, this.projectionDelta.y)),
        Eu(this.projectionDelta, this.layoutCorrected, f, this.latestValues),
        (this.treeScale.x !== h ||
          this.treeScale.y !== d ||
          !qw(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !qw(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners('projectionUpdate', f)));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(a = !0) {
      if ((this.options.visualElement?.scheduleRender(), a)) {
        const o = this.getStack();
        o && o.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      ((this.prevProjectionDelta = Pl()),
        (this.projectionDelta = Pl()),
        (this.projectionDeltaWithTransform = Pl()));
    }
    setAnimationOrigin(a, o = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        u = { ...this.latestValues },
        h = Pl();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !o));
      const d = yn(),
        f = l ? l.source : void 0,
        p = this.layout ? this.layout.source : void 0,
        m = f !== p,
        g = this.getStack(),
        v = !g || g.members.length <= 1,
        y = !!(m && !v && this.options.crossfade === !0 && !this.path.some(uF));
      this.animationProgress = 0;
      let _;
      ((this.mixTargetDelta = (x) => {
        const S = x / 1e3;
        (Qw(h.x, a.x, S),
          Qw(h.y, a.y, S),
          this.setTargetDelta(h),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Au(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            cF(this.relativeTarget, this.relativeTargetOrigin, d, S),
            _ && YN(this.relativeTarget, _) && (this.isProjectionDirty = !1),
            _ || (_ = yn()),
            Qi(_, this.relativeTarget)),
          m &&
            ((this.animationValues = u), HN(u, c, this.latestValues, S, y, v)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = S));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(a) {
      (this.notifyListeners('animationStart'),
        this.currentAnimation?.stop(),
        this.resumingFrom?.currentAnimation?.stop(),
        this.pendingAnimation &&
          (lr(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Nt.update(() => {
          ((Tf.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = wr(0)),
            (this.currentAnimation = BN(this.motionValue, [0, 1e3], {
              ...a,
              velocity: 0,
              isSync: !0,
              onUpdate: (o) => {
                (this.mixTargetDelta(o), a.onUpdate && a.onUpdate(o));
              },
              onStop: () => {},
              onComplete: () => {
                (a.onComplete && a.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const a = this.getStack();
      (a && a.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners('animationComplete'));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(QN),
        this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      const a = this.getLead();
      let {
        targetWithTransforms: o,
        target: l,
        layout: c,
        latestValues: u,
      } = a;
      if (!(!o || !l || !c)) {
        if (
          this !== a &&
          this.layout &&
          c &&
          nI(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || yn();
          const h = hi(this.layout.layoutBox.x);
          ((l.x.min = a.target.x.min), (l.x.max = l.x.min + h));
          const d = hi(this.layout.layoutBox.y);
          ((l.y.min = a.target.y.min), (l.y.max = l.y.min + d));
        }
        (Qi(o, l),
          Il(o, u),
          Eu(this.projectionDeltaWithTransform, this.layoutCorrected, o, u));
      }
    }
    registerSharedNode(a, o) {
      (this.sharedNodes.has(a) || this.sharedNodes.set(a, new KN()),
        this.sharedNodes.get(a).add(o));
      const c = o.options.initialPromotionConfig;
      o.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity
            ? c.shouldPreserveFollowOpacity(o)
            : void 0,
      });
    }
    isLead() {
      const a = this.getStack();
      return a ? a.lead === this : !0;
    }
    getLead() {
      const { layoutId: a } = this.options;
      return a ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: a } = this.options;
      return a ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: a } = this.options;
      if (a) return this.root.sharedNodes.get(a);
    }
    promote({ needsReset: a, transition: o, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      (c && c.promote(this, l),
        a && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        o && this.setOptions({ transition: o }));
    }
    relegate() {
      const a = this.getStack();
      return a ? a.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: a } = this.options;
      if (!a) return;
      let o = !1;
      const { latestValues: l } = a;
      if (
        ((l.z ||
          l.rotate ||
          l.rotateX ||
          l.rotateY ||
          l.rotateZ ||
          l.skewX ||
          l.skewY) &&
          (o = !0),
        !o)
      )
        return;
      const c = {};
      l.z && Gg('z', a, c, this.animationValues);
      for (let u = 0; u < Hg.length; u++)
        (Gg(`rotate${Hg[u]}`, a, c, this.animationValues),
          Gg(`skew${Hg[u]}`, a, c, this.animationValues));
      a.render();
      for (const u in c)
        (a.setStaticValue(u, c[u]),
          this.animationValues && (this.animationValues[u] = c[u]));
      a.scheduleRender();
    }
    applyProjectionStyles(a, o) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        a.visibility = 'hidden';
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        ((this.needsReset = !1),
          (a.visibility = ''),
          (a.opacity = ''),
          (a.pointerEvents = Mf(o?.pointerEvents) || ''),
          (a.transform = l ? l(this.latestValues, '') : 'none'));
        return;
      }
      const c = this.getLead();
      if (!this.projectionDelta || !this.layout || !c.target) {
        (this.options.layoutId &&
          ((a.opacity =
            this.latestValues.opacity !== void 0
              ? this.latestValues.opacity
              : 1),
          (a.pointerEvents = Mf(o?.pointerEvents) || '')),
          this.hasProjected &&
            !$a(this.latestValues) &&
            ((a.transform = l ? l({}, '') : 'none'), (this.hasProjected = !1)));
        return;
      }
      a.visibility = '';
      const u = c.animationValues || c.latestValues;
      this.applyTransformsToTarget();
      let h = JN(this.projectionDeltaWithTransform, this.treeScale, u);
      (l && (h = l(u, h)), (a.transform = h));
      const { x: d, y: f } = this.projectionDelta;
      ((a.transformOrigin = `${d.origin * 100}% ${f.origin * 100}% 0`),
        c.animationValues
          ? (a.opacity =
              c === this
                ? (u.opacity ?? this.latestValues.opacity ?? 1)
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : u.opacityExit)
          : (a.opacity =
              c === this
                ? u.opacity !== void 0
                  ? u.opacity
                  : ''
                : u.opacityExit !== void 0
                  ? u.opacityExit
                  : 0));
      for (const p in Ju) {
        if (u[p] === void 0) continue;
        const { correct: m, applyTo: g, isCSSVariable: v } = Ju[p],
          y = h === 'none' ? u[p] : m(u[p], c);
        if (g) {
          const _ = g.length;
          for (let x = 0; x < _; x++) a[g[x]] = y;
        } else
          v ? (this.options.visualElement.renderState.vars[p] = y) : (a[p] = y);
      }
      this.options.layoutId &&
        (a.pointerEvents = c === this ? Mf(o?.pointerEvents) || '' : 'none');
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((a) => a.currentAnimation?.stop()),
        this.root.nodes.forEach(Yw),
        this.root.sharedNodes.clear());
    }
  };
}
function $N(n) {
  n.updateLayout();
}
function eF(n) {
  const e = n.resumeFrom?.snapshot || n.snapshot;
  if (n.isLead() && n.layout && e && n.hasListeners('didUpdate')) {
    const { layoutBox: t, measuredBox: i } = n.layout,
      { animationType: r } = n.options,
      s = e.source !== n.layout.source;
    r === 'size'
      ? er((u) => {
          const h = s ? e.measuredBox[u] : e.layoutBox[u],
            d = hi(h);
          ((h.min = t[u].min), (h.max = h.min + d));
        })
      : nI(r, e.layoutBox, t) &&
        er((u) => {
          const h = s ? e.measuredBox[u] : e.layoutBox[u],
            d = hi(t[u]);
          ((h.max = h.min + d),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[u].max = n.relativeTarget[u].min + d)));
        });
    const a = Pl();
    Eu(a, t, e.layoutBox);
    const o = Pl();
    s ? Eu(o, n.applyTransform(i, !0), e.measuredBox) : Eu(o, t, e.layoutBox);
    const l = !ZR(a);
    let c = !1;
    if (!n.resumeFrom) {
      const u = n.getClosestProjectingParent();
      if (u && !u.resumeFrom) {
        const { snapshot: h, layout: d } = u;
        if (h && d) {
          const f = yn();
          Au(f, e.layoutBox, h.layoutBox);
          const p = yn();
          (Au(p, t, d.layoutBox),
            $R(f, p) || (c = !0),
            u.options.layoutRoot &&
              ((n.relativeTarget = p),
              (n.relativeTargetOrigin = f),
              (n.relativeParent = u)));
        }
      }
    }
    n.notifyListeners('didUpdate', {
      layout: t,
      snapshot: e,
      delta: o,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeLayoutChanged: c,
    });
  } else if (n.isLead()) {
    const { onExitComplete: t } = n.options;
    t && t();
  }
  n.options.transition = void 0;
}
function tF(n) {
  n.parent &&
    (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
    n.isSharedProjectionDirty ||
      (n.isSharedProjectionDirty = !!(
        n.isProjectionDirty ||
        n.parent.isProjectionDirty ||
        n.parent.isSharedProjectionDirty
      )),
    n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function nF(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function iF(n) {
  n.clearSnapshot();
}
function Yw(n) {
  n.clearMeasurements();
}
function Kw(n) {
  n.isLayoutDirty = !1;
}
function rF(n) {
  const { visualElement: e } = n.options;
  (e && e.getProps().onBeforeLayoutMeasure && e.notify('BeforeLayoutMeasure'),
    n.resetTransform());
}
function Jw(n) {
  (n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0));
}
function sF(n) {
  n.resolveTargetDelta();
}
function aF(n) {
  n.calcProjection();
}
function oF(n) {
  n.resetSkewAndRotation();
}
function lF(n) {
  n.removeLeadSnapshot();
}
function Qw(n, e, t) {
  ((n.translate = ln(e.translate, 0, t)),
    (n.scale = ln(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint));
}
function Zw(n, e, t, i) {
  ((n.min = ln(e.min, t.min, i)), (n.max = ln(e.max, t.max, i)));
}
function cF(n, e, t, i) {
  (Zw(n.x, e.x, t.x, i), Zw(n.y, e.y, t.y, i));
}
function uF(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const hF = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  $w = (n) =>
    typeof navigator < 'u' &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(n),
  eE = $w('applewebkit/') && !$w('chrome/') ? Math.round : Ti;
function tE(n) {
  ((n.min = eE(n.min)), (n.max = eE(n.max)));
}
function dF(n) {
  (tE(n.x), tE(n.y));
}
function nI(n, e, t) {
  return (
    n === 'position' || (n === 'preserve-aspect' && !_N(Xw(e), Xw(t), 0.2))
  );
}
function fF(n) {
  return n !== n.root && n.scroll?.wasRoot;
}
const pF = tI({
    attachResizeListener: (n, e) => Qu(n, 'resize', e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Wg = { current: void 0 },
  iI = tI({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!Wg.current) {
        const n = new pF({});
        (n.mount(window), n.setOptions({ layoutScroll: !0 }), (Wg.current = n));
      }
      return Wg.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : 'none';
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === 'fixed',
  }),
  mF = {
    pan: { Feature: ON },
    drag: { Feature: DN, ProjectionNode: iI, MeasureLayout: KR },
  };
function nE(n, e, t) {
  const { props: i } = n;
  n.animationState &&
    i.whileHover &&
    n.animationState.setActive('whileHover', t === 'Start');
  const r = 'onHover' + t,
    s = i[r];
  s && Nt.postRender(() => s(e, Mh(e)));
}
class gF extends sa {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = Mk(
        e,
        (t, i) => (nE(this.node, i, 'Start'), (r) => nE(this.node, r, 'End'))
      ));
  }
  unmount() {}
}
class vF extends sa {
  constructor() {
    (super(...arguments), (this.isActive = !1));
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(':focus-visible');
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive('whileFocus', !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = wh(
      Qu(this.node.current, 'focus', () => this.onFocus()),
      Qu(this.node.current, 'blur', () => this.onBlur())
    );
  }
  unmount() {}
}
function iE(n, e, t) {
  const { props: i } = n;
  if (n.current instanceof HTMLButtonElement && n.current.disabled) return;
  n.animationState &&
    i.whileTap &&
    n.animationState.setActive('whileTap', t === 'Start');
  const r = 'onTap' + (t === 'End' ? '' : t),
    s = i[r];
  s && Nt.postRender(() => s(e, Mh(e)));
}
class _F extends sa {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = Ik(
        e,
        (t, i) => (
          iE(this.node, i, 'Start'),
          (r, { success: s }) => iE(this.node, r, s ? 'End' : 'Cancel')
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ));
  }
  unmount() {}
}
const s_ = new WeakMap(),
  jg = new WeakMap(),
  yF = (n) => {
    const e = s_.get(n.target);
    e && e(n);
  },
  xF = (n) => {
    n.forEach(yF);
  };
function bF({ root: n, ...e }) {
  const t = n || document;
  jg.has(t) || jg.set(t, {});
  const i = jg.get(t),
    r = JSON.stringify(e);
  return (
    i[r] || (i[r] = new IntersectionObserver(xF, { root: n, ...e })),
    i[r]
  );
}
function SF(n, e, t) {
  const i = bF(e);
  return (
    s_.set(n, t),
    i.observe(n),
    () => {
      (s_.delete(n), i.unobserve(n));
    }
  );
}
const wF = { some: 0, all: 1 };
class EF extends sa {
  constructor() {
    (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = 'some', once: s } = e,
      a = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == 'number' ? r : wF[r],
      },
      o = (l) => {
        const { isIntersecting: c } = l;
        if (
          this.isInView === c ||
          ((this.isInView = c), s && !c && this.hasEnteredView)
        )
          return;
        (c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive('whileInView', c));
        const { onViewportEnter: u, onViewportLeave: h } = this.node.getProps(),
          d = c ? u : h;
        d && d(l);
      };
    return SF(this.node.current, a, o);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > 'u') return;
    const { props: e, prevProps: t } = this.node;
    ['amount', 'margin', 'root'].some(AF(e, t)) && this.startObserver();
  }
  unmount() {}
}
function AF({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const MF = {
    inView: { Feature: EF },
    tap: { Feature: _F },
    focus: { Feature: vF },
    hover: { Feature: gF },
  },
  TF = { layout: { ProjectionNode: iI, MeasureLayout: KR } },
  CF = { ...dN, ...MF, ...mF, ...TF },
  Xte = CB(CF, VB);
function RF(n, e, t) {
  Ue.useInsertionEffect(() => n.on(e, t), [n, e, t]);
}
const IF = 50,
  rE = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0,
  }),
  PF = () => ({ time: 0, x: rE(), y: rE() }),
  DF = {
    x: { length: 'Width', position: 'Left' },
    y: { length: 'Height', position: 'Top' },
  };
function sE(n, e, t, i) {
  const r = t[e],
    { length: s, position: a } = DF[e],
    o = r.current,
    l = t.time;
  ((r.current = n[`scroll${a}`]),
    (r.scrollLength = n[`scroll${s}`] - n[`client${s}`]),
    (r.offset.length = 0),
    (r.offset[0] = 0),
    (r.offset[1] = r.scrollLength),
    (r.progress = ql(0, r.scrollLength, r.current)));
  const c = i - l;
  r.velocity = c > IF ? 0 : Fy(r.current - o, c);
}
function OF(n, e, t) {
  (sE(n, 'x', e, t), sE(n, 'y', e, t), (e.time = t));
}
function LF(n, e) {
  const t = { x: 0, y: 0 };
  let i = n;
  for (; i && i !== e; )
    if (ex(i))
      ((t.x += i.offsetLeft), (t.y += i.offsetTop), (i = i.offsetParent));
    else if (i.tagName === 'svg') {
      const r = i.getBoundingClientRect();
      i = i.parentElement;
      const s = i.getBoundingClientRect();
      ((t.x += r.left - s.left), (t.y += r.top - s.top));
    } else if (i instanceof SVGGraphicsElement) {
      const { x: r, y: s } = i.getBBox();
      ((t.x += r), (t.y += s));
      let a = null,
        o = i.parentNode;
      for (; !a; ) (o.tagName === 'svg' && (a = o), (o = i.parentNode));
      i = a;
    } else break;
  return t;
}
const a_ = { start: 0, center: 0.5, end: 1 };
function aE(n, e, t = 0) {
  let i = 0;
  if ((n in a_ && (n = a_[n]), typeof n == 'string')) {
    const r = parseFloat(n);
    n.endsWith('px')
      ? (i = r)
      : n.endsWith('%')
        ? (n = r / 100)
        : n.endsWith('vw')
          ? (i = (r / 100) * document.documentElement.clientWidth)
          : n.endsWith('vh')
            ? (i = (r / 100) * document.documentElement.clientHeight)
            : (n = r);
  }
  return (typeof n == 'number' && (i = e * n), t + i);
}
const UF = [0, 0];
function kF(n, e, t, i) {
  let r = Array.isArray(n) ? n : UF,
    s = 0,
    a = 0;
  return (
    typeof n == 'number'
      ? (r = [n, n])
      : typeof n == 'string' &&
        ((n = n.trim()),
        n.includes(' ') ? (r = n.split(' ')) : (r = [n, a_[n] ? n : '0'])),
    (s = aE(r[0], t, i)),
    (a = aE(r[1], e)),
    s - a
  );
}
const BF = {
    All: [
      [0, 0],
      [1, 1],
    ],
  },
  NF = { x: 0, y: 0 };
function FF(n) {
  return 'getBBox' in n && n.tagName !== 'svg'
    ? n.getBBox()
    : { width: n.clientWidth, height: n.clientHeight };
}
function zF(n, e, t) {
  const { offset: i = BF.All } = t,
    { target: r = n, axis: s = 'y' } = t,
    a = s === 'y' ? 'height' : 'width',
    o = r !== n ? LF(r, n) : NF,
    l = r === n ? { width: n.scrollWidth, height: n.scrollHeight } : FF(r),
    c = { width: n.clientWidth, height: n.clientHeight };
  e[s].offset.length = 0;
  let u = !e[s].interpolate;
  const h = i.length;
  for (let d = 0; d < h; d++) {
    const f = kF(i[d], c[a], l[a], o[s]);
    (!u && f !== e[s].interpolatorOffsets[d] && (u = !0), (e[s].offset[d] = f));
  }
  (u &&
    ((e[s].interpolate = Yy(e[s].offset, KC(i), { clamp: !1 })),
    (e[s].interpolatorOffsets = [...e[s].offset])),
    (e[s].progress = Gr(0, 1, e[s].interpolate(e[s].current))));
}
function VF(n, e = n, t) {
  if (((t.x.targetOffset = 0), (t.y.targetOffset = 0), e !== n)) {
    let i = e;
    for (; i && i !== n; )
      ((t.x.targetOffset += i.offsetLeft),
        (t.y.targetOffset += i.offsetTop),
        (i = i.offsetParent));
  }
  ((t.x.targetLength = e === n ? e.scrollWidth : e.clientWidth),
    (t.y.targetLength = e === n ? e.scrollHeight : e.clientHeight),
    (t.x.containerLength = n.clientWidth),
    (t.y.containerLength = n.clientHeight));
}
function HF(n, e, t, i = {}) {
  return {
    measure: (r) => {
      (VF(n, i.target, t), OF(n, t, r), (i.offset || i.target) && zF(n, t, i));
    },
    notify: () => e(t),
  };
}
const Wc = new WeakMap(),
  oE = new WeakMap(),
  Xg = new WeakMap(),
  lE = (n) => (n === document.scrollingElement ? window : n);
function rI(n, { container: e = document.scrollingElement, ...t } = {}) {
  if (!e) return Ti;
  let i = Xg.get(e);
  i || ((i = new Set()), Xg.set(e, i));
  const r = PF(),
    s = HF(e, n, r, t);
  if ((i.add(s), !Wc.has(e))) {
    const o = () => {
        for (const h of i) h.measure(zn.timestamp);
        Nt.preUpdate(l);
      },
      l = () => {
        for (const h of i) h.notify();
      },
      c = () => Nt.read(o);
    Wc.set(e, c);
    const u = lE(e);
    (window.addEventListener('resize', c, { passive: !0 }),
      e !== document.documentElement && oE.set(e, Fk(e, c)),
      u.addEventListener('scroll', c, { passive: !0 }),
      c());
  }
  const a = Wc.get(e);
  return (
    Nt.read(a, !1, !0),
    () => {
      lr(a);
      const o = Xg.get(e);
      if (!o || (o.delete(s), o.size)) return;
      const l = Wc.get(e);
      (Wc.delete(e),
        l &&
          (lE(e).removeEventListener('scroll', l),
          oE.get(e)?.(),
          window.removeEventListener('resize', l)));
    }
  );
}
const cE = new Map();
function GF(n) {
  const e = { value: 0 },
    t = rI((i) => {
      e.value = i[n.axis].progress * 100;
    }, n);
  return { currentTime: e, cancel: t };
}
function sI({ source: n, container: e, ...t }) {
  const { axis: i } = t;
  n && (e = n);
  const r = cE.get(e) ?? new Map();
  cE.set(e, r);
  const s = t.target ?? 'self',
    a = r.get(s) ?? {},
    o = i + (t.offset ?? []).join(',');
  return (
    a[o] ||
      (a[o] =
        !t.target && $C()
          ? new ScrollTimeline({ source: e, axis: i })
          : GF({ container: e, ...t })),
    a[o]
  );
}
function WF(n, e) {
  const t = sI(e);
  return n.attachTimeline({
    timeline: e.target ? void 0 : t,
    observe: (i) => (
      i.pause(),
      gR((r) => {
        i.time = i.iterationDuration * r;
      }, t)
    ),
  });
}
function jF(n) {
  return n.length === 2;
}
function XF(n, e) {
  return jF(n)
    ? rI((t) => {
        n(t[e.axis].progress, t);
      }, e)
    : gR(n, sI(e));
}
function qF(
  n,
  { axis: e = 'y', container: t = document.scrollingElement, ...i } = {}
) {
  if (!t) return Ti;
  const r = { axis: e, container: t, ...i };
  return typeof n == 'function' ? XF(n, r) : WF(n, r);
}
const YF = () => ({
    scrollX: wr(0),
    scrollY: wr(0),
    scrollXProgress: wr(0),
    scrollYProgress: wr(0),
  }),
  ad = (n) => (n ? !n.current : !1);
function qte({ container: n, target: e, ...t } = {}) {
  const i = uc(YF),
    r = Ue.useRef(null),
    s = Ue.useRef(!1),
    a = Ue.useCallback(
      () => (
        (r.current = qF(
          (o, { x: l, y: c }) => {
            (i.scrollX.set(l.current),
              i.scrollXProgress.set(l.progress),
              i.scrollY.set(c.current),
              i.scrollYProgress.set(c.progress));
          },
          {
            ...t,
            container: n?.current || void 0,
            target: e?.current || void 0,
          }
        )),
        () => {
          r.current?.();
        }
      ),
      [n, e, JSON.stringify(t.offset)]
    );
  return (
    nm(() => {
      if (((s.current = !1), ad(n) || ad(e))) {
        s.current = !0;
        return;
      } else return a();
    }, [a]),
    Ue.useEffect(() => {
      if (s.current) return (Xu(!ad(n)), Xu(!ad(e)), a());
    }, [a]),
    i
  );
}
function fx(n) {
  const e = uc(() => wr(n)),
    { isStatic: t } = Ue.useContext(pc);
  if (t) {
    const [, i] = Ue.useState(n);
    Ue.useEffect(() => e.on('change', i), []);
  }
  return e;
}
function aI(n, e) {
  const t = fx(e()),
    i = () => t.set(e());
  return (
    i(),
    nm(() => {
      const r = () => Nt.preRender(i, !1, !0),
        s = n.map((a) => a.on('change', r));
      return () => {
        (s.forEach((a) => a()), lr(i));
      };
    }),
    t
  );
}
function KF(n) {
  ((Su.current = []), n());
  const e = aI(Su.current, n);
  return ((Su.current = void 0), e);
}
function JF(n, e, t, i) {
  if (typeof n == 'function') return KF(n);
  const r = typeof e == 'function' ? e : Vk(e, t, i);
  return Array.isArray(n) ? uE(n, r) : uE([n], ([s]) => r(s));
}
function uE(n, e) {
  const t = uc(() => []);
  return aI(n, () => {
    t.length = 0;
    const i = n.length;
    for (let r = 0; r < i; r++) t[r] = n[r].get();
    return e(t);
  });
}
function Yte(n, e = {}) {
  const { isStatic: t } = Ue.useContext(pc),
    i = () => (Hn(n) ? n.get() : n);
  if (t) return JF(i);
  const r = fx(i());
  return (Ue.useInsertionEffect(() => Hk(r, n, e), [r, JSON.stringify(e)]), r);
}
function Kte(n) {
  const e = Ue.useRef(0),
    { isStatic: t } = Ue.useContext(pc);
  Ue.useEffect(() => {
    if (t) return;
    const i = ({ timestamp: r, delta: s }) => {
      (e.current || (e.current = r), n(r - e.current, s));
    };
    return (Nt.update(i, !0), () => lr(i));
  }, [n]);
}
function Jte(n) {
  const e = fx(n.getVelocity()),
    t = () => {
      const i = n.getVelocity();
      (e.set(i), i && Nt.update(t));
    };
  return (
    RF(n, 'change', () => {
      Nt.update(t, !1, !0);
    }),
    e
  );
}
var o_ = function (n, e) {
  return (
    (o_ =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, i) {
          t.__proto__ = i;
        }) ||
      function (t, i) {
        for (var r in i)
          Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]);
      }),
    o_(n, e)
  );
};
function oI(n, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError(
      'Class extends value ' + String(e) + ' is not a constructor or null'
    );
  o_(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype =
    e === null ? Object.create(e) : ((t.prototype = e.prototype), new t());
}
var Zf = function () {
  return (
    (Zf =
      Object.assign ||
      function (e) {
        for (var t, i = 1, r = arguments.length; i < r; i++) {
          t = arguments[i];
          for (var s in t)
            Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
        }
        return e;
      }),
    Zf.apply(this, arguments)
  );
};
function mc(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) &&
      e.indexOf(i) < 0 &&
      (t[i] = n[i]);
  if (n != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
        (t[i[r]] = n[i[r]]);
  return t;
}
function lI(n, e, t, i) {
  var r = arguments.length,
    s =
      r < 3 ? e : i === null ? (i = Object.getOwnPropertyDescriptor(e, t)) : i,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    s = Reflect.decorate(n, e, t, i);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return (r > 3 && s && Object.defineProperty(e, t, s), s);
}
function cI(n, e) {
  return function (t, i) {
    e(t, i, n);
  };
}
function uI(n, e, t, i, r, s) {
  function a(v) {
    if (v !== void 0 && typeof v != 'function')
      throw new TypeError('Function expected');
    return v;
  }
  for (
    var o = i.kind,
      l = o === 'getter' ? 'get' : o === 'setter' ? 'set' : 'value',
      c = !e && n ? (i.static ? n : n.prototype) : null,
      u = e || (c ? Object.getOwnPropertyDescriptor(c, i.name) : {}),
      h,
      d = !1,
      f = t.length - 1;
    f >= 0;
    f--
  ) {
    var p = {};
    for (var m in i) p[m] = m === 'access' ? {} : i[m];
    for (var m in i.access) p.access[m] = i.access[m];
    p.addInitializer = function (v) {
      if (d)
        throw new TypeError(
          'Cannot add initializers after decoration has completed'
        );
      s.push(a(v || null));
    };
    var g = (0, t[f])(o === 'accessor' ? { get: u.get, set: u.set } : u[l], p);
    if (o === 'accessor') {
      if (g === void 0) continue;
      if (g === null || typeof g != 'object')
        throw new TypeError('Object expected');
      ((h = a(g.get)) && (u.get = h),
        (h = a(g.set)) && (u.set = h),
        (h = a(g.init)) && r.unshift(h));
    } else (h = a(g)) && (o === 'field' ? r.unshift(h) : (u[l] = h));
  }
  (c && Object.defineProperty(c, i.name, u), (d = !0));
}
function hI(n, e, t) {
  for (var i = arguments.length > 2, r = 0; r < e.length; r++)
    t = i ? e[r].call(n, t) : e[r].call(n);
  return i ? t : void 0;
}
function dI(n) {
  return typeof n == 'symbol' ? n : ''.concat(n);
}
function fI(n, e, t) {
  return (
    typeof e == 'symbol' &&
      (e = e.description ? '['.concat(e.description, ']') : ''),
    Object.defineProperty(n, 'name', {
      configurable: !0,
      value: t ? ''.concat(t, ' ', e) : e,
    })
  );
}
function pI(n, e) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(n, e);
}
function st(n, e, t, i) {
  function r(s) {
    return s instanceof t
      ? s
      : new t(function (a) {
          a(s);
        });
  }
  return new (t || (t = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (h) {
        a(h);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (h) {
        a(h);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(n, e || [])).next());
  });
}
function mI(n, e) {
  var t = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    i,
    r,
    s,
    a = Object.create(
      (typeof Iterator == 'function' ? Iterator : Object).prototype
    );
  return (
    (a.next = o(0)),
    (a.throw = o(1)),
    (a.return = o(2)),
    typeof Symbol == 'function' &&
      (a[Symbol.iterator] = function () {
        return this;
      }),
    a
  );
  function o(c) {
    return function (u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (i) throw new TypeError('Generator is already executing.');
    for (; a && ((a = 0), c[0] && (t = 0)), t; )
      try {
        if (
          ((i = 1),
          r &&
            (s =
              c[0] & 2
                ? r.return
                : c[0]
                  ? r.throw || ((s = r.return) && s.call(r), 0)
                  : r.next) &&
            !(s = s.call(r, c[1])).done)
        )
          return s;
        switch (((r = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return (t.label++, { value: c[1], done: !1 });
          case 5:
            (t.label++, (r = c[1]), (c = [0]));
            continue;
          case 7:
            ((c = t.ops.pop()), t.trys.pop());
            continue;
          default:
            if (
              ((s = t.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (c[0] === 6 || c[0] === 2))
            ) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < s[1]) {
              ((t.label = s[1]), (s = c));
              break;
            }
            if (s && t.label < s[2]) {
              ((t.label = s[2]), t.ops.push(c));
              break;
            }
            (s[2] && t.ops.pop(), t.trys.pop());
            continue;
        }
        c = e.call(n, t);
      } catch (u) {
        ((c = [6, u]), (r = 0));
      } finally {
        i = s = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var lm = Object.create
  ? function (n, e, t, i) {
      i === void 0 && (i = t);
      var r = Object.getOwnPropertyDescriptor(e, t);
      ((!r || ('get' in r ? !e.__esModule : r.writable || r.configurable)) &&
        (r = {
          enumerable: !0,
          get: function () {
            return e[t];
          },
        }),
        Object.defineProperty(n, i, r));
    }
  : function (n, e, t, i) {
      (i === void 0 && (i = t), (n[i] = e[t]));
    };
function gI(n, e) {
  for (var t in n)
    t !== 'default' &&
      !Object.prototype.hasOwnProperty.call(e, t) &&
      lm(e, n, t);
}
function $f(n) {
  var e = typeof Symbol == 'function' && Symbol.iterator,
    t = e && n[e],
    i = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == 'number')
    return {
      next: function () {
        return (
          n && i >= n.length && (n = void 0),
          { value: n && n[i++], done: !n }
        );
      },
    };
  throw new TypeError(
    e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
  );
}
function px(n, e) {
  var t = typeof Symbol == 'function' && n[Symbol.iterator];
  if (!t) return n;
  var i = t.call(n),
    r,
    s = [],
    a;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; ) s.push(r.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (a) throw a.error;
    }
  }
  return s;
}
function vI() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(px(arguments[e]));
  return n;
}
function _I() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++)
    n += arguments[e].length;
  for (var i = Array(n), r = 0, e = 0; e < t; e++)
    for (var s = arguments[e], a = 0, o = s.length; a < o; a++, r++)
      i[r] = s[a];
  return i;
}
function yI(n, e, t) {
  if (t || arguments.length === 2)
    for (var i = 0, r = e.length, s; i < r; i++)
      (s || !(i in e)) &&
        (s || (s = Array.prototype.slice.call(e, 0, i)), (s[i] = e[i]));
  return n.concat(s || Array.prototype.slice.call(e));
}
function Kl(n) {
  return this instanceof Kl ? ((this.v = n), this) : new Kl(n);
}
function xI(n, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var i = t.apply(n, e || []),
    r,
    s = [];
  return (
    (r = Object.create(
      (typeof AsyncIterator == 'function' ? AsyncIterator : Object).prototype
    )),
    o('next'),
    o('throw'),
    o('return', a),
    (r[Symbol.asyncIterator] = function () {
      return this;
    }),
    r
  );
  function a(f) {
    return function (p) {
      return Promise.resolve(p).then(f, h);
    };
  }
  function o(f, p) {
    i[f] &&
      ((r[f] = function (m) {
        return new Promise(function (g, v) {
          s.push([f, m, g, v]) > 1 || l(f, m);
        });
      }),
      p && (r[f] = p(r[f])));
  }
  function l(f, p) {
    try {
      c(i[f](p));
    } catch (m) {
      d(s[0][3], m);
    }
  }
  function c(f) {
    f.value instanceof Kl
      ? Promise.resolve(f.value.v).then(u, h)
      : d(s[0][2], f);
  }
  function u(f) {
    l('next', f);
  }
  function h(f) {
    l('throw', f);
  }
  function d(f, p) {
    (f(p), s.shift(), s.length && l(s[0][0], s[0][1]));
  }
}
function bI(n) {
  var e, t;
  return (
    (e = {}),
    i('next'),
    i('throw', function (r) {
      throw r;
    }),
    i('return'),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function i(r, s) {
    e[r] = n[r]
      ? function (a) {
          return (t = !t) ? { value: Kl(n[r](a)), done: !1 } : s ? s(a) : a;
        }
      : s;
  }
}
function SI(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.');
  var e = n[Symbol.asyncIterator],
    t;
  return e
    ? e.call(n)
    : ((n = typeof $f == 'function' ? $f(n) : n[Symbol.iterator]()),
      (t = {}),
      i('next'),
      i('throw'),
      i('return'),
      (t[Symbol.asyncIterator] = function () {
        return this;
      }),
      t);
  function i(s) {
    t[s] =
      n[s] &&
      function (a) {
        return new Promise(function (o, l) {
          ((a = n[s](a)), r(o, l, a.done, a.value));
        });
      };
  }
  function r(s, a, o, l) {
    Promise.resolve(l).then(function (c) {
      s({ value: c, done: o });
    }, a);
  }
}
function wI(n, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(n, 'raw', { value: e })
      : (n.raw = e),
    n
  );
}
var QF = Object.create
    ? function (n, e) {
        Object.defineProperty(n, 'default', { enumerable: !0, value: e });
      }
    : function (n, e) {
        n.default = e;
      },
  l_ = function (n) {
    return (
      (l_ =
        Object.getOwnPropertyNames ||
        function (e) {
          var t = [];
          for (var i in e)
            Object.prototype.hasOwnProperty.call(e, i) && (t[t.length] = i);
          return t;
        }),
      l_(n)
    );
  };
function EI(n) {
  if (n && n.__esModule) return n;
  var e = {};
  if (n != null)
    for (var t = l_(n), i = 0; i < t.length; i++)
      t[i] !== 'default' && lm(e, n, t[i]);
  return (QF(e, n), e);
}
function AI(n) {
  return n && n.__esModule ? n : { default: n };
}
function MI(n, e, t, i) {
  if (t === 'a' && !i)
    throw new TypeError('Private accessor was defined without a getter');
  if (typeof e == 'function' ? n !== e || !i : !e.has(n))
    throw new TypeError(
      'Cannot read private member from an object whose class did not declare it'
    );
  return t === 'm' ? i : t === 'a' ? i.call(n) : i ? i.value : e.get(n);
}
function TI(n, e, t, i, r) {
  if (i === 'm') throw new TypeError('Private method is not writable');
  if (i === 'a' && !r)
    throw new TypeError('Private accessor was defined without a setter');
  if (typeof e == 'function' ? n !== e || !r : !e.has(n))
    throw new TypeError(
      'Cannot write private member to an object whose class did not declare it'
    );
  return (i === 'a' ? r.call(n, t) : r ? (r.value = t) : e.set(n, t), t);
}
function CI(n, e) {
  if (e === null || (typeof e != 'object' && typeof e != 'function'))
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof n == 'function' ? e === n : n.has(e);
}
function RI(n, e, t) {
  if (e != null) {
    if (typeof e != 'object' && typeof e != 'function')
      throw new TypeError('Object expected.');
    var i, r;
    if (t) {
      if (!Symbol.asyncDispose)
        throw new TypeError('Symbol.asyncDispose is not defined.');
      i = e[Symbol.asyncDispose];
    }
    if (i === void 0) {
      if (!Symbol.dispose)
        throw new TypeError('Symbol.dispose is not defined.');
      ((i = e[Symbol.dispose]), t && (r = i));
    }
    if (typeof i != 'function') throw new TypeError('Object not disposable.');
    (r &&
      (i = function () {
        try {
          r.call(this);
        } catch (s) {
          return Promise.reject(s);
        }
      }),
      n.stack.push({ value: e, dispose: i, async: t }));
  } else t && n.stack.push({ async: !0 });
  return e;
}
var ZF =
  typeof SuppressedError == 'function'
    ? SuppressedError
    : function (n, e, t) {
        var i = new Error(t);
        return (
          (i.name = 'SuppressedError'),
          (i.error = n),
          (i.suppressed = e),
          i
        );
      };
function II(n) {
  function e(s) {
    ((n.error = n.hasError
      ? new ZF(s, n.error, 'An error was suppressed during disposal.')
      : s),
      (n.hasError = !0));
  }
  var t,
    i = 0;
  function r() {
    for (; (t = n.stack.pop()); )
      try {
        if (!t.async && i === 1)
          return ((i = 0), n.stack.push(t), Promise.resolve().then(r));
        if (t.dispose) {
          var s = t.dispose.call(t.value);
          if (t.async)
            return (
              (i |= 2),
              Promise.resolve(s).then(r, function (a) {
                return (e(a), r());
              })
            );
        } else i |= 1;
      } catch (a) {
        e(a);
      }
    if (i === 1)
      return n.hasError ? Promise.reject(n.error) : Promise.resolve();
    if (n.hasError) throw n.error;
  }
  return r();
}
function PI(n, e) {
  return typeof n == 'string' && /^\.\.?\//.test(n)
    ? n.replace(
        /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
        function (t, i, r, s, a) {
          return i
            ? e
              ? '.jsx'
              : '.js'
            : r && (!s || !a)
              ? t
              : r + s + '.' + a.toLowerCase() + 'js';
        }
      )
    : n;
}
const $F = {
    __extends: oI,
    __assign: Zf,
    __rest: mc,
    __decorate: lI,
    __param: cI,
    __esDecorate: uI,
    __runInitializers: hI,
    __propKey: dI,
    __setFunctionName: fI,
    __metadata: pI,
    __awaiter: st,
    __generator: mI,
    __createBinding: lm,
    __exportStar: gI,
    __values: $f,
    __read: px,
    __spread: vI,
    __spreadArrays: _I,
    __spreadArray: yI,
    __await: Kl,
    __asyncGenerator: xI,
    __asyncDelegator: bI,
    __asyncValues: SI,
    __makeTemplateObject: wI,
    __importStar: EI,
    __importDefault: AI,
    __classPrivateFieldGet: MI,
    __classPrivateFieldSet: TI,
    __classPrivateFieldIn: CI,
    __addDisposableResource: RI,
    __disposeResources: II,
    __rewriteRelativeImportExtension: PI,
  },
  ez = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        __addDisposableResource: RI,
        get __assign() {
          return Zf;
        },
        __asyncDelegator: bI,
        __asyncGenerator: xI,
        __asyncValues: SI,
        __await: Kl,
        __awaiter: st,
        __classPrivateFieldGet: MI,
        __classPrivateFieldIn: CI,
        __classPrivateFieldSet: TI,
        __createBinding: lm,
        __decorate: lI,
        __disposeResources: II,
        __esDecorate: uI,
        __exportStar: gI,
        __extends: oI,
        __generator: mI,
        __importDefault: AI,
        __importStar: EI,
        __makeTemplateObject: wI,
        __metadata: pI,
        __param: cI,
        __propKey: dI,
        __read: px,
        __rest: mc,
        __rewriteRelativeImportExtension: PI,
        __runInitializers: hI,
        __setFunctionName: fI,
        __spread: vI,
        __spreadArray: yI,
        __spreadArrays: _I,
        __values: $f,
        default: $F,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  tz = (n) => (n ? (...e) => n(...e) : (...e) => fetch(...e));
class mx extends Error {
  constructor(e, t = 'FunctionsError', i) {
    (super(e), (this.name = t), (this.context = i));
  }
}
class hE extends mx {
  constructor(e) {
    super(
      'Failed to send a request to the Edge Function',
      'FunctionsFetchError',
      e
    );
  }
}
class dE extends mx {
  constructor(e) {
    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', e);
  }
}
class fE extends mx {
  constructor(e) {
    super(
      'Edge Function returned a non-2xx status code',
      'FunctionsHttpError',
      e
    );
  }
}
var c_;
(function (n) {
  ((n.Any = 'any'),
    (n.ApNortheast1 = 'ap-northeast-1'),
    (n.ApNortheast2 = 'ap-northeast-2'),
    (n.ApSouth1 = 'ap-south-1'),
    (n.ApSoutheast1 = 'ap-southeast-1'),
    (n.ApSoutheast2 = 'ap-southeast-2'),
    (n.CaCentral1 = 'ca-central-1'),
    (n.EuCentral1 = 'eu-central-1'),
    (n.EuWest1 = 'eu-west-1'),
    (n.EuWest2 = 'eu-west-2'),
    (n.EuWest3 = 'eu-west-3'),
    (n.SaEast1 = 'sa-east-1'),
    (n.UsEast1 = 'us-east-1'),
    (n.UsWest1 = 'us-west-1'),
    (n.UsWest2 = 'us-west-2'));
})(c_ || (c_ = {}));
class nz {
  constructor(e, { headers: t = {}, customFetch: i, region: r = c_.Any } = {}) {
    ((this.url = e),
      (this.headers = t),
      (this.region = r),
      (this.fetch = tz(i)));
  }
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`;
  }
  invoke(e) {
    return st(this, arguments, void 0, function* (t, i = {}) {
      var r;
      try {
        const { headers: s, method: a, body: o, signal: l } = i;
        let c = {},
          { region: u } = i;
        u || (u = this.region);
        const h = new URL(`${this.url}/${t}`);
        u &&
          u !== 'any' &&
          ((c['x-region'] = u), h.searchParams.set('forceFunctionRegion', u));
        let d;
        o &&
        ((s && !Object.prototype.hasOwnProperty.call(s, 'Content-Type')) || !s)
          ? (typeof Blob < 'u' && o instanceof Blob) || o instanceof ArrayBuffer
            ? ((c['Content-Type'] = 'application/octet-stream'), (d = o))
            : typeof o == 'string'
              ? ((c['Content-Type'] = 'text/plain'), (d = o))
              : typeof FormData < 'u' && o instanceof FormData
                ? (d = o)
                : ((c['Content-Type'] = 'application/json'),
                  (d = JSON.stringify(o)))
          : (d = o);
        const f = yield this.fetch(h.toString(), {
            method: a || 'POST',
            headers: Object.assign(
              Object.assign(Object.assign({}, c), this.headers),
              s
            ),
            body: d,
            signal: l,
          }).catch((v) => {
            throw v.name === 'AbortError' ? v : new hE(v);
          }),
          p = f.headers.get('x-relay-error');
        if (p && p === 'true') throw new dE(f);
        if (!f.ok) throw new fE(f);
        let m = (
            (r = f.headers.get('Content-Type')) !== null && r !== void 0
              ? r
              : 'text/plain'
          )
            .split(';')[0]
            .trim(),
          g;
        return (
          m === 'application/json'
            ? (g = yield f.json())
            : m === 'application/octet-stream' || m === 'application/pdf'
              ? (g = yield f.blob())
              : m === 'text/event-stream'
                ? (g = f)
                : m === 'multipart/form-data'
                  ? (g = yield f.formData())
                  : (g = yield f.text()),
          { data: g, error: null, response: f }
        );
      } catch (s) {
        return s instanceof Error && s.name === 'AbortError'
          ? { data: null, error: new hE(s) }
          : {
              data: null,
              error: s,
              response: s instanceof fE || s instanceof dE ? s.context : void 0,
            };
      }
    });
  }
}
var Kn = {};
const gc = tO(ez);
var od = {},
  ld = {},
  cd = {},
  ud = {},
  hd = {},
  dd = {},
  pE;
function DI() {
  if (pE) return dd;
  ((pE = 1), Object.defineProperty(dd, '__esModule', { value: !0 }));
  class n extends Error {
    constructor(t) {
      (super(t.message),
        (this.name = 'PostgrestError'),
        (this.details = t.details),
        (this.hint = t.hint),
        (this.code = t.code));
    }
  }
  return ((dd.default = n), dd);
}
var mE;
function OI() {
  if (mE) return hd;
  ((mE = 1), Object.defineProperty(hd, '__esModule', { value: !0 }));
  const e = gc.__importDefault(DI());
  class t {
    constructor(r) {
      var s, a;
      ((this.shouldThrowOnError = !1),
        (this.method = r.method),
        (this.url = r.url),
        (this.headers = new Headers(r.headers)),
        (this.schema = r.schema),
        (this.body = r.body),
        (this.shouldThrowOnError =
          (s = r.shouldThrowOnError) !== null && s !== void 0 ? s : !1),
        (this.signal = r.signal),
        (this.isMaybeSingle =
          (a = r.isMaybeSingle) !== null && a !== void 0 ? a : !1),
        r.fetch ? (this.fetch = r.fetch) : (this.fetch = fetch));
    }
    throwOnError() {
      return ((this.shouldThrowOnError = !0), this);
    }
    setHeader(r, s) {
      return (
        (this.headers = new Headers(this.headers)),
        this.headers.set(r, s),
        this
      );
    }
    then(r, s) {
      (this.schema === void 0 ||
        (['GET', 'HEAD'].includes(this.method)
          ? this.headers.set('Accept-Profile', this.schema)
          : this.headers.set('Content-Profile', this.schema)),
        this.method !== 'GET' &&
          this.method !== 'HEAD' &&
          this.headers.set('Content-Type', 'application/json'));
      const a = this.fetch;
      let o = a(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal,
      }).then(async (l) => {
        var c, u, h, d;
        let f = null,
          p = null,
          m = null,
          g = l.status,
          v = l.statusText;
        if (l.ok) {
          if (this.method !== 'HEAD') {
            const S = await l.text();
            S === '' ||
              (this.headers.get('Accept') === 'text/csv' ||
              (this.headers.get('Accept') &&
                !((c = this.headers.get('Accept')) === null || c === void 0) &&
                c.includes('application/vnd.pgrst.plan+text'))
                ? (p = S)
                : (p = JSON.parse(S)));
          }
          const _ =
              (u = this.headers.get('Prefer')) === null || u === void 0
                ? void 0
                : u.match(/count=(exact|planned|estimated)/),
            x =
              (h = l.headers.get('content-range')) === null || h === void 0
                ? void 0
                : h.split('/');
          (_ && x && x.length > 1 && (m = parseInt(x[1])),
            this.isMaybeSingle &&
              this.method === 'GET' &&
              Array.isArray(p) &&
              (p.length > 1
                ? ((f = {
                    code: 'PGRST116',
                    details: `Results contain ${p.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message:
                      'JSON object requested, multiple (or no) rows returned',
                  }),
                  (p = null),
                  (m = null),
                  (g = 406),
                  (v = 'Not Acceptable'))
                : p.length === 1
                  ? (p = p[0])
                  : (p = null)));
        } else {
          const _ = await l.text();
          try {
            ((f = JSON.parse(_)),
              Array.isArray(f) &&
                l.status === 404 &&
                ((p = []), (f = null), (g = 200), (v = 'OK')));
          } catch {
            l.status === 404 && _ === ''
              ? ((g = 204), (v = 'No Content'))
              : (f = { message: _ });
          }
          if (
            (f &&
              this.isMaybeSingle &&
              !((d = f?.details) === null || d === void 0) &&
              d.includes('0 rows') &&
              ((f = null), (g = 200), (v = 'OK')),
            f && this.shouldThrowOnError)
          )
            throw new e.default(f);
        }
        return { error: f, data: p, count: m, status: g, statusText: v };
      });
      return (
        this.shouldThrowOnError ||
          (o = o.catch((l) => {
            var c, u, h;
            return {
              error: {
                message: `${(c = l?.name) !== null && c !== void 0 ? c : 'FetchError'}: ${l?.message}`,
                details: `${(u = l?.stack) !== null && u !== void 0 ? u : ''}`,
                hint: '',
                code: `${(h = l?.code) !== null && h !== void 0 ? h : ''}`,
              },
              data: null,
              count: null,
              status: 0,
              statusText: '',
            };
          })),
        o.then(r, s)
      );
    }
    returns() {
      return this;
    }
    overrideTypes() {
      return this;
    }
  }
  return ((hd.default = t), hd);
}
var gE;
function LI() {
  if (gE) return ud;
  ((gE = 1), Object.defineProperty(ud, '__esModule', { value: !0 }));
  const e = gc.__importDefault(OI());
  class t extends e.default {
    select(r) {
      let s = !1;
      const a = (r ?? '*')
        .split('')
        .map((o) => (/\s/.test(o) && !s ? '' : (o === '"' && (s = !s), o)))
        .join('');
      return (
        this.url.searchParams.set('select', a),
        this.headers.append('Prefer', 'return=representation'),
        this
      );
    }
    order(
      r,
      {
        ascending: s = !0,
        nullsFirst: a,
        foreignTable: o,
        referencedTable: l = o,
      } = {}
    ) {
      const c = l ? `${l}.order` : 'order',
        u = this.url.searchParams.get(c);
      return (
        this.url.searchParams.set(
          c,
          `${u ? `${u},` : ''}${r}.${s ? 'asc' : 'desc'}${a === void 0 ? '' : a ? '.nullsfirst' : '.nullslast'}`
        ),
        this
      );
    }
    limit(r, { foreignTable: s, referencedTable: a = s } = {}) {
      const o = typeof a > 'u' ? 'limit' : `${a}.limit`;
      return (this.url.searchParams.set(o, `${r}`), this);
    }
    range(r, s, { foreignTable: a, referencedTable: o = a } = {}) {
      const l = typeof o > 'u' ? 'offset' : `${o}.offset`,
        c = typeof o > 'u' ? 'limit' : `${o}.limit`;
      return (
        this.url.searchParams.set(l, `${r}`),
        this.url.searchParams.set(c, `${s - r + 1}`),
        this
      );
    }
    abortSignal(r) {
      return ((this.signal = r), this);
    }
    single() {
      return (
        this.headers.set('Accept', 'application/vnd.pgrst.object+json'),
        this
      );
    }
    maybeSingle() {
      return (
        this.method === 'GET'
          ? this.headers.set('Accept', 'application/json')
          : this.headers.set('Accept', 'application/vnd.pgrst.object+json'),
        (this.isMaybeSingle = !0),
        this
      );
    }
    csv() {
      return (this.headers.set('Accept', 'text/csv'), this);
    }
    geojson() {
      return (this.headers.set('Accept', 'application/geo+json'), this);
    }
    explain({
      analyze: r = !1,
      verbose: s = !1,
      settings: a = !1,
      buffers: o = !1,
      wal: l = !1,
      format: c = 'text',
    } = {}) {
      var u;
      const h = [
          r ? 'analyze' : null,
          s ? 'verbose' : null,
          a ? 'settings' : null,
          o ? 'buffers' : null,
          l ? 'wal' : null,
        ]
          .filter(Boolean)
          .join('|'),
        d =
          (u = this.headers.get('Accept')) !== null && u !== void 0
            ? u
            : 'application/json';
      return (
        this.headers.set(
          'Accept',
          `application/vnd.pgrst.plan+${c}; for="${d}"; options=${h};`
        ),
        c === 'json' ? this : this
      );
    }
    rollback() {
      return (this.headers.append('Prefer', 'tx=rollback'), this);
    }
    returns() {
      return this;
    }
    maxAffected(r) {
      return (
        this.headers.append('Prefer', 'handling=strict'),
        this.headers.append('Prefer', `max-affected=${r}`),
        this
      );
    }
  }
  return ((ud.default = t), ud);
}
var vE;
function gx() {
  if (vE) return cd;
  ((vE = 1), Object.defineProperty(cd, '__esModule', { value: !0 }));
  const e = gc.__importDefault(LI()),
    t = new RegExp('[,()]');
  class i extends e.default {
    eq(s, a) {
      return (this.url.searchParams.append(s, `eq.${a}`), this);
    }
    neq(s, a) {
      return (this.url.searchParams.append(s, `neq.${a}`), this);
    }
    gt(s, a) {
      return (this.url.searchParams.append(s, `gt.${a}`), this);
    }
    gte(s, a) {
      return (this.url.searchParams.append(s, `gte.${a}`), this);
    }
    lt(s, a) {
      return (this.url.searchParams.append(s, `lt.${a}`), this);
    }
    lte(s, a) {
      return (this.url.searchParams.append(s, `lte.${a}`), this);
    }
    like(s, a) {
      return (this.url.searchParams.append(s, `like.${a}`), this);
    }
    likeAllOf(s, a) {
      return (
        this.url.searchParams.append(s, `like(all).{${a.join(',')}}`),
        this
      );
    }
    likeAnyOf(s, a) {
      return (
        this.url.searchParams.append(s, `like(any).{${a.join(',')}}`),
        this
      );
    }
    ilike(s, a) {
      return (this.url.searchParams.append(s, `ilike.${a}`), this);
    }
    ilikeAllOf(s, a) {
      return (
        this.url.searchParams.append(s, `ilike(all).{${a.join(',')}}`),
        this
      );
    }
    ilikeAnyOf(s, a) {
      return (
        this.url.searchParams.append(s, `ilike(any).{${a.join(',')}}`),
        this
      );
    }
    is(s, a) {
      return (this.url.searchParams.append(s, `is.${a}`), this);
    }
    in(s, a) {
      const o = Array.from(new Set(a))
        .map((l) => (typeof l == 'string' && t.test(l) ? `"${l}"` : `${l}`))
        .join(',');
      return (this.url.searchParams.append(s, `in.(${o})`), this);
    }
    contains(s, a) {
      return (
        typeof a == 'string'
          ? this.url.searchParams.append(s, `cs.${a}`)
          : Array.isArray(a)
            ? this.url.searchParams.append(s, `cs.{${a.join(',')}}`)
            : this.url.searchParams.append(s, `cs.${JSON.stringify(a)}`),
        this
      );
    }
    containedBy(s, a) {
      return (
        typeof a == 'string'
          ? this.url.searchParams.append(s, `cd.${a}`)
          : Array.isArray(a)
            ? this.url.searchParams.append(s, `cd.{${a.join(',')}}`)
            : this.url.searchParams.append(s, `cd.${JSON.stringify(a)}`),
        this
      );
    }
    rangeGt(s, a) {
      return (this.url.searchParams.append(s, `sr.${a}`), this);
    }
    rangeGte(s, a) {
      return (this.url.searchParams.append(s, `nxl.${a}`), this);
    }
    rangeLt(s, a) {
      return (this.url.searchParams.append(s, `sl.${a}`), this);
    }
    rangeLte(s, a) {
      return (this.url.searchParams.append(s, `nxr.${a}`), this);
    }
    rangeAdjacent(s, a) {
      return (this.url.searchParams.append(s, `adj.${a}`), this);
    }
    overlaps(s, a) {
      return (
        typeof a == 'string'
          ? this.url.searchParams.append(s, `ov.${a}`)
          : this.url.searchParams.append(s, `ov.{${a.join(',')}}`),
        this
      );
    }
    textSearch(s, a, { config: o, type: l } = {}) {
      let c = '';
      l === 'plain'
        ? (c = 'pl')
        : l === 'phrase'
          ? (c = 'ph')
          : l === 'websearch' && (c = 'w');
      const u = o === void 0 ? '' : `(${o})`;
      return (this.url.searchParams.append(s, `${c}fts${u}.${a}`), this);
    }
    match(s) {
      return (
        Object.entries(s).forEach(([a, o]) => {
          this.url.searchParams.append(a, `eq.${o}`);
        }),
        this
      );
    }
    not(s, a, o) {
      return (this.url.searchParams.append(s, `not.${a}.${o}`), this);
    }
    or(s, { foreignTable: a, referencedTable: o = a } = {}) {
      const l = o ? `${o}.or` : 'or';
      return (this.url.searchParams.append(l, `(${s})`), this);
    }
    filter(s, a, o) {
      return (this.url.searchParams.append(s, `${a}.${o}`), this);
    }
  }
  return ((cd.default = i), cd);
}
var _E;
function UI() {
  if (_E) return ld;
  ((_E = 1), Object.defineProperty(ld, '__esModule', { value: !0 }));
  const e = gc.__importDefault(gx());
  class t {
    constructor(r, { headers: s = {}, schema: a, fetch: o }) {
      ((this.url = r),
        (this.headers = new Headers(s)),
        (this.schema = a),
        (this.fetch = o));
    }
    select(r, s) {
      const { head: a = !1, count: o } = s ?? {},
        l = a ? 'HEAD' : 'GET';
      let c = !1;
      const u = (r ?? '*')
        .split('')
        .map((h) => (/\s/.test(h) && !c ? '' : (h === '"' && (c = !c), h)))
        .join('');
      return (
        this.url.searchParams.set('select', u),
        o && this.headers.append('Prefer', `count=${o}`),
        new e.default({
          method: l,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
        })
      );
    }
    insert(r, { count: s, defaultToNull: a = !0 } = {}) {
      var o;
      const l = 'POST';
      if (
        (s && this.headers.append('Prefer', `count=${s}`),
        a || this.headers.append('Prefer', 'missing=default'),
        Array.isArray(r))
      ) {
        const c = r.reduce((u, h) => u.concat(Object.keys(h)), []);
        if (c.length > 0) {
          const u = [...new Set(c)].map((h) => `"${h}"`);
          this.url.searchParams.set('columns', u.join(','));
        }
      }
      return new e.default({
        method: l,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: r,
        fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch,
      });
    }
    upsert(
      r,
      {
        onConflict: s,
        ignoreDuplicates: a = !1,
        count: o,
        defaultToNull: l = !0,
      } = {}
    ) {
      var c;
      const u = 'POST';
      if (
        (this.headers.append(
          'Prefer',
          `resolution=${a ? 'ignore' : 'merge'}-duplicates`
        ),
        s !== void 0 && this.url.searchParams.set('on_conflict', s),
        o && this.headers.append('Prefer', `count=${o}`),
        l || this.headers.append('Prefer', 'missing=default'),
        Array.isArray(r))
      ) {
        const h = r.reduce((d, f) => d.concat(Object.keys(f)), []);
        if (h.length > 0) {
          const d = [...new Set(h)].map((f) => `"${f}"`);
          this.url.searchParams.set('columns', d.join(','));
        }
      }
      return new e.default({
        method: u,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: r,
        fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch,
      });
    }
    update(r, { count: s } = {}) {
      var a;
      const o = 'PATCH';
      return (
        s && this.headers.append('Prefer', `count=${s}`),
        new e.default({
          method: o,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: r,
          fetch: (a = this.fetch) !== null && a !== void 0 ? a : fetch,
        })
      );
    }
    delete({ count: r } = {}) {
      var s;
      const a = 'DELETE';
      return (
        r && this.headers.append('Prefer', `count=${r}`),
        new e.default({
          method: a,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: (s = this.fetch) !== null && s !== void 0 ? s : fetch,
        })
      );
    }
  }
  return ((ld.default = t), ld);
}
var yE;
function iz() {
  if (yE) return od;
  ((yE = 1), Object.defineProperty(od, '__esModule', { value: !0 }));
  const n = gc,
    e = n.__importDefault(UI()),
    t = n.__importDefault(gx());
  class i {
    constructor(s, { headers: a = {}, schema: o, fetch: l } = {}) {
      ((this.url = s),
        (this.headers = new Headers(a)),
        (this.schemaName = o),
        (this.fetch = l));
    }
    from(s) {
      const a = new URL(`${this.url}/${s}`);
      return new e.default(a, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch,
      });
    }
    schema(s) {
      return new i(this.url, {
        headers: this.headers,
        schema: s,
        fetch: this.fetch,
      });
    }
    rpc(s, a = {}, { head: o = !1, get: l = !1, count: c } = {}) {
      var u;
      let h;
      const d = new URL(`${this.url}/rpc/${s}`);
      let f;
      o || l
        ? ((h = o ? 'HEAD' : 'GET'),
          Object.entries(a)
            .filter(([m, g]) => g !== void 0)
            .map(([m, g]) => [
              m,
              Array.isArray(g) ? `{${g.join(',')}}` : `${g}`,
            ])
            .forEach(([m, g]) => {
              d.searchParams.append(m, g);
            }))
        : ((h = 'POST'), (f = a));
      const p = new Headers(this.headers);
      return (
        c && p.set('Prefer', `count=${c}`),
        new t.default({
          method: h,
          url: d,
          headers: p,
          schema: this.schemaName,
          body: f,
          fetch: (u = this.fetch) !== null && u !== void 0 ? u : fetch,
        })
      );
    }
  }
  return ((od.default = i), od);
}
var xE;
function rz() {
  if (xE) return Kn;
  ((xE = 1),
    Object.defineProperty(Kn, '__esModule', { value: !0 }),
    (Kn.PostgrestError =
      Kn.PostgrestBuilder =
      Kn.PostgrestTransformBuilder =
      Kn.PostgrestFilterBuilder =
      Kn.PostgrestQueryBuilder =
      Kn.PostgrestClient =
        void 0));
  const n = gc,
    e = n.__importDefault(iz());
  Kn.PostgrestClient = e.default;
  const t = n.__importDefault(UI());
  Kn.PostgrestQueryBuilder = t.default;
  const i = n.__importDefault(gx());
  Kn.PostgrestFilterBuilder = i.default;
  const r = n.__importDefault(LI());
  Kn.PostgrestTransformBuilder = r.default;
  const s = n.__importDefault(OI());
  Kn.PostgrestBuilder = s.default;
  const a = n.__importDefault(DI());
  return (
    (Kn.PostgrestError = a.default),
    (Kn.default = {
      PostgrestClient: e.default,
      PostgrestQueryBuilder: t.default,
      PostgrestFilterBuilder: i.default,
      PostgrestTransformBuilder: r.default,
      PostgrestBuilder: s.default,
      PostgrestError: a.default,
    }),
    Kn
  );
}
var kI = rz();
const BI = cy(kI),
  sz = eO({ __proto__: null, default: BI }, [kI]),
  {
    PostgrestClient: az,
    PostgrestQueryBuilder: Qte,
    PostgrestFilterBuilder: Zte,
    PostgrestTransformBuilder: $te,
    PostgrestBuilder: ene,
    PostgrestError: tne,
  } = BI || sz;
class oz {
  static detectEnvironment() {
    var e;
    if (typeof WebSocket < 'u')
      return { type: 'native', constructor: WebSocket };
    if (typeof globalThis < 'u' && typeof globalThis.WebSocket < 'u')
      return { type: 'native', constructor: globalThis.WebSocket };
    if (typeof global < 'u' && typeof global.WebSocket < 'u')
      return { type: 'native', constructor: global.WebSocket };
    if (
      typeof globalThis < 'u' &&
      typeof globalThis.WebSocketPair < 'u' &&
      typeof globalThis.WebSocket > 'u'
    )
      return {
        type: 'cloudflare',
        error:
          'Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.',
        workaround:
          'Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.',
      };
    if (
      (typeof globalThis < 'u' && globalThis.EdgeRuntime) ||
      (typeof navigator < 'u' &&
        !((e = navigator.userAgent) === null || e === void 0) &&
        e.includes('Vercel-Edge'))
    )
      return {
        type: 'unsupported',
        error:
          'Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.',
        workaround:
          'Use serverless functions or a different deployment target for WebSocket functionality.',
      };
    if (typeof process < 'u') {
      const t = process.versions;
      if (t && t.node) {
        const i = t.node,
          r = parseInt(i.replace(/^v/, '').split('.')[0]);
        return r >= 22
          ? typeof globalThis.WebSocket < 'u'
            ? { type: 'native', constructor: globalThis.WebSocket }
            : {
                type: 'unsupported',
                error: `Node.js ${r} detected but native WebSocket not found.`,
                workaround:
                  'Provide a WebSocket implementation via the transport option.',
              }
          : {
              type: 'unsupported',
              error: `Node.js ${r} detected without native WebSocket support.`,
              workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`,
            };
      }
    }
    return {
      type: 'unsupported',
      error: 'Unknown JavaScript runtime without WebSocket support.',
      workaround:
        "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.",
    };
  }
  static getWebSocketConstructor() {
    const e = this.detectEnvironment();
    if (e.constructor) return e.constructor;
    let t = e.error || 'WebSocket not supported in this environment.';
    throw (
      e.workaround &&
        (t += `

Suggested solution: ${e.workaround}`),
      new Error(t)
    );
  }
  static createWebSocket(e, t) {
    const i = this.getWebSocketConstructor();
    return new i(e, t);
  }
  static isWebSocketSupported() {
    try {
      const e = this.detectEnvironment();
      return e.type === 'native' || e.type === 'ws';
    } catch {
      return !1;
    }
  }
}
const lz = '2.80.0',
  cz = `realtime-js/${lz}`,
  uz = '1.0.0',
  u_ = 1e4,
  hz = 1e3,
  dz = 100;
var Mu;
(function (n) {
  ((n[(n.connecting = 0)] = 'connecting'),
    (n[(n.open = 1)] = 'open'),
    (n[(n.closing = 2)] = 'closing'),
    (n[(n.closed = 3)] = 'closed'));
})(Mu || (Mu = {}));
var Dn;
(function (n) {
  ((n.closed = 'closed'),
    (n.errored = 'errored'),
    (n.joined = 'joined'),
    (n.joining = 'joining'),
    (n.leaving = 'leaving'));
})(Dn || (Dn = {}));
var xr;
(function (n) {
  ((n.close = 'phx_close'),
    (n.error = 'phx_error'),
    (n.join = 'phx_join'),
    (n.reply = 'phx_reply'),
    (n.leave = 'phx_leave'),
    (n.access_token = 'access_token'));
})(xr || (xr = {}));
var h_;
(function (n) {
  n.websocket = 'websocket';
})(h_ || (h_ = {}));
var no;
(function (n) {
  ((n.Connecting = 'connecting'),
    (n.Open = 'open'),
    (n.Closing = 'closing'),
    (n.Closed = 'closed'));
})(no || (no = {}));
class fz {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(e, t) {
    return e.constructor === ArrayBuffer
      ? t(this._binaryDecode(e))
      : t(typeof e == 'string' ? JSON.parse(e) : {});
  }
  _binaryDecode(e) {
    const t = new DataView(e),
      i = new TextDecoder();
    return this._decodeBroadcast(e, t, i);
  }
  _decodeBroadcast(e, t, i) {
    const r = t.getUint8(1),
      s = t.getUint8(2);
    let a = this.HEADER_LENGTH + 2;
    const o = i.decode(e.slice(a, a + r));
    a = a + r;
    const l = i.decode(e.slice(a, a + s));
    a = a + s;
    const c = JSON.parse(i.decode(e.slice(a, e.byteLength)));
    return { ref: null, topic: o, event: l, payload: c };
  }
}
let NI = class {
  constructor(e, t) {
    ((this.callback = e),
      (this.timerCalc = t),
      (this.timer = void 0),
      (this.tries = 0),
      (this.callback = e),
      (this.timerCalc = t));
  }
  reset() {
    ((this.tries = 0), clearTimeout(this.timer), (this.timer = void 0));
  }
  scheduleTimeout() {
    (clearTimeout(this.timer),
      (this.timer = setTimeout(
        () => {
          ((this.tries = this.tries + 1), this.callback());
        },
        this.timerCalc(this.tries + 1)
      )));
  }
};
var en;
(function (n) {
  ((n.abstime = 'abstime'),
    (n.bool = 'bool'),
    (n.date = 'date'),
    (n.daterange = 'daterange'),
    (n.float4 = 'float4'),
    (n.float8 = 'float8'),
    (n.int2 = 'int2'),
    (n.int4 = 'int4'),
    (n.int4range = 'int4range'),
    (n.int8 = 'int8'),
    (n.int8range = 'int8range'),
    (n.json = 'json'),
    (n.jsonb = 'jsonb'),
    (n.money = 'money'),
    (n.numeric = 'numeric'),
    (n.oid = 'oid'),
    (n.reltime = 'reltime'),
    (n.text = 'text'),
    (n.time = 'time'),
    (n.timestamp = 'timestamp'),
    (n.timestamptz = 'timestamptz'),
    (n.timetz = 'timetz'),
    (n.tsrange = 'tsrange'),
    (n.tstzrange = 'tstzrange'));
})(en || (en = {}));
const bE = (n, e, t = {}) => {
    var i;
    const r = (i = t.skipTypes) !== null && i !== void 0 ? i : [];
    return e
      ? Object.keys(e).reduce((s, a) => ((s[a] = pz(a, n, e, r)), s), {})
      : {};
  },
  pz = (n, e, t, i) => {
    const r = e.find((o) => o.name === n),
      s = r?.type,
      a = t[n];
    return s && !i.includes(s) ? FI(s, a) : d_(a);
  },
  FI = (n, e) => {
    if (n.charAt(0) === '_') {
      const t = n.slice(1, n.length);
      return _z(e, t);
    }
    switch (n) {
      case en.bool:
        return mz(e);
      case en.float4:
      case en.float8:
      case en.int2:
      case en.int4:
      case en.int8:
      case en.numeric:
      case en.oid:
        return gz(e);
      case en.json:
      case en.jsonb:
        return vz(e);
      case en.timestamp:
        return yz(e);
      case en.abstime:
      case en.date:
      case en.daterange:
      case en.int4range:
      case en.int8range:
      case en.money:
      case en.reltime:
      case en.text:
      case en.time:
      case en.timestamptz:
      case en.timetz:
      case en.tsrange:
      case en.tstzrange:
        return d_(e);
      default:
        return d_(e);
    }
  },
  d_ = (n) => n,
  mz = (n) => {
    switch (n) {
      case 't':
        return !0;
      case 'f':
        return !1;
      default:
        return n;
    }
  },
  gz = (n) => {
    if (typeof n == 'string') {
      const e = parseFloat(n);
      if (!Number.isNaN(e)) return e;
    }
    return n;
  },
  vz = (n) => {
    if (typeof n == 'string')
      try {
        return JSON.parse(n);
      } catch (e) {
        return (console.log(`JSON parse error: ${e}`), n);
      }
    return n;
  },
  _z = (n, e) => {
    if (typeof n != 'string') return n;
    const t = n.length - 1,
      i = n[t];
    if (n[0] === '{' && i === '}') {
      let s;
      const a = n.slice(1, t);
      try {
        s = JSON.parse('[' + a + ']');
      } catch {
        s = a ? a.split(',') : [];
      }
      return s.map((o) => FI(e, o));
    }
    return n;
  },
  yz = (n) => (typeof n == 'string' ? n.replace(' ', 'T') : n),
  zI = (n) => {
    const e = new URL(n);
    return (
      (e.protocol = e.protocol.replace(/^ws/i, 'http')),
      (e.pathname = e.pathname
        .replace(/\/+$/, '')
        .replace(/\/socket\/websocket$/i, '')
        .replace(/\/socket$/i, '')
        .replace(/\/websocket$/i, '')),
      e.pathname === '' || e.pathname === '/'
        ? (e.pathname = '/api/broadcast')
        : (e.pathname = e.pathname + '/api/broadcast'),
      e.href
    );
  };
class qg {
  constructor(e, t, i = {}, r = u_) {
    ((this.channel = e),
      (this.event = t),
      (this.payload = i),
      (this.timeout = r),
      (this.sent = !1),
      (this.timeoutTimer = void 0),
      (this.ref = ''),
      (this.receivedResp = null),
      (this.recHooks = []),
      (this.refEvent = null));
  }
  resend(e) {
    ((this.timeout = e),
      this._cancelRefEvent(),
      (this.ref = ''),
      (this.refEvent = null),
      (this.receivedResp = null),
      (this.sent = !1),
      this.send());
  }
  send() {
    this._hasReceived('timeout') ||
      (this.startTimeout(),
      (this.sent = !0),
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef(),
      }));
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e);
  }
  receive(e, t) {
    var i;
    return (
      this._hasReceived(e) &&
        t(
          (i = this.receivedResp) === null || i === void 0 ? void 0 : i.response
        ),
      this.recHooks.push({ status: e, callback: t }),
      this
    );
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    ((this.ref = this.channel.socket._makeRef()),
      (this.refEvent = this.channel._replyEventName(this.ref)));
    const e = (t) => {
      (this._cancelRefEvent(),
        this._cancelTimeout(),
        (this.receivedResp = t),
        this._matchReceive(t));
    };
    (this.channel._on(this.refEvent, {}, e),
      (this.timeoutTimer = setTimeout(() => {
        this.trigger('timeout', {});
      }, this.timeout)));
  }
  trigger(e, t) {
    this.refEvent &&
      this.channel._trigger(this.refEvent, { status: e, response: t });
  }
  destroy() {
    (this._cancelRefEvent(), this._cancelTimeout());
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    (clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0));
  }
  _matchReceive({ status: e, response: t }) {
    this.recHooks.filter((i) => i.status === e).forEach((i) => i.callback(t));
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
}
var SE;
(function (n) {
  ((n.SYNC = 'sync'), (n.JOIN = 'join'), (n.LEAVE = 'leave'));
})(SE || (SE = {}));
class Tu {
  constructor(e, t) {
    ((this.channel = e),
      (this.state = {}),
      (this.pendingDiffs = []),
      (this.joinRef = null),
      (this.enabled = !1),
      (this.caller = {
        onJoin: () => {},
        onLeave: () => {},
        onSync: () => {},
      }));
    const i = t?.events || { state: 'presence_state', diff: 'presence_diff' };
    (this.channel._on(i.state, {}, (r) => {
      const { onJoin: s, onLeave: a, onSync: o } = this.caller;
      ((this.joinRef = this.channel._joinRef()),
        (this.state = Tu.syncState(this.state, r, s, a)),
        this.pendingDiffs.forEach((l) => {
          this.state = Tu.syncDiff(this.state, l, s, a);
        }),
        (this.pendingDiffs = []),
        o());
    }),
      this.channel._on(i.diff, {}, (r) => {
        const { onJoin: s, onLeave: a, onSync: o } = this.caller;
        this.inPendingSyncState()
          ? this.pendingDiffs.push(r)
          : ((this.state = Tu.syncDiff(this.state, r, s, a)), o());
      }),
      this.onJoin((r, s, a) => {
        this.channel._trigger('presence', {
          event: 'join',
          key: r,
          currentPresences: s,
          newPresences: a,
        });
      }),
      this.onLeave((r, s, a) => {
        this.channel._trigger('presence', {
          event: 'leave',
          key: r,
          currentPresences: s,
          leftPresences: a,
        });
      }),
      this.onSync(() => {
        this.channel._trigger('presence', { event: 'sync' });
      }));
  }
  static syncState(e, t, i, r) {
    const s = this.cloneDeep(e),
      a = this.transformState(t),
      o = {},
      l = {};
    return (
      this.map(s, (c, u) => {
        a[c] || (l[c] = u);
      }),
      this.map(a, (c, u) => {
        const h = s[c];
        if (h) {
          const d = u.map((g) => g.presence_ref),
            f = h.map((g) => g.presence_ref),
            p = u.filter((g) => f.indexOf(g.presence_ref) < 0),
            m = h.filter((g) => d.indexOf(g.presence_ref) < 0);
          (p.length > 0 && (o[c] = p), m.length > 0 && (l[c] = m));
        } else o[c] = u;
      }),
      this.syncDiff(s, { joins: o, leaves: l }, i, r)
    );
  }
  static syncDiff(e, t, i, r) {
    const { joins: s, leaves: a } = {
      joins: this.transformState(t.joins),
      leaves: this.transformState(t.leaves),
    };
    return (
      i || (i = () => {}),
      r || (r = () => {}),
      this.map(s, (o, l) => {
        var c;
        const u = (c = e[o]) !== null && c !== void 0 ? c : [];
        if (((e[o] = this.cloneDeep(l)), u.length > 0)) {
          const h = e[o].map((f) => f.presence_ref),
            d = u.filter((f) => h.indexOf(f.presence_ref) < 0);
          e[o].unshift(...d);
        }
        i(o, u, l);
      }),
      this.map(a, (o, l) => {
        let c = e[o];
        if (!c) return;
        const u = l.map((h) => h.presence_ref);
        ((c = c.filter((h) => u.indexOf(h.presence_ref) < 0)),
          (e[o] = c),
          r(o, c, l),
          c.length === 0 && delete e[o]);
      }),
      e
    );
  }
  static map(e, t) {
    return Object.getOwnPropertyNames(e).map((i) => t(i, e[i]));
  }
  static transformState(e) {
    return (
      (e = this.cloneDeep(e)),
      Object.getOwnPropertyNames(e).reduce((t, i) => {
        const r = e[i];
        return (
          'metas' in r
            ? (t[i] = r.metas.map(
                (s) => (
                  (s.presence_ref = s.phx_ref),
                  delete s.phx_ref,
                  delete s.phx_ref_prev,
                  s
                )
              ))
            : (t[i] = r),
          t
        );
      }, {})
    );
  }
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e));
  }
  onJoin(e) {
    this.caller.onJoin = e;
  }
  onLeave(e) {
    this.caller.onLeave = e;
  }
  onSync(e) {
    this.caller.onSync = e;
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var wE;
(function (n) {
  ((n.ALL = '*'),
    (n.INSERT = 'INSERT'),
    (n.UPDATE = 'UPDATE'),
    (n.DELETE = 'DELETE'));
})(wE || (wE = {}));
var Cu;
(function (n) {
  ((n.BROADCAST = 'broadcast'),
    (n.PRESENCE = 'presence'),
    (n.POSTGRES_CHANGES = 'postgres_changes'),
    (n.SYSTEM = 'system'));
})(Cu || (Cu = {}));
var ss;
(function (n) {
  ((n.SUBSCRIBED = 'SUBSCRIBED'),
    (n.TIMED_OUT = 'TIMED_OUT'),
    (n.CLOSED = 'CLOSED'),
    (n.CHANNEL_ERROR = 'CHANNEL_ERROR'));
})(ss || (ss = {}));
class vx {
  constructor(e, t = { config: {} }, i) {
    var r, s;
    if (
      ((this.topic = e),
      (this.params = t),
      (this.socket = i),
      (this.bindings = {}),
      (this.state = Dn.closed),
      (this.joinedOnce = !1),
      (this.pushBuffer = []),
      (this.subTopic = e.replace(/^realtime:/i, '')),
      (this.params.config = Object.assign(
        {
          broadcast: { ack: !1, self: !1 },
          presence: { key: '', enabled: !1 },
          private: !1,
        },
        t.config
      )),
      (this.timeout = this.socket.timeout),
      (this.joinPush = new qg(this, xr.join, this.params, this.timeout)),
      (this.rejoinTimer = new NI(
        () => this._rejoinUntilConnected(),
        this.socket.reconnectAfterMs
      )),
      this.joinPush.receive('ok', () => {
        ((this.state = Dn.joined),
          this.rejoinTimer.reset(),
          this.pushBuffer.forEach((a) => a.send()),
          (this.pushBuffer = []));
      }),
      this._onClose(() => {
        (this.rejoinTimer.reset(),
          this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`),
          (this.state = Dn.closed),
          this.socket._remove(this));
      }),
      this._onError((a) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log('channel', `error ${this.topic}`, a),
          (this.state = Dn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive('timeout', () => {
        this._isJoining() &&
          (this.socket.log(
            'channel',
            `timeout ${this.topic}`,
            this.joinPush.timeout
          ),
          (this.state = Dn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive('error', (a) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log('channel', `error ${this.topic}`, a),
          (this.state = Dn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this._on(xr.reply, {}, (a, o) => {
        this._trigger(this._replyEventName(o), a);
      }),
      (this.presence = new Tu(this)),
      (this.broadcastEndpointURL = zI(this.socket.endPoint)),
      (this.private = this.params.config.private || !1),
      !this.private &&
        !(
          (s =
            (r = this.params.config) === null || r === void 0
              ? void 0
              : r.broadcast) === null || s === void 0
        ) &&
        s.replay)
    )
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
  }
  subscribe(e, t = this.timeout) {
    var i, r, s;
    if (
      (this.socket.isConnected() || this.socket.connect(),
      this.state == Dn.closed)
    ) {
      const {
          config: { broadcast: a, presence: o, private: l },
        } = this.params,
        c =
          (r =
            (i = this.bindings.postgres_changes) === null || i === void 0
              ? void 0
              : i.map((f) => f.filter)) !== null && r !== void 0
            ? r
            : [],
        u =
          (!!this.bindings[Cu.PRESENCE] &&
            this.bindings[Cu.PRESENCE].length > 0) ||
          ((s = this.params.config.presence) === null || s === void 0
            ? void 0
            : s.enabled) === !0,
        h = {},
        d = {
          broadcast: a,
          presence: Object.assign(Object.assign({}, o), { enabled: u }),
          postgres_changes: c,
          private: l,
        };
      (this.socket.accessTokenValue &&
        (h.access_token = this.socket.accessTokenValue),
        this._onError((f) => e?.(ss.CHANNEL_ERROR, f)),
        this._onClose(() => e?.(ss.CLOSED)),
        this.updateJoinPayload(Object.assign({ config: d }, h)),
        (this.joinedOnce = !0),
        this._rejoin(t),
        this.joinPush
          .receive('ok', async ({ postgres_changes: f }) => {
            var p;
            if ((this.socket.setAuth(), f === void 0)) {
              e?.(ss.SUBSCRIBED);
              return;
            } else {
              const m = this.bindings.postgres_changes,
                g = (p = m?.length) !== null && p !== void 0 ? p : 0,
                v = [];
              for (let y = 0; y < g; y++) {
                const _ = m[y],
                  {
                    filter: { event: x, schema: S, table: b, filter: A },
                  } = _,
                  E = f && f[y];
                if (
                  E &&
                  E.event === x &&
                  E.schema === S &&
                  E.table === b &&
                  E.filter === A
                )
                  v.push(Object.assign(Object.assign({}, _), { id: E.id }));
                else {
                  (this.unsubscribe(),
                    (this.state = Dn.errored),
                    e?.(
                      ss.CHANNEL_ERROR,
                      new Error(
                        'mismatch between server and client bindings for postgres changes'
                      )
                    ));
                  return;
                }
              }
              ((this.bindings.postgres_changes = v), e && e(ss.SUBSCRIBED));
              return;
            }
          })
          .receive('error', (f) => {
            ((this.state = Dn.errored),
              e?.(
                ss.CHANNEL_ERROR,
                new Error(
                  JSON.stringify(Object.values(f).join(', ') || 'error')
                )
              ));
          })
          .receive('timeout', () => {
            e?.(ss.TIMED_OUT);
          }));
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(e, t = {}) {
    return await this.send(
      { type: 'presence', event: 'track', payload: e },
      t.timeout || this.timeout
    );
  }
  async untrack(e = {}) {
    return await this.send({ type: 'presence', event: 'untrack' }, e);
  }
  on(e, t, i) {
    return (
      this.state === Dn.joined &&
        e === Cu.PRESENCE &&
        (this.socket.log(
          'channel',
          `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`
        ),
        this.unsubscribe().then(() => this.subscribe())),
      this._on(e, t, i)
    );
  }
  async httpSend(e, t, i = {}) {
    var r;
    const s = this.socket.accessTokenValue
      ? `Bearer ${this.socket.accessTokenValue}`
      : '';
    if (t == null) return Promise.reject('Payload is required for httpSend()');
    const a = {
        method: 'POST',
        headers: {
          Authorization: s,
          apikey: this.socket.apiKey ? this.socket.apiKey : '',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event: e,
              payload: t,
              private: this.private,
            },
          ],
        }),
      },
      o = await this._fetchWithTimeout(
        this.broadcastEndpointURL,
        a,
        (r = i.timeout) !== null && r !== void 0 ? r : this.timeout
      );
    if (o.status === 202) return { success: !0 };
    let l = o.statusText;
    try {
      const c = await o.json();
      l = c.error || c.message || l;
    } catch {}
    return Promise.reject(new Error(l));
  }
  async send(e, t = {}) {
    var i, r;
    if (!this._canPush() && e.type === 'broadcast') {
      console.warn(
        'Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.'
      );
      const { event: s, payload: a } = e,
        l = {
          method: 'POST',
          headers: {
            Authorization: this.socket.accessTokenValue
              ? `Bearer ${this.socket.accessTokenValue}`
              : '',
            apikey: this.socket.apiKey ? this.socket.apiKey : '',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event: s,
                payload: a,
                private: this.private,
              },
            ],
          }),
        };
      try {
        const c = await this._fetchWithTimeout(
          this.broadcastEndpointURL,
          l,
          (i = t.timeout) !== null && i !== void 0 ? i : this.timeout
        );
        return (
          await ((r = c.body) === null || r === void 0 ? void 0 : r.cancel()),
          c.ok ? 'ok' : 'error'
        );
      } catch (c) {
        return c.name === 'AbortError' ? 'timed out' : 'error';
      }
    } else
      return new Promise((s) => {
        var a, o, l;
        const c = this._push(e.type, e, t.timeout || this.timeout);
        (e.type === 'broadcast' &&
          !(
            !(
              (l =
                (o =
                  (a = this.params) === null || a === void 0
                    ? void 0
                    : a.config) === null || o === void 0
                  ? void 0
                  : o.broadcast) === null || l === void 0
            ) && l.ack
          ) &&
          s('ok'),
          c.receive('ok', () => s('ok')),
          c.receive('error', () => s('error')),
          c.receive('timeout', () => s('timed out')));
      });
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e);
  }
  unsubscribe(e = this.timeout) {
    this.state = Dn.leaving;
    const t = () => {
      (this.socket.log('channel', `leave ${this.topic}`),
        this._trigger(xr.close, 'leave', this._joinRef()));
    };
    this.joinPush.destroy();
    let i = null;
    return new Promise((r) => {
      ((i = new qg(this, xr.leave, {}, e)),
        i
          .receive('ok', () => {
            (t(), r('ok'));
          })
          .receive('timeout', () => {
            (t(), r('timed out'));
          })
          .receive('error', () => {
            r('error');
          }),
        i.send(),
        this._canPush() || i.trigger('ok', {}));
    }).finally(() => {
      i?.destroy();
    });
  }
  teardown() {
    (this.pushBuffer.forEach((e) => e.destroy()),
      (this.pushBuffer = []),
      this.rejoinTimer.reset(),
      this.joinPush.destroy(),
      (this.state = Dn.closed),
      (this.bindings = {}));
  }
  async _fetchWithTimeout(e, t, i) {
    const r = new AbortController(),
      s = setTimeout(() => r.abort(), i),
      a = await this.socket.fetch(
        e,
        Object.assign(Object.assign({}, t), { signal: r.signal })
      );
    return (clearTimeout(s), a);
  }
  _push(e, t, i = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let r = new qg(this, e, t, i);
    return (this._canPush() ? r.send() : this._addToPushBuffer(r), r);
  }
  _addToPushBuffer(e) {
    if (
      (e.startTimeout(), this.pushBuffer.push(e), this.pushBuffer.length > dz)
    ) {
      const t = this.pushBuffer.shift();
      t &&
        (t.destroy(),
        this.socket.log(
          'channel',
          `discarded push due to buffer overflow: ${t.event}`,
          t.payload
        ));
    }
  }
  _onMessage(e, t, i) {
    return t;
  }
  _isMember(e) {
    return this.topic === e;
  }
  _joinRef() {
    return this.joinPush.ref;
  }
  _trigger(e, t, i) {
    var r, s;
    const a = e.toLocaleLowerCase(),
      { close: o, error: l, leave: c, join: u } = xr;
    if (i && [o, l, c, u].indexOf(a) >= 0 && i !== this._joinRef()) return;
    let d = this._onMessage(a, t, i);
    if (t && !d)
      throw 'channel onMessage callbacks must return the payload, modified or unmodified';
    ['insert', 'update', 'delete'].includes(a)
      ? (r = this.bindings.postgres_changes) === null ||
        r === void 0 ||
        r
          .filter((f) => {
            var p, m, g;
            return (
              ((p = f.filter) === null || p === void 0 ? void 0 : p.event) ===
                '*' ||
              ((g =
                (m = f.filter) === null || m === void 0 ? void 0 : m.event) ===
                null || g === void 0
                ? void 0
                : g.toLocaleLowerCase()) === a
            );
          })
          .map((f) => f.callback(d, i))
      : (s = this.bindings[a]) === null ||
        s === void 0 ||
        s
          .filter((f) => {
            var p, m, g, v, y, _;
            if (['broadcast', 'presence', 'postgres_changes'].includes(a))
              if ('id' in f) {
                const x = f.id,
                  S =
                    (p = f.filter) === null || p === void 0 ? void 0 : p.event;
                return (
                  x &&
                  ((m = t.ids) === null || m === void 0
                    ? void 0
                    : m.includes(x)) &&
                  (S === '*' ||
                    S?.toLocaleLowerCase() ===
                      ((g = t.data) === null || g === void 0
                        ? void 0
                        : g.type.toLocaleLowerCase()))
                );
              } else {
                const x =
                  (y =
                    (v = f?.filter) === null || v === void 0
                      ? void 0
                      : v.event) === null || y === void 0
                    ? void 0
                    : y.toLocaleLowerCase();
                return (
                  x === '*' ||
                  x ===
                    ((_ = t?.event) === null || _ === void 0
                      ? void 0
                      : _.toLocaleLowerCase())
                );
              }
            else return f.type.toLocaleLowerCase() === a;
          })
          .map((f) => {
            if (typeof d == 'object' && 'ids' in d) {
              const p = d.data,
                {
                  schema: m,
                  table: g,
                  commit_timestamp: v,
                  type: y,
                  errors: _,
                } = p;
              d = Object.assign(
                Object.assign(
                  {},
                  {
                    schema: m,
                    table: g,
                    commit_timestamp: v,
                    eventType: y,
                    new: {},
                    old: {},
                    errors: _,
                  }
                ),
                this._getPayloadRecords(p)
              );
            }
            f.callback(d, i);
          });
  }
  _isClosed() {
    return this.state === Dn.closed;
  }
  _isJoined() {
    return this.state === Dn.joined;
  }
  _isJoining() {
    return this.state === Dn.joining;
  }
  _isLeaving() {
    return this.state === Dn.leaving;
  }
  _replyEventName(e) {
    return `chan_reply_${e}`;
  }
  _on(e, t, i) {
    const r = e.toLocaleLowerCase(),
      s = { type: r, filter: t, callback: i };
    return (
      this.bindings[r] ? this.bindings[r].push(s) : (this.bindings[r] = [s]),
      this
    );
  }
  _off(e, t) {
    const i = e.toLocaleLowerCase();
    return (
      this.bindings[i] &&
        (this.bindings[i] = this.bindings[i].filter((r) => {
          var s;
          return !(
            ((s = r.type) === null || s === void 0
              ? void 0
              : s.toLocaleLowerCase()) === i && vx.isEqual(r.filter, t)
          );
        })),
      this
    );
  }
  static isEqual(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const i in e) if (e[i] !== t[i]) return !1;
    return !0;
  }
  _rejoinUntilConnected() {
    (this.rejoinTimer.scheduleTimeout(),
      this.socket.isConnected() && this._rejoin());
  }
  _onClose(e) {
    this._on(xr.close, {}, e);
  }
  _onError(e) {
    this._on(xr.error, {}, (t) => e(t));
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  _rejoin(e = this.timeout) {
    this._isLeaving() ||
      (this.socket._leaveOpenTopic(this.topic),
      (this.state = Dn.joining),
      this.joinPush.resend(e));
  }
  _getPayloadRecords(e) {
    const t = { new: {}, old: {} };
    return (
      (e.type === 'INSERT' || e.type === 'UPDATE') &&
        (t.new = bE(e.columns, e.record)),
      (e.type === 'UPDATE' || e.type === 'DELETE') &&
        (t.old = bE(e.columns, e.old_record)),
      t
    );
  }
}
const Yg = () => {},
  fd = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100,
  },
  xz = [1e3, 2e3, 5e3, 1e4],
  bz = 1e4,
  Sz = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class wz {
  constructor(e, t) {
    var i;
    if (
      ((this.accessTokenValue = null),
      (this.apiKey = null),
      (this.channels = new Array()),
      (this.endPoint = ''),
      (this.httpEndpoint = ''),
      (this.headers = {}),
      (this.params = {}),
      (this.timeout = u_),
      (this.transport = null),
      (this.heartbeatIntervalMs = fd.HEARTBEAT_INTERVAL),
      (this.heartbeatTimer = void 0),
      (this.pendingHeartbeatRef = null),
      (this.heartbeatCallback = Yg),
      (this.ref = 0),
      (this.reconnectTimer = null),
      (this.logger = Yg),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.serializer = new fz()),
      (this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: [],
      }),
      (this.accessToken = null),
      (this._connectionState = 'disconnected'),
      (this._wasManualDisconnect = !1),
      (this._authPromise = null),
      (this._resolveFetch = (r) =>
        r ? (...s) => r(...s) : (...s) => fetch(...s)),
      !(!((i = t?.params) === null || i === void 0) && i.apikey))
    )
      throw new Error('API key is required to connect to Realtime');
    ((this.apiKey = t.params.apikey),
      (this.endPoint = `${e}/${h_.websocket}`),
      (this.httpEndpoint = zI(e)),
      this._initializeOptions(t),
      this._setupReconnectionTimer(),
      (this.fetch = this._resolveFetch(t?.fetch)));
  }
  connect() {
    if (
      !(
        this.isConnecting() ||
        this.isDisconnecting() ||
        (this.conn !== null && this.isConnected())
      )
    ) {
      if (
        (this._setConnectionState('connecting'),
        this._setAuthSafely('connect'),
        this.transport)
      )
        this.conn = new this.transport(this.endpointURL());
      else
        try {
          this.conn = oz.createWebSocket(this.endpointURL());
        } catch (e) {
          this._setConnectionState('disconnected');
          const t = e.message;
          throw t.includes('Node.js')
            ? new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`)
            : new Error(`WebSocket not available: ${t}`);
        }
      this._setupConnectionHandlers();
    }
  }
  endpointURL() {
    return this._appendParams(
      this.endPoint,
      Object.assign({}, this.params, { vsn: uz })
    );
  }
  disconnect(e, t) {
    if (!this.isDisconnecting())
      if ((this._setConnectionState('disconnecting', !0), this.conn)) {
        const i = setTimeout(() => {
          this._setConnectionState('disconnected');
        }, 100);
        ((this.conn.onclose = () => {
          (clearTimeout(i), this._setConnectionState('disconnected'));
        }),
          e ? this.conn.close(e, t ?? '') : this.conn.close(),
          this._teardownConnection());
      } else this._setConnectionState('disconnected');
  }
  getChannels() {
    return this.channels;
  }
  async removeChannel(e) {
    const t = await e.unsubscribe();
    return (this.channels.length === 0 && this.disconnect(), t);
  }
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map((t) => t.unsubscribe()));
    return ((this.channels = []), this.disconnect(), e);
  }
  log(e, t, i) {
    this.logger(e, t, i);
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case Mu.connecting:
        return no.Connecting;
      case Mu.open:
        return no.Open;
      case Mu.closing:
        return no.Closing;
      default:
        return no.Closed;
    }
  }
  isConnected() {
    return this.connectionState() === no.Open;
  }
  isConnecting() {
    return this._connectionState === 'connecting';
  }
  isDisconnecting() {
    return this._connectionState === 'disconnecting';
  }
  channel(e, t = { config: {} }) {
    const i = `realtime:${e}`,
      r = this.getChannels().find((s) => s.topic === i);
    if (r) return r;
    {
      const s = new vx(`realtime:${e}`, t, this);
      return (this.channels.push(s), s);
    }
  }
  push(e) {
    const { topic: t, event: i, payload: r, ref: s } = e,
      a = () => {
        this.encode(e, (o) => {
          var l;
          (l = this.conn) === null || l === void 0 || l.send(o);
        });
      };
    (this.log('push', `${t} ${i} (${s})`, r),
      this.isConnected() ? a() : this.sendBuffer.push(a));
  }
  async setAuth(e = null) {
    this._authPromise = this._performAuth(e);
    try {
      await this._authPromise;
    } finally {
      this._authPromise = null;
    }
  }
  async sendHeartbeat() {
    var e;
    if (!this.isConnected()) {
      try {
        this.heartbeatCallback('disconnected');
      } catch (t) {
        this.log('error', 'error in heartbeat callback', t);
      }
      return;
    }
    if (this.pendingHeartbeatRef) {
      ((this.pendingHeartbeatRef = null),
        this.log(
          'transport',
          'heartbeat timeout. Attempting to re-establish connection'
        ));
      try {
        this.heartbeatCallback('timeout');
      } catch (t) {
        this.log('error', 'error in heartbeat callback', t);
      }
      ((this._wasManualDisconnect = !1),
        (e = this.conn) === null ||
          e === void 0 ||
          e.close(hz, 'heartbeat timeout'),
        setTimeout(() => {
          var t;
          this.isConnected() ||
            (t = this.reconnectTimer) === null ||
            t === void 0 ||
            t.scheduleTimeout();
        }, fd.HEARTBEAT_TIMEOUT_FALLBACK));
      return;
    }
    ((this.pendingHeartbeatRef = this._makeRef()),
      this.push({
        topic: 'phoenix',
        event: 'heartbeat',
        payload: {},
        ref: this.pendingHeartbeatRef,
      }));
    try {
      this.heartbeatCallback('sent');
    } catch (t) {
      this.log('error', 'error in heartbeat callback', t);
    }
    this._setAuthSafely('heartbeat');
  }
  onHeartbeat(e) {
    this.heartbeatCallback = e;
  }
  flushSendBuffer() {
    this.isConnected() &&
      this.sendBuffer.length > 0 &&
      (this.sendBuffer.forEach((e) => e()), (this.sendBuffer = []));
  }
  _makeRef() {
    let e = this.ref + 1;
    return (
      e === this.ref ? (this.ref = 0) : (this.ref = e),
      this.ref.toString()
    );
  }
  _leaveOpenTopic(e) {
    let t = this.channels.find(
      (i) => i.topic === e && (i._isJoined() || i._isJoining())
    );
    t &&
      (this.log('transport', `leaving duplicate topic "${e}"`),
      t.unsubscribe());
  }
  _remove(e) {
    this.channels = this.channels.filter((t) => t.topic !== e.topic);
  }
  _onConnMessage(e) {
    this.decode(e.data, (t) => {
      if (t.topic === 'phoenix' && t.event === 'phx_reply')
        try {
          this.heartbeatCallback(t.payload.status === 'ok' ? 'ok' : 'error');
        } catch (c) {
          this.log('error', 'error in heartbeat callback', c);
        }
      t.ref &&
        t.ref === this.pendingHeartbeatRef &&
        (this.pendingHeartbeatRef = null);
      const { topic: i, event: r, payload: s, ref: a } = t,
        o = a ? `(${a})` : '',
        l = s.status || '';
      (this.log('receive', `${l} ${i} ${r} ${o}`.trim(), s),
        this.channels
          .filter((c) => c._isMember(i))
          .forEach((c) => c._trigger(r, s, a)),
        this._triggerStateCallbacks('message', t));
    });
  }
  _clearTimer(e) {
    var t;
    e === 'heartbeat' && this.heartbeatTimer
      ? (clearInterval(this.heartbeatTimer), (this.heartbeatTimer = void 0))
      : e === 'reconnect' &&
        ((t = this.reconnectTimer) === null || t === void 0 || t.reset());
  }
  _clearAllTimers() {
    (this._clearTimer('heartbeat'), this._clearTimer('reconnect'));
  }
  _setupConnectionHandlers() {
    this.conn &&
      ('binaryType' in this.conn && (this.conn.binaryType = 'arraybuffer'),
      (this.conn.onopen = () => this._onConnOpen()),
      (this.conn.onerror = (e) => this._onConnError(e)),
      (this.conn.onmessage = (e) => this._onConnMessage(e)),
      (this.conn.onclose = (e) => this._onConnClose(e)));
  }
  _teardownConnection() {
    (this.conn &&
      ((this.conn.onopen = null),
      (this.conn.onerror = null),
      (this.conn.onmessage = null),
      (this.conn.onclose = null),
      (this.conn = null)),
      this._clearAllTimers(),
      this.channels.forEach((e) => e.teardown()));
  }
  _onConnOpen() {
    (this._setConnectionState('connected'),
      this.log('transport', `connected to ${this.endpointURL()}`),
      this.flushSendBuffer(),
      this._clearTimer('reconnect'),
      this.worker
        ? this.workerRef || this._startWorkerHeartbeat()
        : this._startHeartbeat(),
      this._triggerStateCallbacks('open'));
  }
  _startHeartbeat() {
    (this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      (this.heartbeatTimer = setInterval(
        () => this.sendHeartbeat(),
        this.heartbeatIntervalMs
      )));
  }
  _startWorkerHeartbeat() {
    this.workerUrl
      ? this.log('worker', `starting worker for from ${this.workerUrl}`)
      : this.log('worker', 'starting default worker');
    const e = this._workerObjectUrl(this.workerUrl);
    ((this.workerRef = new Worker(e)),
      (this.workerRef.onerror = (t) => {
        (this.log('worker', 'worker error', t.message),
          this.workerRef.terminate());
      }),
      (this.workerRef.onmessage = (t) => {
        t.data.event === 'keepAlive' && this.sendHeartbeat();
      }),
      this.workerRef.postMessage({
        event: 'start',
        interval: this.heartbeatIntervalMs,
      }));
  }
  _onConnClose(e) {
    var t;
    (this._setConnectionState('disconnected'),
      this.log('transport', 'close', e),
      this._triggerChanError(),
      this._clearTimer('heartbeat'),
      this._wasManualDisconnect ||
        (t = this.reconnectTimer) === null ||
        t === void 0 ||
        t.scheduleTimeout(),
      this._triggerStateCallbacks('close', e));
  }
  _onConnError(e) {
    (this._setConnectionState('disconnected'),
      this.log('transport', `${e}`),
      this._triggerChanError(),
      this._triggerStateCallbacks('error', e));
  }
  _triggerChanError() {
    this.channels.forEach((e) => e._trigger(xr.error));
  }
  _appendParams(e, t) {
    if (Object.keys(t).length === 0) return e;
    const i = e.match(/\?/) ? '&' : '?',
      r = new URLSearchParams(t);
    return `${e}${i}${r}`;
  }
  _workerObjectUrl(e) {
    let t;
    if (e) t = e;
    else {
      const i = new Blob([Sz], { type: 'application/javascript' });
      t = URL.createObjectURL(i);
    }
    return t;
  }
  _setConnectionState(e, t = !1) {
    ((this._connectionState = e),
      e === 'connecting'
        ? (this._wasManualDisconnect = !1)
        : e === 'disconnecting' && (this._wasManualDisconnect = t));
  }
  async _performAuth(e = null) {
    let t;
    (e
      ? (t = e)
      : this.accessToken
        ? (t = await this.accessToken())
        : (t = this.accessTokenValue),
      this.accessTokenValue != t &&
        ((this.accessTokenValue = t),
        this.channels.forEach((i) => {
          const r = { access_token: t, version: cz };
          (t && i.updateJoinPayload(r),
            i.joinedOnce &&
              i._isJoined() &&
              i._push(xr.access_token, { access_token: t }));
        })));
  }
  async _waitForAuthIfNeeded() {
    this._authPromise && (await this._authPromise);
  }
  _setAuthSafely(e = 'general') {
    this.setAuth().catch((t) => {
      this.log('error', `error setting auth in ${e}`, t);
    });
  }
  _triggerStateCallbacks(e, t) {
    try {
      this.stateChangeCallbacks[e].forEach((i) => {
        try {
          i(t);
        } catch (r) {
          this.log('error', `error in ${e} callback`, r);
        }
      });
    } catch (i) {
      this.log('error', `error triggering ${e} callbacks`, i);
    }
  }
  _setupReconnectionTimer() {
    this.reconnectTimer = new NI(async () => {
      setTimeout(async () => {
        (await this._waitForAuthIfNeeded(),
          this.isConnected() || this.connect());
      }, fd.RECONNECT_DELAY);
    }, this.reconnectAfterMs);
  }
  _initializeOptions(e) {
    var t, i, r, s, a, o, l, c, u;
    if (
      ((this.transport =
        (t = e?.transport) !== null && t !== void 0 ? t : null),
      (this.timeout = (i = e?.timeout) !== null && i !== void 0 ? i : u_),
      (this.heartbeatIntervalMs =
        (r = e?.heartbeatIntervalMs) !== null && r !== void 0
          ? r
          : fd.HEARTBEAT_INTERVAL),
      (this.worker = (s = e?.worker) !== null && s !== void 0 ? s : !1),
      (this.accessToken =
        (a = e?.accessToken) !== null && a !== void 0 ? a : null),
      (this.heartbeatCallback =
        (o = e?.heartbeatCallback) !== null && o !== void 0 ? o : Yg),
      e?.params && (this.params = e.params),
      e?.logger && (this.logger = e.logger),
      (e?.logLevel || e?.log_level) &&
        ((this.logLevel = e.logLevel || e.log_level),
        (this.params = Object.assign(Object.assign({}, this.params), {
          log_level: this.logLevel,
        }))),
      (this.reconnectAfterMs =
        (l = e?.reconnectAfterMs) !== null && l !== void 0
          ? l
          : (h) => xz[h - 1] || bz),
      (this.encode =
        (c = e?.encode) !== null && c !== void 0
          ? c
          : (h, d) => d(JSON.stringify(h))),
      (this.decode =
        (u = e?.decode) !== null && u !== void 0
          ? u
          : this.serializer.decode.bind(this.serializer)),
      this.worker)
    ) {
      if (typeof window < 'u' && !window.Worker)
        throw new Error('Web Worker is not supported');
      this.workerUrl = e?.workerUrl;
    }
  }
}
class _x extends Error {
  constructor(e) {
    (super(e), (this.__isStorageError = !0), (this.name = 'StorageError'));
  }
}
function sn(n) {
  return typeof n == 'object' && n !== null && '__isStorageError' in n;
}
class Ez extends _x {
  constructor(e, t, i) {
    (super(e),
      (this.name = 'StorageApiError'),
      (this.status = t),
      (this.statusCode = i));
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode,
    };
  }
}
class f_ extends _x {
  constructor(e, t) {
    (super(e), (this.name = 'StorageUnknownError'), (this.originalError = t));
  }
}
const yx = (n) => (n ? (...e) => n(...e) : (...e) => fetch(...e)),
  Az = () => Response,
  p_ = (n) => {
    if (Array.isArray(n)) return n.map((t) => p_(t));
    if (typeof n == 'function' || n !== Object(n)) return n;
    const e = {};
    return (
      Object.entries(n).forEach(([t, i]) => {
        const r = t.replace(/([-_][a-z])/gi, (s) =>
          s.toUpperCase().replace(/[-_]/g, '')
        );
        e[r] = p_(i);
      }),
      e
    );
  },
  Mz = (n) => {
    if (typeof n != 'object' || n === null) return !1;
    const e = Object.getPrototypeOf(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  Kg = (n) => {
    var e;
    return (
      n.msg ||
      n.message ||
      n.error_description ||
      (typeof n.error == 'string'
        ? n.error
        : (e = n.error) === null || e === void 0
          ? void 0
          : e.message) ||
      JSON.stringify(n)
    );
  },
  Tz = (n, e, t) =>
    st(void 0, void 0, void 0, function* () {
      const i = yield Az();
      n instanceof i && !t?.noResolveJson
        ? n
            .json()
            .then((r) => {
              const s = n.status || 500,
                a = r?.statusCode || s + '';
              e(new Ez(Kg(r), s, a));
            })
            .catch((r) => {
              e(new f_(Kg(r), r));
            })
        : e(new f_(Kg(n), n));
    }),
  Cz = (n, e, t, i) => {
    const r = { method: n, headers: e?.headers || {} };
    return n === 'GET' || !i
      ? r
      : (Mz(i)
          ? ((r.headers = Object.assign(
              { 'Content-Type': 'application/json' },
              e?.headers
            )),
            (r.body = JSON.stringify(i)))
          : (r.body = i),
        e?.duplex && (r.duplex = e.duplex),
        Object.assign(Object.assign({}, r), t));
  };
function Th(n, e, t, i, r, s) {
  return st(this, void 0, void 0, function* () {
    return new Promise((a, o) => {
      n(t, Cz(e, i, r, s))
        .then((l) => {
          if (!l.ok) throw l;
          return i?.noResolveJson ? l : l.json();
        })
        .then((l) => a(l))
        .catch((l) => Tz(l, o, i));
    });
  });
}
function Zu(n, e, t, i) {
  return st(this, void 0, void 0, function* () {
    return Th(n, 'GET', e, t, i);
  });
}
function yr(n, e, t, i, r) {
  return st(this, void 0, void 0, function* () {
    return Th(n, 'POST', e, i, r, t);
  });
}
function m_(n, e, t, i, r) {
  return st(this, void 0, void 0, function* () {
    return Th(n, 'PUT', e, i, r, t);
  });
}
function Rz(n, e, t, i) {
  return st(this, void 0, void 0, function* () {
    return Th(
      n,
      'HEAD',
      e,
      Object.assign(Object.assign({}, t), { noResolveJson: !0 }),
      i
    );
  });
}
function xx(n, e, t, i, r) {
  return st(this, void 0, void 0, function* () {
    return Th(n, 'DELETE', e, i, r, t);
  });
}
class Iz {
  constructor(e, t) {
    ((this.downloadFn = e), (this.shouldThrowOnError = t));
  }
  then(e, t) {
    return this.execute().then(e, t);
  }
  execute() {
    return st(this, void 0, void 0, function* () {
      try {
        return { data: (yield this.downloadFn()).body, error: null };
      } catch (e) {
        if (this.shouldThrowOnError) throw e;
        if (sn(e)) return { data: null, error: e };
        throw e;
      }
    });
  }
}
var VI;
class Pz {
  constructor(e, t) {
    ((this.downloadFn = e),
      (this.shouldThrowOnError = t),
      (this[VI] = 'BlobDownloadBuilder'),
      (this.promise = null));
  }
  asStream() {
    return new Iz(this.downloadFn, this.shouldThrowOnError);
  }
  then(e, t) {
    return this.getPromise().then(e, t);
  }
  catch(e) {
    return this.getPromise().catch(e);
  }
  finally(e) {
    return this.getPromise().finally(e);
  }
  getPromise() {
    return (this.promise || (this.promise = this.execute()), this.promise);
  }
  execute() {
    return st(this, void 0, void 0, function* () {
      try {
        return { data: yield (yield this.downloadFn()).blob(), error: null };
      } catch (e) {
        if (this.shouldThrowOnError) throw e;
        if (sn(e)) return { data: null, error: e };
        throw e;
      }
    });
  }
}
VI = Symbol.toStringTag;
const Dz = { limit: 100, offset: 0, sortBy: { column: 'name', order: 'asc' } },
  EE = {
    cacheControl: '3600',
    contentType: 'text/plain;charset=UTF-8',
    upsert: !1,
  };
class Oz {
  constructor(e, t = {}, i, r) {
    ((this.shouldThrowOnError = !1),
      (this.url = e),
      (this.headers = t),
      (this.bucketId = i),
      (this.fetch = yx(r)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  uploadOrUpdate(e, t, i, r) {
    return st(this, void 0, void 0, function* () {
      try {
        let s;
        const a = Object.assign(Object.assign({}, EE), r);
        let o = Object.assign(
          Object.assign({}, this.headers),
          e === 'POST' && { 'x-upsert': String(a.upsert) }
        );
        const l = a.metadata;
        (typeof Blob < 'u' && i instanceof Blob
          ? ((s = new FormData()),
            s.append('cacheControl', a.cacheControl),
            l && s.append('metadata', this.encodeMetadata(l)),
            s.append('', i))
          : typeof FormData < 'u' && i instanceof FormData
            ? ((s = i),
              s.has('cacheControl') || s.append('cacheControl', a.cacheControl),
              l &&
                !s.has('metadata') &&
                s.append('metadata', this.encodeMetadata(l)))
            : ((s = i),
              (o['cache-control'] = `max-age=${a.cacheControl}`),
              (o['content-type'] = a.contentType),
              l && (o['x-metadata'] = this.toBase64(this.encodeMetadata(l))),
              ((typeof ReadableStream < 'u' && s instanceof ReadableStream) ||
                (s &&
                  typeof s == 'object' &&
                  'pipe' in s &&
                  typeof s.pipe == 'function')) &&
                !a.duplex &&
                (a.duplex = 'half')),
          r?.headers && (o = Object.assign(Object.assign({}, o), r.headers)));
        const c = this._removeEmptyFolders(t),
          u = this._getFinalPath(c),
          h = yield (e == 'PUT' ? m_ : yr)(
            this.fetch,
            `${this.url}/object/${u}`,
            s,
            Object.assign({ headers: o }, a?.duplex ? { duplex: a.duplex } : {})
          );
        return { data: { path: c, id: h.Id, fullPath: h.Key }, error: null };
      } catch (s) {
        if (this.shouldThrowOnError) throw s;
        if (sn(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  upload(e, t, i) {
    return st(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('POST', e, t, i);
    });
  }
  uploadToSignedUrl(e, t, i, r) {
    return st(this, void 0, void 0, function* () {
      const s = this._removeEmptyFolders(e),
        a = this._getFinalPath(s),
        o = new URL(this.url + `/object/upload/sign/${a}`);
      o.searchParams.set('token', t);
      try {
        let l;
        const c = Object.assign({ upsert: EE.upsert }, r),
          u = Object.assign(Object.assign({}, this.headers), {
            'x-upsert': String(c.upsert),
          });
        typeof Blob < 'u' && i instanceof Blob
          ? ((l = new FormData()),
            l.append('cacheControl', c.cacheControl),
            l.append('', i))
          : typeof FormData < 'u' && i instanceof FormData
            ? ((l = i), l.append('cacheControl', c.cacheControl))
            : ((l = i),
              (u['cache-control'] = `max-age=${c.cacheControl}`),
              (u['content-type'] = c.contentType));
        const h = yield m_(this.fetch, o.toString(), l, { headers: u });
        return { data: { path: s, fullPath: h.Key }, error: null };
      } catch (l) {
        if (this.shouldThrowOnError) throw l;
        if (sn(l)) return { data: null, error: l };
        throw l;
      }
    });
  }
  createSignedUploadUrl(e, t) {
    return st(this, void 0, void 0, function* () {
      try {
        let i = this._getFinalPath(e);
        const r = Object.assign({}, this.headers);
        t?.upsert && (r['x-upsert'] = 'true');
        const s = yield yr(
            this.fetch,
            `${this.url}/object/upload/sign/${i}`,
            {},
            { headers: r }
          ),
          a = new URL(this.url + s.url),
          o = a.searchParams.get('token');
        if (!o) throw new _x('No token returned by API');
        return {
          data: { signedUrl: a.toString(), path: e, token: o },
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (sn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  update(e, t, i) {
    return st(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('PUT', e, t, i);
    });
  }
  move(e, t, i) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/object/move`,
            {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: t,
              destinationBucket: i?.destinationBucket,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  copy(e, t, i) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield yr(
              this.fetch,
              `${this.url}/object/copy`,
              {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: t,
                destinationBucket: i?.destinationBucket,
              },
              { headers: this.headers }
            )).Key,
          },
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrl(e, t, i) {
    return st(this, void 0, void 0, function* () {
      try {
        let r = this._getFinalPath(e),
          s = yield yr(
            this.fetch,
            `${this.url}/object/sign/${r}`,
            Object.assign(
              { expiresIn: t },
              i?.transform ? { transform: i.transform } : {}
            ),
            { headers: this.headers }
          );
        const a = i?.download
          ? `&download=${i.download === !0 ? '' : i.download}`
          : '';
        return (
          (s = { signedUrl: encodeURI(`${this.url}${s.signedURL}${a}`) }),
          { data: s, error: null }
        );
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  createSignedUrls(e, t, i) {
    return st(this, void 0, void 0, function* () {
      try {
        const r = yield yr(
            this.fetch,
            `${this.url}/object/sign/${this.bucketId}`,
            { expiresIn: t, paths: e },
            { headers: this.headers }
          ),
          s = i?.download
            ? `&download=${i.download === !0 ? '' : i.download}`
            : '';
        return {
          data: r.map((a) =>
            Object.assign(Object.assign({}, a), {
              signedUrl: a.signedURL
                ? encodeURI(`${this.url}${a.signedURL}${s}`)
                : null,
            })
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  download(e, t) {
    const r =
        typeof t?.transform < 'u' ? 'render/image/authenticated' : 'object',
      s = this.transformOptsToQueryString(t?.transform || {}),
      a = s ? `?${s}` : '',
      o = this._getFinalPath(e),
      l = () =>
        Zu(this.fetch, `${this.url}/${r}/${o}${a}`, {
          headers: this.headers,
          noResolveJson: !0,
        });
    return new Pz(l, this.shouldThrowOnError);
  }
  info(e) {
    return st(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        const i = yield Zu(this.fetch, `${this.url}/object/info/${t}`, {
          headers: this.headers,
        });
        return { data: p_(i), error: null };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (sn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  exists(e) {
    return st(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        return (
          yield Rz(this.fetch, `${this.url}/object/${t}`, {
            headers: this.headers,
          }),
          { data: !0, error: null }
        );
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (sn(i) && i instanceof f_) {
          const r = i.originalError;
          if ([400, 404].includes(r?.status)) return { data: !1, error: i };
        }
        throw i;
      }
    });
  }
  getPublicUrl(e, t) {
    const i = this._getFinalPath(e),
      r = [],
      s = t?.download ? `download=${t.download === !0 ? '' : t.download}` : '';
    s !== '' && r.push(s);
    const o = typeof t?.transform < 'u' ? 'render/image' : 'object',
      l = this.transformOptsToQueryString(t?.transform || {});
    l !== '' && r.push(l);
    let c = r.join('&');
    return (
      c !== '' && (c = `?${c}`),
      { data: { publicUrl: encodeURI(`${this.url}/${o}/public/${i}${c}`) } }
    );
  }
  remove(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield xx(
            this.fetch,
            `${this.url}/object/${this.bucketId}`,
            { prefixes: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  list(e, t, i) {
    return st(this, void 0, void 0, function* () {
      try {
        const r = Object.assign(Object.assign(Object.assign({}, Dz), t), {
          prefix: e || '',
        });
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/object/list/${this.bucketId}`,
            r,
            { headers: this.headers },
            i
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  listV2(e, t) {
    return st(this, void 0, void 0, function* () {
      try {
        const i = Object.assign({}, e);
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/object/list-v2/${this.bucketId}`,
            i,
            { headers: this.headers },
            t
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (sn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  encodeMetadata(e) {
    return JSON.stringify(e);
  }
  toBase64(e) {
    return typeof Buffer < 'u' ? Buffer.from(e).toString('base64') : btoa(e);
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e.replace(/^\/+/, '')}`;
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, '').replace(/\/+/g, '/');
  }
  transformOptsToQueryString(e) {
    const t = [];
    return (
      e.width && t.push(`width=${e.width}`),
      e.height && t.push(`height=${e.height}`),
      e.resize && t.push(`resize=${e.resize}`),
      e.format && t.push(`format=${e.format}`),
      e.quality && t.push(`quality=${e.quality}`),
      t.join('&')
    );
  }
}
const HI = '2.80.0',
  GI = { 'X-Client-Info': `storage-js/${HI}` };
class Lz {
  constructor(e, t = {}, i, r) {
    this.shouldThrowOnError = !1;
    const s = new URL(e);
    (r?.useNewHostname &&
      /supabase\.(co|in|red)$/.test(s.hostname) &&
      !s.hostname.includes('storage.supabase.') &&
      (s.hostname = s.hostname.replace('supabase.', 'storage.supabase.')),
      (this.url = s.href.replace(/\/$/, '')),
      (this.headers = Object.assign(Object.assign({}, GI), t)),
      (this.fetch = yx(i)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  listBuckets(e) {
    return st(this, void 0, void 0, function* () {
      try {
        const t = this.listBucketOptionsToQueryString(e);
        return {
          data: yield Zu(this.fetch, `${this.url}/bucket${t}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Zu(this.fetch, `${this.url}/bucket/${e}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  createBucket(e) {
    return st(this, arguments, void 0, function* (t, i = { public: !1 }) {
      try {
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/bucket`,
            {
              id: t,
              name: t,
              type: i.type,
              public: i.public,
              file_size_limit: i.fileSizeLimit,
              allowed_mime_types: i.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (sn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  updateBucket(e, t) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield m_(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {
              id: e,
              name: e,
              public: t.public,
              file_size_limit: t.fileSizeLimit,
              allowed_mime_types: t.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (sn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  emptyBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/bucket/${e}/empty`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield xx(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBucketOptionsToQueryString(e) {
    const t = {};
    return (
      e &&
        ('limit' in e && (t.limit = String(e.limit)),
        'offset' in e && (t.offset = String(e.offset)),
        e.search && (t.search = e.search),
        e.sortColumn && (t.sortColumn = e.sortColumn),
        e.sortOrder && (t.sortOrder = e.sortOrder)),
      Object.keys(t).length > 0 ? '?' + new URLSearchParams(t).toString() : ''
    );
  }
}
class Uz {
  constructor(e, t = {}, i) {
    ((this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, '')),
      (this.headers = Object.assign(Object.assign({}, GI), t)),
      (this.fetch = yx(i)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  createBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield yr(
            this.fetch,
            `${this.url}/bucket`,
            { name: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBuckets(e) {
    return st(this, void 0, void 0, function* () {
      try {
        const t = new URLSearchParams();
        (e?.limit !== void 0 && t.set('limit', e.limit.toString()),
          e?.offset !== void 0 && t.set('offset', e.offset.toString()),
          e?.sortColumn && t.set('sortColumn', e.sortColumn),
          e?.sortOrder && t.set('sortOrder', e.sortOrder),
          e?.search && t.set('search', e.search));
        const i = t.toString(),
          r = i ? `${this.url}/bucket?${i}` : `${this.url}/bucket`;
        return {
          data: yield Zu(this.fetch, r, { headers: this.headers }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield xx(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (sn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
const bx = {
  'X-Client-Info': `storage-js/${HI}`,
  'Content-Type': 'application/json',
};
class WI extends Error {
  constructor(e) {
    (super(e),
      (this.__isStorageVectorsError = !0),
      (this.name = 'StorageVectorsError'));
  }
}
function Ni(n) {
  return typeof n == 'object' && n !== null && '__isStorageVectorsError' in n;
}
class Jg extends WI {
  constructor(e, t, i) {
    (super(e),
      (this.name = 'StorageVectorsApiError'),
      (this.status = t),
      (this.statusCode = i));
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode,
    };
  }
}
class kz extends WI {
  constructor(e, t) {
    (super(e),
      (this.name = 'StorageVectorsUnknownError'),
      (this.originalError = t));
  }
}
var AE;
(function (n) {
  ((n.InternalError = 'InternalError'),
    (n.S3VectorConflictException = 'S3VectorConflictException'),
    (n.S3VectorNotFoundException = 'S3VectorNotFoundException'),
    (n.S3VectorBucketNotEmpty = 'S3VectorBucketNotEmpty'),
    (n.S3VectorMaxBucketsExceeded = 'S3VectorMaxBucketsExceeded'),
    (n.S3VectorMaxIndexesExceeded = 'S3VectorMaxIndexesExceeded'));
})(AE || (AE = {}));
const Sx = (n) => (n ? (...e) => n(...e) : (...e) => fetch(...e)),
  Bz = (n) => {
    if (typeof n != 'object' || n === null) return !1;
    const e = Object.getPrototypeOf(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  ME = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  Nz = (n, e, t) =>
    st(void 0, void 0, void 0, function* () {
      if (
        n &&
        typeof n == 'object' &&
        'status' in n &&
        'ok' in n &&
        typeof n.status == 'number' &&
        !t?.noResolveJson
      ) {
        const r = n.status || 500,
          s = n;
        if (typeof s.json == 'function')
          s.json()
            .then((a) => {
              const o = a?.statusCode || a?.code || r + '';
              e(new Jg(ME(a), r, o));
            })
            .catch(() => {
              const a = r + '',
                o = s.statusText || `HTTP ${r} error`;
              e(new Jg(o, r, a));
            });
        else {
          const a = r + '',
            o = s.statusText || `HTTP ${r} error`;
          e(new Jg(o, r, a));
        }
      } else e(new kz(ME(n), n));
    }),
  Fz = (n, e, t, i) => {
    const r = { method: n, headers: e?.headers || {} };
    return i
      ? (Bz(i)
          ? ((r.headers = Object.assign(
              { 'Content-Type': 'application/json' },
              e?.headers
            )),
            (r.body = JSON.stringify(i)))
          : (r.body = i),
        Object.assign(Object.assign({}, r), t))
      : r;
  };
function zz(n, e, t, i, r, s) {
  return st(this, void 0, void 0, function* () {
    return new Promise((a, o) => {
      n(t, Fz(e, i, r, s))
        .then((l) => {
          if (!l.ok) throw l;
          if (i?.noResolveJson) return l;
          const c = l.headers.get('content-type');
          return !c || !c.includes('application/json') ? {} : l.json();
        })
        .then((l) => a(l))
        .catch((l) => Nz(l, o, i));
    });
  });
}
function Fi(n, e, t, i, r) {
  return st(this, void 0, void 0, function* () {
    return zz(n, 'POST', e, i, r, t);
  });
}
class Vz {
  constructor(e, t = {}, i) {
    ((this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, '')),
      (this.headers = Object.assign(Object.assign({}, bx), t)),
      (this.fetch = Sx(i)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  createIndex(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Fi(this.fetch, `${this.url}/CreateIndex`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getIndex(e, t) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Fi(
            this.fetch,
            `${this.url}/GetIndex`,
            { vectorBucketName: e, indexName: t },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (Ni(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  listIndexes(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Fi(this.fetch, `${this.url}/ListIndexes`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteIndex(e, t) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Fi(
              this.fetch,
              `${this.url}/DeleteIndex`,
              { vectorBucketName: e, indexName: t },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (Ni(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
}
class Hz {
  constructor(e, t = {}, i) {
    ((this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, '')),
      (this.headers = Object.assign(Object.assign({}, bx), t)),
      (this.fetch = Sx(i)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  putVectors(e) {
    return st(this, void 0, void 0, function* () {
      try {
        if (e.vectors.length < 1 || e.vectors.length > 500)
          throw new Error('Vector batch size must be between 1 and 500 items');
        return {
          data:
            (yield Fi(this.fetch, `${this.url}/PutVectors`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getVectors(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Fi(this.fetch, `${this.url}/GetVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listVectors(e) {
    return st(this, void 0, void 0, function* () {
      try {
        if (e.segmentCount !== void 0) {
          if (e.segmentCount < 1 || e.segmentCount > 16)
            throw new Error('segmentCount must be between 1 and 16');
          if (
            e.segmentIndex !== void 0 &&
            (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount)
          )
            throw new Error(
              `segmentIndex must be between 0 and ${e.segmentCount - 1}`
            );
        }
        return {
          data: yield Fi(this.fetch, `${this.url}/ListVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  queryVectors(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Fi(this.fetch, `${this.url}/QueryVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteVectors(e) {
    return st(this, void 0, void 0, function* () {
      try {
        if (e.keys.length < 1 || e.keys.length > 500)
          throw new Error('Keys batch size must be between 1 and 500 items');
        return {
          data:
            (yield Fi(this.fetch, `${this.url}/DeleteVectors`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
class Gz {
  constructor(e, t = {}, i) {
    ((this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, '')),
      (this.headers = Object.assign(Object.assign({}, bx), t)),
      (this.fetch = Sx(i)));
  }
  throwOnError() {
    return ((this.shouldThrowOnError = !0), this);
  }
  createBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Fi(
              this.fetch,
              `${this.url}/CreateVectorBucket`,
              { vectorBucketName: e },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Fi(
            this.fetch,
            `${this.url}/GetVectorBucket`,
            { vectorBucketName: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBuckets() {
    return st(this, arguments, void 0, function* (e = {}) {
      try {
        return {
          data: yield Fi(this.fetch, `${this.url}/ListVectorBuckets`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return st(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Fi(
              this.fetch,
              `${this.url}/DeleteVectorBucket`,
              { vectorBucketName: e },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ni(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
class Wz extends Gz {
  constructor(e, t = {}) {
    super(e, t.headers || {}, t.fetch);
  }
  from(e) {
    return new jz(this.url, this.headers, e, this.fetch);
  }
}
class jz extends Vz {
  constructor(e, t, i, r) {
    (super(e, t, r), (this.vectorBucketName = i));
  }
  createIndex(e) {
    const t = Object.create(null, {
      createIndex: { get: () => super.createIndex },
    });
    return st(this, void 0, void 0, function* () {
      return t.createIndex.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
        })
      );
    });
  }
  listIndexes() {
    const e = Object.create(null, {
      listIndexes: { get: () => super.listIndexes },
    });
    return st(this, arguments, void 0, function* (t = {}) {
      return e.listIndexes.call(
        this,
        Object.assign(Object.assign({}, t), {
          vectorBucketName: this.vectorBucketName,
        })
      );
    });
  }
  getIndex(e) {
    const t = Object.create(null, { getIndex: { get: () => super.getIndex } });
    return st(this, void 0, void 0, function* () {
      return t.getIndex.call(this, this.vectorBucketName, e);
    });
  }
  deleteIndex(e) {
    const t = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex },
    });
    return st(this, void 0, void 0, function* () {
      return t.deleteIndex.call(this, this.vectorBucketName, e);
    });
  }
  index(e) {
    return new Xz(this.url, this.headers, this.vectorBucketName, e, this.fetch);
  }
}
class Xz extends Hz {
  constructor(e, t, i, r, s) {
    (super(e, t, s), (this.vectorBucketName = i), (this.indexName = r));
  }
  putVectors(e) {
    const t = Object.create(null, {
      putVectors: { get: () => super.putVectors },
    });
    return st(this, void 0, void 0, function* () {
      return t.putVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  getVectors(e) {
    const t = Object.create(null, {
      getVectors: { get: () => super.getVectors },
    });
    return st(this, void 0, void 0, function* () {
      return t.getVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  listVectors() {
    const e = Object.create(null, {
      listVectors: { get: () => super.listVectors },
    });
    return st(this, arguments, void 0, function* (t = {}) {
      return e.listVectors.call(
        this,
        Object.assign(Object.assign({}, t), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  queryVectors(e) {
    const t = Object.create(null, {
      queryVectors: { get: () => super.queryVectors },
    });
    return st(this, void 0, void 0, function* () {
      return t.queryVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  deleteVectors(e) {
    const t = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors },
    });
    return st(this, void 0, void 0, function* () {
      return t.deleteVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
}
class qz extends Lz {
  constructor(e, t = {}, i, r) {
    super(e, t, i, r);
  }
  from(e) {
    return new Oz(this.url, this.headers, e, this.fetch);
  }
  get vectors() {
    return new Wz(this.url + '/vector', {
      headers: this.headers,
      fetch: this.fetch,
    });
  }
  get analytics() {
    return new Uz(this.url + '/iceberg', this.headers, this.fetch);
  }
}
const Yz = '2.80.0';
let du = '';
typeof Deno < 'u'
  ? (du = 'deno')
  : typeof document < 'u'
    ? (du = 'web')
    : typeof navigator < 'u' && navigator.product === 'ReactNative'
      ? (du = 'react-native')
      : (du = 'node');
const Kz = { 'X-Client-Info': `supabase-js-${du}/${Yz}` },
  Jz = { headers: Kz },
  Qz = { schema: 'public' },
  Zz = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: 'implicit',
  },
  $z = {},
  e4 = (n) => (n ? (...e) => n(...e) : (...e) => fetch(...e)),
  t4 = () => Headers,
  n4 = (n, e, t) => {
    const i = e4(t),
      r = t4();
    return async (s, a) => {
      var o;
      const l = (o = await e()) !== null && o !== void 0 ? o : n;
      let c = new r(a?.headers);
      return (
        c.has('apikey') || c.set('apikey', n),
        c.has('Authorization') || c.set('Authorization', `Bearer ${l}`),
        i(s, Object.assign(Object.assign({}, a), { headers: c }))
      );
    };
  };
function i4(n) {
  return n.endsWith('/') ? n : n + '/';
}
function r4(n, e) {
  var t, i;
  const { db: r, auth: s, realtime: a, global: o } = n,
    { db: l, auth: c, realtime: u, global: h } = e,
    d = {
      db: Object.assign(Object.assign({}, l), r),
      auth: Object.assign(Object.assign({}, c), s),
      realtime: Object.assign(Object.assign({}, u), a),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, h), o), {
        headers: Object.assign(
          Object.assign({}, (t = h?.headers) !== null && t !== void 0 ? t : {}),
          (i = o?.headers) !== null && i !== void 0 ? i : {}
        ),
      }),
      accessToken: async () => '',
    };
  return (
    n.accessToken ? (d.accessToken = n.accessToken) : delete d.accessToken,
    d
  );
}
function s4(n) {
  const e = n?.trim();
  if (!e) throw new Error('supabaseUrl is required.');
  if (!e.match(/^https?:\/\//i))
    throw new Error('Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.');
  try {
    return new URL(i4(e));
  } catch {
    throw Error('Invalid supabaseUrl: Provided URL is malformed.');
  }
}
const jI = '2.80.0',
  Sl = 30 * 1e3,
  g_ = 3,
  Qg = g_ * Sl,
  a4 = 'http://localhost:9999',
  o4 = 'supabase.auth.token',
  l4 = { 'X-Client-Info': `gotrue-js/${jI}` },
  v_ = 'X-Supabase-Api-Version',
  XI = {
    '2024-01-01': {
      timestamp: Date.parse('2024-01-01T00:00:00.0Z'),
      name: '2024-01-01',
    },
  },
  c4 = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  u4 = 600 * 1e3;
class $u extends Error {
  constructor(e, t, i) {
    (super(e),
      (this.__isAuthError = !0),
      (this.name = 'AuthError'),
      (this.status = t),
      (this.code = i));
  }
}
function lt(n) {
  return typeof n == 'object' && n !== null && '__isAuthError' in n;
}
class h4 extends $u {
  constructor(e, t, i) {
    (super(e, t, i),
      (this.name = 'AuthApiError'),
      (this.status = t),
      (this.code = i));
  }
}
function d4(n) {
  return lt(n) && n.name === 'AuthApiError';
}
class io extends $u {
  constructor(e, t) {
    (super(e), (this.name = 'AuthUnknownError'), (this.originalError = t));
  }
}
class aa extends $u {
  constructor(e, t, i, r) {
    (super(e, i, r), (this.name = t), (this.status = i));
  }
}
class gr extends aa {
  constructor() {
    super('Auth session missing!', 'AuthSessionMissingError', 400, void 0);
  }
}
function f4(n) {
  return lt(n) && n.name === 'AuthSessionMissingError';
}
class qo extends aa {
  constructor() {
    super(
      'Auth session or user missing',
      'AuthInvalidTokenResponseError',
      500,
      void 0
    );
  }
}
class pd extends aa {
  constructor(e) {
    super(e, 'AuthInvalidCredentialsError', 400, void 0);
  }
}
class md extends aa {
  constructor(e, t = null) {
    (super(e, 'AuthImplicitGrantRedirectError', 500, void 0),
      (this.details = null),
      (this.details = t));
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
function p4(n) {
  return lt(n) && n.name === 'AuthImplicitGrantRedirectError';
}
class TE extends aa {
  constructor(e, t = null) {
    (super(e, 'AuthPKCEGrantCodeExchangeError', 500, void 0),
      (this.details = null),
      (this.details = t));
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
class __ extends aa {
  constructor(e, t) {
    super(e, 'AuthRetryableFetchError', t, void 0);
  }
}
function Zg(n) {
  return lt(n) && n.name === 'AuthRetryableFetchError';
}
class CE extends aa {
  constructor(e, t, i) {
    (super(e, 'AuthWeakPasswordError', t, 'weak_password'), (this.reasons = i));
  }
}
class y_ extends aa {
  constructor(e) {
    super(e, 'AuthInvalidJwtError', 400, 'invalid_jwt');
  }
}
const ep =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split(
      ''
    ),
  RE = ` 	
\r=`.split(''),
  m4 = (() => {
    const n = new Array(128);
    for (let e = 0; e < n.length; e += 1) n[e] = -1;
    for (let e = 0; e < RE.length; e += 1) n[RE[e].charCodeAt(0)] = -2;
    for (let e = 0; e < ep.length; e += 1) n[ep[e].charCodeAt(0)] = e;
    return n;
  })();
function IE(n, e, t) {
  if (n !== null)
    for (e.queue = (e.queue << 8) | n, e.queuedBits += 8; e.queuedBits >= 6; ) {
      const i = (e.queue >> (e.queuedBits - 6)) & 63;
      (t(ep[i]), (e.queuedBits -= 6));
    }
  else if (e.queuedBits > 0)
    for (
      e.queue = e.queue << (6 - e.queuedBits), e.queuedBits = 6;
      e.queuedBits >= 6;

    ) {
      const i = (e.queue >> (e.queuedBits - 6)) & 63;
      (t(ep[i]), (e.queuedBits -= 6));
    }
}
function qI(n, e, t) {
  const i = m4[n];
  if (i > -1)
    for (e.queue = (e.queue << 6) | i, e.queuedBits += 6; e.queuedBits >= 8; )
      (t((e.queue >> (e.queuedBits - 8)) & 255), (e.queuedBits -= 8));
  else {
    if (i === -2) return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`);
  }
}
function PE(n) {
  const e = [],
    t = (a) => {
      e.push(String.fromCodePoint(a));
    },
    i = { utf8seq: 0, codepoint: 0 },
    r = { queue: 0, queuedBits: 0 },
    s = (a) => {
      _4(a, i, t);
    };
  for (let a = 0; a < n.length; a += 1) qI(n.charCodeAt(a), r, s);
  return e.join('');
}
function g4(n, e) {
  if (n <= 127) {
    e(n);
    return;
  } else if (n <= 2047) {
    (e(192 | (n >> 6)), e(128 | (n & 63)));
    return;
  } else if (n <= 65535) {
    (e(224 | (n >> 12)), e(128 | ((n >> 6) & 63)), e(128 | (n & 63)));
    return;
  } else if (n <= 1114111) {
    (e(240 | (n >> 18)),
      e(128 | ((n >> 12) & 63)),
      e(128 | ((n >> 6) & 63)),
      e(128 | (n & 63)));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`);
}
function v4(n, e) {
  for (let t = 0; t < n.length; t += 1) {
    let i = n.charCodeAt(t);
    if (i > 55295 && i <= 56319) {
      const r = ((i - 55296) * 1024) & 65535;
      ((i = (((n.charCodeAt(t + 1) - 56320) & 65535) | r) + 65536), (t += 1));
    }
    g4(i, e);
  }
}
function _4(n, e, t) {
  if (e.utf8seq === 0) {
    if (n <= 127) {
      t(n);
      return;
    }
    for (let i = 1; i < 6; i += 1)
      if (((n >> (7 - i)) & 1) === 0) {
        e.utf8seq = i;
        break;
      }
    if (e.utf8seq === 2) e.codepoint = n & 31;
    else if (e.utf8seq === 3) e.codepoint = n & 15;
    else if (e.utf8seq === 4) e.codepoint = n & 7;
    else throw new Error('Invalid UTF-8 sequence');
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (n <= 127) throw new Error('Invalid UTF-8 sequence');
    ((e.codepoint = (e.codepoint << 6) | (n & 63)),
      (e.utf8seq -= 1),
      e.utf8seq === 0 && t(e.codepoint));
  }
}
function Fl(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    i = (r) => {
      e.push(r);
    };
  for (let r = 0; r < n.length; r += 1) qI(n.charCodeAt(r), t, i);
  return new Uint8Array(e);
}
function y4(n) {
  const e = [];
  return (v4(n, (t) => e.push(t)), new Uint8Array(e));
}
function co(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    i = (r) => {
      e.push(r);
    };
  return (n.forEach((r) => IE(r, t, i)), IE(null, t, i), e.join(''));
}
function x4(n) {
  return Math.round(Date.now() / 1e3) + n;
}
function b4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (n) {
    const e = (Math.random() * 16) | 0;
    return (n == 'x' ? e : (e & 3) | 8).toString(16);
  });
}
const $n = () => typeof window < 'u' && typeof document < 'u',
  La = { tested: !1, writable: !1 },
  YI = () => {
    if (!$n()) return !1;
    try {
      if (typeof globalThis.localStorage != 'object') return !1;
    } catch {
      return !1;
    }
    if (La.tested) return La.writable;
    const n = `lswt-${Math.random()}${Math.random()}`;
    try {
      (globalThis.localStorage.setItem(n, n),
        globalThis.localStorage.removeItem(n),
        (La.tested = !0),
        (La.writable = !0));
    } catch {
      ((La.tested = !0), (La.writable = !1));
    }
    return La.writable;
  };
function S4(n) {
  const e = {},
    t = new URL(n);
  if (t.hash && t.hash[0] === '#')
    try {
      new URLSearchParams(t.hash.substring(1)).forEach((r, s) => {
        e[s] = r;
      });
    } catch {}
  return (
    t.searchParams.forEach((i, r) => {
      e[r] = i;
    }),
    e
  );
}
const KI = (n) => (n ? (...e) => n(...e) : (...e) => fetch(...e)),
  w4 = (n) =>
    typeof n == 'object' &&
    n !== null &&
    'status' in n &&
    'ok' in n &&
    'json' in n &&
    typeof n.json == 'function',
  wl = async (n, e, t) => {
    await n.setItem(e, JSON.stringify(t));
  },
  Ua = async (n, e) => {
    const t = await n.getItem(e);
    if (!t) return null;
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  },
  Ss = async (n, e) => {
    await n.removeItem(e);
  };
class cm {
  constructor() {
    this.promise = new cm.promiseConstructor((e, t) => {
      ((this.resolve = e), (this.reject = t));
    });
  }
}
cm.promiseConstructor = Promise;
function $g(n) {
  const e = n.split('.');
  if (e.length !== 3) throw new y_('Invalid JWT structure');
  for (let i = 0; i < e.length; i++)
    if (!c4.test(e[i])) throw new y_('JWT not in base64url format');
  return {
    header: JSON.parse(PE(e[0])),
    payload: JSON.parse(PE(e[1])),
    signature: Fl(e[2]),
    raw: { header: e[0], payload: e[1] },
  };
}
async function E4(n) {
  return await new Promise((e) => {
    setTimeout(() => e(null), n);
  });
}
function A4(n, e) {
  return new Promise((i, r) => {
    (async () => {
      for (let s = 0; s < 1 / 0; s++)
        try {
          const a = await n(s);
          if (!e(s, null, a)) {
            i(a);
            return;
          }
        } catch (a) {
          if (!e(s, a)) {
            r(a);
            return;
          }
        }
    })();
  });
}
function M4(n) {
  return ('0' + n.toString(16)).substr(-2);
}
function T4() {
  const e = new Uint32Array(56);
  if (typeof crypto > 'u') {
    const t =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',
      i = t.length;
    let r = '';
    for (let s = 0; s < 56; s++) r += t.charAt(Math.floor(Math.random() * i));
    return r;
  }
  return (crypto.getRandomValues(e), Array.from(e, M4).join(''));
}
async function C4(n) {
  const t = new TextEncoder().encode(n),
    i = await crypto.subtle.digest('SHA-256', t),
    r = new Uint8Array(i);
  return Array.from(r)
    .map((s) => String.fromCharCode(s))
    .join('');
}
async function R4(n) {
  if (
    !(
      typeof crypto < 'u' &&
      typeof crypto.subtle < 'u' &&
      typeof TextEncoder < 'u'
    )
  )
    return (
      console.warn(
        'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'
      ),
      n
    );
  const t = await C4(n);
  return btoa(t).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
async function Yo(n, e, t = !1) {
  const i = T4();
  let r = i;
  (t && (r += '/PASSWORD_RECOVERY'), await wl(n, `${e}-code-verifier`, r));
  const s = await R4(i);
  return [s, i === s ? 'plain' : 's256'];
}
const I4 = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function P4(n) {
  const e = n.headers.get(v_);
  if (!e || !e.match(I4)) return null;
  try {
    return new Date(`${e}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function D4(n) {
  if (!n) throw new Error('Missing exp claim');
  const e = Math.floor(Date.now() / 1e3);
  if (n <= e) throw new Error('JWT has expired');
}
function O4(n) {
  switch (n) {
    case 'RS256':
      return { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } };
    case 'ES256':
      return { name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } };
    default:
      throw new Error('Invalid alg claim');
  }
}
const L4 = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function Ko(n) {
  if (!L4.test(n))
    throw new Error(
      '@supabase/auth-js: Expected parameter to be UUID but is not'
    );
}
function e0() {
  const n = {};
  return new Proxy(n, {
    get: (e, t) => {
      if (t === '__isUserNotAvailableProxy') return !0;
      if (typeof t == 'symbol') {
        const i = t.toString();
        if (
          i === 'Symbol(Symbol.toPrimitive)' ||
          i === 'Symbol(Symbol.toStringTag)' ||
          i === 'Symbol(util.inspect.custom)'
        )
          return;
      }
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`
      );
    },
    set: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
    deleteProperty: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
  });
}
function U4(n, e) {
  return new Proxy(n, {
    get: (t, i, r) => {
      if (i === '__isInsecureUserWarningProxy') return !0;
      if (typeof i == 'symbol') {
        const s = i.toString();
        if (
          s === 'Symbol(Symbol.toPrimitive)' ||
          s === 'Symbol(Symbol.toStringTag)' ||
          s === 'Symbol(util.inspect.custom)' ||
          s === 'Symbol(nodejs.util.inspect.custom)'
        )
          return Reflect.get(t, i, r);
      }
      return (
        !e.value &&
          typeof i == 'string' &&
          (console.warn(
            'Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.'
          ),
          (e.value = !0)),
        Reflect.get(t, i, r)
      );
    },
  });
}
function DE(n) {
  return JSON.parse(JSON.stringify(n));
}
const eo = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  k4 = [502, 503, 504];
async function OE(n) {
  var e;
  if (!w4(n)) throw new __(eo(n), 0);
  if (k4.includes(n.status)) throw new __(eo(n), n.status);
  let t;
  try {
    t = await n.json();
  } catch (s) {
    throw new io(eo(s), s);
  }
  let i;
  const r = P4(n);
  if (
    (r &&
    r.getTime() >= XI['2024-01-01'].timestamp &&
    typeof t == 'object' &&
    t &&
    typeof t.code == 'string'
      ? (i = t.code)
      : typeof t == 'object' &&
        t &&
        typeof t.error_code == 'string' &&
        (i = t.error_code),
    i)
  ) {
    if (i === 'weak_password')
      throw new CE(
        eo(t),
        n.status,
        ((e = t.weak_password) === null || e === void 0 ? void 0 : e.reasons) ||
          []
      );
    if (i === 'session_not_found') throw new gr();
  } else if (
    typeof t == 'object' &&
    t &&
    typeof t.weak_password == 'object' &&
    t.weak_password &&
    Array.isArray(t.weak_password.reasons) &&
    t.weak_password.reasons.length &&
    t.weak_password.reasons.reduce((s, a) => s && typeof a == 'string', !0)
  )
    throw new CE(eo(t), n.status, t.weak_password.reasons);
  throw new h4(eo(t), n.status || 500, i);
}
const B4 = (n, e, t, i) => {
  const r = { method: n, headers: e?.headers || {} };
  return n === 'GET'
    ? r
    : ((r.headers = Object.assign(
        { 'Content-Type': 'application/json;charset=UTF-8' },
        e?.headers
      )),
      (r.body = JSON.stringify(i)),
      Object.assign(Object.assign({}, r), t));
};
async function dt(n, e, t, i) {
  var r;
  const s = Object.assign({}, i?.headers);
  (s[v_] || (s[v_] = XI['2024-01-01'].name),
    i?.jwt && (s.Authorization = `Bearer ${i.jwt}`));
  const a = (r = i?.query) !== null && r !== void 0 ? r : {};
  i?.redirectTo && (a.redirect_to = i.redirectTo);
  const o = Object.keys(a).length
      ? '?' + new URLSearchParams(a).toString()
      : '',
    l = await N4(
      n,
      e,
      t + o,
      { headers: s, noResolveJson: i?.noResolveJson },
      {},
      i?.body
    );
  return i?.xform ? i?.xform(l) : { data: Object.assign({}, l), error: null };
}
async function N4(n, e, t, i, r, s) {
  const a = B4(e, i, r, s);
  let o;
  try {
    o = await n(t, Object.assign({}, a));
  } catch (l) {
    throw (console.error(l), new __(eo(l), 0));
  }
  if ((o.ok || (await OE(o)), i?.noResolveJson)) return o;
  try {
    return await o.json();
  } catch (l) {
    await OE(l);
  }
}
function vr(n) {
  var e;
  let t = null;
  V4(n) &&
    ((t = Object.assign({}, n)),
    n.expires_at || (t.expires_at = x4(n.expires_in)));
  const i = (e = n.user) !== null && e !== void 0 ? e : n;
  return { data: { session: t, user: i }, error: null };
}
function LE(n) {
  const e = vr(n);
  return (
    !e.error &&
      n.weak_password &&
      typeof n.weak_password == 'object' &&
      Array.isArray(n.weak_password.reasons) &&
      n.weak_password.reasons.length &&
      n.weak_password.message &&
      typeof n.weak_password.message == 'string' &&
      n.weak_password.reasons.reduce((t, i) => t && typeof i == 'string', !0) &&
      (e.data.weak_password = n.weak_password),
    e
  );
}
function ks(n) {
  var e;
  return {
    data: { user: (e = n.user) !== null && e !== void 0 ? e : n },
    error: null,
  };
}
function F4(n) {
  return { data: n, error: null };
}
function z4(n) {
  const {
      action_link: e,
      email_otp: t,
      hashed_token: i,
      redirect_to: r,
      verification_type: s,
    } = n,
    a = mc(n, [
      'action_link',
      'email_otp',
      'hashed_token',
      'redirect_to',
      'verification_type',
    ]),
    o = {
      action_link: e,
      email_otp: t,
      hashed_token: i,
      redirect_to: r,
      verification_type: s,
    },
    l = Object.assign({}, a);
  return { data: { properties: o, user: l }, error: null };
}
function UE(n) {
  return n;
}
function V4(n) {
  return n.access_token && n.refresh_token && n.expires_in;
}
const t0 = ['global', 'local', 'others'];
class H4 {
  constructor({ url: e = '', headers: t = {}, fetch: i }) {
    ((this.url = e),
      (this.headers = t),
      (this.fetch = KI(i)),
      (this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this),
      }),
      (this.oauth = {
        listClients: this._listOAuthClients.bind(this),
        createClient: this._createOAuthClient.bind(this),
        getClient: this._getOAuthClient.bind(this),
        updateClient: this._updateOAuthClient.bind(this),
        deleteClient: this._deleteOAuthClient.bind(this),
        regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this),
      }));
  }
  async signOut(e, t = t0[0]) {
    if (t0.indexOf(t) < 0)
      throw new Error(
        `@supabase/auth-js: Parameter scope must be one of ${t0.join(', ')}`
      );
    try {
      return (
        await dt(this.fetch, 'POST', `${this.url}/logout?scope=${t}`, {
          headers: this.headers,
          jwt: e,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (i) {
      if (lt(i)) return { data: null, error: i };
      throw i;
    }
  }
  async inviteUserByEmail(e, t = {}) {
    try {
      return await dt(this.fetch, 'POST', `${this.url}/invite`, {
        body: { email: e, data: t.data },
        headers: this.headers,
        redirectTo: t.redirectTo,
        xform: ks,
      });
    } catch (i) {
      if (lt(i)) return { data: { user: null }, error: i };
      throw i;
    }
  }
  async generateLink(e) {
    try {
      const { options: t } = e,
        i = mc(e, ['options']),
        r = Object.assign(Object.assign({}, i), t);
      return (
        'newEmail' in i && ((r.new_email = i?.newEmail), delete r.newEmail),
        await dt(this.fetch, 'POST', `${this.url}/admin/generate_link`, {
          body: r,
          headers: this.headers,
          xform: z4,
          redirectTo: t?.redirectTo,
        })
      );
    } catch (t) {
      if (lt(t)) return { data: { properties: null, user: null }, error: t };
      throw t;
    }
  }
  async createUser(e) {
    try {
      return await dt(this.fetch, 'POST', `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: ks,
      });
    } catch (t) {
      if (lt(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async listUsers(e) {
    var t, i, r, s, a, o, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        u = await dt(this.fetch, 'GET', `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (i =
                (t = e?.page) === null || t === void 0
                  ? void 0
                  : t.toString()) !== null && i !== void 0
                ? i
                : '',
            per_page:
              (s =
                (r = e?.perPage) === null || r === void 0
                  ? void 0
                  : r.toString()) !== null && s !== void 0
                ? s
                : '',
          },
          xform: UE,
        });
      if (u.error) throw u.error;
      const h = await u.json(),
        d =
          (a = u.headers.get('x-total-count')) !== null && a !== void 0 ? a : 0,
        f =
          (l =
            (o = u.headers.get('link')) === null || o === void 0
              ? void 0
              : o.split(',')) !== null && l !== void 0
            ? l
            : [];
      return (
        f.length > 0 &&
          (f.forEach((p) => {
            const m = parseInt(p.split(';')[0].split('=')[1].substring(0, 1)),
              g = JSON.parse(p.split(';')[1].split('=')[1]);
            c[`${g}Page`] = m;
          }),
          (c.total = parseInt(d))),
        { data: Object.assign(Object.assign({}, h), c), error: null }
      );
    } catch (c) {
      if (lt(c)) return { data: { users: [] }, error: c };
      throw c;
    }
  }
  async getUserById(e) {
    Ko(e);
    try {
      return await dt(this.fetch, 'GET', `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: ks,
      });
    } catch (t) {
      if (lt(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async updateUserById(e, t) {
    Ko(e);
    try {
      return await dt(this.fetch, 'PUT', `${this.url}/admin/users/${e}`, {
        body: t,
        headers: this.headers,
        xform: ks,
      });
    } catch (i) {
      if (lt(i)) return { data: { user: null }, error: i };
      throw i;
    }
  }
  async deleteUser(e, t = !1) {
    Ko(e);
    try {
      return await dt(this.fetch, 'DELETE', `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: { should_soft_delete: t },
        xform: ks,
      });
    } catch (i) {
      if (lt(i)) return { data: { user: null }, error: i };
      throw i;
    }
  }
  async _listFactors(e) {
    Ko(e.userId);
    try {
      const { data: t, error: i } = await dt(
        this.fetch,
        'GET',
        `${this.url}/admin/users/${e.userId}/factors`,
        {
          headers: this.headers,
          xform: (r) => ({ data: { factors: r }, error: null }),
        }
      );
      return { data: t, error: i };
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _deleteFactor(e) {
    (Ko(e.userId), Ko(e.id));
    try {
      return {
        data: await dt(
          this.fetch,
          'DELETE',
          `${this.url}/admin/users/${e.userId}/factors/${e.id}`,
          { headers: this.headers }
        ),
        error: null,
      };
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _listOAuthClients(e) {
    var t, i, r, s, a, o, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        u = await dt(this.fetch, 'GET', `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (i =
                (t = e?.page) === null || t === void 0
                  ? void 0
                  : t.toString()) !== null && i !== void 0
                ? i
                : '',
            per_page:
              (s =
                (r = e?.perPage) === null || r === void 0
                  ? void 0
                  : r.toString()) !== null && s !== void 0
                ? s
                : '',
          },
          xform: UE,
        });
      if (u.error) throw u.error;
      const h = await u.json(),
        d =
          (a = u.headers.get('x-total-count')) !== null && a !== void 0 ? a : 0,
        f =
          (l =
            (o = u.headers.get('link')) === null || o === void 0
              ? void 0
              : o.split(',')) !== null && l !== void 0
            ? l
            : [];
      return (
        f.length > 0 &&
          (f.forEach((p) => {
            const m = parseInt(p.split(';')[0].split('=')[1].substring(0, 1)),
              g = JSON.parse(p.split(';')[1].split('=')[1]);
            c[`${g}Page`] = m;
          }),
          (c.total = parseInt(d))),
        { data: Object.assign(Object.assign({}, h), c), error: null }
      );
    } catch (c) {
      if (lt(c)) return { data: { clients: [] }, error: c };
      throw c;
    }
  }
  async _createOAuthClient(e) {
    try {
      return await dt(this.fetch, 'POST', `${this.url}/admin/oauth/clients`, {
        body: e,
        headers: this.headers,
        xform: (t) => ({ data: t, error: null }),
      });
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _getOAuthClient(e) {
    try {
      return await dt(
        this.fetch,
        'GET',
        `${this.url}/admin/oauth/clients/${e}`,
        { headers: this.headers, xform: (t) => ({ data: t, error: null }) }
      );
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _updateOAuthClient(e, t) {
    try {
      return await dt(
        this.fetch,
        'PUT',
        `${this.url}/admin/oauth/clients/${e}`,
        {
          body: t,
          headers: this.headers,
          xform: (i) => ({ data: i, error: null }),
        }
      );
    } catch (i) {
      if (lt(i)) return { data: null, error: i };
      throw i;
    }
  }
  async _deleteOAuthClient(e) {
    try {
      return (
        await dt(this.fetch, 'DELETE', `${this.url}/admin/oauth/clients/${e}`, {
          headers: this.headers,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _regenerateOAuthClientSecret(e) {
    try {
      return await dt(
        this.fetch,
        'POST',
        `${this.url}/admin/oauth/clients/${e}/regenerate_secret`,
        { headers: this.headers, xform: (t) => ({ data: t, error: null }) }
      );
    } catch (t) {
      if (lt(t)) return { data: null, error: t };
      throw t;
    }
  }
}
function kE(n = {}) {
  return {
    getItem: (e) => n[e] || null,
    setItem: (e, t) => {
      n[e] = t;
    },
    removeItem: (e) => {
      delete n[e];
    },
  };
}
const Jo = {
  debug: !!(
    globalThis &&
    YI() &&
    globalThis.localStorage &&
    globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'
  ),
};
class JI extends Error {
  constructor(e) {
    (super(e), (this.isAcquireTimeout = !0));
  }
}
class G4 extends JI {}
async function W4(n, e, t) {
  Jo.debug &&
    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', n, e);
  const i = new globalThis.AbortController();
  return (
    e > 0 &&
      setTimeout(() => {
        (i.abort(),
          Jo.debug &&
            console.log(
              '@supabase/gotrue-js: navigatorLock acquire timed out',
              n
            ));
      }, e),
    await Promise.resolve().then(() =>
      globalThis.navigator.locks.request(
        n,
        e === 0
          ? { mode: 'exclusive', ifAvailable: !0 }
          : { mode: 'exclusive', signal: i.signal },
        async (r) => {
          if (r) {
            Jo.debug &&
              console.log(
                '@supabase/gotrue-js: navigatorLock: acquired',
                n,
                r.name
              );
            try {
              return await t();
            } finally {
              Jo.debug &&
                console.log(
                  '@supabase/gotrue-js: navigatorLock: released',
                  n,
                  r.name
                );
            }
          } else {
            if (e === 0)
              throw (
                Jo.debug &&
                  console.log(
                    '@supabase/gotrue-js: navigatorLock: not immediately available',
                    n
                  ),
                new G4(
                  `Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`
                )
              );
            if (Jo.debug)
              try {
                const s = await globalThis.navigator.locks.query();
                console.log(
                  '@supabase/gotrue-js: Navigator LockManager state',
                  JSON.stringify(s, null, '  ')
                );
              } catch (s) {
                console.warn(
                  '@supabase/gotrue-js: Error when querying Navigator LockManager state',
                  s
                );
              }
            return (
              console.warn(
                '@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request'
              ),
              await t()
            );
          }
        }
      )
    )
  );
}
function j4() {
  if (typeof globalThis != 'object')
    try {
      (Object.defineProperty(Object.prototype, '__magic__', {
        get: function () {
          return this;
        },
        configurable: !0,
      }),
        (__magic__.globalThis = __magic__),
        delete Object.prototype.__magic__);
    } catch {
      typeof self < 'u' && (self.globalThis = self);
    }
}
function QI(n) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(n))
    throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);
  return n.toLowerCase();
}
function X4(n) {
  return parseInt(n, 16);
}
function q4(n) {
  const e = new TextEncoder().encode(n);
  return '0x' + Array.from(e, (i) => i.toString(16).padStart(2, '0')).join('');
}
function Y4(n) {
  var e;
  const {
    chainId: t,
    domain: i,
    expirationTime: r,
    issuedAt: s = new Date(),
    nonce: a,
    notBefore: o,
    requestId: l,
    resources: c,
    scheme: u,
    uri: h,
    version: d,
  } = n;
  {
    if (!Number.isInteger(t))
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`
      );
    if (!i)
      throw new Error(
        '@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.'
      );
    if (a && a.length < 8)
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${a}`
      );
    if (!h)
      throw new Error(
        '@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.'
      );
    if (d !== '1')
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${d}`
      );
    if (
      !((e = n.statement) === null || e === void 0) &&
      e.includes(`
`)
    )
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`
      );
  }
  const f = QI(n.address),
    p = u ? `${u}://${i}` : i,
    m = n.statement
      ? `${n.statement}
`
      : '',
    g = `${p} wants you to sign in with your Ethereum account:
${f}

${m}`;
  let v = `URI: ${h}
Version: ${d}
Chain ID: ${t}${
    a
      ? `
Nonce: ${a}`
      : ''
  }
Issued At: ${s.toISOString()}`;
  if (
    (r &&
      (v += `
Expiration Time: ${r.toISOString()}`),
    o &&
      (v += `
Not Before: ${o.toISOString()}`),
    l &&
      (v += `
Request ID: ${l}`),
    c)
  ) {
    let y = `
Resources:`;
    for (const _ of c) {
      if (!_ || typeof _ != 'string')
        throw new Error(
          `@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${_}`
        );
      y += `
- ${_}`;
    }
    v += y;
  }
  return `${g}
${v}`;
}
class En extends Error {
  constructor({ message: e, code: t, cause: i, name: r }) {
    var s;
    (super(e, { cause: i }),
      (this.__isWebAuthnError = !0),
      (this.name =
        (s = r ?? (i instanceof Error ? i.name : void 0)) !== null &&
        s !== void 0
          ? s
          : 'Unknown Error'),
      (this.code = t));
  }
}
class tp extends En {
  constructor(e, t) {
    (super({
      code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
      cause: t,
      message: e,
    }),
      (this.name = 'WebAuthnUnknownError'),
      (this.originalError = t));
  }
}
function K4({ error: n, options: e }) {
  var t, i, r;
  const { publicKey: s } = e;
  if (!s) throw Error('options was missing required publicKey property');
  if (n.name === 'AbortError') {
    if (e.signal instanceof AbortSignal)
      return new En({
        message: 'Registration ceremony was sent an abort signal',
        code: 'ERROR_CEREMONY_ABORTED',
        cause: n,
      });
  } else if (n.name === 'ConstraintError') {
    if (
      ((t = s.authenticatorSelection) === null || t === void 0
        ? void 0
        : t.requireResidentKey) === !0
    )
      return new En({
        message:
          'Discoverable credentials were required but no available authenticator supported it',
        code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',
        cause: n,
      });
    if (
      e.mediation === 'conditional' &&
      ((i = s.authenticatorSelection) === null || i === void 0
        ? void 0
        : i.userVerification) === 'required'
    )
      return new En({
        message:
          'User verification was required during automatic registration but it could not be performed',
        code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',
        cause: n,
      });
    if (
      ((r = s.authenticatorSelection) === null || r === void 0
        ? void 0
        : r.userVerification) === 'required'
    )
      return new En({
        message:
          'User verification was required but no available authenticator supported it',
        code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',
        cause: n,
      });
  } else {
    if (n.name === 'InvalidStateError')
      return new En({
        message: 'The authenticator was previously registered',
        code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',
        cause: n,
      });
    if (n.name === 'NotAllowedError')
      return new En({
        message: n.message,
        code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
        cause: n,
      });
    if (n.name === 'NotSupportedError')
      return s.pubKeyCredParams.filter((o) => o.type === 'public-key')
        .length === 0
        ? new En({
            message: 'No entry in pubKeyCredParams was of type "public-key"',
            code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',
            cause: n,
          })
        : new En({
            message:
              'No available authenticator supported any of the specified pubKeyCredParams algorithms',
            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',
            cause: n,
          });
    if (n.name === 'SecurityError') {
      const a = window.location.hostname;
      if (ZI(a)) {
        if (s.rp.id !== a)
          return new En({
            message: `The RP ID "${s.rp.id}" is invalid for this domain`,
            code: 'ERROR_INVALID_RP_ID',
            cause: n,
          });
      } else
        return new En({
          message: `${window.location.hostname} is an invalid domain`,
          code: 'ERROR_INVALID_DOMAIN',
          cause: n,
        });
    } else if (n.name === 'TypeError') {
      if (s.user.id.byteLength < 1 || s.user.id.byteLength > 64)
        return new En({
          message: 'User ID was not between 1 and 64 characters',
          code: 'ERROR_INVALID_USER_ID_LENGTH',
          cause: n,
        });
    } else if (n.name === 'UnknownError')
      return new En({
        message:
          'The authenticator was unable to process the specified options, or could not create a new credential',
        code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
        cause: n,
      });
  }
  return new En({
    message: 'a Non-Webauthn related error has occurred',
    code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
    cause: n,
  });
}
function J4({ error: n, options: e }) {
  const { publicKey: t } = e;
  if (!t) throw Error('options was missing required publicKey property');
  if (n.name === 'AbortError') {
    if (e.signal instanceof AbortSignal)
      return new En({
        message: 'Authentication ceremony was sent an abort signal',
        code: 'ERROR_CEREMONY_ABORTED',
        cause: n,
      });
  } else {
    if (n.name === 'NotAllowedError')
      return new En({
        message: n.message,
        code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
        cause: n,
      });
    if (n.name === 'SecurityError') {
      const i = window.location.hostname;
      if (ZI(i)) {
        if (t.rpId !== i)
          return new En({
            message: `The RP ID "${t.rpId}" is invalid for this domain`,
            code: 'ERROR_INVALID_RP_ID',
            cause: n,
          });
      } else
        return new En({
          message: `${window.location.hostname} is an invalid domain`,
          code: 'ERROR_INVALID_DOMAIN',
          cause: n,
        });
    } else if (n.name === 'UnknownError')
      return new En({
        message:
          'The authenticator was unable to process the specified options, or could not create a new assertion signature',
        code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
        cause: n,
      });
  }
  return new En({
    message: 'a Non-Webauthn related error has occurred',
    code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
    cause: n,
  });
}
class Q4 {
  createNewAbortSignal() {
    if (this.controller) {
      const t = new Error('Cancelling existing WebAuthn API call for new one');
      ((t.name = 'AbortError'), this.controller.abort(t));
    }
    const e = new AbortController();
    return ((this.controller = e), e.signal);
  }
  cancelCeremony() {
    if (this.controller) {
      const e = new Error('Manually cancelling existing WebAuthn API call');
      ((e.name = 'AbortError'),
        this.controller.abort(e),
        (this.controller = void 0));
    }
  }
}
const Z4 = new Q4();
function $4(n) {
  if (!n) throw new Error('Credential creation options are required');
  if (
    typeof PublicKeyCredential < 'u' &&
    'parseCreationOptionsFromJSON' in PublicKeyCredential &&
    typeof PublicKeyCredential.parseCreationOptionsFromJSON == 'function'
  )
    return PublicKeyCredential.parseCreationOptionsFromJSON(n);
  const { challenge: e, user: t, excludeCredentials: i } = n,
    r = mc(n, ['challenge', 'user', 'excludeCredentials']),
    s = Fl(e).buffer,
    a = Object.assign(Object.assign({}, t), { id: Fl(t.id).buffer }),
    o = Object.assign(Object.assign({}, r), { challenge: s, user: a });
  if (i && i.length > 0) {
    o.excludeCredentials = new Array(i.length);
    for (let l = 0; l < i.length; l++) {
      const c = i[l];
      o.excludeCredentials[l] = Object.assign(Object.assign({}, c), {
        id: Fl(c.id).buffer,
        type: c.type || 'public-key',
        transports: c.transports,
      });
    }
  }
  return o;
}
function eV(n) {
  if (!n) throw new Error('Credential request options are required');
  if (
    typeof PublicKeyCredential < 'u' &&
    'parseRequestOptionsFromJSON' in PublicKeyCredential &&
    typeof PublicKeyCredential.parseRequestOptionsFromJSON == 'function'
  )
    return PublicKeyCredential.parseRequestOptionsFromJSON(n);
  const { challenge: e, allowCredentials: t } = n,
    i = mc(n, ['challenge', 'allowCredentials']),
    r = Fl(e).buffer,
    s = Object.assign(Object.assign({}, i), { challenge: r });
  if (t && t.length > 0) {
    s.allowCredentials = new Array(t.length);
    for (let a = 0; a < t.length; a++) {
      const o = t[a];
      s.allowCredentials[a] = Object.assign(Object.assign({}, o), {
        id: Fl(o.id).buffer,
        type: o.type || 'public-key',
        transports: o.transports,
      });
    }
  }
  return s;
}
function tV(n) {
  var e;
  if ('toJSON' in n && typeof n.toJSON == 'function') return n.toJSON();
  const t = n;
  return {
    id: n.id,
    rawId: n.id,
    response: {
      attestationObject: co(new Uint8Array(n.response.attestationObject)),
      clientDataJSON: co(new Uint8Array(n.response.clientDataJSON)),
    },
    type: 'public-key',
    clientExtensionResults: n.getClientExtensionResults(),
    authenticatorAttachment:
      (e = t.authenticatorAttachment) !== null && e !== void 0 ? e : void 0,
  };
}
function nV(n) {
  var e;
  if ('toJSON' in n && typeof n.toJSON == 'function') return n.toJSON();
  const t = n,
    i = n.getClientExtensionResults(),
    r = n.response;
  return {
    id: n.id,
    rawId: n.id,
    response: {
      authenticatorData: co(new Uint8Array(r.authenticatorData)),
      clientDataJSON: co(new Uint8Array(r.clientDataJSON)),
      signature: co(new Uint8Array(r.signature)),
      userHandle: r.userHandle ? co(new Uint8Array(r.userHandle)) : void 0,
    },
    type: 'public-key',
    clientExtensionResults: i,
    authenticatorAttachment:
      (e = t.authenticatorAttachment) !== null && e !== void 0 ? e : void 0,
  };
}
function ZI(n) {
  return n === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n);
}
function BE() {
  var n, e;
  return !!(
    $n() &&
    'PublicKeyCredential' in window &&
    window.PublicKeyCredential &&
    'credentials' in navigator &&
    typeof ((n = navigator?.credentials) === null || n === void 0
      ? void 0
      : n.create) == 'function' &&
    typeof ((e = navigator?.credentials) === null || e === void 0
      ? void 0
      : e.get) == 'function'
  );
}
async function iV(n) {
  try {
    const e = await navigator.credentials.create(n);
    return e
      ? e instanceof PublicKeyCredential
        ? { data: e, error: null }
        : {
            data: null,
            error: new tp('Browser returned unexpected credential type', e),
          }
      : { data: null, error: new tp('Empty credential response', e) };
  } catch (e) {
    return { data: null, error: K4({ error: e, options: n }) };
  }
}
async function rV(n) {
  try {
    const e = await navigator.credentials.get(n);
    return e
      ? e instanceof PublicKeyCredential
        ? { data: e, error: null }
        : {
            data: null,
            error: new tp('Browser returned unexpected credential type', e),
          }
      : { data: null, error: new tp('Empty credential response', e) };
  } catch (e) {
    return { data: null, error: J4({ error: e, options: n }) };
  }
}
const sV = {
    hints: ['security-key'],
    authenticatorSelection: {
      authenticatorAttachment: 'cross-platform',
      requireResidentKey: !1,
      userVerification: 'preferred',
      residentKey: 'discouraged',
    },
    attestation: 'none',
  },
  aV = { userVerification: 'preferred', hints: ['security-key'] };
function np(...n) {
  const e = (r) => r !== null && typeof r == 'object' && !Array.isArray(r),
    t = (r) => r instanceof ArrayBuffer || ArrayBuffer.isView(r),
    i = {};
  for (const r of n)
    if (r)
      for (const s in r) {
        const a = r[s];
        if (a !== void 0)
          if (Array.isArray(a)) i[s] = a;
          else if (t(a)) i[s] = a;
          else if (e(a)) {
            const o = i[s];
            e(o) ? (i[s] = np(o, a)) : (i[s] = np(a));
          } else i[s] = a;
      }
  return i;
}
function oV(n, e) {
  return np(sV, n, e || {});
}
function lV(n, e) {
  return np(aV, n, e || {});
}
class cV {
  constructor(e) {
    ((this.client = e),
      (this.enroll = this._enroll.bind(this)),
      (this.challenge = this._challenge.bind(this)),
      (this.verify = this._verify.bind(this)),
      (this.authenticate = this._authenticate.bind(this)),
      (this.register = this._register.bind(this)));
  }
  async _enroll(e) {
    return this.client.mfa.enroll(
      Object.assign(Object.assign({}, e), { factorType: 'webauthn' })
    );
  }
  async _challenge(
    { factorId: e, webauthn: t, friendlyName: i, signal: r },
    s
  ) {
    try {
      const { data: a, error: o } = await this.client.mfa.challenge({
        factorId: e,
        webauthn: t,
      });
      if (!a) return { data: null, error: o };
      const l = r ?? Z4.createNewAbortSignal();
      if (a.webauthn.type === 'create') {
        const { user: c } = a.webauthn.credential_options.publicKey;
        (c.name || (c.name = `${c.id}:${i}`),
          c.displayName || (c.displayName = c.name));
      }
      switch (a.webauthn.type) {
        case 'create': {
          const c = oV(a.webauthn.credential_options.publicKey, s?.create),
            { data: u, error: h } = await iV({ publicKey: c, signal: l });
          return u
            ? {
                data: {
                  factorId: e,
                  challengeId: a.id,
                  webauthn: { type: a.webauthn.type, credential_response: u },
                },
                error: null,
              }
            : { data: null, error: h };
        }
        case 'request': {
          const c = lV(a.webauthn.credential_options.publicKey, s?.request),
            { data: u, error: h } = await rV(
              Object.assign(Object.assign({}, a.webauthn.credential_options), {
                publicKey: c,
                signal: l,
              })
            );
          return u
            ? {
                data: {
                  factorId: e,
                  challengeId: a.id,
                  webauthn: { type: a.webauthn.type, credential_response: u },
                },
                error: null,
              }
            : { data: null, error: h };
        }
      }
    } catch (a) {
      return lt(a)
        ? { data: null, error: a }
        : { data: null, error: new io('Unexpected error in challenge', a) };
    }
  }
  async _verify({ challengeId: e, factorId: t, webauthn: i }) {
    return this.client.mfa.verify({ factorId: t, challengeId: e, webauthn: i });
  }
  async _authenticate(
    {
      factorId: e,
      webauthn: {
        rpId: t = typeof window < 'u' ? window.location.hostname : void 0,
        rpOrigins: i = typeof window < 'u' ? [window.location.origin] : void 0,
        signal: r,
      },
    },
    s
  ) {
    if (!t)
      return {
        data: null,
        error: new $u('rpId is required for WebAuthn authentication'),
      };
    try {
      if (!BE())
        return {
          data: null,
          error: new io('Browser does not support WebAuthn', null),
        };
      const { data: a, error: o } = await this.challenge(
        { factorId: e, webauthn: { rpId: t, rpOrigins: i }, signal: r },
        { request: s }
      );
      if (!a) return { data: null, error: o };
      const { webauthn: l } = a;
      return this._verify({
        factorId: e,
        challengeId: a.challengeId,
        webauthn: {
          type: l.type,
          rpId: t,
          rpOrigins: i,
          credential_response: l.credential_response,
        },
      });
    } catch (a) {
      return lt(a)
        ? { data: null, error: a }
        : { data: null, error: new io('Unexpected error in authenticate', a) };
    }
  }
  async _register(
    {
      friendlyName: e,
      rpId: t = typeof window < 'u' ? window.location.hostname : void 0,
      rpOrigins: i = typeof window < 'u' ? [window.location.origin] : void 0,
      signal: r,
    },
    s
  ) {
    if (!t)
      return {
        data: null,
        error: new $u('rpId is required for WebAuthn registration'),
      };
    try {
      if (!BE())
        return {
          data: null,
          error: new io('Browser does not support WebAuthn', null),
        };
      const { data: a, error: o } = await this._enroll({ friendlyName: e });
      if (!a)
        return (
          await this.client.mfa
            .listFactors()
            .then((u) => {
              var h;
              return (h = u.data) === null || h === void 0
                ? void 0
                : h.all.find(
                    (d) =>
                      d.factor_type === 'webauthn' &&
                      d.friendly_name === e &&
                      d.status !== 'unverified'
                  );
            })
            .then((u) =>
              u ? this.client.mfa.unenroll({ factorId: u?.id }) : void 0
            ),
          { data: null, error: o }
        );
      const { data: l, error: c } = await this._challenge(
        {
          factorId: a.id,
          friendlyName: a.friendly_name,
          webauthn: { rpId: t, rpOrigins: i },
          signal: r,
        },
        { create: s }
      );
      return l
        ? this._verify({
            factorId: a.id,
            challengeId: l.challengeId,
            webauthn: {
              rpId: t,
              rpOrigins: i,
              type: l.webauthn.type,
              credential_response: l.webauthn.credential_response,
            },
          })
        : { data: null, error: c };
    } catch (a) {
      return lt(a)
        ? { data: null, error: a }
        : { data: null, error: new io('Unexpected error in register', a) };
    }
  }
}
j4();
const uV = {
  url: a4,
  storageKey: o4,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: l4,
  flowType: 'implicit',
  debug: !1,
  hasCustomAuthorizationHeader: !1,
  throwOnError: !1,
};
async function NE(n, e, t) {
  return await t();
}
const Qo = {};
class eh {
  get jwks() {
    var e, t;
    return (t =
      (e = Qo[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !==
      null && t !== void 0
      ? t
      : { keys: [] };
  }
  set jwks(e) {
    Qo[this.storageKey] = Object.assign(
      Object.assign({}, Qo[this.storageKey]),
      { jwks: e }
    );
  }
  get jwks_cached_at() {
    var e, t;
    return (t =
      (e = Qo[this.storageKey]) === null || e === void 0
        ? void 0
        : e.cachedAt) !== null && t !== void 0
      ? t
      : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(e) {
    Qo[this.storageKey] = Object.assign(
      Object.assign({}, Qo[this.storageKey]),
      { cachedAt: e }
    );
  }
  constructor(e) {
    var t, i, r;
    ((this.userStorage = null),
      (this.memoryStorage = null),
      (this.stateChangeEmitters = new Map()),
      (this.autoRefreshTicker = null),
      (this.visibilityChangedCallback = null),
      (this.refreshingDeferred = null),
      (this.initializePromise = null),
      (this.detectSessionInUrl = !0),
      (this.hasCustomAuthorizationHeader = !1),
      (this.suppressGetSessionWarning = !1),
      (this.lockAcquired = !1),
      (this.pendingInLock = []),
      (this.broadcastChannel = null),
      (this.logger = console.log));
    const s = Object.assign(Object.assign({}, uV), e);
    if (
      ((this.storageKey = s.storageKey),
      (this.instanceID =
        (t = eh.nextInstanceID[this.storageKey]) !== null && t !== void 0
          ? t
          : 0),
      (eh.nextInstanceID[this.storageKey] = this.instanceID + 1),
      (this.logDebugMessages = !!s.debug),
      typeof s.debug == 'function' && (this.logger = s.debug),
      this.instanceID > 0 && $n())
    ) {
      const a = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
      (console.warn(a), this.logDebugMessages && console.trace(a));
    }
    if (
      ((this.persistSession = s.persistSession),
      (this.autoRefreshToken = s.autoRefreshToken),
      (this.admin = new H4({ url: s.url, headers: s.headers, fetch: s.fetch })),
      (this.url = s.url),
      (this.headers = s.headers),
      (this.fetch = KI(s.fetch)),
      (this.lock = s.lock || NE),
      (this.detectSessionInUrl = s.detectSessionInUrl),
      (this.flowType = s.flowType),
      (this.hasCustomAuthorizationHeader = s.hasCustomAuthorizationHeader),
      (this.throwOnError = s.throwOnError),
      s.lock
        ? (this.lock = s.lock)
        : $n() &&
            !((i = globalThis?.navigator) === null || i === void 0) &&
            i.locks
          ? (this.lock = W4)
          : (this.lock = NE),
      this.jwks ||
        ((this.jwks = { keys: [] }),
        (this.jwks_cached_at = Number.MIN_SAFE_INTEGER)),
      (this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel:
          this._getAuthenticatorAssuranceLevel.bind(this),
        webauthn: new cV(this),
      }),
      (this.oauth = {
        getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
        approveAuthorization: this._approveAuthorization.bind(this),
        denyAuthorization: this._denyAuthorization.bind(this),
      }),
      this.persistSession
        ? (s.storage
            ? (this.storage = s.storage)
            : YI()
              ? (this.storage = globalThis.localStorage)
              : ((this.memoryStorage = {}),
                (this.storage = kE(this.memoryStorage))),
          s.userStorage && (this.userStorage = s.userStorage))
        : ((this.memoryStorage = {}), (this.storage = kE(this.memoryStorage))),
      $n() &&
        globalThis.BroadcastChannel &&
        this.persistSession &&
        this.storageKey)
    ) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(
          this.storageKey
        );
      } catch (a) {
        console.error(
          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',
          a
        );
      }
      (r = this.broadcastChannel) === null ||
        r === void 0 ||
        r.addEventListener('message', async (a) => {
          (this._debug(
            'received broadcast notification from other tab or client',
            a
          ),
            await this._notifyAllSubscribers(a.data.event, a.data.session, !1));
        });
    }
    this.initialize();
  }
  isThrowOnErrorEnabled() {
    return this.throwOnError;
  }
  _returnResult(e) {
    if (this.throwOnError && e && e.error) throw e.error;
    return e;
  }
  _logPrefix() {
    return `GoTrueClient@${this.storageKey}:${this.instanceID} (${jI}) ${new Date().toISOString()}`;
  }
  _debug(...e) {
    return (
      this.logDebugMessages && this.logger(this._logPrefix(), ...e),
      this
    );
  }
  async initialize() {
    return this.initializePromise
      ? await this.initializePromise
      : ((this.initializePromise = (async () =>
          await this._acquireLock(-1, async () => await this._initialize()))()),
        await this.initializePromise);
  }
  async _initialize() {
    var e;
    try {
      let t = {},
        i = 'none';
      if (
        ($n() &&
          ((t = S4(window.location.href)),
          this._isImplicitGrantCallback(t)
            ? (i = 'implicit')
            : (await this._isPKCECallback(t)) && (i = 'pkce')),
        $n() && this.detectSessionInUrl && i !== 'none')
      ) {
        const { data: r, error: s } = await this._getSessionFromURL(t, i);
        if (s) {
          if (
            (this._debug(
              '#_initialize()',
              'error detecting session from URL',
              s
            ),
            p4(s))
          ) {
            const l =
              (e = s.details) === null || e === void 0 ? void 0 : e.code;
            if (
              l === 'identity_already_exists' ||
              l === 'identity_not_found' ||
              l === 'single_identity_not_deletable'
            )
              return { error: s };
          }
          return (await this._removeSession(), { error: s });
        }
        const { session: a, redirectType: o } = r;
        return (
          this._debug(
            '#_initialize()',
            'detected session in URL',
            a,
            'redirect type',
            o
          ),
          await this._saveSession(a),
          setTimeout(async () => {
            o === 'recovery'
              ? await this._notifyAllSubscribers('PASSWORD_RECOVERY', a)
              : await this._notifyAllSubscribers('SIGNED_IN', a);
          }, 0),
          { error: null }
        );
      }
      return (await this._recoverAndRefresh(), { error: null });
    } catch (t) {
      return lt(t)
        ? this._returnResult({ error: t })
        : this._returnResult({
            error: new io('Unexpected error during initialization', t),
          });
    } finally {
      (await this._handleVisibilityChange(),
        this._debug('#_initialize()', 'end'));
    }
  }
  async signInAnonymously(e) {
    var t, i, r;
    try {
      const s = await dt(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data:
              (i =
                (t = e?.options) === null || t === void 0 ? void 0 : t.data) !==
                null && i !== void 0
                ? i
                : {},
            gotrue_meta_security: {
              captcha_token:
                (r = e?.options) === null || r === void 0
                  ? void 0
                  : r.captchaToken,
            },
          },
          xform: vr,
        }),
        { data: a, error: o } = s;
      if (o || !a)
        return this._returnResult({
          data: { user: null, session: null },
          error: o,
        });
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers('SIGNED_IN', l)),
        this._returnResult({ data: { user: c, session: l }, error: null })
      );
    } catch (s) {
      if (lt(s))
        return this._returnResult({
          data: { user: null, session: null },
          error: s,
        });
      throw s;
    }
  }
  async signUp(e) {
    var t, i, r;
    try {
      let s;
      if ('email' in e) {
        const { email: u, password: h, options: d } = e;
        let f = null,
          p = null;
        (this.flowType === 'pkce' &&
          ([f, p] = await Yo(this.storage, this.storageKey)),
          (s = await dt(this.fetch, 'POST', `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: d?.emailRedirectTo,
            body: {
              email: u,
              password: h,
              data: (t = d?.data) !== null && t !== void 0 ? t : {},
              gotrue_meta_security: { captcha_token: d?.captchaToken },
              code_challenge: f,
              code_challenge_method: p,
            },
            xform: vr,
          })));
      } else if ('phone' in e) {
        const { phone: u, password: h, options: d } = e;
        s = await dt(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: u,
            password: h,
            data: (i = d?.data) !== null && i !== void 0 ? i : {},
            channel: (r = d?.channel) !== null && r !== void 0 ? r : 'sms',
            gotrue_meta_security: { captcha_token: d?.captchaToken },
          },
          xform: vr,
        });
      } else
        throw new pd(
          'You must provide either an email or phone number and a password'
        );
      const { data: a, error: o } = s;
      if (o || !a)
        return this._returnResult({
          data: { user: null, session: null },
          error: o,
        });
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers('SIGNED_IN', l)),
        this._returnResult({ data: { user: c, session: l }, error: null })
      );
    } catch (s) {
      if (lt(s))
        return this._returnResult({
          data: { user: null, session: null },
          error: s,
        });
      throw s;
    }
  }
  async signInWithPassword(e) {
    try {
      let t;
      if ('email' in e) {
        const { email: s, password: a, options: o } = e;
        t = await dt(
          this.fetch,
          'POST',
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              email: s,
              password: a,
              gotrue_meta_security: { captcha_token: o?.captchaToken },
            },
            xform: LE,
          }
        );
      } else if ('phone' in e) {
        const { phone: s, password: a, options: o } = e;
        t = await dt(
          this.fetch,
          'POST',
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              phone: s,
              password: a,
              gotrue_meta_security: { captcha_token: o?.captchaToken },
            },
            xform: LE,
          }
        );
      } else
        throw new pd(
          'You must provide either an email or phone number and a password'
        );
      const { data: i, error: r } = t;
      if (r)
        return this._returnResult({
          data: { user: null, session: null },
          error: r,
        });
      if (!i || !i.session || !i.user) {
        const s = new qo();
        return this._returnResult({
          data: { user: null, session: null },
          error: s,
        });
      }
      return (
        i.session &&
          (await this._saveSession(i.session),
          await this._notifyAllSubscribers('SIGNED_IN', i.session)),
        this._returnResult({
          data: Object.assign(
            { user: i.user, session: i.session },
            i.weak_password ? { weakPassword: i.weak_password } : null
          ),
          error: r,
        })
      );
    } catch (t) {
      if (lt(t))
        return this._returnResult({
          data: { user: null, session: null },
          error: t,
        });
      throw t;
    }
  }
  async signInWithOAuth(e) {
    var t, i, r, s;
    return await this._handleProviderSignIn(e.provider, {
      redirectTo:
        (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo,
      scopes: (i = e.options) === null || i === void 0 ? void 0 : i.scopes,
      queryParams:
        (r = e.options) === null || r === void 0 ? void 0 : r.queryParams,
      skipBrowserRedirect:
        (s = e.options) === null || s === void 0
          ? void 0
          : s.skipBrowserRedirect,
    });
  }
  async exchangeCodeForSession(e) {
    return (
      await this.initializePromise,
      this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    );
  }
  async signInWithWeb3(e) {
    const { chain: t } = e;
    switch (t) {
      case 'ethereum':
        return await this.signInWithEthereum(e);
      case 'solana':
        return await this.signInWithSolana(e);
      default:
        throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`);
    }
  }
  async signInWithEthereum(e) {
    var t, i, r, s, a, o, l, c, u, h, d;
    let f, p;
    if ('message' in e) ((f = e.message), (p = e.signature));
    else {
      const { chain: m, wallet: g, statement: v, options: y } = e;
      let _;
      if ($n())
        if (typeof g == 'object') _ = g;
        else {
          const w = window;
          if (
            'ethereum' in w &&
            typeof w.ethereum == 'object' &&
            'request' in w.ethereum &&
            typeof w.ethereum.request == 'function'
          )
            _ = w.ethereum;
          else
            throw new Error(
              "@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead."
            );
        }
      else {
        if (typeof g != 'object' || !y?.url)
          throw new Error(
            '@supabase/auth-js: Both wallet and url must be specified in non-browser environments.'
          );
        _ = g;
      }
      const x = new URL(
          (t = y?.url) !== null && t !== void 0 ? t : window.location.href
        ),
        S = await _.request({ method: 'eth_requestAccounts' })
          .then((w) => w)
          .catch(() => {
            throw new Error(
              '@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid'
            );
          });
      if (!S || S.length === 0)
        throw new Error(
          '@supabase/auth-js: No accounts available. Please ensure the wallet is connected.'
        );
      const b = QI(S[0]);
      let A =
        (i = y?.signInWithEthereum) === null || i === void 0
          ? void 0
          : i.chainId;
      if (!A) {
        const w = await _.request({ method: 'eth_chainId' });
        A = X4(w);
      }
      const E = {
        domain: x.host,
        address: b,
        statement: v,
        uri: x.href,
        version: '1',
        chainId: A,
        nonce:
          (r = y?.signInWithEthereum) === null || r === void 0
            ? void 0
            : r.nonce,
        issuedAt:
          (a =
            (s = y?.signInWithEthereum) === null || s === void 0
              ? void 0
              : s.issuedAt) !== null && a !== void 0
            ? a
            : new Date(),
        expirationTime:
          (o = y?.signInWithEthereum) === null || o === void 0
            ? void 0
            : o.expirationTime,
        notBefore:
          (l = y?.signInWithEthereum) === null || l === void 0
            ? void 0
            : l.notBefore,
        requestId:
          (c = y?.signInWithEthereum) === null || c === void 0
            ? void 0
            : c.requestId,
        resources:
          (u = y?.signInWithEthereum) === null || u === void 0
            ? void 0
            : u.resources,
      };
      ((f = Y4(E)),
        (p = await _.request({ method: 'personal_sign', params: [q4(f), b] })));
    }
    try {
      const { data: m, error: g } = await dt(
        this.fetch,
        'POST',
        `${this.url}/token?grant_type=web3`,
        {
          headers: this.headers,
          body: Object.assign(
            { chain: 'ethereum', message: f, signature: p },
            !((h = e.options) === null || h === void 0) && h.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token:
                      (d = e.options) === null || d === void 0
                        ? void 0
                        : d.captchaToken,
                  },
                }
              : null
          ),
          xform: vr,
        }
      );
      if (g) throw g;
      if (!m || !m.session || !m.user) {
        const v = new qo();
        return this._returnResult({
          data: { user: null, session: null },
          error: v,
        });
      }
      return (
        m.session &&
          (await this._saveSession(m.session),
          await this._notifyAllSubscribers('SIGNED_IN', m.session)),
        this._returnResult({ data: Object.assign({}, m), error: g })
      );
    } catch (m) {
      if (lt(m))
        return this._returnResult({
          data: { user: null, session: null },
          error: m,
        });
      throw m;
    }
  }
  async signInWithSolana(e) {
    var t, i, r, s, a, o, l, c, u, h, d, f;
    let p, m;
    if ('message' in e) ((p = e.message), (m = e.signature));
    else {
      const { chain: g, wallet: v, statement: y, options: _ } = e;
      let x;
      if ($n())
        if (typeof v == 'object') x = v;
        else {
          const b = window;
          if (
            'solana' in b &&
            typeof b.solana == 'object' &&
            (('signIn' in b.solana && typeof b.solana.signIn == 'function') ||
              ('signMessage' in b.solana &&
                typeof b.solana.signMessage == 'function'))
          )
            x = b.solana;
          else
            throw new Error(
              "@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead."
            );
        }
      else {
        if (typeof v != 'object' || !_?.url)
          throw new Error(
            '@supabase/auth-js: Both wallet and url must be specified in non-browser environments.'
          );
        x = v;
      }
      const S = new URL(
        (t = _?.url) !== null && t !== void 0 ? t : window.location.href
      );
      if ('signIn' in x && x.signIn) {
        const b = await x.signIn(
          Object.assign(
            Object.assign(
              Object.assign(
                { issuedAt: new Date().toISOString() },
                _?.signInWithSolana
              ),
              { version: '1', domain: S.host, uri: S.href }
            ),
            y ? { statement: y } : null
          )
        );
        let A;
        if (Array.isArray(b) && b[0] && typeof b[0] == 'object') A = b[0];
        else if (
          b &&
          typeof b == 'object' &&
          'signedMessage' in b &&
          'signature' in b
        )
          A = b;
        else
          throw new Error(
            '@supabase/auth-js: Wallet method signIn() returned unrecognized value'
          );
        if (
          'signedMessage' in A &&
          'signature' in A &&
          (typeof A.signedMessage == 'string' ||
            A.signedMessage instanceof Uint8Array) &&
          A.signature instanceof Uint8Array
        )
          ((p =
            typeof A.signedMessage == 'string'
              ? A.signedMessage
              : new TextDecoder().decode(A.signedMessage)),
            (m = A.signature));
        else
          throw new Error(
            '@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields'
          );
      } else {
        if (
          !('signMessage' in x) ||
          typeof x.signMessage != 'function' ||
          !('publicKey' in x) ||
          typeof x != 'object' ||
          !x.publicKey ||
          !('toBase58' in x.publicKey) ||
          typeof x.publicKey.toBase58 != 'function'
        )
          throw new Error(
            '@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API'
          );
        p = [
          `${S.host} wants you to sign in with your Solana account:`,
          x.publicKey.toBase58(),
          ...(y ? ['', y, ''] : ['']),
          'Version: 1',
          `URI: ${S.href}`,
          `Issued At: ${(r = (i = _?.signInWithSolana) === null || i === void 0 ? void 0 : i.issuedAt) !== null && r !== void 0 ? r : new Date().toISOString()}`,
          ...(!((s = _?.signInWithSolana) === null || s === void 0) &&
          s.notBefore
            ? [`Not Before: ${_.signInWithSolana.notBefore}`]
            : []),
          ...(!((a = _?.signInWithSolana) === null || a === void 0) &&
          a.expirationTime
            ? [`Expiration Time: ${_.signInWithSolana.expirationTime}`]
            : []),
          ...(!((o = _?.signInWithSolana) === null || o === void 0) && o.chainId
            ? [`Chain ID: ${_.signInWithSolana.chainId}`]
            : []),
          ...(!((l = _?.signInWithSolana) === null || l === void 0) && l.nonce
            ? [`Nonce: ${_.signInWithSolana.nonce}`]
            : []),
          ...(!((c = _?.signInWithSolana) === null || c === void 0) &&
          c.requestId
            ? [`Request ID: ${_.signInWithSolana.requestId}`]
            : []),
          ...(!(
            (h =
              (u = _?.signInWithSolana) === null || u === void 0
                ? void 0
                : u.resources) === null || h === void 0
          ) && h.length
            ? [
                'Resources',
                ..._.signInWithSolana.resources.map((A) => `- ${A}`),
              ]
            : []),
        ].join(`
`);
        const b = await x.signMessage(new TextEncoder().encode(p), 'utf8');
        if (!b || !(b instanceof Uint8Array))
          throw new Error(
            '@supabase/auth-js: Wallet signMessage() API returned an recognized value'
          );
        m = b;
      }
    }
    try {
      const { data: g, error: v } = await dt(
        this.fetch,
        'POST',
        `${this.url}/token?grant_type=web3`,
        {
          headers: this.headers,
          body: Object.assign(
            { chain: 'solana', message: p, signature: co(m) },
            !((d = e.options) === null || d === void 0) && d.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token:
                      (f = e.options) === null || f === void 0
                        ? void 0
                        : f.captchaToken,
                  },
                }
              : null
          ),
          xform: vr,
        }
      );
      if (v) throw v;
      if (!g || !g.session || !g.user) {
        const y = new qo();
        return this._returnResult({
          data: { user: null, session: null },
          error: y,
        });
      }
      return (
        g.session &&
          (await this._saveSession(g.session),
          await this._notifyAllSubscribers('SIGNED_IN', g.session)),
        this._returnResult({ data: Object.assign({}, g), error: v })
      );
    } catch (g) {
      if (lt(g))
        return this._returnResult({
          data: { user: null, session: null },
          error: g,
        });
      throw g;
    }
  }
  async _exchangeCodeForSession(e) {
    const t = await Ua(this.storage, `${this.storageKey}-code-verifier`),
      [i, r] = (t ?? '').split('/');
    try {
      const { data: s, error: a } = await dt(
        this.fetch,
        'POST',
        `${this.url}/token?grant_type=pkce`,
        {
          headers: this.headers,
          body: { auth_code: e, code_verifier: i },
          xform: vr,
        }
      );
      if ((await Ss(this.storage, `${this.storageKey}-code-verifier`), a))
        throw a;
      if (!s || !s.session || !s.user) {
        const o = new qo();
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: o,
        });
      }
      return (
        s.session &&
          (await this._saveSession(s.session),
          await this._notifyAllSubscribers('SIGNED_IN', s.session)),
        this._returnResult({
          data: Object.assign(Object.assign({}, s), {
            redirectType: r ?? null,
          }),
          error: a,
        })
      );
    } catch (s) {
      if (lt(s))
        return this._returnResult({
          data: { user: null, session: null, redirectType: null },
          error: s,
        });
      throw s;
    }
  }
  async signInWithIdToken(e) {
    try {
      const {
          options: t,
          provider: i,
          token: r,
          access_token: s,
          nonce: a,
        } = e,
        o = await dt(
          this.fetch,
          'POST',
          `${this.url}/token?grant_type=id_token`,
          {
            headers: this.headers,
            body: {
              provider: i,
              id_token: r,
              access_token: s,
              nonce: a,
              gotrue_meta_security: { captcha_token: t?.captchaToken },
            },
            xform: vr,
          }
        ),
        { data: l, error: c } = o;
      if (c)
        return this._returnResult({
          data: { user: null, session: null },
          error: c,
        });
      if (!l || !l.session || !l.user) {
        const u = new qo();
        return this._returnResult({
          data: { user: null, session: null },
          error: u,
        });
      }
      return (
        l.session &&
          (await this._saveSession(l.session),
          await this._notifyAllSubscribers('SIGNED_IN', l.session)),
        this._returnResult({ data: l, error: c })
      );
    } catch (t) {
      if (lt(t))
        return this._returnResult({
          data: { user: null, session: null },
          error: t,
        });
      throw t;
    }
  }
  async signInWithOtp(e) {
    var t, i, r, s, a;
    try {
      if ('email' in e) {
        const { email: o, options: l } = e;
        let c = null,
          u = null;
        this.flowType === 'pkce' &&
          ([c, u] = await Yo(this.storage, this.storageKey));
        const { error: h } = await dt(this.fetch, 'POST', `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: o,
            data: (t = l?.data) !== null && t !== void 0 ? t : {},
            create_user:
              (i = l?.shouldCreateUser) !== null && i !== void 0 ? i : !0,
            gotrue_meta_security: { captcha_token: l?.captchaToken },
            code_challenge: c,
            code_challenge_method: u,
          },
          redirectTo: l?.emailRedirectTo,
        });
        return this._returnResult({
          data: { user: null, session: null },
          error: h,
        });
      }
      if ('phone' in e) {
        const { phone: o, options: l } = e,
          { data: c, error: u } = await dt(
            this.fetch,
            'POST',
            `${this.url}/otp`,
            {
              headers: this.headers,
              body: {
                phone: o,
                data: (r = l?.data) !== null && r !== void 0 ? r : {},
                create_user:
                  (s = l?.shouldCreateUser) !== null && s !== void 0 ? s : !0,
                gotrue_meta_security: { captcha_token: l?.captchaToken },
                channel: (a = l?.channel) !== null && a !== void 0 ? a : 'sms',
              },
            }
          );
        return this._returnResult({
          data: { user: null, session: null, messageId: c?.message_id },
          error: u,
        });
      }
      throw new pd('You must provide either an email or phone number.');
    } catch (o) {
      if (lt(o))
        return this._returnResult({
          data: { user: null, session: null },
          error: o,
        });
      throw o;
    }
  }
  async verifyOtp(e) {
    var t, i;
    try {
      let r, s;
      'options' in e &&
        ((r = (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo),
        (s =
          (i = e.options) === null || i === void 0 ? void 0 : i.captchaToken));
      const { data: a, error: o } = await dt(
        this.fetch,
        'POST',
        `${this.url}/verify`,
        {
          headers: this.headers,
          body: Object.assign(Object.assign({}, e), {
            gotrue_meta_security: { captcha_token: s },
          }),
          redirectTo: r,
          xform: vr,
        }
      );
      if (o) throw o;
      if (!a) throw new Error('An error occurred on token verification.');
      const l = a.session,
        c = a.user;
      return (
        l?.access_token &&
          (await this._saveSession(l),
          await this._notifyAllSubscribers(
            e.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN',
            l
          )),
        this._returnResult({ data: { user: c, session: l }, error: null })
      );
    } catch (r) {
      if (lt(r))
        return this._returnResult({
          data: { user: null, session: null },
          error: r,
        });
      throw r;
    }
  }
  async signInWithSSO(e) {
    var t, i, r;
    try {
      let s = null,
        a = null;
      this.flowType === 'pkce' &&
        ([s, a] = await Yo(this.storage, this.storageKey));
      const o = await dt(this.fetch, 'POST', `${this.url}/sso`, {
        body: Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  {},
                  'providerId' in e ? { provider_id: e.providerId } : null
                ),
                'domain' in e ? { domain: e.domain } : null
              ),
              {
                redirect_to:
                  (i =
                    (t = e.options) === null || t === void 0
                      ? void 0
                      : t.redirectTo) !== null && i !== void 0
                    ? i
                    : void 0,
              }
            ),
            !((r = e?.options) === null || r === void 0) && r.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token: e.options.captchaToken,
                  },
                }
              : null
          ),
          {
            skip_http_redirect: !0,
            code_challenge: s,
            code_challenge_method: a,
          }
        ),
        headers: this.headers,
        xform: F4,
      });
      return this._returnResult(o);
    } catch (s) {
      if (lt(s)) return this._returnResult({ data: null, error: s });
      throw s;
    }
  }
  async reauthenticate() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._reauthenticate())
    );
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (e) => {
        const {
          data: { session: t },
          error: i,
        } = e;
        if (i) throw i;
        if (!t) throw new gr();
        const { error: r } = await dt(
          this.fetch,
          'GET',
          `${this.url}/reauthenticate`,
          { headers: this.headers, jwt: t.access_token }
        );
        return this._returnResult({
          data: { user: null, session: null },
          error: r,
        });
      });
    } catch (e) {
      if (lt(e))
        return this._returnResult({
          data: { user: null, session: null },
          error: e,
        });
      throw e;
    }
  }
  async resend(e) {
    try {
      const t = `${this.url}/resend`;
      if ('email' in e) {
        const { email: i, type: r, options: s } = e,
          { error: a } = await dt(this.fetch, 'POST', t, {
            headers: this.headers,
            body: {
              email: i,
              type: r,
              gotrue_meta_security: { captcha_token: s?.captchaToken },
            },
            redirectTo: s?.emailRedirectTo,
          });
        return this._returnResult({
          data: { user: null, session: null },
          error: a,
        });
      } else if ('phone' in e) {
        const { phone: i, type: r, options: s } = e,
          { data: a, error: o } = await dt(this.fetch, 'POST', t, {
            headers: this.headers,
            body: {
              phone: i,
              type: r,
              gotrue_meta_security: { captcha_token: s?.captchaToken },
            },
          });
        return this._returnResult({
          data: { user: null, session: null, messageId: a?.message_id },
          error: o,
        });
      }
      throw new pd(
        'You must provide either an email or phone number and a type'
      );
    } catch (t) {
      if (lt(t))
        return this._returnResult({
          data: { user: null, session: null },
          error: t,
        });
      throw t;
    }
  }
  async getSession() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => this._useSession(async (t) => t))
    );
  }
  async _acquireLock(e, t) {
    this._debug('#_acquireLock', 'begin', e);
    try {
      if (this.lockAcquired) {
        const i = this.pendingInLock.length
            ? this.pendingInLock[this.pendingInLock.length - 1]
            : Promise.resolve(),
          r = (async () => (await i, await t()))();
        return (
          this.pendingInLock.push(
            (async () => {
              try {
                await r;
              } catch {}
            })()
          ),
          r
        );
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug(
          '#_acquireLock',
          'lock acquired for storage key',
          this.storageKey
        );
        try {
          this.lockAcquired = !0;
          const i = t();
          for (
            this.pendingInLock.push(
              (async () => {
                try {
                  await i;
                } catch {}
              })()
            ),
              await i;
            this.pendingInLock.length;

          ) {
            const r = [...this.pendingInLock];
            (await Promise.all(r), this.pendingInLock.splice(0, r.length));
          }
          return await i;
        } finally {
          (this._debug(
            '#_acquireLock',
            'lock released for storage key',
            this.storageKey
          ),
            (this.lockAcquired = !1));
        }
      });
    } finally {
      this._debug('#_acquireLock', 'end');
    }
  }
  async _useSession(e) {
    this._debug('#_useSession', 'begin');
    try {
      const t = await this.__loadSession();
      return await e(t);
    } finally {
      this._debug('#_useSession', 'end');
    }
  }
  async __loadSession() {
    (this._debug('#__loadSession()', 'begin'),
      this.lockAcquired ||
        this._debug(
          '#__loadSession()',
          'used outside of an acquired lock!',
          new Error().stack
        ));
    try {
      let e = null;
      const t = await Ua(this.storage, this.storageKey);
      if (
        (this._debug('#getSession()', 'session from storage', t),
        t !== null &&
          (this._isValidSession(t)
            ? (e = t)
            : (this._debug(
                '#getSession()',
                'session from storage is not valid'
              ),
              await this._removeSession())),
        !e)
      )
        return { data: { session: null }, error: null };
      const i = e.expires_at ? e.expires_at * 1e3 - Date.now() < Qg : !1;
      if (
        (this._debug(
          '#__loadSession()',
          `session has${i ? '' : ' not'} expired`,
          'expires_at',
          e.expires_at
        ),
        !i)
      ) {
        if (this.userStorage) {
          const a = await Ua(this.userStorage, this.storageKey + '-user');
          a?.user ? (e.user = a.user) : (e.user = e0());
        }
        if (
          this.storage.isServer &&
          e.user &&
          !e.user.__isUserNotAvailableProxy
        ) {
          const a = { value: this.suppressGetSessionWarning };
          ((e.user = U4(e.user, a)),
            a.value && (this.suppressGetSessionWarning = !0));
        }
        return { data: { session: e }, error: null };
      }
      const { data: r, error: s } = await this._callRefreshToken(
        e.refresh_token
      );
      return s
        ? this._returnResult({ data: { session: null }, error: s })
        : this._returnResult({ data: { session: r }, error: null });
    } finally {
      this._debug('#__loadSession()', 'end');
    }
  }
  async getUser(e) {
    return e
      ? await this._getUser(e)
      : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(e) {
    try {
      return e
        ? await dt(this.fetch, 'GET', `${this.url}/user`, {
            headers: this.headers,
            jwt: e,
            xform: ks,
          })
        : await this._useSession(async (t) => {
            var i, r, s;
            const { data: a, error: o } = t;
            if (o) throw o;
            return !(
              !((i = a.session) === null || i === void 0) && i.access_token
            ) && !this.hasCustomAuthorizationHeader
              ? { data: { user: null }, error: new gr() }
              : await dt(this.fetch, 'GET', `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    (s =
                      (r = a.session) === null || r === void 0
                        ? void 0
                        : r.access_token) !== null && s !== void 0
                      ? s
                      : void 0,
                  xform: ks,
                });
          });
    } catch (t) {
      if (lt(t))
        return (
          f4(t) &&
            (await this._removeSession(),
            await Ss(this.storage, `${this.storageKey}-code-verifier`)),
          this._returnResult({ data: { user: null }, error: t })
        );
      throw t;
    }
  }
  async updateUser(e, t = {}) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._updateUser(e, t))
    );
  }
  async _updateUser(e, t = {}) {
    try {
      return await this._useSession(async (i) => {
        const { data: r, error: s } = i;
        if (s) throw s;
        if (!r.session) throw new gr();
        const a = r.session;
        let o = null,
          l = null;
        this.flowType === 'pkce' &&
          e.email != null &&
          ([o, l] = await Yo(this.storage, this.storageKey));
        const { data: c, error: u } = await dt(
          this.fetch,
          'PUT',
          `${this.url}/user`,
          {
            headers: this.headers,
            redirectTo: t?.emailRedirectTo,
            body: Object.assign(Object.assign({}, e), {
              code_challenge: o,
              code_challenge_method: l,
            }),
            jwt: a.access_token,
            xform: ks,
          }
        );
        if (u) throw u;
        return (
          (a.user = c.user),
          await this._saveSession(a),
          await this._notifyAllSubscribers('USER_UPDATED', a),
          this._returnResult({ data: { user: a.user }, error: null })
        );
      });
    } catch (i) {
      if (lt(i)) return this._returnResult({ data: { user: null }, error: i });
      throw i;
    }
  }
  async setSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._setSession(e))
    );
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token) throw new gr();
      const t = Date.now() / 1e3;
      let i = t,
        r = !0,
        s = null;
      const { payload: a } = $g(e.access_token);
      if ((a.exp && ((i = a.exp), (r = i <= t)), r)) {
        const { data: o, error: l } = await this._callRefreshToken(
          e.refresh_token
        );
        if (l)
          return this._returnResult({
            data: { user: null, session: null },
            error: l,
          });
        if (!o) return { data: { user: null, session: null }, error: null };
        s = o;
      } else {
        const { data: o, error: l } = await this._getUser(e.access_token);
        if (l) throw l;
        ((s = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: o.user,
          token_type: 'bearer',
          expires_in: i - t,
          expires_at: i,
        }),
          await this._saveSession(s),
          await this._notifyAllSubscribers('SIGNED_IN', s));
      }
      return this._returnResult({
        data: { user: s.user, session: s },
        error: null,
      });
    } catch (t) {
      if (lt(t))
        return this._returnResult({
          data: { session: null, user: null },
          error: t,
        });
      throw t;
    }
  }
  async refreshSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._refreshSession(e))
    );
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async (t) => {
        var i;
        if (!e) {
          const { data: a, error: o } = t;
          if (o) throw o;
          e = (i = a.session) !== null && i !== void 0 ? i : void 0;
        }
        if (!e?.refresh_token) throw new gr();
        const { data: r, error: s } = await this._callRefreshToken(
          e.refresh_token
        );
        return s
          ? this._returnResult({
              data: { user: null, session: null },
              error: s,
            })
          : r
            ? this._returnResult({
                data: { user: r.user, session: r },
                error: null,
              })
            : this._returnResult({
                data: { user: null, session: null },
                error: null,
              });
      });
    } catch (t) {
      if (lt(t))
        return this._returnResult({
          data: { user: null, session: null },
          error: t,
        });
      throw t;
    }
  }
  async _getSessionFromURL(e, t) {
    try {
      if (!$n()) throw new md('No browser detected.');
      if (e.error || e.error_description || e.error_code)
        throw new md(
          e.error_description ||
            'Error in URL with unspecified error_description',
          {
            error: e.error || 'unspecified_error',
            code: e.error_code || 'unspecified_code',
          }
        );
      switch (t) {
        case 'implicit':
          if (this.flowType === 'pkce')
            throw new TE('Not a valid PKCE flow url.');
          break;
        case 'pkce':
          if (this.flowType === 'implicit')
            throw new md('Not a valid implicit grant flow url.');
          break;
        default:
      }
      if (t === 'pkce') {
        if (
          (this._debug('#_initialize()', 'begin', 'is PKCE flow', !0), !e.code)
        )
          throw new TE('No code detected.');
        const { data: y, error: _ } = await this._exchangeCodeForSession(
          e.code
        );
        if (_) throw _;
        const x = new URL(window.location.href);
        return (
          x.searchParams.delete('code'),
          window.history.replaceState(window.history.state, '', x.toString()),
          { data: { session: y.session, redirectType: null }, error: null }
        );
      }
      const {
        provider_token: i,
        provider_refresh_token: r,
        access_token: s,
        refresh_token: a,
        expires_in: o,
        expires_at: l,
        token_type: c,
      } = e;
      if (!s || !o || !a || !c) throw new md('No session defined in URL');
      const u = Math.round(Date.now() / 1e3),
        h = parseInt(o);
      let d = u + h;
      l && (d = parseInt(l));
      const f = d - u;
      f * 1e3 <= Sl &&
        console.warn(
          `@supabase/gotrue-js: Session as retrieved from URL expires in ${f}s, should have been closer to ${h}s`
        );
      const p = d - h;
      u - p >= 120
        ? console.warn(
            '@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale',
            p,
            d,
            u
          )
        : u - p < 0 &&
          console.warn(
            '@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew',
            p,
            d,
            u
          );
      const { data: m, error: g } = await this._getUser(s);
      if (g) throw g;
      const v = {
        provider_token: i,
        provider_refresh_token: r,
        access_token: s,
        expires_in: h,
        expires_at: d,
        refresh_token: a,
        token_type: c,
        user: m.user,
      };
      return (
        (window.location.hash = ''),
        this._debug('#_getSessionFromURL()', 'clearing window.location.hash'),
        this._returnResult({
          data: { session: v, redirectType: e.type },
          error: null,
        })
      );
    } catch (i) {
      if (lt(i))
        return this._returnResult({
          data: { session: null, redirectType: null },
          error: i,
        });
      throw i;
    }
  }
  _isImplicitGrantCallback(e) {
    return !!(e.access_token || e.error_description);
  }
  async _isPKCECallback(e) {
    const t = await Ua(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && t);
  }
  async signOut(e = { scope: 'global' }) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._signOut(e))
    );
  }
  async _signOut({ scope: e } = { scope: 'global' }) {
    return await this._useSession(async (t) => {
      var i;
      const { data: r, error: s } = t;
      if (s) return this._returnResult({ error: s });
      const a =
        (i = r.session) === null || i === void 0 ? void 0 : i.access_token;
      if (a) {
        const { error: o } = await this.admin.signOut(a, e);
        if (
          o &&
          !(d4(o) && (o.status === 404 || o.status === 401 || o.status === 403))
        )
          return this._returnResult({ error: o });
      }
      return (
        e !== 'others' &&
          (await this._removeSession(),
          await Ss(this.storage, `${this.storageKey}-code-verifier`)),
        this._returnResult({ error: null })
      );
    });
  }
  onAuthStateChange(e) {
    const t = b4(),
      i = {
        id: t,
        callback: e,
        unsubscribe: () => {
          (this._debug(
            '#unsubscribe()',
            'state change callback with id removed',
            t
          ),
            this.stateChangeEmitters.delete(t));
        },
      };
    return (
      this._debug('#onAuthStateChange()', 'registered callback with id', t),
      this.stateChangeEmitters.set(t, i),
      (async () => (
        await this.initializePromise,
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(t);
        })
      ))(),
      { data: { subscription: i } }
    );
  }
  async _emitInitialSession(e) {
    return await this._useSession(async (t) => {
      var i, r;
      try {
        const {
          data: { session: s },
          error: a,
        } = t;
        if (a) throw a;
        (await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0
          ? void 0
          : i.callback('INITIAL_SESSION', s)),
          this._debug('INITIAL_SESSION', 'callback id', e, 'session', s));
      } catch (s) {
        (await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0
          ? void 0
          : r.callback('INITIAL_SESSION', null)),
          this._debug('INITIAL_SESSION', 'callback id', e, 'error', s),
          console.error(s));
      }
    });
  }
  async resetPasswordForEmail(e, t = {}) {
    let i = null,
      r = null;
    this.flowType === 'pkce' &&
      ([i, r] = await Yo(this.storage, this.storageKey, !0));
    try {
      return await dt(this.fetch, 'POST', `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: i,
          code_challenge_method: r,
          gotrue_meta_security: { captcha_token: t.captchaToken },
        },
        headers: this.headers,
        redirectTo: t.redirectTo,
      });
    } catch (s) {
      if (lt(s)) return this._returnResult({ data: null, error: s });
      throw s;
    }
  }
  async getUserIdentities() {
    var e;
    try {
      const { data: t, error: i } = await this.getUser();
      if (i) throw i;
      return this._returnResult({
        data: {
          identities: (e = t.user.identities) !== null && e !== void 0 ? e : [],
        },
        error: null,
      });
    } catch (t) {
      if (lt(t)) return this._returnResult({ data: null, error: t });
      throw t;
    }
  }
  async linkIdentity(e) {
    return 'token' in e
      ? this.linkIdentityIdToken(e)
      : this.linkIdentityOAuth(e);
  }
  async linkIdentityOAuth(e) {
    var t;
    try {
      const { data: i, error: r } = await this._useSession(async (s) => {
        var a, o, l, c, u;
        const { data: h, error: d } = s;
        if (d) throw d;
        const f = await this._getUrlForProvider(
          `${this.url}/user/identities/authorize`,
          e.provider,
          {
            redirectTo:
              (a = e.options) === null || a === void 0 ? void 0 : a.redirectTo,
            scopes:
              (o = e.options) === null || o === void 0 ? void 0 : o.scopes,
            queryParams:
              (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
            skipBrowserRedirect: !0,
          }
        );
        return await dt(this.fetch, 'GET', f, {
          headers: this.headers,
          jwt:
            (u =
              (c = h.session) === null || c === void 0
                ? void 0
                : c.access_token) !== null && u !== void 0
              ? u
              : void 0,
        });
      });
      if (r) throw r;
      return (
        $n() &&
          !(
            !((t = e.options) === null || t === void 0) && t.skipBrowserRedirect
          ) &&
          window.location.assign(i?.url),
        this._returnResult({
          data: { provider: e.provider, url: i?.url },
          error: null,
        })
      );
    } catch (i) {
      if (lt(i))
        return this._returnResult({
          data: { provider: e.provider, url: null },
          error: i,
        });
      throw i;
    }
  }
  async linkIdentityIdToken(e) {
    return await this._useSession(async (t) => {
      var i;
      try {
        const {
          error: r,
          data: { session: s },
        } = t;
        if (r) throw r;
        const {
            options: a,
            provider: o,
            token: l,
            access_token: c,
            nonce: u,
          } = e,
          h = await dt(
            this.fetch,
            'POST',
            `${this.url}/token?grant_type=id_token`,
            {
              headers: this.headers,
              jwt: (i = s?.access_token) !== null && i !== void 0 ? i : void 0,
              body: {
                provider: o,
                id_token: l,
                access_token: c,
                nonce: u,
                link_identity: !0,
                gotrue_meta_security: { captcha_token: a?.captchaToken },
              },
              xform: vr,
            }
          ),
          { data: d, error: f } = h;
        return f
          ? this._returnResult({
              data: { user: null, session: null },
              error: f,
            })
          : !d || !d.session || !d.user
            ? this._returnResult({
                data: { user: null, session: null },
                error: new qo(),
              })
            : (d.session &&
                (await this._saveSession(d.session),
                await this._notifyAllSubscribers('USER_UPDATED', d.session)),
              this._returnResult({ data: d, error: f }));
      } catch (r) {
        if (lt(r))
          return this._returnResult({
            data: { user: null, session: null },
            error: r,
          });
        throw r;
      }
    });
  }
  async unlinkIdentity(e) {
    try {
      return await this._useSession(async (t) => {
        var i, r;
        const { data: s, error: a } = t;
        if (a) throw a;
        return await dt(
          this.fetch,
          'DELETE',
          `${this.url}/user/identities/${e.identity_id}`,
          {
            headers: this.headers,
            jwt:
              (r =
                (i = s.session) === null || i === void 0
                  ? void 0
                  : i.access_token) !== null && r !== void 0
                ? r
                : void 0,
          }
        );
      });
    } catch (t) {
      if (lt(t)) return this._returnResult({ data: null, error: t });
      throw t;
    }
  }
  async _refreshAccessToken(e) {
    const t = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
    this._debug(t, 'begin');
    try {
      const i = Date.now();
      return await A4(
        async (r) => (
          r > 0 && (await E4(200 * Math.pow(2, r - 1))),
          this._debug(t, 'refreshing attempt', r),
          await dt(
            this.fetch,
            'POST',
            `${this.url}/token?grant_type=refresh_token`,
            { body: { refresh_token: e }, headers: this.headers, xform: vr }
          )
        ),
        (r, s) => {
          const a = 200 * Math.pow(2, r);
          return s && Zg(s) && Date.now() + a - i < Sl;
        }
      );
    } catch (i) {
      if ((this._debug(t, 'error', i), lt(i)))
        return this._returnResult({
          data: { session: null, user: null },
          error: i,
        });
      throw i;
    } finally {
      this._debug(t, 'end');
    }
  }
  _isValidSession(e) {
    return (
      typeof e == 'object' &&
      e !== null &&
      'access_token' in e &&
      'refresh_token' in e &&
      'expires_at' in e
    );
  }
  async _handleProviderSignIn(e, t) {
    const i = await this._getUrlForProvider(`${this.url}/authorize`, e, {
      redirectTo: t.redirectTo,
      scopes: t.scopes,
      queryParams: t.queryParams,
    });
    return (
      this._debug(
        '#_handleProviderSignIn()',
        'provider',
        e,
        'options',
        t,
        'url',
        i
      ),
      $n() && !t.skipBrowserRedirect && window.location.assign(i),
      { data: { provider: e, url: i }, error: null }
    );
  }
  async _recoverAndRefresh() {
    var e, t;
    const i = '#_recoverAndRefresh()';
    this._debug(i, 'begin');
    try {
      const r = await Ua(this.storage, this.storageKey);
      if (r && this.userStorage) {
        let a = await Ua(this.userStorage, this.storageKey + '-user');
        (!this.storage.isServer &&
          Object.is(this.storage, this.userStorage) &&
          !a &&
          ((a = { user: r.user }),
          await wl(this.userStorage, this.storageKey + '-user', a)),
          (r.user = (e = a?.user) !== null && e !== void 0 ? e : e0()));
      } else if (r && !r.user && !r.user) {
        const a = await Ua(this.storage, this.storageKey + '-user');
        a && a?.user
          ? ((r.user = a.user),
            await Ss(this.storage, this.storageKey + '-user'),
            await wl(this.storage, this.storageKey, r))
          : (r.user = e0());
      }
      if (
        (this._debug(i, 'session from storage', r), !this._isValidSession(r))
      ) {
        (this._debug(i, 'session is not valid'),
          r !== null && (await this._removeSession()));
        return;
      }
      const s =
        ((t = r.expires_at) !== null && t !== void 0 ? t : 1 / 0) * 1e3 -
          Date.now() <
        Qg;
      if (
        (this._debug(
          i,
          `session has${s ? '' : ' not'} expired with margin of ${Qg}s`
        ),
        s)
      ) {
        if (this.autoRefreshToken && r.refresh_token) {
          const { error: a } = await this._callRefreshToken(r.refresh_token);
          a &&
            (console.error(a),
            Zg(a) ||
              (this._debug(
                i,
                'refresh failed with a non-retryable error, removing the session',
                a
              ),
              await this._removeSession()));
        }
      } else if (r.user && r.user.__isUserNotAvailableProxy === !0)
        try {
          const { data: a, error: o } = await this._getUser(r.access_token);
          !o && a?.user
            ? ((r.user = a.user),
              await this._saveSession(r),
              await this._notifyAllSubscribers('SIGNED_IN', r))
            : this._debug(
                i,
                'could not get user data, skipping SIGNED_IN notification'
              );
        } catch (a) {
          (console.error('Error getting user data:', a),
            this._debug(
              i,
              'error getting user data, skipping SIGNED_IN notification',
              a
            ));
        }
      else await this._notifyAllSubscribers('SIGNED_IN', r);
    } catch (r) {
      (this._debug(i, 'error', r), console.error(r));
      return;
    } finally {
      this._debug(i, 'end');
    }
  }
  async _callRefreshToken(e) {
    var t, i;
    if (!e) throw new gr();
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const r = `#_callRefreshToken(${e.substring(0, 5)}...)`;
    this._debug(r, 'begin');
    try {
      this.refreshingDeferred = new cm();
      const { data: s, error: a } = await this._refreshAccessToken(e);
      if (a) throw a;
      if (!s.session) throw new gr();
      (await this._saveSession(s.session),
        await this._notifyAllSubscribers('TOKEN_REFRESHED', s.session));
      const o = { data: s.session, error: null };
      return (this.refreshingDeferred.resolve(o), o);
    } catch (s) {
      if ((this._debug(r, 'error', s), lt(s))) {
        const a = { data: null, error: s };
        return (
          Zg(s) || (await this._removeSession()),
          (t = this.refreshingDeferred) === null ||
            t === void 0 ||
            t.resolve(a),
          a
        );
      }
      throw (
        (i = this.refreshingDeferred) === null || i === void 0 || i.reject(s),
        s
      );
    } finally {
      ((this.refreshingDeferred = null), this._debug(r, 'end'));
    }
  }
  async _notifyAllSubscribers(e, t, i = !0) {
    const r = `#_notifyAllSubscribers(${e})`;
    this._debug(r, 'begin', t, `broadcast = ${i}`);
    try {
      this.broadcastChannel &&
        i &&
        this.broadcastChannel.postMessage({ event: e, session: t });
      const s = [],
        a = Array.from(this.stateChangeEmitters.values()).map(async (o) => {
          try {
            await o.callback(e, t);
          } catch (l) {
            s.push(l);
          }
        });
      if ((await Promise.all(a), s.length > 0)) {
        for (let o = 0; o < s.length; o += 1) console.error(s[o]);
        throw s[0];
      }
    } finally {
      this._debug(r, 'end');
    }
  }
  async _saveSession(e) {
    (this._debug('#_saveSession()', e), (this.suppressGetSessionWarning = !0));
    const t = Object.assign({}, e),
      i = t.user && t.user.__isUserNotAvailableProxy === !0;
    if (this.userStorage) {
      !i &&
        t.user &&
        (await wl(this.userStorage, this.storageKey + '-user', {
          user: t.user,
        }));
      const r = Object.assign({}, t);
      delete r.user;
      const s = DE(r);
      await wl(this.storage, this.storageKey, s);
    } else {
      const r = DE(t);
      await wl(this.storage, this.storageKey, r);
    }
  }
  async _removeSession() {
    (this._debug('#_removeSession()'),
      await Ss(this.storage, this.storageKey),
      await Ss(this.storage, this.storageKey + '-code-verifier'),
      await Ss(this.storage, this.storageKey + '-user'),
      this.userStorage &&
        (await Ss(this.userStorage, this.storageKey + '-user')),
      await this._notifyAllSubscribers('SIGNED_OUT', null));
  }
  _removeVisibilityChangedCallback() {
    this._debug('#_removeVisibilityChangedCallback()');
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e &&
        $n() &&
        window?.removeEventListener &&
        window.removeEventListener('visibilitychange', e);
    } catch (t) {
      console.error('removing visibilitychange callback failed', t);
    }
  }
  async _startAutoRefresh() {
    (await this._stopAutoRefresh(), this._debug('#_startAutoRefresh()'));
    const e = setInterval(() => this._autoRefreshTokenTick(), Sl);
    ((this.autoRefreshTicker = e),
      e && typeof e == 'object' && typeof e.unref == 'function'
        ? e.unref()
        : typeof Deno < 'u' &&
          typeof Deno.unrefTimer == 'function' &&
          Deno.unrefTimer(e),
      setTimeout(async () => {
        (await this.initializePromise, await this._autoRefreshTokenTick());
      }, 0));
  }
  async _stopAutoRefresh() {
    this._debug('#_stopAutoRefresh()');
    const e = this.autoRefreshTicker;
    ((this.autoRefreshTicker = null), e && clearInterval(e));
  }
  async startAutoRefresh() {
    (this._removeVisibilityChangedCallback(), await this._startAutoRefresh());
  }
  async stopAutoRefresh() {
    (this._removeVisibilityChangedCallback(), await this._stopAutoRefresh());
  }
  async _autoRefreshTokenTick() {
    this._debug('#_autoRefreshTokenTick()', 'begin');
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async (t) => {
              const {
                data: { session: i },
              } = t;
              if (!i || !i.refresh_token || !i.expires_at) {
                this._debug('#_autoRefreshTokenTick()', 'no session');
                return;
              }
              const r = Math.floor((i.expires_at * 1e3 - e) / Sl);
              (this._debug(
                '#_autoRefreshTokenTick()',
                `access token expires in ${r} ticks, a tick lasts ${Sl}ms, refresh threshold is ${g_} ticks`
              ),
                r <= g_ && (await this._callRefreshToken(i.refresh_token)));
            });
          } catch (t) {
            console.error(
              'Auto refresh tick failed with error. This is likely a transient error.',
              t
            );
          }
        } finally {
          this._debug('#_autoRefreshTokenTick()', 'end');
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof JI)
        this._debug('auto refresh token tick lock not available');
      else throw e;
    }
  }
  async _handleVisibilityChange() {
    if (
      (this._debug('#_handleVisibilityChange()'),
      !$n() || !window?.addEventListener)
    )
      return (this.autoRefreshToken && this.startAutoRefresh(), !1);
    try {
      ((this.visibilityChangedCallback = async () =>
        await this._onVisibilityChanged(!1)),
        window?.addEventListener(
          'visibilitychange',
          this.visibilityChangedCallback
        ),
        await this._onVisibilityChanged(!0));
    } catch (e) {
      console.error('_handleVisibilityChange', e);
    }
  }
  async _onVisibilityChanged(e) {
    const t = `#_onVisibilityChanged(${e})`;
    (this._debug(t, 'visibilityState', document.visibilityState),
      document.visibilityState === 'visible'
        ? (this.autoRefreshToken && this._startAutoRefresh(),
          e ||
            (await this.initializePromise,
            await this._acquireLock(-1, async () => {
              if (document.visibilityState !== 'visible') {
                this._debug(
                  t,
                  'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting'
                );
                return;
              }
              await this._recoverAndRefresh();
            })))
        : document.visibilityState === 'hidden' &&
          this.autoRefreshToken &&
          this._stopAutoRefresh());
  }
  async _getUrlForProvider(e, t, i) {
    const r = [`provider=${encodeURIComponent(t)}`];
    if (
      (i?.redirectTo &&
        r.push(`redirect_to=${encodeURIComponent(i.redirectTo)}`),
      i?.scopes && r.push(`scopes=${encodeURIComponent(i.scopes)}`),
      this.flowType === 'pkce')
    ) {
      const [s, a] = await Yo(this.storage, this.storageKey),
        o = new URLSearchParams({
          code_challenge: `${encodeURIComponent(s)}`,
          code_challenge_method: `${encodeURIComponent(a)}`,
        });
      r.push(o.toString());
    }
    if (i?.queryParams) {
      const s = new URLSearchParams(i.queryParams);
      r.push(s.toString());
    }
    return (
      i?.skipBrowserRedirect &&
        r.push(`skip_http_redirect=${i.skipBrowserRedirect}`),
      `${e}?${r.join('&')}`
    );
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async (t) => {
        var i;
        const { data: r, error: s } = t;
        return s
          ? this._returnResult({ data: null, error: s })
          : await dt(
              this.fetch,
              'DELETE',
              `${this.url}/factors/${e.factorId}`,
              {
                headers: this.headers,
                jwt:
                  (i = r?.session) === null || i === void 0
                    ? void 0
                    : i.access_token,
              }
            );
      });
    } catch (t) {
      if (lt(t)) return this._returnResult({ data: null, error: t });
      throw t;
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async (t) => {
        var i, r;
        const { data: s, error: a } = t;
        if (a) return this._returnResult({ data: null, error: a });
        const o = Object.assign(
            { friendly_name: e.friendlyName, factor_type: e.factorType },
            e.factorType === 'phone'
              ? { phone: e.phone }
              : e.factorType === 'totp'
                ? { issuer: e.issuer }
                : {}
          ),
          { data: l, error: c } = await dt(
            this.fetch,
            'POST',
            `${this.url}/factors`,
            {
              body: o,
              headers: this.headers,
              jwt:
                (i = s?.session) === null || i === void 0
                  ? void 0
                  : i.access_token,
            }
          );
        return c
          ? this._returnResult({ data: null, error: c })
          : (e.factorType === 'totp' &&
              l.type === 'totp' &&
              !((r = l?.totp) === null || r === void 0) &&
              r.qr_code &&
              (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
            this._returnResult({ data: l, error: null }));
      });
    } catch (t) {
      if (lt(t)) return this._returnResult({ data: null, error: t });
      throw t;
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var i;
          const { data: r, error: s } = t;
          if (s) return this._returnResult({ data: null, error: s });
          const a = Object.assign(
              { challenge_id: e.challengeId },
              'webauthn' in e
                ? {
                    webauthn: Object.assign(Object.assign({}, e.webauthn), {
                      credential_response:
                        e.webauthn.type === 'create'
                          ? tV(e.webauthn.credential_response)
                          : nV(e.webauthn.credential_response),
                    }),
                  }
                : { code: e.code }
            ),
            { data: o, error: l } = await dt(
              this.fetch,
              'POST',
              `${this.url}/factors/${e.factorId}/verify`,
              {
                body: a,
                headers: this.headers,
                jwt:
                  (i = r?.session) === null || i === void 0
                    ? void 0
                    : i.access_token,
              }
            );
          return l
            ? this._returnResult({ data: null, error: l })
            : (await this._saveSession(
                Object.assign(
                  { expires_at: Math.round(Date.now() / 1e3) + o.expires_in },
                  o
                )
              ),
              await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', o),
              this._returnResult({ data: o, error: l }));
        });
      } catch (t) {
        if (lt(t)) return this._returnResult({ data: null, error: t });
        throw t;
      }
    });
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var i;
          const { data: r, error: s } = t;
          if (s) return this._returnResult({ data: null, error: s });
          const a = await dt(
            this.fetch,
            'POST',
            `${this.url}/factors/${e.factorId}/challenge`,
            {
              body: e,
              headers: this.headers,
              jwt:
                (i = r?.session) === null || i === void 0
                  ? void 0
                  : i.access_token,
            }
          );
          if (a.error) return a;
          const { data: o } = a;
          if (o.type !== 'webauthn') return { data: o, error: null };
          switch (o.webauthn.type) {
            case 'create':
              return {
                data: Object.assign(Object.assign({}, o), {
                  webauthn: Object.assign(Object.assign({}, o.webauthn), {
                    credential_options: Object.assign(
                      Object.assign({}, o.webauthn.credential_options),
                      { publicKey: $4(o.webauthn.credential_options.publicKey) }
                    ),
                  }),
                }),
                error: null,
              };
            case 'request':
              return {
                data: Object.assign(Object.assign({}, o), {
                  webauthn: Object.assign(Object.assign({}, o.webauthn), {
                    credential_options: Object.assign(
                      Object.assign({}, o.webauthn.credential_options),
                      { publicKey: eV(o.webauthn.credential_options.publicKey) }
                    ),
                  }),
                }),
                error: null,
              };
          }
        });
      } catch (t) {
        if (lt(t)) return this._returnResult({ data: null, error: t });
        throw t;
      }
    });
  }
  async _challengeAndVerify(e) {
    const { data: t, error: i } = await this._challenge({
      factorId: e.factorId,
    });
    return i
      ? this._returnResult({ data: null, error: i })
      : await this._verify({
          factorId: e.factorId,
          challengeId: t.id,
          code: e.code,
        });
  }
  async _listFactors() {
    var e;
    const {
      data: { user: t },
      error: i,
    } = await this.getUser();
    if (i) return { data: null, error: i };
    const r = { all: [], phone: [], totp: [], webauthn: [] };
    for (const s of (e = t?.factors) !== null && e !== void 0 ? e : [])
      (r.all.push(s), s.status === 'verified' && r[s.factor_type].push(s));
    return { data: r, error: null };
  }
  async _getAuthenticatorAssuranceLevel() {
    var e, t;
    const {
      data: { session: i },
      error: r,
    } = await this.getSession();
    if (r) return this._returnResult({ data: null, error: r });
    if (!i)
      return {
        data: {
          currentLevel: null,
          nextLevel: null,
          currentAuthenticationMethods: [],
        },
        error: null,
      };
    const { payload: s } = $g(i.access_token);
    let a = null;
    s.aal && (a = s.aal);
    let o = a;
    ((t =
      (e = i.user.factors) === null || e === void 0
        ? void 0
        : e.filter((u) => u.status === 'verified')) !== null && t !== void 0
      ? t
      : []
    ).length > 0 && (o = 'aal2');
    const c = s.amr || [];
    return {
      data: { currentLevel: a, nextLevel: o, currentAuthenticationMethods: c },
      error: null,
    };
  }
  async _getAuthorizationDetails(e) {
    try {
      return await this._useSession(async (t) => {
        const {
          data: { session: i },
          error: r,
        } = t;
        return r
          ? this._returnResult({ data: null, error: r })
          : i
            ? await dt(
                this.fetch,
                'GET',
                `${this.url}/oauth/authorizations/${e}`,
                {
                  headers: this.headers,
                  jwt: i.access_token,
                  xform: (s) => ({ data: s, error: null }),
                }
              )
            : this._returnResult({ data: null, error: new gr() });
      });
    } catch (t) {
      if (lt(t)) return this._returnResult({ data: null, error: t });
      throw t;
    }
  }
  async _approveAuthorization(e, t) {
    try {
      return await this._useSession(async (i) => {
        const {
          data: { session: r },
          error: s,
        } = i;
        if (s) return this._returnResult({ data: null, error: s });
        if (!r) return this._returnResult({ data: null, error: new gr() });
        const a = await dt(
          this.fetch,
          'POST',
          `${this.url}/oauth/authorizations/${e}/consent`,
          {
            headers: this.headers,
            jwt: r.access_token,
            body: { action: 'approve' },
            xform: (o) => ({ data: o, error: null }),
          }
        );
        return (
          a.data &&
            a.data.redirect_url &&
            $n() &&
            !t?.skipBrowserRedirect &&
            window.location.assign(a.data.redirect_url),
          a
        );
      });
    } catch (i) {
      if (lt(i)) return this._returnResult({ data: null, error: i });
      throw i;
    }
  }
  async _denyAuthorization(e, t) {
    try {
      return await this._useSession(async (i) => {
        const {
          data: { session: r },
          error: s,
        } = i;
        if (s) return this._returnResult({ data: null, error: s });
        if (!r) return this._returnResult({ data: null, error: new gr() });
        const a = await dt(
          this.fetch,
          'POST',
          `${this.url}/oauth/authorizations/${e}/consent`,
          {
            headers: this.headers,
            jwt: r.access_token,
            body: { action: 'deny' },
            xform: (o) => ({ data: o, error: null }),
          }
        );
        return (
          a.data &&
            a.data.redirect_url &&
            $n() &&
            !t?.skipBrowserRedirect &&
            window.location.assign(a.data.redirect_url),
          a
        );
      });
    } catch (i) {
      if (lt(i)) return this._returnResult({ data: null, error: i });
      throw i;
    }
  }
  async fetchJwk(e, t = { keys: [] }) {
    let i = t.keys.find((o) => o.kid === e);
    if (i) return i;
    const r = Date.now();
    if (
      ((i = this.jwks.keys.find((o) => o.kid === e)),
      i && this.jwks_cached_at + u4 > r)
    )
      return i;
    const { data: s, error: a } = await dt(
      this.fetch,
      'GET',
      `${this.url}/.well-known/jwks.json`,
      { headers: this.headers }
    );
    if (a) throw a;
    return !s.keys ||
      s.keys.length === 0 ||
      ((this.jwks = s),
      (this.jwks_cached_at = r),
      (i = s.keys.find((o) => o.kid === e)),
      !i)
      ? null
      : i;
  }
  async getClaims(e, t = {}) {
    try {
      let i = e;
      if (!i) {
        const { data: f, error: p } = await this.getSession();
        if (p || !f.session)
          return this._returnResult({ data: null, error: p });
        i = f.session.access_token;
      }
      const {
        header: r,
        payload: s,
        signature: a,
        raw: { header: o, payload: l },
      } = $g(i);
      t?.allowExpired || D4(s.exp);
      const c =
        !r.alg ||
        r.alg.startsWith('HS') ||
        !r.kid ||
        !('crypto' in globalThis && 'subtle' in globalThis.crypto)
          ? null
          : await this.fetchJwk(r.kid, t?.keys ? { keys: t.keys } : t?.jwks);
      if (!c) {
        const { error: f } = await this.getUser(i);
        if (f) throw f;
        return { data: { claims: s, header: r, signature: a }, error: null };
      }
      const u = O4(r.alg),
        h = await crypto.subtle.importKey('jwk', c, u, !0, ['verify']);
      if (!(await crypto.subtle.verify(u, h, a, y4(`${o}.${l}`))))
        throw new y_('Invalid JWT signature');
      return { data: { claims: s, header: r, signature: a }, error: null };
    } catch (i) {
      if (lt(i)) return this._returnResult({ data: null, error: i });
      throw i;
    }
  }
}
eh.nextInstanceID = {};
const hV = eh;
class dV extends hV {
  constructor(e) {
    super(e);
  }
}
class fV {
  constructor(e, t, i) {
    var r, s, a;
    ((this.supabaseUrl = e), (this.supabaseKey = t));
    const o = s4(e);
    if (!t) throw new Error('supabaseKey is required.');
    ((this.realtimeUrl = new URL('realtime/v1', o)),
      (this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(
        'http',
        'ws'
      )),
      (this.authUrl = new URL('auth/v1', o)),
      (this.storageUrl = new URL('storage/v1', o)),
      (this.functionsUrl = new URL('functions/v1', o)));
    const l = `sb-${o.hostname.split('.')[0]}-auth-token`,
      c = {
        db: Qz,
        realtime: $z,
        auth: Object.assign(Object.assign({}, Zz), { storageKey: l }),
        global: Jz,
      },
      u = r4(i ?? {}, c);
    ((this.storageKey =
      (r = u.auth.storageKey) !== null && r !== void 0 ? r : ''),
      (this.headers = (s = u.global.headers) !== null && s !== void 0 ? s : {}),
      u.accessToken
        ? ((this.accessToken = u.accessToken),
          (this.auth = new Proxy(
            {},
            {
              get: (h, d) => {
                throw new Error(
                  `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(d)} is not possible`
                );
              },
            }
          )))
        : (this.auth = this._initSupabaseAuthClient(
            (a = u.auth) !== null && a !== void 0 ? a : {},
            this.headers,
            u.global.fetch
          )),
      (this.fetch = n4(t, this._getAccessToken.bind(this), u.global.fetch)),
      (this.realtime = this._initRealtimeClient(
        Object.assign(
          {
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this),
          },
          u.realtime
        )
      )),
      (this.rest = new az(new URL('rest/v1', o).href, {
        headers: this.headers,
        schema: u.db.schema,
        fetch: this.fetch,
      })),
      (this.storage = new qz(
        this.storageUrl.href,
        this.headers,
        this.fetch,
        i?.storage
      )),
      u.accessToken || this._listenForAuthEvents());
  }
  get functions() {
    return new nz(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch,
    });
  }
  from(e) {
    return this.rest.from(e);
  }
  schema(e) {
    return this.rest.schema(e);
  }
  rpc(e, t = {}, i = { head: !1, get: !1, count: void 0 }) {
    return this.rest.rpc(e, t, i);
  }
  channel(e, t = { config: {} }) {
    return this.realtime.channel(e, t);
  }
  getChannels() {
    return this.realtime.getChannels();
  }
  removeChannel(e) {
    return this.realtime.removeChannel(e);
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  async _getAccessToken() {
    var e, t;
    if (this.accessToken) return await this.accessToken();
    const { data: i } = await this.auth.getSession();
    return (t =
      (e = i.session) === null || e === void 0 ? void 0 : e.access_token) !==
      null && t !== void 0
      ? t
      : this.supabaseKey;
  }
  _initSupabaseAuthClient(
    {
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: i,
      storage: r,
      userStorage: s,
      storageKey: a,
      flowType: o,
      lock: l,
      debug: c,
      throwOnError: u,
    },
    h,
    d
  ) {
    const f = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`,
    };
    return new dV({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, f), h),
      storageKey: a,
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: i,
      storage: r,
      userStorage: s,
      flowType: o,
      lock: l,
      debug: c,
      throwOnError: u,
      fetch: d,
      hasCustomAuthorizationHeader: Object.keys(this.headers).some(
        (p) => p.toLowerCase() === 'authorization'
      ),
    });
  }
  _initRealtimeClient(e) {
    return new wz(
      this.realtimeUrl.href,
      Object.assign(Object.assign({}, e), {
        params: Object.assign({ apikey: this.supabaseKey }, e?.params),
      })
    );
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((t, i) => {
      this._handleTokenChanged(t, 'CLIENT', i?.access_token);
    });
  }
  _handleTokenChanged(e, t, i) {
    (e === 'TOKEN_REFRESHED' || e === 'SIGNED_IN') &&
    this.changedAccessToken !== i
      ? ((this.changedAccessToken = i), this.realtime.setAuth(i))
      : e === 'SIGNED_OUT' &&
        (this.realtime.setAuth(),
        t == 'STORAGE' && this.auth.signOut(),
        (this.changedAccessToken = void 0));
  }
}
const ine = (n, e, t) => new fV(n, e, t);
function pV() {
  if (typeof window < 'u' || typeof process > 'u') return !1;
  const n = process.version;
  if (n == null) return !1;
  const e = n.match(/^v(\d+)\./);
  return e ? parseInt(e[1], 10) <= 18 : !1;
}
pV() &&
  console.warn(
    '  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217'
  );
const Xn = [];
for (let n = 0; n < 256; ++n) Xn.push((n + 256).toString(16).slice(1));
function mV(n, e = 0) {
  return (
    Xn[n[e + 0]] +
    Xn[n[e + 1]] +
    Xn[n[e + 2]] +
    Xn[n[e + 3]] +
    '-' +
    Xn[n[e + 4]] +
    Xn[n[e + 5]] +
    '-' +
    Xn[n[e + 6]] +
    Xn[n[e + 7]] +
    '-' +
    Xn[n[e + 8]] +
    Xn[n[e + 9]] +
    '-' +
    Xn[n[e + 10]] +
    Xn[n[e + 11]] +
    Xn[n[e + 12]] +
    Xn[n[e + 13]] +
    Xn[n[e + 14]] +
    Xn[n[e + 15]]
  ).toLowerCase();
}
let n0;
const gV = new Uint8Array(16);
function vV() {
  if (!n0) {
    if (typeof crypto > 'u' || !crypto.getRandomValues)
      throw new Error(
        'crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported'
      );
    n0 = crypto.getRandomValues.bind(crypto);
  }
  return n0(gV);
}
const _V =
    typeof crypto < 'u' && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  FE = { randomUUID: _V };
function yV(n, e, t) {
  n = n || {};
  const i = n.random ?? n.rng?.() ?? vV();
  if (i.length < 16) throw new Error('Random bytes length must be >= 16');
  return ((i[6] = (i[6] & 15) | 64), (i[8] = (i[8] & 63) | 128), mV(i));
}
function rne(n, e, t) {
  return FE.randomUUID && !n ? FE.randomUUID() : yV(n);
}
function $I(n) {
  var e,
    t,
    i = '';
  if (typeof n == 'string' || typeof n == 'number') i += n;
  else if (typeof n == 'object')
    if (Array.isArray(n)) {
      var r = n.length;
      for (e = 0; e < r; e++)
        n[e] && (t = $I(n[e])) && (i && (i += ' '), (i += t));
    } else for (t in n) n[t] && (i && (i += ' '), (i += t));
  return i;
}
function xV() {
  for (var n, e, t = 0, i = '', r = arguments.length; t < r; t++)
    (n = arguments[t]) && (e = $I(n)) && (i && (i += ' '), (i += e));
  return i;
}
const wx = '-',
  bV = (n) => {
    const e = wV(n),
      { conflictingClassGroups: t, conflictingClassGroupModifiers: i } = n;
    return {
      getClassGroupId: (a) => {
        const o = a.split(wx);
        return (o[0] === '' && o.length !== 1 && o.shift(), eP(o, e) || SV(a));
      },
      getConflictingClassGroupIds: (a, o) => {
        const l = t[a] || [];
        return o && i[a] ? [...l, ...i[a]] : l;
      },
    };
  },
  eP = (n, e) => {
    if (n.length === 0) return e.classGroupId;
    const t = n[0],
      i = e.nextPart.get(t),
      r = i ? eP(n.slice(1), i) : void 0;
    if (r) return r;
    if (e.validators.length === 0) return;
    const s = n.join(wx);
    return e.validators.find(({ validator: a }) => a(s))?.classGroupId;
  },
  zE = /^\[(.+)\]$/,
  SV = (n) => {
    if (zE.test(n)) {
      const e = zE.exec(n)[1],
        t = e?.substring(0, e.indexOf(':'));
      if (t) return 'arbitrary..' + t;
    }
  },
  wV = (n) => {
    const { theme: e, classGroups: t } = n,
      i = { nextPart: new Map(), validators: [] };
    for (const r in t) x_(t[r], i, r, e);
    return i;
  },
  x_ = (n, e, t, i) => {
    n.forEach((r) => {
      if (typeof r == 'string') {
        const s = r === '' ? e : VE(e, r);
        s.classGroupId = t;
        return;
      }
      if (typeof r == 'function') {
        if (EV(r)) {
          x_(r(i), e, t, i);
          return;
        }
        e.validators.push({ validator: r, classGroupId: t });
        return;
      }
      Object.entries(r).forEach(([s, a]) => {
        x_(a, VE(e, s), t, i);
      });
    });
  },
  VE = (n, e) => {
    let t = n;
    return (
      e.split(wx).forEach((i) => {
        (t.nextPart.has(i) ||
          t.nextPart.set(i, { nextPart: new Map(), validators: [] }),
          (t = t.nextPart.get(i)));
      }),
      t
    );
  },
  EV = (n) => n.isThemeGetter,
  AV = (n) => {
    if (n < 1) return { get: () => {}, set: () => {} };
    let e = 0,
      t = new Map(),
      i = new Map();
    const r = (s, a) => {
      (t.set(s, a), e++, e > n && ((e = 0), (i = t), (t = new Map())));
    };
    return {
      get(s) {
        let a = t.get(s);
        if (a !== void 0) return a;
        if ((a = i.get(s)) !== void 0) return (r(s, a), a);
      },
      set(s, a) {
        t.has(s) ? t.set(s, a) : r(s, a);
      },
    };
  },
  b_ = '!',
  S_ = ':',
  MV = S_.length,
  TV = (n) => {
    const { prefix: e, experimentalParseClassName: t } = n;
    let i = (r) => {
      const s = [];
      let a = 0,
        o = 0,
        l = 0,
        c;
      for (let p = 0; p < r.length; p++) {
        let m = r[p];
        if (a === 0 && o === 0) {
          if (m === S_) {
            (s.push(r.slice(l, p)), (l = p + MV));
            continue;
          }
          if (m === '/') {
            c = p;
            continue;
          }
        }
        m === '[' ? a++ : m === ']' ? a-- : m === '(' ? o++ : m === ')' && o--;
      }
      const u = s.length === 0 ? r : r.substring(l),
        h = CV(u),
        d = h !== u,
        f = c && c > l ? c - l : void 0;
      return {
        modifiers: s,
        hasImportantModifier: d,
        baseClassName: h,
        maybePostfixModifierPosition: f,
      };
    };
    if (e) {
      const r = e + S_,
        s = i;
      i = (a) =>
        a.startsWith(r)
          ? s(a.substring(r.length))
          : {
              isExternal: !0,
              modifiers: [],
              hasImportantModifier: !1,
              baseClassName: a,
              maybePostfixModifierPosition: void 0,
            };
    }
    if (t) {
      const r = i;
      i = (s) => t({ className: s, parseClassName: r });
    }
    return i;
  },
  CV = (n) =>
    n.endsWith(b_)
      ? n.substring(0, n.length - 1)
      : n.startsWith(b_)
        ? n.substring(1)
        : n,
  RV = (n) => {
    const e = Object.fromEntries(n.orderSensitiveModifiers.map((i) => [i, !0]));
    return (i) => {
      if (i.length <= 1) return i;
      const r = [];
      let s = [];
      return (
        i.forEach((a) => {
          a[0] === '[' || e[a] ? (r.push(...s.sort(), a), (s = [])) : s.push(a);
        }),
        r.push(...s.sort()),
        r
      );
    };
  },
  IV = (n) => ({
    cache: AV(n.cacheSize),
    parseClassName: TV(n),
    sortModifiers: RV(n),
    ...bV(n),
  }),
  PV = /\s+/,
  DV = (n, e) => {
    const {
        parseClassName: t,
        getClassGroupId: i,
        getConflictingClassGroupIds: r,
        sortModifiers: s,
      } = e,
      a = [],
      o = n.trim().split(PV);
    let l = '';
    for (let c = o.length - 1; c >= 0; c -= 1) {
      const u = o[c],
        {
          isExternal: h,
          modifiers: d,
          hasImportantModifier: f,
          baseClassName: p,
          maybePostfixModifierPosition: m,
        } = t(u);
      if (h) {
        l = u + (l.length > 0 ? ' ' + l : l);
        continue;
      }
      let g = !!m,
        v = i(g ? p.substring(0, m) : p);
      if (!v) {
        if (!g) {
          l = u + (l.length > 0 ? ' ' + l : l);
          continue;
        }
        if (((v = i(p)), !v)) {
          l = u + (l.length > 0 ? ' ' + l : l);
          continue;
        }
        g = !1;
      }
      const y = s(d).join(':'),
        _ = f ? y + b_ : y,
        x = _ + v;
      if (a.includes(x)) continue;
      a.push(x);
      const S = r(v, g);
      for (let b = 0; b < S.length; ++b) {
        const A = S[b];
        a.push(_ + A);
      }
      l = u + (l.length > 0 ? ' ' + l : l);
    }
    return l;
  };
function OV() {
  let n = 0,
    e,
    t,
    i = '';
  for (; n < arguments.length; )
    (e = arguments[n++]) && (t = tP(e)) && (i && (i += ' '), (i += t));
  return i;
}
const tP = (n) => {
  if (typeof n == 'string') return n;
  let e,
    t = '';
  for (let i = 0; i < n.length; i++)
    n[i] && (e = tP(n[i])) && (t && (t += ' '), (t += e));
  return t;
};
function LV(n, ...e) {
  let t,
    i,
    r,
    s = a;
  function a(l) {
    const c = e.reduce((u, h) => h(u), n());
    return ((t = IV(c)), (i = t.cache.get), (r = t.cache.set), (s = o), o(l));
  }
  function o(l) {
    const c = i(l);
    if (c) return c;
    const u = DV(l, t);
    return (r(l, u), u);
  }
  return function () {
    return s(OV.apply(null, arguments));
  };
}
const Pn = (n) => {
    const e = (t) => t[n] || [];
    return ((e.isThemeGetter = !0), e);
  },
  nP = /^\[(?:(\w[\w-]*):)?(.+)\]$/i,
  iP = /^\((?:(\w[\w-]*):)?(.+)\)$/i,
  UV = /^\d+\/\d+$/,
  kV = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  BV =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  NV = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/,
  FV = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  zV =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Zo = (n) => UV.test(n),
  Ct = (n) => !!n && !Number.isNaN(Number(n)),
  ws = (n) => !!n && Number.isInteger(Number(n)),
  i0 = (n) => n.endsWith('%') && Ct(n.slice(0, -1)),
  Jr = (n) => kV.test(n),
  VV = () => !0,
  HV = (n) => BV.test(n) && !NV.test(n),
  rP = () => !1,
  GV = (n) => FV.test(n),
  WV = (n) => zV.test(n),
  jV = (n) => !Qe(n) && !Ze(n),
  XV = (n) => vc(n, oP, rP),
  Qe = (n) => nP.test(n),
  ka = (n) => vc(n, lP, HV),
  r0 = (n) => vc(n, QV, Ct),
  HE = (n) => vc(n, sP, rP),
  qV = (n) => vc(n, aP, WV),
  gd = (n) => vc(n, cP, GV),
  Ze = (n) => iP.test(n),
  jc = (n) => _c(n, lP),
  YV = (n) => _c(n, ZV),
  GE = (n) => _c(n, sP),
  KV = (n) => _c(n, oP),
  JV = (n) => _c(n, aP),
  vd = (n) => _c(n, cP, !0),
  vc = (n, e, t) => {
    const i = nP.exec(n);
    return i ? (i[1] ? e(i[1]) : t(i[2])) : !1;
  },
  _c = (n, e, t = !1) => {
    const i = iP.exec(n);
    return i ? (i[1] ? e(i[1]) : t) : !1;
  },
  sP = (n) => n === 'position' || n === 'percentage',
  aP = (n) => n === 'image' || n === 'url',
  oP = (n) => n === 'length' || n === 'size' || n === 'bg-size',
  lP = (n) => n === 'length',
  QV = (n) => n === 'number',
  ZV = (n) => n === 'family-name',
  cP = (n) => n === 'shadow',
  $V = () => {
    const n = Pn('color'),
      e = Pn('font'),
      t = Pn('text'),
      i = Pn('font-weight'),
      r = Pn('tracking'),
      s = Pn('leading'),
      a = Pn('breakpoint'),
      o = Pn('container'),
      l = Pn('spacing'),
      c = Pn('radius'),
      u = Pn('shadow'),
      h = Pn('inset-shadow'),
      d = Pn('text-shadow'),
      f = Pn('drop-shadow'),
      p = Pn('blur'),
      m = Pn('perspective'),
      g = Pn('aspect'),
      v = Pn('ease'),
      y = Pn('animate'),
      _ = () => [
        'auto',
        'avoid',
        'all',
        'avoid-page',
        'page',
        'left',
        'right',
        'column',
      ],
      x = () => [
        'center',
        'top',
        'bottom',
        'left',
        'right',
        'top-left',
        'left-top',
        'top-right',
        'right-top',
        'bottom-right',
        'right-bottom',
        'bottom-left',
        'left-bottom',
      ],
      S = () => [...x(), Ze, Qe],
      b = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'],
      A = () => ['auto', 'contain', 'none'],
      E = () => [Ze, Qe, l],
      w = () => [Zo, 'full', 'auto', ...E()],
      M = () => [ws, 'none', 'subgrid', Ze, Qe],
      T = () => ['auto', { span: ['full', ws, Ze, Qe] }, ws, Ze, Qe],
      D = () => [ws, 'auto', Ze, Qe],
      L = () => ['auto', 'min', 'max', 'fr', Ze, Qe],
      O = () => [
        'start',
        'end',
        'center',
        'between',
        'around',
        'evenly',
        'stretch',
        'baseline',
        'center-safe',
        'end-safe',
      ],
      z = () => [
        'start',
        'end',
        'center',
        'stretch',
        'center-safe',
        'end-safe',
      ],
      C = () => ['auto', ...E()],
      N = () => [
        Zo,
        'auto',
        'full',
        'dvw',
        'dvh',
        'lvw',
        'lvh',
        'svw',
        'svh',
        'min',
        'max',
        'fit',
        ...E(),
      ],
      U = () => [n, Ze, Qe],
      W = () => [...x(), GE, HE, { position: [Ze, Qe] }],
      G = () => ['no-repeat', { repeat: ['', 'x', 'y', 'space', 'round'] }],
      ne = () => ['auto', 'cover', 'contain', KV, XV, { size: [Ze, Qe] }],
      ve = () => [i0, jc, ka],
      Se = () => ['', 'none', 'full', c, Ze, Qe],
      Ae = () => ['', Ct, jc, ka],
      Oe = () => ['solid', 'dashed', 'dotted', 'double'],
      Z = () => [
        'normal',
        'multiply',
        'screen',
        'overlay',
        'darken',
        'lighten',
        'color-dodge',
        'color-burn',
        'hard-light',
        'soft-light',
        'difference',
        'exclusion',
        'hue',
        'saturation',
        'color',
        'luminosity',
      ],
      J = () => [Ct, i0, GE, HE],
      de = () => ['', 'none', p, Ze, Qe],
      fe = () => ['none', Ct, Ze, Qe],
      K = () => ['none', Ct, Ze, Qe],
      oe = () => [Ct, Ze, Qe],
      he = () => [Zo, 'full', ...E()];
    return {
      cacheSize: 500,
      theme: {
        animate: ['spin', 'ping', 'pulse', 'bounce'],
        aspect: ['video'],
        blur: [Jr],
        breakpoint: [Jr],
        color: [VV],
        container: [Jr],
        'drop-shadow': [Jr],
        ease: ['in', 'out', 'in-out'],
        font: [jV],
        'font-weight': [
          'thin',
          'extralight',
          'light',
          'normal',
          'medium',
          'semibold',
          'bold',
          'extrabold',
          'black',
        ],
        'inset-shadow': [Jr],
        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose'],
        perspective: [
          'dramatic',
          'near',
          'normal',
          'midrange',
          'distant',
          'none',
        ],
        radius: [Jr],
        shadow: [Jr],
        spacing: ['px', Ct],
        text: [Jr],
        'text-shadow': [Jr],
        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest'],
      },
      classGroups: {
        aspect: [{ aspect: ['auto', 'square', Zo, Qe, Ze, g] }],
        container: ['container'],
        columns: [{ columns: [Ct, Qe, Ze, o] }],
        'break-after': [{ 'break-after': _() }],
        'break-before': [{ 'break-before': _() }],
        'break-inside': [
          { 'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column'] },
        ],
        'box-decoration': [{ 'box-decoration': ['slice', 'clone'] }],
        box: [{ box: ['border', 'content'] }],
        display: [
          'block',
          'inline-block',
          'inline',
          'flex',
          'inline-flex',
          'table',
          'inline-table',
          'table-caption',
          'table-cell',
          'table-column',
          'table-column-group',
          'table-footer-group',
          'table-header-group',
          'table-row-group',
          'table-row',
          'flow-root',
          'grid',
          'inline-grid',
          'contents',
          'list-item',
          'hidden',
        ],
        sr: ['sr-only', 'not-sr-only'],
        float: [{ float: ['right', 'left', 'none', 'start', 'end'] }],
        clear: [{ clear: ['left', 'right', 'both', 'none', 'start', 'end'] }],
        isolation: ['isolate', 'isolation-auto'],
        'object-fit': [
          { object: ['contain', 'cover', 'fill', 'none', 'scale-down'] },
        ],
        'object-position': [{ object: S() }],
        overflow: [{ overflow: b() }],
        'overflow-x': [{ 'overflow-x': b() }],
        'overflow-y': [{ 'overflow-y': b() }],
        overscroll: [{ overscroll: A() }],
        'overscroll-x': [{ 'overscroll-x': A() }],
        'overscroll-y': [{ 'overscroll-y': A() }],
        position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],
        inset: [{ inset: w() }],
        'inset-x': [{ 'inset-x': w() }],
        'inset-y': [{ 'inset-y': w() }],
        start: [{ start: w() }],
        end: [{ end: w() }],
        top: [{ top: w() }],
        right: [{ right: w() }],
        bottom: [{ bottom: w() }],
        left: [{ left: w() }],
        visibility: ['visible', 'invisible', 'collapse'],
        z: [{ z: [ws, 'auto', Ze, Qe] }],
        basis: [{ basis: [Zo, 'full', 'auto', o, ...E()] }],
        'flex-direction': [
          { flex: ['row', 'row-reverse', 'col', 'col-reverse'] },
        ],
        'flex-wrap': [{ flex: ['nowrap', 'wrap', 'wrap-reverse'] }],
        flex: [{ flex: [Ct, Zo, 'auto', 'initial', 'none', Qe] }],
        grow: [{ grow: ['', Ct, Ze, Qe] }],
        shrink: [{ shrink: ['', Ct, Ze, Qe] }],
        order: [{ order: [ws, 'first', 'last', 'none', Ze, Qe] }],
        'grid-cols': [{ 'grid-cols': M() }],
        'col-start-end': [{ col: T() }],
        'col-start': [{ 'col-start': D() }],
        'col-end': [{ 'col-end': D() }],
        'grid-rows': [{ 'grid-rows': M() }],
        'row-start-end': [{ row: T() }],
        'row-start': [{ 'row-start': D() }],
        'row-end': [{ 'row-end': D() }],
        'grid-flow': [
          { 'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense'] },
        ],
        'auto-cols': [{ 'auto-cols': L() }],
        'auto-rows': [{ 'auto-rows': L() }],
        gap: [{ gap: E() }],
        'gap-x': [{ 'gap-x': E() }],
        'gap-y': [{ 'gap-y': E() }],
        'justify-content': [{ justify: [...O(), 'normal'] }],
        'justify-items': [{ 'justify-items': [...z(), 'normal'] }],
        'justify-self': [{ 'justify-self': ['auto', ...z()] }],
        'align-content': [{ content: ['normal', ...O()] }],
        'align-items': [{ items: [...z(), { baseline: ['', 'last'] }] }],
        'align-self': [{ self: ['auto', ...z(), { baseline: ['', 'last'] }] }],
        'place-content': [{ 'place-content': O() }],
        'place-items': [{ 'place-items': [...z(), 'baseline'] }],
        'place-self': [{ 'place-self': ['auto', ...z()] }],
        p: [{ p: E() }],
        px: [{ px: E() }],
        py: [{ py: E() }],
        ps: [{ ps: E() }],
        pe: [{ pe: E() }],
        pt: [{ pt: E() }],
        pr: [{ pr: E() }],
        pb: [{ pb: E() }],
        pl: [{ pl: E() }],
        m: [{ m: C() }],
        mx: [{ mx: C() }],
        my: [{ my: C() }],
        ms: [{ ms: C() }],
        me: [{ me: C() }],
        mt: [{ mt: C() }],
        mr: [{ mr: C() }],
        mb: [{ mb: C() }],
        ml: [{ ml: C() }],
        'space-x': [{ 'space-x': E() }],
        'space-x-reverse': ['space-x-reverse'],
        'space-y': [{ 'space-y': E() }],
        'space-y-reverse': ['space-y-reverse'],
        size: [{ size: N() }],
        w: [{ w: [o, 'screen', ...N()] }],
        'min-w': [{ 'min-w': [o, 'screen', 'none', ...N()] }],
        'max-w': [
          { 'max-w': [o, 'screen', 'none', 'prose', { screen: [a] }, ...N()] },
        ],
        h: [{ h: ['screen', 'lh', ...N()] }],
        'min-h': [{ 'min-h': ['screen', 'lh', 'none', ...N()] }],
        'max-h': [{ 'max-h': ['screen', 'lh', ...N()] }],
        'font-size': [{ text: ['base', t, jc, ka] }],
        'font-smoothing': ['antialiased', 'subpixel-antialiased'],
        'font-style': ['italic', 'not-italic'],
        'font-weight': [{ font: [i, Ze, r0] }],
        'font-stretch': [
          {
            'font-stretch': [
              'ultra-condensed',
              'extra-condensed',
              'condensed',
              'semi-condensed',
              'normal',
              'semi-expanded',
              'expanded',
              'extra-expanded',
              'ultra-expanded',
              i0,
              Qe,
            ],
          },
        ],
        'font-family': [{ font: [YV, Qe, e] }],
        'fvn-normal': ['normal-nums'],
        'fvn-ordinal': ['ordinal'],
        'fvn-slashed-zero': ['slashed-zero'],
        'fvn-figure': ['lining-nums', 'oldstyle-nums'],
        'fvn-spacing': ['proportional-nums', 'tabular-nums'],
        'fvn-fraction': ['diagonal-fractions', 'stacked-fractions'],
        tracking: [{ tracking: [r, Ze, Qe] }],
        'line-clamp': [{ 'line-clamp': [Ct, 'none', Ze, r0] }],
        leading: [{ leading: [s, ...E()] }],
        'list-image': [{ 'list-image': ['none', Ze, Qe] }],
        'list-style-position': [{ list: ['inside', 'outside'] }],
        'list-style-type': [{ list: ['disc', 'decimal', 'none', Ze, Qe] }],
        'text-alignment': [
          { text: ['left', 'center', 'right', 'justify', 'start', 'end'] },
        ],
        'placeholder-color': [{ placeholder: U() }],
        'text-color': [{ text: U() }],
        'text-decoration': [
          'underline',
          'overline',
          'line-through',
          'no-underline',
        ],
        'text-decoration-style': [{ decoration: [...Oe(), 'wavy'] }],
        'text-decoration-thickness': [
          { decoration: [Ct, 'from-font', 'auto', Ze, ka] },
        ],
        'text-decoration-color': [{ decoration: U() }],
        'underline-offset': [{ 'underline-offset': [Ct, 'auto', Ze, Qe] }],
        'text-transform': [
          'uppercase',
          'lowercase',
          'capitalize',
          'normal-case',
        ],
        'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],
        'text-wrap': [{ text: ['wrap', 'nowrap', 'balance', 'pretty'] }],
        indent: [{ indent: E() }],
        'vertical-align': [
          {
            align: [
              'baseline',
              'top',
              'middle',
              'bottom',
              'text-top',
              'text-bottom',
              'sub',
              'super',
              Ze,
              Qe,
            ],
          },
        ],
        whitespace: [
          {
            whitespace: [
              'normal',
              'nowrap',
              'pre',
              'pre-line',
              'pre-wrap',
              'break-spaces',
            ],
          },
        ],
        break: [{ break: ['normal', 'words', 'all', 'keep'] }],
        wrap: [{ wrap: ['break-word', 'anywhere', 'normal'] }],
        hyphens: [{ hyphens: ['none', 'manual', 'auto'] }],
        content: [{ content: ['none', Ze, Qe] }],
        'bg-attachment': [{ bg: ['fixed', 'local', 'scroll'] }],
        'bg-clip': [{ 'bg-clip': ['border', 'padding', 'content', 'text'] }],
        'bg-origin': [{ 'bg-origin': ['border', 'padding', 'content'] }],
        'bg-position': [{ bg: W() }],
        'bg-repeat': [{ bg: G() }],
        'bg-size': [{ bg: ne() }],
        'bg-image': [
          {
            bg: [
              'none',
              {
                linear: [
                  { to: ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'] },
                  ws,
                  Ze,
                  Qe,
                ],
                radial: ['', Ze, Qe],
                conic: [ws, Ze, Qe],
              },
              JV,
              qV,
            ],
          },
        ],
        'bg-color': [{ bg: U() }],
        'gradient-from-pos': [{ from: ve() }],
        'gradient-via-pos': [{ via: ve() }],
        'gradient-to-pos': [{ to: ve() }],
        'gradient-from': [{ from: U() }],
        'gradient-via': [{ via: U() }],
        'gradient-to': [{ to: U() }],
        rounded: [{ rounded: Se() }],
        'rounded-s': [{ 'rounded-s': Se() }],
        'rounded-e': [{ 'rounded-e': Se() }],
        'rounded-t': [{ 'rounded-t': Se() }],
        'rounded-r': [{ 'rounded-r': Se() }],
        'rounded-b': [{ 'rounded-b': Se() }],
        'rounded-l': [{ 'rounded-l': Se() }],
        'rounded-ss': [{ 'rounded-ss': Se() }],
        'rounded-se': [{ 'rounded-se': Se() }],
        'rounded-ee': [{ 'rounded-ee': Se() }],
        'rounded-es': [{ 'rounded-es': Se() }],
        'rounded-tl': [{ 'rounded-tl': Se() }],
        'rounded-tr': [{ 'rounded-tr': Se() }],
        'rounded-br': [{ 'rounded-br': Se() }],
        'rounded-bl': [{ 'rounded-bl': Se() }],
        'border-w': [{ border: Ae() }],
        'border-w-x': [{ 'border-x': Ae() }],
        'border-w-y': [{ 'border-y': Ae() }],
        'border-w-s': [{ 'border-s': Ae() }],
        'border-w-e': [{ 'border-e': Ae() }],
        'border-w-t': [{ 'border-t': Ae() }],
        'border-w-r': [{ 'border-r': Ae() }],
        'border-w-b': [{ 'border-b': Ae() }],
        'border-w-l': [{ 'border-l': Ae() }],
        'divide-x': [{ 'divide-x': Ae() }],
        'divide-x-reverse': ['divide-x-reverse'],
        'divide-y': [{ 'divide-y': Ae() }],
        'divide-y-reverse': ['divide-y-reverse'],
        'border-style': [{ border: [...Oe(), 'hidden', 'none'] }],
        'divide-style': [{ divide: [...Oe(), 'hidden', 'none'] }],
        'border-color': [{ border: U() }],
        'border-color-x': [{ 'border-x': U() }],
        'border-color-y': [{ 'border-y': U() }],
        'border-color-s': [{ 'border-s': U() }],
        'border-color-e': [{ 'border-e': U() }],
        'border-color-t': [{ 'border-t': U() }],
        'border-color-r': [{ 'border-r': U() }],
        'border-color-b': [{ 'border-b': U() }],
        'border-color-l': [{ 'border-l': U() }],
        'divide-color': [{ divide: U() }],
        'outline-style': [{ outline: [...Oe(), 'none', 'hidden'] }],
        'outline-offset': [{ 'outline-offset': [Ct, Ze, Qe] }],
        'outline-w': [{ outline: ['', Ct, jc, ka] }],
        'outline-color': [{ outline: U() }],
        shadow: [{ shadow: ['', 'none', u, vd, gd] }],
        'shadow-color': [{ shadow: U() }],
        'inset-shadow': [{ 'inset-shadow': ['none', h, vd, gd] }],
        'inset-shadow-color': [{ 'inset-shadow': U() }],
        'ring-w': [{ ring: Ae() }],
        'ring-w-inset': ['ring-inset'],
        'ring-color': [{ ring: U() }],
        'ring-offset-w': [{ 'ring-offset': [Ct, ka] }],
        'ring-offset-color': [{ 'ring-offset': U() }],
        'inset-ring-w': [{ 'inset-ring': Ae() }],
        'inset-ring-color': [{ 'inset-ring': U() }],
        'text-shadow': [{ 'text-shadow': ['none', d, vd, gd] }],
        'text-shadow-color': [{ 'text-shadow': U() }],
        opacity: [{ opacity: [Ct, Ze, Qe] }],
        'mix-blend': [{ 'mix-blend': [...Z(), 'plus-darker', 'plus-lighter'] }],
        'bg-blend': [{ 'bg-blend': Z() }],
        'mask-clip': [
          {
            'mask-clip': [
              'border',
              'padding',
              'content',
              'fill',
              'stroke',
              'view',
            ],
          },
          'mask-no-clip',
        ],
        'mask-composite': [
          { mask: ['add', 'subtract', 'intersect', 'exclude'] },
        ],
        'mask-image-linear-pos': [{ 'mask-linear': [Ct] }],
        'mask-image-linear-from-pos': [{ 'mask-linear-from': J() }],
        'mask-image-linear-to-pos': [{ 'mask-linear-to': J() }],
        'mask-image-linear-from-color': [{ 'mask-linear-from': U() }],
        'mask-image-linear-to-color': [{ 'mask-linear-to': U() }],
        'mask-image-t-from-pos': [{ 'mask-t-from': J() }],
        'mask-image-t-to-pos': [{ 'mask-t-to': J() }],
        'mask-image-t-from-color': [{ 'mask-t-from': U() }],
        'mask-image-t-to-color': [{ 'mask-t-to': U() }],
        'mask-image-r-from-pos': [{ 'mask-r-from': J() }],
        'mask-image-r-to-pos': [{ 'mask-r-to': J() }],
        'mask-image-r-from-color': [{ 'mask-r-from': U() }],
        'mask-image-r-to-color': [{ 'mask-r-to': U() }],
        'mask-image-b-from-pos': [{ 'mask-b-from': J() }],
        'mask-image-b-to-pos': [{ 'mask-b-to': J() }],
        'mask-image-b-from-color': [{ 'mask-b-from': U() }],
        'mask-image-b-to-color': [{ 'mask-b-to': U() }],
        'mask-image-l-from-pos': [{ 'mask-l-from': J() }],
        'mask-image-l-to-pos': [{ 'mask-l-to': J() }],
        'mask-image-l-from-color': [{ 'mask-l-from': U() }],
        'mask-image-l-to-color': [{ 'mask-l-to': U() }],
        'mask-image-x-from-pos': [{ 'mask-x-from': J() }],
        'mask-image-x-to-pos': [{ 'mask-x-to': J() }],
        'mask-image-x-from-color': [{ 'mask-x-from': U() }],
        'mask-image-x-to-color': [{ 'mask-x-to': U() }],
        'mask-image-y-from-pos': [{ 'mask-y-from': J() }],
        'mask-image-y-to-pos': [{ 'mask-y-to': J() }],
        'mask-image-y-from-color': [{ 'mask-y-from': U() }],
        'mask-image-y-to-color': [{ 'mask-y-to': U() }],
        'mask-image-radial': [{ 'mask-radial': [Ze, Qe] }],
        'mask-image-radial-from-pos': [{ 'mask-radial-from': J() }],
        'mask-image-radial-to-pos': [{ 'mask-radial-to': J() }],
        'mask-image-radial-from-color': [{ 'mask-radial-from': U() }],
        'mask-image-radial-to-color': [{ 'mask-radial-to': U() }],
        'mask-image-radial-shape': [{ 'mask-radial': ['circle', 'ellipse'] }],
        'mask-image-radial-size': [
          {
            'mask-radial': [
              { closest: ['side', 'corner'], farthest: ['side', 'corner'] },
            ],
          },
        ],
        'mask-image-radial-pos': [{ 'mask-radial-at': x() }],
        'mask-image-conic-pos': [{ 'mask-conic': [Ct] }],
        'mask-image-conic-from-pos': [{ 'mask-conic-from': J() }],
        'mask-image-conic-to-pos': [{ 'mask-conic-to': J() }],
        'mask-image-conic-from-color': [{ 'mask-conic-from': U() }],
        'mask-image-conic-to-color': [{ 'mask-conic-to': U() }],
        'mask-mode': [{ mask: ['alpha', 'luminance', 'match'] }],
        'mask-origin': [
          {
            'mask-origin': [
              'border',
              'padding',
              'content',
              'fill',
              'stroke',
              'view',
            ],
          },
        ],
        'mask-position': [{ mask: W() }],
        'mask-repeat': [{ mask: G() }],
        'mask-size': [{ mask: ne() }],
        'mask-type': [{ 'mask-type': ['alpha', 'luminance'] }],
        'mask-image': [{ mask: ['none', Ze, Qe] }],
        filter: [{ filter: ['', 'none', Ze, Qe] }],
        blur: [{ blur: de() }],
        brightness: [{ brightness: [Ct, Ze, Qe] }],
        contrast: [{ contrast: [Ct, Ze, Qe] }],
        'drop-shadow': [{ 'drop-shadow': ['', 'none', f, vd, gd] }],
        'drop-shadow-color': [{ 'drop-shadow': U() }],
        grayscale: [{ grayscale: ['', Ct, Ze, Qe] }],
        'hue-rotate': [{ 'hue-rotate': [Ct, Ze, Qe] }],
        invert: [{ invert: ['', Ct, Ze, Qe] }],
        saturate: [{ saturate: [Ct, Ze, Qe] }],
        sepia: [{ sepia: ['', Ct, Ze, Qe] }],
        'backdrop-filter': [{ 'backdrop-filter': ['', 'none', Ze, Qe] }],
        'backdrop-blur': [{ 'backdrop-blur': de() }],
        'backdrop-brightness': [{ 'backdrop-brightness': [Ct, Ze, Qe] }],
        'backdrop-contrast': [{ 'backdrop-contrast': [Ct, Ze, Qe] }],
        'backdrop-grayscale': [{ 'backdrop-grayscale': ['', Ct, Ze, Qe] }],
        'backdrop-hue-rotate': [{ 'backdrop-hue-rotate': [Ct, Ze, Qe] }],
        'backdrop-invert': [{ 'backdrop-invert': ['', Ct, Ze, Qe] }],
        'backdrop-opacity': [{ 'backdrop-opacity': [Ct, Ze, Qe] }],
        'backdrop-saturate': [{ 'backdrop-saturate': [Ct, Ze, Qe] }],
        'backdrop-sepia': [{ 'backdrop-sepia': ['', Ct, Ze, Qe] }],
        'border-collapse': [{ border: ['collapse', 'separate'] }],
        'border-spacing': [{ 'border-spacing': E() }],
        'border-spacing-x': [{ 'border-spacing-x': E() }],
        'border-spacing-y': [{ 'border-spacing-y': E() }],
        'table-layout': [{ table: ['auto', 'fixed'] }],
        caption: [{ caption: ['top', 'bottom'] }],
        transition: [
          {
            transition: [
              '',
              'all',
              'colors',
              'opacity',
              'shadow',
              'transform',
              'none',
              Ze,
              Qe,
            ],
          },
        ],
        'transition-behavior': [{ transition: ['normal', 'discrete'] }],
        duration: [{ duration: [Ct, 'initial', Ze, Qe] }],
        ease: [{ ease: ['linear', 'initial', v, Ze, Qe] }],
        delay: [{ delay: [Ct, Ze, Qe] }],
        animate: [{ animate: ['none', y, Ze, Qe] }],
        backface: [{ backface: ['hidden', 'visible'] }],
        perspective: [{ perspective: [m, Ze, Qe] }],
        'perspective-origin': [{ 'perspective-origin': S() }],
        rotate: [{ rotate: fe() }],
        'rotate-x': [{ 'rotate-x': fe() }],
        'rotate-y': [{ 'rotate-y': fe() }],
        'rotate-z': [{ 'rotate-z': fe() }],
        scale: [{ scale: K() }],
        'scale-x': [{ 'scale-x': K() }],
        'scale-y': [{ 'scale-y': K() }],
        'scale-z': [{ 'scale-z': K() }],
        'scale-3d': ['scale-3d'],
        skew: [{ skew: oe() }],
        'skew-x': [{ 'skew-x': oe() }],
        'skew-y': [{ 'skew-y': oe() }],
        transform: [{ transform: [Ze, Qe, '', 'none', 'gpu', 'cpu'] }],
        'transform-origin': [{ origin: S() }],
        'transform-style': [{ transform: ['3d', 'flat'] }],
        translate: [{ translate: he() }],
        'translate-x': [{ 'translate-x': he() }],
        'translate-y': [{ 'translate-y': he() }],
        'translate-z': [{ 'translate-z': he() }],
        'translate-none': ['translate-none'],
        accent: [{ accent: U() }],
        appearance: [{ appearance: ['none', 'auto'] }],
        'caret-color': [{ caret: U() }],
        'color-scheme': [
          {
            scheme: [
              'normal',
              'dark',
              'light',
              'light-dark',
              'only-dark',
              'only-light',
            ],
          },
        ],
        cursor: [
          {
            cursor: [
              'auto',
              'default',
              'pointer',
              'wait',
              'text',
              'move',
              'help',
              'not-allowed',
              'none',
              'context-menu',
              'progress',
              'cell',
              'crosshair',
              'vertical-text',
              'alias',
              'copy',
              'no-drop',
              'grab',
              'grabbing',
              'all-scroll',
              'col-resize',
              'row-resize',
              'n-resize',
              'e-resize',
              's-resize',
              'w-resize',
              'ne-resize',
              'nw-resize',
              'se-resize',
              'sw-resize',
              'ew-resize',
              'ns-resize',
              'nesw-resize',
              'nwse-resize',
              'zoom-in',
              'zoom-out',
              Ze,
              Qe,
            ],
          },
        ],
        'field-sizing': [{ 'field-sizing': ['fixed', 'content'] }],
        'pointer-events': [{ 'pointer-events': ['auto', 'none'] }],
        resize: [{ resize: ['none', '', 'y', 'x'] }],
        'scroll-behavior': [{ scroll: ['auto', 'smooth'] }],
        'scroll-m': [{ 'scroll-m': E() }],
        'scroll-mx': [{ 'scroll-mx': E() }],
        'scroll-my': [{ 'scroll-my': E() }],
        'scroll-ms': [{ 'scroll-ms': E() }],
        'scroll-me': [{ 'scroll-me': E() }],
        'scroll-mt': [{ 'scroll-mt': E() }],
        'scroll-mr': [{ 'scroll-mr': E() }],
        'scroll-mb': [{ 'scroll-mb': E() }],
        'scroll-ml': [{ 'scroll-ml': E() }],
        'scroll-p': [{ 'scroll-p': E() }],
        'scroll-px': [{ 'scroll-px': E() }],
        'scroll-py': [{ 'scroll-py': E() }],
        'scroll-ps': [{ 'scroll-ps': E() }],
        'scroll-pe': [{ 'scroll-pe': E() }],
        'scroll-pt': [{ 'scroll-pt': E() }],
        'scroll-pr': [{ 'scroll-pr': E() }],
        'scroll-pb': [{ 'scroll-pb': E() }],
        'scroll-pl': [{ 'scroll-pl': E() }],
        'snap-align': [{ snap: ['start', 'end', 'center', 'align-none'] }],
        'snap-stop': [{ snap: ['normal', 'always'] }],
        'snap-type': [{ snap: ['none', 'x', 'y', 'both'] }],
        'snap-strictness': [{ snap: ['mandatory', 'proximity'] }],
        touch: [{ touch: ['auto', 'none', 'manipulation'] }],
        'touch-x': [{ 'touch-pan': ['x', 'left', 'right'] }],
        'touch-y': [{ 'touch-pan': ['y', 'up', 'down'] }],
        'touch-pz': ['touch-pinch-zoom'],
        select: [{ select: ['none', 'text', 'all', 'auto'] }],
        'will-change': [
          {
            'will-change': ['auto', 'scroll', 'contents', 'transform', Ze, Qe],
          },
        ],
        fill: [{ fill: ['none', ...U()] }],
        'stroke-w': [{ stroke: [Ct, jc, ka, r0] }],
        stroke: [{ stroke: ['none', ...U()] }],
        'forced-color-adjust': [{ 'forced-color-adjust': ['auto', 'none'] }],
      },
      conflictingClassGroups: {
        overflow: ['overflow-x', 'overflow-y'],
        overscroll: ['overscroll-x', 'overscroll-y'],
        inset: [
          'inset-x',
          'inset-y',
          'start',
          'end',
          'top',
          'right',
          'bottom',
          'left',
        ],
        'inset-x': ['right', 'left'],
        'inset-y': ['top', 'bottom'],
        flex: ['basis', 'grow', 'shrink'],
        gap: ['gap-x', 'gap-y'],
        p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],
        px: ['pr', 'pl'],
        py: ['pt', 'pb'],
        m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],
        mx: ['mr', 'ml'],
        my: ['mt', 'mb'],
        size: ['w', 'h'],
        'font-size': ['leading'],
        'fvn-normal': [
          'fvn-ordinal',
          'fvn-slashed-zero',
          'fvn-figure',
          'fvn-spacing',
          'fvn-fraction',
        ],
        'fvn-ordinal': ['fvn-normal'],
        'fvn-slashed-zero': ['fvn-normal'],
        'fvn-figure': ['fvn-normal'],
        'fvn-spacing': ['fvn-normal'],
        'fvn-fraction': ['fvn-normal'],
        'line-clamp': ['display', 'overflow'],
        rounded: [
          'rounded-s',
          'rounded-e',
          'rounded-t',
          'rounded-r',
          'rounded-b',
          'rounded-l',
          'rounded-ss',
          'rounded-se',
          'rounded-ee',
          'rounded-es',
          'rounded-tl',
          'rounded-tr',
          'rounded-br',
          'rounded-bl',
        ],
        'rounded-s': ['rounded-ss', 'rounded-es'],
        'rounded-e': ['rounded-se', 'rounded-ee'],
        'rounded-t': ['rounded-tl', 'rounded-tr'],
        'rounded-r': ['rounded-tr', 'rounded-br'],
        'rounded-b': ['rounded-br', 'rounded-bl'],
        'rounded-l': ['rounded-tl', 'rounded-bl'],
        'border-spacing': ['border-spacing-x', 'border-spacing-y'],
        'border-w': [
          'border-w-x',
          'border-w-y',
          'border-w-s',
          'border-w-e',
          'border-w-t',
          'border-w-r',
          'border-w-b',
          'border-w-l',
        ],
        'border-w-x': ['border-w-r', 'border-w-l'],
        'border-w-y': ['border-w-t', 'border-w-b'],
        'border-color': [
          'border-color-x',
          'border-color-y',
          'border-color-s',
          'border-color-e',
          'border-color-t',
          'border-color-r',
          'border-color-b',
          'border-color-l',
        ],
        'border-color-x': ['border-color-r', 'border-color-l'],
        'border-color-y': ['border-color-t', 'border-color-b'],
        translate: ['translate-x', 'translate-y', 'translate-none'],
        'translate-none': [
          'translate',
          'translate-x',
          'translate-y',
          'translate-z',
        ],
        'scroll-m': [
          'scroll-mx',
          'scroll-my',
          'scroll-ms',
          'scroll-me',
          'scroll-mt',
          'scroll-mr',
          'scroll-mb',
          'scroll-ml',
        ],
        'scroll-mx': ['scroll-mr', 'scroll-ml'],
        'scroll-my': ['scroll-mt', 'scroll-mb'],
        'scroll-p': [
          'scroll-px',
          'scroll-py',
          'scroll-ps',
          'scroll-pe',
          'scroll-pt',
          'scroll-pr',
          'scroll-pb',
          'scroll-pl',
        ],
        'scroll-px': ['scroll-pr', 'scroll-pl'],
        'scroll-py': ['scroll-pt', 'scroll-pb'],
        touch: ['touch-x', 'touch-y', 'touch-pz'],
        'touch-x': ['touch'],
        'touch-y': ['touch'],
        'touch-pz': ['touch'],
      },
      conflictingClassGroupModifiers: { 'font-size': ['leading'] },
      orderSensitiveModifiers: [
        '*',
        '**',
        'after',
        'backdrop',
        'before',
        'details-content',
        'file',
        'first-letter',
        'first-line',
        'marker',
        'placeholder',
        'selection',
      ],
    };
  },
  sne = LV($V);
function uP(n, e, t) {
  return Math.max(n, Math.min(e, t));
}
class eH {
  advance(e) {
    if (!this.isRunning) return;
    let t = !1;
    if (this.lerp)
      ((this.value =
        ((i = this.value),
        (r = this.to),
        (s = 60 * this.lerp),
        (a = e),
        (function (o, l, c) {
          return (1 - c) * o + c * l;
        })(i, r, 1 - Math.exp(-s * a)))),
        Math.round(this.value) === this.to &&
          ((this.value = this.to), (t = !0)));
    else {
      this.currentTime += e;
      const o = uP(0, this.currentTime / this.duration, 1);
      t = o >= 1;
      const l = t ? 1 : this.easing(o);
      this.value = this.from + (this.to - this.from) * l;
    }
    var i, r, s, a;
    (this.onUpdate?.(this.value, t), t && this.stop());
  }
  stop() {
    this.isRunning = !1;
  }
  fromTo(
    e,
    t,
    {
      lerp: i = 0.1,
      duration: r = 1,
      easing: s = (l) => l,
      onStart: a,
      onUpdate: o,
    }
  ) {
    ((this.from = this.value = e),
      (this.to = t),
      (this.lerp = i),
      (this.duration = r),
      (this.easing = s),
      (this.currentTime = 0),
      (this.isRunning = !0),
      a?.(),
      (this.onUpdate = o));
  }
}
class tH {
  constructor({
    wrapper: e,
    content: t,
    autoResize: i = !0,
    debounce: r = 250,
  } = {}) {
    ((this.wrapper = e),
      (this.content = t),
      i &&
        ((this.debouncedResize = (function (s, a) {
          let o;
          return function () {
            let l = arguments,
              c = this;
            (clearTimeout(o),
              (o = setTimeout(function () {
                s.apply(c, l);
              }, a)));
          };
        })(this.resize, r)),
        this.wrapper === window
          ? window.addEventListener('resize', this.debouncedResize, !1)
          : ((this.wrapperResizeObserver = new ResizeObserver(
              this.debouncedResize
            )),
            this.wrapperResizeObserver.observe(this.wrapper)),
        (this.contentResizeObserver = new ResizeObserver(this.debouncedResize)),
        this.contentResizeObserver.observe(this.content)),
      this.resize());
  }
  destroy() {
    (this.wrapperResizeObserver?.disconnect(),
      this.contentResizeObserver?.disconnect(),
      window.removeEventListener('resize', this.debouncedResize, !1));
  }
  resize = () => {
    (this.onWrapperResize(), this.onContentResize());
  };
  onWrapperResize = () => {
    this.wrapper === window
      ? ((this.width = window.innerWidth), (this.height = window.innerHeight))
      : ((this.width = this.wrapper.clientWidth),
        (this.height = this.wrapper.clientHeight));
  };
  onContentResize = () => {
    this.wrapper === window
      ? ((this.scrollHeight = this.content.scrollHeight),
        (this.scrollWidth = this.content.scrollWidth))
      : ((this.scrollHeight = this.wrapper.scrollHeight),
        (this.scrollWidth = this.wrapper.scrollWidth));
  };
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height,
    };
  }
}
class hP {
  constructor() {
    this.events = {};
  }
  emit(e, ...t) {
    let i = this.events[e] || [];
    for (let r = 0, s = i.length; r < s; r++) i[r](...t);
  }
  on(e, t) {
    return (
      this.events[e]?.push(t) || (this.events[e] = [t]),
      () => {
        this.events[e] = this.events[e]?.filter((i) => t !== i);
      }
    );
  }
  off(e, t) {
    this.events[e] = this.events[e]?.filter((i) => t !== i);
  }
  destroy() {
    this.events = {};
  }
}
const WE = 100 / 6;
class nH {
  constructor(e, { wheelMultiplier: t = 1, touchMultiplier: i = 1 }) {
    ((this.element = e),
      (this.wheelMultiplier = t),
      (this.touchMultiplier = i),
      (this.touchStart = { x: null, y: null }),
      (this.emitter = new hP()),
      window.addEventListener('resize', this.onWindowResize, !1),
      this.onWindowResize(),
      this.element.addEventListener('wheel', this.onWheel, { passive: !1 }),
      this.element.addEventListener('touchstart', this.onTouchStart, {
        passive: !1,
      }),
      this.element.addEventListener('touchmove', this.onTouchMove, {
        passive: !1,
      }),
      this.element.addEventListener('touchend', this.onTouchEnd, {
        passive: !1,
      }));
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  destroy() {
    (this.emitter.destroy(),
      window.removeEventListener('resize', this.onWindowResize, !1),
      this.element.removeEventListener('wheel', this.onWheel, { passive: !1 }),
      this.element.removeEventListener('touchstart', this.onTouchStart, {
        passive: !1,
      }),
      this.element.removeEventListener('touchmove', this.onTouchMove, {
        passive: !1,
      }),
      this.element.removeEventListener('touchend', this.onTouchEnd, {
        passive: !1,
      }));
  }
  onTouchStart = (e) => {
    const { clientX: t, clientY: i } = e.targetTouches ? e.targetTouches[0] : e;
    ((this.touchStart.x = t),
      (this.touchStart.y = i),
      (this.lastDelta = { x: 0, y: 0 }),
      this.emitter.emit('scroll', { deltaX: 0, deltaY: 0, event: e }));
  };
  onTouchMove = (e) => {
    const { clientX: t, clientY: i } = e.targetTouches ? e.targetTouches[0] : e,
      r = -(t - this.touchStart.x) * this.touchMultiplier,
      s = -(i - this.touchStart.y) * this.touchMultiplier;
    ((this.touchStart.x = t),
      (this.touchStart.y = i),
      (this.lastDelta = { x: r, y: s }),
      this.emitter.emit('scroll', { deltaX: r, deltaY: s, event: e }));
  };
  onTouchEnd = (e) => {
    this.emitter.emit('scroll', {
      deltaX: this.lastDelta.x,
      deltaY: this.lastDelta.y,
      event: e,
    });
  };
  onWheel = (e) => {
    let { deltaX: t, deltaY: i, deltaMode: r } = e;
    ((t *= r === 1 ? WE : r === 2 ? this.windowWidth : 1),
      (i *= r === 1 ? WE : r === 2 ? this.windowHeight : 1),
      (t *= this.wheelMultiplier),
      (i *= this.wheelMultiplier),
      this.emitter.emit('scroll', { deltaX: t, deltaY: i, event: e }));
  };
  onWindowResize = () => {
    ((this.windowWidth = window.innerWidth),
      (this.windowHeight = window.innerHeight));
  };
}
class ane {
  constructor({
    wrapper: e = window,
    content: t = document.documentElement,
    wheelEventsTarget: i = e,
    eventsTarget: r = i,
    smoothWheel: s = !0,
    syncTouch: a = !1,
    syncTouchLerp: o = 0.075,
    touchInertiaMultiplier: l = 35,
    duration: c,
    easing: u = (_) => Math.min(1, 1.001 - Math.pow(2, -10 * _)),
    lerp: h = !c && 0.1,
    infinite: d = !1,
    orientation: f = 'vertical',
    gestureOrientation: p = 'vertical',
    touchMultiplier: m = 1,
    wheelMultiplier: g = 1,
    autoResize: v = !0,
    __experimental__naiveDimensions: y = !1,
  } = {}) {
    ((this.__isSmooth = !1),
      (this.__isScrolling = !1),
      (this.__isStopped = !1),
      (this.__isLocked = !1),
      (this.onVirtualScroll = ({ deltaX: _, deltaY: x, event: S }) => {
        if (S.ctrlKey) return;
        const b = S.type.includes('touch'),
          A = S.type.includes('wheel');
        if (
          this.options.syncTouch &&
          b &&
          S.type === 'touchstart' &&
          !this.isStopped &&
          !this.isLocked
        )
          return void this.reset();
        const E = _ === 0 && x === 0,
          w =
            (this.options.gestureOrientation === 'vertical' && x === 0) ||
            (this.options.gestureOrientation === 'horizontal' && _ === 0);
        if (E || w) return;
        let M = S.composedPath();
        if (
          ((M = M.slice(0, M.indexOf(this.rootElement))),
          M.find((O) => {
            var z, C, N, U, W;
            return (
              ((z = O.hasAttribute) === null || z === void 0
                ? void 0
                : z.call(O, 'data-lenis-prevent')) ||
              (b &&
                ((C = O.hasAttribute) === null || C === void 0
                  ? void 0
                  : C.call(O, 'data-lenis-prevent-touch'))) ||
              (A &&
                ((N = O.hasAttribute) === null || N === void 0
                  ? void 0
                  : N.call(O, 'data-lenis-prevent-wheel'))) ||
              (((U = O.classList) === null || U === void 0
                ? void 0
                : U.contains('lenis')) &&
                !(
                  !((W = O.classList) === null || W === void 0) &&
                  W.contains('lenis-stopped')
                ))
            );
          }))
        )
          return;
        if (this.isStopped || this.isLocked) return void S.preventDefault();
        if (
          ((this.isSmooth =
            (this.options.syncTouch && b) || (this.options.smoothWheel && A)),
          !this.isSmooth)
        )
          return ((this.isScrolling = !1), void this.animate.stop());
        S.preventDefault();
        let T = x;
        this.options.gestureOrientation === 'both'
          ? (T = Math.abs(x) > Math.abs(_) ? x : _)
          : this.options.gestureOrientation === 'horizontal' && (T = _);
        const D = b && this.options.syncTouch,
          L = b && S.type === 'touchend' && Math.abs(T) > 5;
        (L && (T = this.velocity * this.options.touchInertiaMultiplier),
          this.scrollTo(
            this.targetScroll + T,
            Object.assign(
              { programmatic: !1 },
              D
                ? { lerp: L ? this.options.syncTouchLerp : 1 }
                : {
                    lerp: this.options.lerp,
                    duration: this.options.duration,
                    easing: this.options.easing,
                  }
            )
          ));
      }),
      (this.onNativeScroll = () => {
        if (!this.__preventNextScrollEvent && !this.isScrolling) {
          const _ = this.animatedScroll;
          ((this.animatedScroll = this.targetScroll = this.actualScroll),
            (this.velocity = 0),
            (this.direction = Math.sign(this.animatedScroll - _)),
            this.emit());
        }
      }),
      (window.lenisVersion = '1.0.42'),
      (e !== document.documentElement && e !== document.body) || (e = window),
      (this.options = {
        wrapper: e,
        content: t,
        wheelEventsTarget: i,
        eventsTarget: r,
        smoothWheel: s,
        syncTouch: a,
        syncTouchLerp: o,
        touchInertiaMultiplier: l,
        duration: c,
        easing: u,
        lerp: h,
        infinite: d,
        gestureOrientation: p,
        orientation: f,
        touchMultiplier: m,
        wheelMultiplier: g,
        autoResize: v,
        __experimental__naiveDimensions: y,
      }),
      (this.animate = new eH()),
      (this.emitter = new hP()),
      (this.dimensions = new tH({ wrapper: e, content: t, autoResize: v })),
      this.toggleClassName('lenis', !0),
      (this.velocity = 0),
      (this.isLocked = !1),
      (this.isStopped = !1),
      (this.isSmooth = a || s),
      (this.isScrolling = !1),
      (this.targetScroll = this.animatedScroll = this.actualScroll),
      this.options.wrapper.addEventListener('scroll', this.onNativeScroll, !1),
      (this.virtualScroll = new nH(r, {
        touchMultiplier: m,
        wheelMultiplier: g,
      })),
      this.virtualScroll.on('scroll', this.onVirtualScroll));
  }
  destroy() {
    (this.emitter.destroy(),
      this.options.wrapper.removeEventListener(
        'scroll',
        this.onNativeScroll,
        !1
      ),
      this.virtualScroll.destroy(),
      this.dimensions.destroy(),
      this.toggleClassName('lenis', !1),
      this.toggleClassName('lenis-smooth', !1),
      this.toggleClassName('lenis-scrolling', !1),
      this.toggleClassName('lenis-stopped', !1),
      this.toggleClassName('lenis-locked', !1));
  }
  on(e, t) {
    return this.emitter.on(e, t);
  }
  off(e, t) {
    return this.emitter.off(e, t);
  }
  setScroll(e) {
    this.isHorizontal
      ? (this.rootElement.scrollLeft = e)
      : (this.rootElement.scrollTop = e);
  }
  resize() {
    this.dimensions.resize();
  }
  emit() {
    this.emitter.emit('scroll', this);
  }
  reset() {
    ((this.isLocked = !1),
      (this.isScrolling = !1),
      (this.animatedScroll = this.targetScroll = this.actualScroll),
      (this.velocity = 0),
      this.animate.stop());
  }
  start() {
    this.isStopped && ((this.isStopped = !1), this.reset());
  }
  stop() {
    this.isStopped ||
      ((this.isStopped = !0), this.animate.stop(), this.reset());
  }
  raf(e) {
    const t = e - (this.time || e);
    ((this.time = e), this.animate.advance(0.001 * t));
  }
  scrollTo(
    e,
    {
      offset: t = 0,
      immediate: i = !1,
      lock: r = !1,
      duration: s = this.options.duration,
      easing: a = this.options.easing,
      lerp: o = !s && this.options.lerp,
      onComplete: l,
      force: c = !1,
      programmatic: u = !0,
    } = {}
  ) {
    if ((!this.isStopped && !this.isLocked) || c) {
      if (['top', 'left', 'start'].includes(e)) e = 0;
      else if (['bottom', 'right', 'end'].includes(e)) e = this.limit;
      else {
        let h;
        if (
          (typeof e == 'string'
            ? (h = document.querySelector(e))
            : e?.nodeType && (h = e),
          h)
        ) {
          if (this.options.wrapper !== window) {
            const f = this.options.wrapper.getBoundingClientRect();
            t -= this.isHorizontal ? f.left : f.top;
          }
          const d = h.getBoundingClientRect();
          e = (this.isHorizontal ? d.left : d.top) + this.animatedScroll;
        }
      }
      if (typeof e == 'number') {
        if (
          ((e += t),
          (e = Math.round(e)),
          this.options.infinite
            ? u && (this.targetScroll = this.animatedScroll = this.scroll)
            : (e = uP(0, e, this.limit)),
          i)
        )
          return (
            (this.animatedScroll = this.targetScroll = e),
            this.setScroll(this.scroll),
            this.reset(),
            void (l == null || l(this))
          );
        if (!u) {
          if (e === this.targetScroll) return;
          this.targetScroll = e;
        }
        this.animate.fromTo(this.animatedScroll, e, {
          duration: s,
          easing: a,
          lerp: o,
          onStart: () => {
            (r && (this.isLocked = !0), (this.isScrolling = !0));
          },
          onUpdate: (h, d) => {
            ((this.isScrolling = !0),
              (this.velocity = h - this.animatedScroll),
              (this.direction = Math.sign(this.velocity)),
              (this.animatedScroll = h),
              this.setScroll(this.scroll),
              u && (this.targetScroll = h),
              d || this.emit(),
              d &&
                (this.reset(),
                this.emit(),
                l?.(this),
                (this.__preventNextScrollEvent = !0),
                requestAnimationFrame(() => {
                  delete this.__preventNextScrollEvent;
                })));
          },
        });
      }
    }
  }
  get rootElement() {
    return this.options.wrapper === window
      ? document.documentElement
      : this.options.wrapper;
  }
  get limit() {
    return this.options.__experimental__naiveDimensions
      ? this.isHorizontal
        ? this.rootElement.scrollWidth - this.rootElement.clientWidth
        : this.rootElement.scrollHeight - this.rootElement.clientHeight
      : this.dimensions.limit[this.isHorizontal ? 'x' : 'y'];
  }
  get isHorizontal() {
    return this.options.orientation === 'horizontal';
  }
  get actualScroll() {
    return this.isHorizontal
      ? this.rootElement.scrollLeft
      : this.rootElement.scrollTop;
  }
  get scroll() {
    return this.options.infinite
      ? ((e = this.animatedScroll), (t = this.limit), ((e % t) + t) % t)
      : this.animatedScroll;
    var e, t;
  }
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  get isSmooth() {
    return this.__isSmooth;
  }
  set isSmooth(e) {
    this.__isSmooth !== e &&
      ((this.__isSmooth = e), this.toggleClassName('lenis-smooth', e));
  }
  get isScrolling() {
    return this.__isScrolling;
  }
  set isScrolling(e) {
    this.__isScrolling !== e &&
      ((this.__isScrolling = e), this.toggleClassName('lenis-scrolling', e));
  }
  get isStopped() {
    return this.__isStopped;
  }
  set isStopped(e) {
    this.__isStopped !== e &&
      ((this.__isStopped = e), this.toggleClassName('lenis-stopped', e));
  }
  get isLocked() {
    return this.__isLocked;
  }
  set isLocked(e) {
    this.__isLocked !== e &&
      ((this.__isLocked = e), this.toggleClassName('lenis-locked', e));
  }
  get className() {
    let e = 'lenis';
    return (
      this.isStopped && (e += ' lenis-stopped'),
      this.isLocked && (e += ' lenis-locked'),
      this.isScrolling && (e += ' lenis-scrolling'),
      this.isSmooth && (e += ' lenis-smooth'),
      e
    );
  }
  toggleClassName(e, t) {
    (this.rootElement.classList.toggle(e, t),
      this.emitter.emit('className change', this));
  }
}
const At = typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__,
  Jt = globalThis,
  So = '10.23.0';
function um() {
  return (hm(Jt), Jt);
}
function hm(n) {
  const e = (n.__SENTRY__ = n.__SENTRY__ || {});
  return ((e.version = e.version || So), (e[So] = e[So] || {}));
}
function yc(n, e, t = Jt) {
  const i = (t.__SENTRY__ = t.__SENTRY__ || {}),
    r = (i[So] = i[So] || {});
  return r[n] || (r[n] = e());
}
const iH = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'],
  rH = 'Sentry Logger ',
  ip = {};
function xc(n) {
  if (!('console' in Jt)) return n();
  const e = Jt.console,
    t = {},
    i = Object.keys(ip);
  i.forEach((r) => {
    const s = ip[r];
    ((t[r] = e[r]), (e[r] = s));
  });
  try {
    return n();
  } finally {
    i.forEach((r) => {
      e[r] = t[r];
    });
  }
}
function sH() {
  Ax().enabled = !0;
}
function aH() {
  Ax().enabled = !1;
}
function dP() {
  return Ax().enabled;
}
function oH(...n) {
  Ex('log', ...n);
}
function lH(...n) {
  Ex('warn', ...n);
}
function cH(...n) {
  Ex('error', ...n);
}
function Ex(n, ...e) {
  At &&
    dP() &&
    xc(() => {
      Jt.console[n](`${rH}[${n}]:`, ...e);
    });
}
function Ax() {
  return At ? yc('loggerSettings', () => ({ enabled: !1 })) : { enabled: !1 };
}
const mt = {
    enable: sH,
    disable: aH,
    isEnabled: dP,
    log: oH,
    warn: lH,
    error: cH,
  },
  fP = 50,
  Co = '?',
  jE = /\(error: (.*)\)/,
  XE = /captureMessage|captureException/;
function pP(...n) {
  const e = n.sort((t, i) => t[0] - i[0]).map((t) => t[1]);
  return (t, i = 0, r = 0) => {
    const s = [],
      a = t.split(`
`);
    for (let o = i; o < a.length; o++) {
      let l = a[o];
      l.length > 1024 && (l = l.slice(0, 1024));
      const c = jE.test(l) ? l.replace(jE, '$1') : l;
      if (!c.match(/\S*Error: /)) {
        for (const u of e) {
          const h = u(c);
          if (h) {
            s.push(h);
            break;
          }
        }
        if (s.length >= fP + r) break;
      }
    }
    return hH(s.slice(r));
  };
}
function uH(n) {
  return Array.isArray(n) ? pP(...n) : n;
}
function hH(n) {
  if (!n.length) return [];
  const e = Array.from(n);
  return (
    /sentryWrapped/.test(_d(e).function || '') && e.pop(),
    e.reverse(),
    XE.test(_d(e).function || '') &&
      (e.pop(), XE.test(_d(e).function || '') && e.pop()),
    e
      .slice(0, fP)
      .map((t) => ({
        ...t,
        filename: t.filename || _d(e).filename,
        function: t.function || Co,
      }))
  );
}
function _d(n) {
  return n[n.length - 1] || {};
}
const s0 = '<anonymous>';
function Zs(n) {
  try {
    return !n || typeof n != 'function' ? s0 : n.name || s0;
  } catch {
    return s0;
  }
}
function qE(n) {
  const e = n.exception;
  if (e) {
    const t = [];
    try {
      return (
        e.values.forEach((i) => {
          i.stacktrace.frames && t.push(...i.stacktrace.frames);
        }),
        t
      );
    } catch {
      return;
    }
  }
}
const Cf = {},
  YE = {};
function Fo(n, e) {
  ((Cf[n] = Cf[n] || []), Cf[n].push(e));
}
function zo(n, e) {
  if (!YE[n]) {
    YE[n] = !0;
    try {
      e();
    } catch (t) {
      At && mt.error(`Error while instrumenting ${n}`, t);
    }
  }
}
function Ar(n, e) {
  const t = n && Cf[n];
  if (t)
    for (const i of t)
      try {
        i(e);
      } catch (r) {
        At &&
          mt.error(
            `Error while triggering instrumentation handler.
Type: ${n}
Name: ${Zs(i)}
Error:`,
            r
          );
      }
}
let a0 = null;
function dH(n) {
  const e = 'error';
  (Fo(e, n), zo(e, fH));
}
function fH() {
  ((a0 = Jt.onerror),
    (Jt.onerror = function (n, e, t, i, r) {
      return (
        Ar('error', { column: i, error: r, line: t, msg: n, url: e }),
        a0 ? a0.apply(this, arguments) : !1
      );
    }),
    (Jt.onerror.__SENTRY_INSTRUMENTED__ = !0));
}
let o0 = null;
function pH(n) {
  const e = 'unhandledrejection';
  (Fo(e, n), zo(e, mH));
}
function mH() {
  ((o0 = Jt.onunhandledrejection),
    (Jt.onunhandledrejection = function (n) {
      return (Ar('unhandledrejection', n), o0 ? o0.apply(this, arguments) : !0);
    }),
    (Jt.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0));
}
const mP = Object.prototype.toString;
function Mx(n) {
  switch (mP.call(n)) {
    case '[object Error]':
    case '[object Exception]':
    case '[object DOMException]':
    case '[object WebAssembly.Exception]':
      return !0;
    default:
      return $s(n, Error);
  }
}
function bc(n, e) {
  return mP.call(n) === `[object ${e}]`;
}
function gP(n) {
  return bc(n, 'ErrorEvent');
}
function KE(n) {
  return bc(n, 'DOMError');
}
function gH(n) {
  return bc(n, 'DOMException');
}
function us(n) {
  return bc(n, 'String');
}
function Tx(n) {
  return (
    typeof n == 'object' &&
    n !== null &&
    '__sentry_template_string__' in n &&
    '__sentry_template_values__' in n
  );
}
function dm(n) {
  return (
    n === null || Tx(n) || (typeof n != 'object' && typeof n != 'function')
  );
}
function th(n) {
  return bc(n, 'Object');
}
function fm(n) {
  return typeof Event < 'u' && $s(n, Event);
}
function vH(n) {
  return typeof Element < 'u' && $s(n, Element);
}
function _H(n) {
  return bc(n, 'RegExp');
}
function Ch(n) {
  return !!(n?.then && typeof n.then == 'function');
}
function yH(n) {
  return (
    th(n) &&
    'nativeEvent' in n &&
    'preventDefault' in n &&
    'stopPropagation' in n
  );
}
function $s(n, e) {
  try {
    return n instanceof e;
  } catch {
    return !1;
  }
}
function vP(n) {
  return !!(typeof n == 'object' && n !== null && (n.__isVue || n._isVue));
}
function xH(n) {
  return typeof Request < 'u' && $s(n, Request);
}
const Cx = Jt,
  bH = 80;
function _P(n, e = {}) {
  if (!n) return '<unknown>';
  try {
    let t = n;
    const i = 5,
      r = [];
    let s = 0,
      a = 0;
    const o = ' > ',
      l = o.length;
    let c;
    const u = Array.isArray(e) ? e : e.keyAttrs,
      h = (!Array.isArray(e) && e.maxStringLength) || bH;
    for (
      ;
      t &&
      s++ < i &&
      ((c = SH(t, u)),
      !(c === 'html' || (s > 1 && a + r.length * l + c.length >= h)));

    )
      (r.push(c), (a += c.length), (t = t.parentNode));
    return r.reverse().join(o);
  } catch {
    return '<unknown>';
  }
}
function SH(n, e) {
  const t = n,
    i = [];
  if (!t?.tagName) return '';
  if (Cx.HTMLElement && t instanceof HTMLElement && t.dataset) {
    if (t.dataset.sentryComponent) return t.dataset.sentryComponent;
    if (t.dataset.sentryElement) return t.dataset.sentryElement;
  }
  i.push(t.tagName.toLowerCase());
  const r = e?.length
    ? e.filter((a) => t.getAttribute(a)).map((a) => [a, t.getAttribute(a)])
    : null;
  if (r?.length)
    r.forEach((a) => {
      i.push(`[${a[0]}="${a[1]}"]`);
    });
  else {
    t.id && i.push(`#${t.id}`);
    const a = t.className;
    if (a && us(a)) {
      const o = a.split(/\s+/);
      for (const l of o) i.push(`.${l}`);
    }
  }
  const s = ['aria-label', 'type', 'name', 'title', 'alt'];
  for (const a of s) {
    const o = t.getAttribute(a);
    o && i.push(`[${a}="${o}"]`);
  }
  return i.join('');
}
function Rx() {
  try {
    return Cx.document.location.href;
  } catch {
    return '';
  }
}
function wH(n) {
  if (!Cx.HTMLElement) return null;
  let e = n;
  const t = 5;
  for (let i = 0; i < t; i++) {
    if (!e) return null;
    if (e instanceof HTMLElement) {
      if (e.dataset.sentryComponent) return e.dataset.sentryComponent;
      if (e.dataset.sentryElement) return e.dataset.sentryElement;
    }
    e = e.parentNode;
  }
  return null;
}
function rp(n, e = 0) {
  return typeof n != 'string' || e === 0 || n.length <= e
    ? n
    : `${n.slice(0, e)}...`;
}
function JE(n, e) {
  if (!Array.isArray(n)) return '';
  const t = [];
  for (let i = 0; i < n.length; i++) {
    const r = n[i];
    try {
      vP(r) ? t.push('[VueViewModel]') : t.push(String(r));
    } catch {
      t.push('[value cannot be serialized]');
    }
  }
  return t.join(e);
}
function Rf(n, e, t = !1) {
  return us(n)
    ? _H(e)
      ? e.test(n)
      : us(e)
        ? t
          ? n === e
          : n.includes(e)
        : !1
    : !1;
}
function pm(n, e = [], t = !1) {
  return e.some((i) => Rf(n, i, t));
}
function Vi(n, e, t) {
  if (!(e in n)) return;
  const i = n[e];
  if (typeof i != 'function') return;
  const r = t(i);
  typeof r == 'function' && yP(r, i);
  try {
    n[e] = r;
  } catch {
    At && mt.log(`Failed to replace method "${e}" in object`, n);
  }
}
function Ro(n, e, t) {
  try {
    Object.defineProperty(n, e, { value: t, writable: !0, configurable: !0 });
  } catch {
    At && mt.log(`Failed to add non-enumerable property "${e}" to object`, n);
  }
}
function yP(n, e) {
  try {
    const t = e.prototype || {};
    ((n.prototype = e.prototype = t), Ro(n, '__sentry_original__', e));
  } catch {}
}
function Ix(n) {
  return n.__sentry_original__;
}
function xP(n) {
  if (Mx(n))
    return { message: n.message, name: n.name, stack: n.stack, ...ZE(n) };
  if (fm(n)) {
    const e = {
      type: n.type,
      target: QE(n.target),
      currentTarget: QE(n.currentTarget),
      ...ZE(n),
    };
    return (
      typeof CustomEvent < 'u' && $s(n, CustomEvent) && (e.detail = n.detail),
      e
    );
  } else return n;
}
function QE(n) {
  try {
    return vH(n) ? _P(n) : Object.prototype.toString.call(n);
  } catch {
    return '<unknown>';
  }
}
function ZE(n) {
  if (typeof n == 'object' && n !== null) {
    const e = {};
    for (const t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e;
  } else return {};
}
function EH(n, e = 40) {
  const t = Object.keys(xP(n));
  t.sort();
  const i = t[0];
  if (!i) return '[object has no keys]';
  if (i.length >= e) return rp(i, e);
  for (let r = t.length; r > 0; r--) {
    const s = t.slice(0, r).join(', ');
    if (!(s.length > e)) return r === t.length ? s : rp(s, e);
  }
  return '';
}
function AH() {
  const n = Jt;
  return n.crypto || n.msCrypto;
}
let l0;
function MH() {
  return Math.random() * 16;
}
function ar(n = AH()) {
  try {
    if (n?.randomUUID) return n.randomUUID().replace(/-/g, '');
  } catch {}
  return (
    l0 || (l0 = '10000000100040008000' + 1e11),
    l0.replace(/[018]/g, (e) => (e ^ ((MH() & 15) >> (e / 4))).toString(16))
  );
}
function bP(n) {
  return n.exception?.values?.[0];
}
function ro(n) {
  const { message: e, event_id: t } = n;
  if (e) return e;
  const i = bP(n);
  return i
    ? i.type && i.value
      ? `${i.type}: ${i.value}`
      : i.type || i.value || t || '<unknown>'
    : t || '<unknown>';
}
function w_(n, e, t) {
  const i = (n.exception = n.exception || {}),
    r = (i.values = i.values || []),
    s = (r[0] = r[0] || {});
  (s.value || (s.value = e || ''), s.type || (s.type = 'Error'));
}
function Jl(n, e) {
  const t = bP(n);
  if (!t) return;
  const i = { type: 'generic', handled: !0 },
    r = t.mechanism;
  if (((t.mechanism = { ...i, ...r, ...e }), e && 'data' in e)) {
    const s = { ...r?.data, ...e.data };
    t.mechanism.data = s;
  }
}
function $E(n) {
  if (TH(n)) return !0;
  try {
    Ro(n, '__sentry_captured__', !0);
  } catch {}
  return !1;
}
function TH(n) {
  try {
    return n.__sentry_captured__;
  } catch {}
}
const SP = 1e3;
function Rh() {
  return Date.now() / SP;
}
function CH() {
  const { performance: n } = Jt;
  if (!n?.now || !n.timeOrigin) return Rh;
  const e = n.timeOrigin;
  return () => (e + n.now()) / SP;
}
let eA;
function hs() {
  return (eA ?? (eA = CH()))();
}
function RH(n) {
  const e = hs(),
    t = {
      sid: ar(),
      init: !0,
      timestamp: e,
      started: e,
      duration: 0,
      status: 'ok',
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => PH(t),
    };
  return (n && Ql(t, n), t);
}
function Ql(n, e = {}) {
  if (
    (e.user &&
      (!n.ipAddress && e.user.ip_address && (n.ipAddress = e.user.ip_address),
      !n.did &&
        !e.did &&
        (n.did = e.user.id || e.user.email || e.user.username)),
    (n.timestamp = e.timestamp || hs()),
    e.abnormal_mechanism && (n.abnormal_mechanism = e.abnormal_mechanism),
    e.ignoreDuration && (n.ignoreDuration = e.ignoreDuration),
    e.sid && (n.sid = e.sid.length === 32 ? e.sid : ar()),
    e.init !== void 0 && (n.init = e.init),
    !n.did && e.did && (n.did = `${e.did}`),
    typeof e.started == 'number' && (n.started = e.started),
    n.ignoreDuration)
  )
    n.duration = void 0;
  else if (typeof e.duration == 'number') n.duration = e.duration;
  else {
    const t = n.timestamp - n.started;
    n.duration = t >= 0 ? t : 0;
  }
  (e.release && (n.release = e.release),
    e.environment && (n.environment = e.environment),
    !n.ipAddress && e.ipAddress && (n.ipAddress = e.ipAddress),
    !n.userAgent && e.userAgent && (n.userAgent = e.userAgent),
    typeof e.errors == 'number' && (n.errors = e.errors),
    e.status && (n.status = e.status));
}
function IH(n, e) {
  let t = {};
  (n.status === 'ok' && (t = { status: 'exited' }), Ql(n, t));
}
function PH(n) {
  return {
    sid: `${n.sid}`,
    init: n.init,
    started: new Date(n.started * 1e3).toISOString(),
    timestamp: new Date(n.timestamp * 1e3).toISOString(),
    status: n.status,
    errors: n.errors,
    did:
      typeof n.did == 'number' || typeof n.did == 'string'
        ? `${n.did}`
        : void 0,
    duration: n.duration,
    abnormal_mechanism: n.abnormal_mechanism,
    attrs: {
      release: n.release,
      environment: n.environment,
      ip_address: n.ipAddress,
      user_agent: n.userAgent,
    },
  };
}
function Ih(n, e, t = 2) {
  if (!e || typeof e != 'object' || t <= 0) return e;
  if (n && Object.keys(e).length === 0) return n;
  const i = { ...n };
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      (i[r] = Ih(i[r], e[r], t - 1));
  return i;
}
function tA() {
  return ar();
}
function wP() {
  return ar().substring(16);
}
const E_ = '_sentrySpan';
function nA(n, e) {
  e ? Ro(n, E_, e) : delete n[E_];
}
function iA(n) {
  return n[E_];
}
const DH = 100;
class _s {
  constructor() {
    ((this._notifyingListeners = !1),
      (this._scopeListeners = []),
      (this._eventProcessors = []),
      (this._breadcrumbs = []),
      (this._attachments = []),
      (this._user = {}),
      (this._tags = {}),
      (this._extra = {}),
      (this._contexts = {}),
      (this._sdkProcessingMetadata = {}),
      (this._propagationContext = {
        traceId: tA(),
        sampleRand: Math.random(),
      }));
  }
  clone() {
    const e = new _s();
    return (
      (e._breadcrumbs = [...this._breadcrumbs]),
      (e._tags = { ...this._tags }),
      (e._extra = { ...this._extra }),
      (e._contexts = { ...this._contexts }),
      this._contexts.flags &&
        (e._contexts.flags = { values: [...this._contexts.flags.values] }),
      (e._user = this._user),
      (e._level = this._level),
      (e._session = this._session),
      (e._transactionName = this._transactionName),
      (e._fingerprint = this._fingerprint),
      (e._eventProcessors = [...this._eventProcessors]),
      (e._attachments = [...this._attachments]),
      (e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
      (e._propagationContext = { ...this._propagationContext }),
      (e._client = this._client),
      (e._lastEventId = this._lastEventId),
      nA(e, iA(this)),
      e
    );
  }
  setClient(e) {
    this._client = e;
  }
  setLastEventId(e) {
    this._lastEventId = e;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  addEventProcessor(e) {
    return (this._eventProcessors.push(e), this);
  }
  setUser(e) {
    return (
      (this._user = e || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        username: void 0,
      }),
      this._session && Ql(this._session, { user: e }),
      this._notifyScopeListeners(),
      this
    );
  }
  getUser() {
    return this._user;
  }
  setTags(e) {
    return (
      (this._tags = { ...this._tags, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setTag(e, t) {
    return (
      (this._tags = { ...this._tags, [e]: t }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtras(e) {
    return (
      (this._extra = { ...this._extra, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtra(e, t) {
    return (
      (this._extra = { ...this._extra, [e]: t }),
      this._notifyScopeListeners(),
      this
    );
  }
  setFingerprint(e) {
    return ((this._fingerprint = e), this._notifyScopeListeners(), this);
  }
  setLevel(e) {
    return ((this._level = e), this._notifyScopeListeners(), this);
  }
  setTransactionName(e) {
    return ((this._transactionName = e), this._notifyScopeListeners(), this);
  }
  setContext(e, t) {
    return (
      t === null ? delete this._contexts[e] : (this._contexts[e] = t),
      this._notifyScopeListeners(),
      this
    );
  }
  setSession(e) {
    return (
      e ? (this._session = e) : delete this._session,
      this._notifyScopeListeners(),
      this
    );
  }
  getSession() {
    return this._session;
  }
  update(e) {
    if (!e) return this;
    const t = typeof e == 'function' ? e(this) : e,
      i = t instanceof _s ? t.getScopeData() : th(t) ? e : void 0,
      {
        tags: r,
        extra: s,
        user: a,
        contexts: o,
        level: l,
        fingerprint: c = [],
        propagationContext: u,
      } = i || {};
    return (
      (this._tags = { ...this._tags, ...r }),
      (this._extra = { ...this._extra, ...s }),
      (this._contexts = { ...this._contexts, ...o }),
      a && Object.keys(a).length && (this._user = a),
      l && (this._level = l),
      c.length && (this._fingerprint = c),
      u && (this._propagationContext = u),
      this
    );
  }
  clear() {
    return (
      (this._breadcrumbs = []),
      (this._tags = {}),
      (this._extra = {}),
      (this._user = {}),
      (this._contexts = {}),
      (this._level = void 0),
      (this._transactionName = void 0),
      (this._fingerprint = void 0),
      (this._session = void 0),
      nA(this, void 0),
      (this._attachments = []),
      this.setPropagationContext({ traceId: tA(), sampleRand: Math.random() }),
      this._notifyScopeListeners(),
      this
    );
  }
  addBreadcrumb(e, t) {
    const i = typeof t == 'number' ? t : DH;
    if (i <= 0) return this;
    const r = {
      timestamp: Rh(),
      ...e,
      message: e.message ? rp(e.message, 2048) : e.message,
    };
    return (
      this._breadcrumbs.push(r),
      this._breadcrumbs.length > i &&
        ((this._breadcrumbs = this._breadcrumbs.slice(-i)),
        this._client?.recordDroppedEvent('buffer_overflow', 'log_item')),
      this._notifyScopeListeners(),
      this
    );
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return ((this._breadcrumbs = []), this._notifyScopeListeners(), this);
  }
  addAttachment(e) {
    return (this._attachments.push(e), this);
  }
  clearAttachments() {
    return ((this._attachments = []), this);
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: iA(this),
    };
  }
  setSDKProcessingMetadata(e) {
    return (
      (this._sdkProcessingMetadata = Ih(this._sdkProcessingMetadata, e, 2)),
      this
    );
  }
  setPropagationContext(e) {
    return ((this._propagationContext = e), this);
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(e, t) {
    const i = t?.event_id || ar();
    if (!this._client)
      return (
        At &&
          mt.warn(
            'No client configured on scope - will not capture exception!'
          ),
        i
      );
    const r = new Error('Sentry syntheticException');
    return (
      this._client.captureException(
        e,
        { originalException: e, syntheticException: r, ...t, event_id: i },
        this
      ),
      i
    );
  }
  captureMessage(e, t, i) {
    const r = i?.event_id || ar();
    if (!this._client)
      return (
        At &&
          mt.warn('No client configured on scope - will not capture message!'),
        r
      );
    const s = new Error(e);
    return (
      this._client.captureMessage(
        e,
        t,
        { originalException: e, syntheticException: s, ...i, event_id: r },
        this
      ),
      r
    );
  }
  captureEvent(e, t) {
    const i = t?.event_id || ar();
    return this._client
      ? (this._client.captureEvent(e, { ...t, event_id: i }, this), i)
      : (At &&
          mt.warn('No client configured on scope - will not capture event!'),
        i);
  }
  _notifyScopeListeners() {
    this._notifyingListeners ||
      ((this._notifyingListeners = !0),
      this._scopeListeners.forEach((e) => {
        e(this);
      }),
      (this._notifyingListeners = !1));
  }
}
function OH() {
  return yc('defaultCurrentScope', () => new _s());
}
function LH() {
  return yc('defaultIsolationScope', () => new _s());
}
class UH {
  constructor(e, t) {
    let i;
    e ? (i = e) : (i = new _s());
    let r;
    (t ? (r = t) : (r = new _s()),
      (this._stack = [{ scope: i }]),
      (this._isolationScope = r));
  }
  withScope(e) {
    const t = this._pushScope();
    let i;
    try {
      i = e(t);
    } catch (r) {
      throw (this._popScope(), r);
    }
    return Ch(i)
      ? i.then(
          (r) => (this._popScope(), r),
          (r) => {
            throw (this._popScope(), r);
          }
        )
      : (this._popScope(), i);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const e = this.getScope().clone();
    return (this._stack.push({ client: this.getClient(), scope: e }), e);
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function Zl() {
  const n = um(),
    e = hm(n);
  return (e.stack = e.stack || new UH(OH(), LH()));
}
function kH(n) {
  return Zl().withScope(n);
}
function BH(n, e) {
  const t = Zl();
  return t.withScope(() => ((t.getStackTop().scope = n), e(n)));
}
function rA(n) {
  return Zl().withScope(() => n(Zl().getIsolationScope()));
}
function NH() {
  return {
    withIsolationScope: rA,
    withScope: kH,
    withSetScope: BH,
    withSetIsolationScope: (n, e) => rA(e),
    getCurrentScope: () => Zl().getScope(),
    getIsolationScope: () => Zl().getIsolationScope(),
  };
}
function Px(n) {
  const e = hm(n);
  return e.acs ? e.acs : NH();
}
function oa() {
  const n = um();
  return Px(n).getCurrentScope();
}
function Sc() {
  const n = um();
  return Px(n).getIsolationScope();
}
function FH() {
  return yc('globalScope', () => new _s());
}
function zH(...n) {
  const e = um(),
    t = Px(e);
  if (n.length === 2) {
    const [i, r] = n;
    return i ? t.withSetScope(i, r) : t.withScope(r);
  }
  return t.withScope(n[0]);
}
function mi() {
  return oa().getClient();
}
function VH(n) {
  const e = n.getPropagationContext(),
    { traceId: t, parentSpanId: i, propagationSpanId: r } = e,
    s = { trace_id: t, span_id: r || wP() };
  return (i && (s.parent_span_id = i), s);
}
const HH = 'sentry.source',
  GH = 'sentry.sample_rate',
  WH = 'sentry.previous_trace_sample_rate',
  jH = 'sentry.op',
  XH = 'sentry.origin',
  EP = 'sentry.profile_id',
  AP = 'sentry.exclusive_time',
  qH = 0,
  YH = 1,
  KH = '_sentryScope',
  JH = '_sentryIsolationScope';
function QH(n) {
  if (n) {
    if (typeof n == 'object' && 'deref' in n && typeof n.deref == 'function')
      try {
        return n.deref();
      } catch {
        return;
      }
    return n;
  }
}
function MP(n) {
  const e = n;
  return { scope: e[KH], isolationScope: QH(e[JH]) };
}
const ZH = 'sentry-',
  $H = /^sentry-/;
function e5(n) {
  const e = t5(n);
  if (!e) return;
  const t = Object.entries(e).reduce((i, [r, s]) => {
    if (r.match($H)) {
      const a = r.slice(ZH.length);
      i[a] = s;
    }
    return i;
  }, {});
  if (Object.keys(t).length > 0) return t;
}
function t5(n) {
  if (!(!n || (!us(n) && !Array.isArray(n))))
    return Array.isArray(n)
      ? n.reduce((e, t) => {
          const i = sA(t);
          return (
            Object.entries(i).forEach(([r, s]) => {
              e[r] = s;
            }),
            e
          );
        }, {})
      : sA(n);
}
function sA(n) {
  return n
    .split(',')
    .map((e) => {
      const t = e.indexOf('=');
      if (t === -1) return [];
      const i = e.slice(0, t),
        r = e.slice(t + 1);
      return [i, r].map((s) => {
        try {
          return decodeURIComponent(s.trim());
        } catch {
          return;
        }
      });
    })
    .reduce((e, [t, i]) => (t && i && (e[t] = i), e), {});
}
const n5 = /^o(\d+)\./,
  i5 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function r5(n) {
  return n === 'http' || n === 'https';
}
function Ph(n, e = !1) {
  const {
    host: t,
    path: i,
    pass: r,
    port: s,
    projectId: a,
    protocol: o,
    publicKey: l,
  } = n;
  return `${o}://${l}${e && r ? `:${r}` : ''}@${t}${s ? `:${s}` : ''}/${i && `${i}/`}${a}`;
}
function s5(n) {
  const e = i5.exec(n);
  if (!e) {
    xc(() => {
      console.error(`Invalid Sentry Dsn: ${n}`);
    });
    return;
  }
  const [t, i, r = '', s = '', a = '', o = ''] = e.slice(1);
  let l = '',
    c = o;
  const u = c.split('/');
  if ((u.length > 1 && ((l = u.slice(0, -1).join('/')), (c = u.pop())), c)) {
    const h = c.match(/^\d+/);
    h && (c = h[0]);
  }
  return TP({
    host: s,
    pass: r,
    path: l,
    projectId: c,
    port: a,
    protocol: t,
    publicKey: i,
  });
}
function TP(n) {
  return {
    protocol: n.protocol,
    publicKey: n.publicKey || '',
    pass: n.pass || '',
    host: n.host,
    port: n.port || '',
    path: n.path || '',
    projectId: n.projectId,
  };
}
function a5(n) {
  if (!At) return !0;
  const { port: e, projectId: t, protocol: i } = n;
  return ['protocol', 'publicKey', 'host', 'projectId'].find((a) =>
    n[a] ? !1 : (mt.error(`Invalid Sentry Dsn: ${a} missing`), !0)
  )
    ? !1
    : t.match(/^\d+$/)
      ? r5(i)
        ? e && isNaN(parseInt(e, 10))
          ? (mt.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1)
          : !0
        : (mt.error(`Invalid Sentry Dsn: Invalid protocol ${i}`), !1)
      : (mt.error(`Invalid Sentry Dsn: Invalid projectId ${t}`), !1);
}
function o5(n) {
  return n.match(n5)?.[1];
}
function l5(n) {
  const e = n.getOptions(),
    { host: t } = n.getDsn() || {};
  let i;
  return (e.orgId ? (i = String(e.orgId)) : t && (i = o5(t)), i);
}
function c5(n) {
  const e = typeof n == 'string' ? s5(n) : TP(n);
  if (!(!e || !a5(e))) return e;
}
function u5(n) {
  if (typeof n == 'boolean') return Number(n);
  const e = typeof n == 'string' ? parseFloat(n) : n;
  if (!(typeof e != 'number' || isNaN(e) || e < 0 || e > 1)) return e;
}
const CP = 1;
let aA = !1;
function h5(n) {
  const { spanId: e, traceId: t, isRemote: i } = n.spanContext(),
    r = i ? e : Dx(n).parent_span_id,
    s = MP(n).scope,
    a = i ? s?.getPropagationContext().propagationSpanId || wP() : e;
  return { parent_span_id: r, span_id: a, trace_id: t };
}
function d5(n) {
  if (n && n.length > 0)
    return n.map(
      ({
        context: { spanId: e, traceId: t, traceFlags: i, ...r },
        attributes: s,
      }) => ({
        span_id: e,
        trace_id: t,
        sampled: i === CP,
        attributes: s,
        ...r,
      })
    );
}
function oA(n) {
  return typeof n == 'number'
    ? lA(n)
    : Array.isArray(n)
      ? n[0] + n[1] / 1e9
      : n instanceof Date
        ? lA(n.getTime())
        : hs();
}
function lA(n) {
  return n > 9999999999 ? n / 1e3 : n;
}
function Dx(n) {
  if (p5(n)) return n.getSpanJSON();
  const { spanId: e, traceId: t } = n.spanContext();
  if (f5(n)) {
    const {
        attributes: i,
        startTime: r,
        name: s,
        endTime: a,
        status: o,
        links: l,
      } = n,
      c =
        'parentSpanId' in n
          ? n.parentSpanId
          : 'parentSpanContext' in n
            ? n.parentSpanContext?.spanId
            : void 0;
    return {
      span_id: e,
      trace_id: t,
      data: i,
      description: s,
      parent_span_id: c,
      start_timestamp: oA(r),
      timestamp: oA(a) || void 0,
      status: g5(o),
      op: i[jH],
      origin: i[XH],
      links: d5(l),
    };
  }
  return { span_id: e, trace_id: t, start_timestamp: 0, data: {} };
}
function f5(n) {
  const e = n;
  return (
    !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status
  );
}
function p5(n) {
  return typeof n.getSpanJSON == 'function';
}
function m5(n) {
  const { traceFlags: e } = n.spanContext();
  return e === CP;
}
function g5(n) {
  if (!(!n || n.code === qH))
    return n.code === YH ? 'ok' : n.message || 'internal_error';
}
const v5 = '_sentryRootSpan';
function RP(n) {
  return n[v5] || n;
}
function cA() {
  aA ||
    (xc(() => {
      console.warn(
        '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly or use `ignoreSpans`.'
      );
    }),
    (aA = !0));
}
function _5(n) {
  if (typeof __SENTRY_TRACING__ == 'boolean' && !__SENTRY_TRACING__) return !1;
  const e = mi()?.getOptions();
  return !!e && (e.tracesSampleRate != null || !!e.tracesSampler);
}
function uA(n) {
  mt.log(
    `Ignoring span ${n.op} - ${n.description} because it matches \`ignoreSpans\`.`
  );
}
function hA(n, e) {
  if (!e?.length || !n.description) return !1;
  for (const t of e) {
    if (x5(t)) {
      if (Rf(n.description, t)) return (At && uA(n), !0);
      continue;
    }
    if (!t.name && !t.op) continue;
    const i = t.name ? Rf(n.description, t.name) : !0,
      r = t.op ? n.op && Rf(n.op, t.op) : !0;
    if (i && r) return (At && uA(n), !0);
  }
  return !1;
}
function y5(n, e) {
  const t = e.parent_span_id,
    i = e.span_id;
  if (t) for (const r of n) r.parent_span_id === i && (r.parent_span_id = t);
}
function x5(n) {
  return typeof n == 'string' || n instanceof RegExp;
}
const Ox = 'production',
  b5 = '_frozenDsc';
function IP(n, e) {
  const t = e.getOptions(),
    { publicKey: i } = e.getDsn() || {},
    r = {
      environment: t.environment || Ox,
      release: t.release,
      public_key: i,
      trace_id: n,
      org_id: l5(e),
    };
  return (e.emit('createDsc', r), r);
}
function S5(n, e) {
  const t = e.getPropagationContext();
  return t.dsc || IP(t.traceId, n);
}
function w5(n) {
  const e = mi();
  if (!e) return {};
  const t = RP(n),
    i = Dx(t),
    r = i.data,
    s = t.spanContext().traceState,
    a = s?.get('sentry.sample_rate') ?? r[GH] ?? r[WH];
  function o(p) {
    return (
      (typeof a == 'number' || typeof a == 'string') &&
        (p.sample_rate = `${a}`),
      p
    );
  }
  const l = t[b5];
  if (l) return o(l);
  const c = s?.get('sentry.dsc'),
    u = c && e5(c);
  if (u) return o(u);
  const h = IP(n.spanContext().traceId, e),
    d = r[HH],
    f = i.description;
  return (
    d !== 'url' && f && (h.transaction = f),
    _5() &&
      ((h.sampled = String(m5(t))),
      (h.sample_rand =
        s?.get('sentry.sample_rand') ??
        MP(t).scope?.getPropagationContext().sampleRand.toString())),
    o(h),
    e.emit('createDsc', h, t),
    h
  );
}
function as(n, e = 100, t = 1 / 0) {
  try {
    return A_('', n, e, t);
  } catch (i) {
    return { ERROR: `**non-serializable** (${i})` };
  }
}
function PP(n, e = 3, t = 100 * 1024) {
  const i = as(n, e);
  return T5(i) > t ? PP(n, e - 1, t) : i;
}
function A_(n, e, t = 1 / 0, i = 1 / 0, r = C5()) {
  const [s, a] = r;
  if (
    e == null ||
    ['boolean', 'string'].includes(typeof e) ||
    (typeof e == 'number' && Number.isFinite(e))
  )
    return e;
  const o = E5(n, e);
  if (!o.startsWith('[object ')) return o;
  if (e.__sentry_skip_normalization__) return e;
  const l =
    typeof e.__sentry_override_normalization_depth__ == 'number'
      ? e.__sentry_override_normalization_depth__
      : t;
  if (l === 0) return o.replace('object ', '');
  if (s(e)) return '[Circular ~]';
  const c = e;
  if (c && typeof c.toJSON == 'function')
    try {
      const f = c.toJSON();
      return A_('', f, l - 1, i, r);
    } catch {}
  const u = Array.isArray(e) ? [] : {};
  let h = 0;
  const d = xP(e);
  for (const f in d) {
    if (!Object.prototype.hasOwnProperty.call(d, f)) continue;
    if (h >= i) {
      u[f] = '[MaxProperties ~]';
      break;
    }
    const p = d[f];
    ((u[f] = A_(f, p, l - 1, i, r)), h++);
  }
  return (a(e), u);
}
function E5(n, e) {
  try {
    if (n === 'domain' && e && typeof e == 'object' && e._events)
      return '[Domain]';
    if (n === 'domainEmitter') return '[DomainEmitter]';
    if (typeof global < 'u' && e === global) return '[Global]';
    if (typeof window < 'u' && e === window) return '[Window]';
    if (typeof document < 'u' && e === document) return '[Document]';
    if (vP(e)) return '[VueViewModel]';
    if (yH(e)) return '[SyntheticEvent]';
    if (typeof e == 'number' && !Number.isFinite(e)) return `[${e}]`;
    if (typeof e == 'function') return `[Function: ${Zs(e)}]`;
    if (typeof e == 'symbol') return `[${String(e)}]`;
    if (typeof e == 'bigint') return `[BigInt: ${String(e)}]`;
    const t = A5(e);
    return /^HTML(\w*)Element$/.test(t)
      ? `[HTMLElement: ${t}]`
      : `[object ${t}]`;
  } catch (t) {
    return `**non-serializable** (${t})`;
  }
}
function A5(n) {
  const e = Object.getPrototypeOf(n);
  return e?.constructor ? e.constructor.name : 'null prototype';
}
function M5(n) {
  return ~-encodeURI(n).split(/%..|./).length;
}
function T5(n) {
  return M5(JSON.stringify(n));
}
function C5() {
  const n = new WeakSet();
  function e(i) {
    return n.has(i) ? !0 : (n.add(i), !1);
  }
  function t(i) {
    n.delete(i);
  }
  return [e, t];
}
function wc(n, e = []) {
  return [n, e];
}
function R5(n, e) {
  const [t, i] = n;
  return [t, [...i, e]];
}
function dA(n, e) {
  const t = n[1];
  for (const i of t) {
    const r = i[0].type;
    if (e(i, r)) return !0;
  }
  return !1;
}
function M_(n) {
  const e = hm(Jt);
  return e.encodePolyfill ? e.encodePolyfill(n) : new TextEncoder().encode(n);
}
function I5(n) {
  const [e, t] = n;
  let i = JSON.stringify(e);
  function r(s) {
    typeof i == 'string'
      ? (i = typeof s == 'string' ? i + s : [M_(i), s])
      : i.push(typeof s == 'string' ? M_(s) : s);
  }
  for (const s of t) {
    const [a, o] = s;
    if (
      (r(`
${JSON.stringify(a)}
`),
      typeof o == 'string' || o instanceof Uint8Array)
    )
      r(o);
    else {
      let l;
      try {
        l = JSON.stringify(o);
      } catch {
        l = JSON.stringify(as(o));
      }
      r(l);
    }
  }
  return typeof i == 'string' ? i : P5(i);
}
function P5(n) {
  const e = n.reduce((r, s) => r + s.length, 0),
    t = new Uint8Array(e);
  let i = 0;
  for (const r of n) (t.set(r, i), (i += r.length));
  return t;
}
function D5(n) {
  const e = typeof n.data == 'string' ? M_(n.data) : n.data;
  return [
    {
      type: 'attachment',
      length: e.length,
      filename: n.filename,
      content_type: n.contentType,
      attachment_type: n.attachmentType,
    },
    e,
  ];
}
const O5 = {
  session: 'session',
  sessions: 'session',
  attachment: 'attachment',
  transaction: 'transaction',
  event: 'error',
  client_report: 'internal',
  user_report: 'default',
  profile: 'profile',
  profile_chunk: 'profile',
  replay_event: 'replay',
  replay_recording: 'replay',
  check_in: 'monitor',
  feedback: 'feedback',
  span: 'span',
  raw_security: 'security',
  log: 'log_item',
  metric: 'metric',
  trace_metric: 'metric',
};
function fA(n) {
  return O5[n];
}
function DP(n) {
  if (!n?.sdk) return;
  const { name: e, version: t } = n.sdk;
  return { name: e, version: t };
}
function L5(n, e, t, i) {
  const r = n.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: n.event_id,
    sent_at: new Date().toISOString(),
    ...(e && { sdk: e }),
    ...(!!t && i && { dsn: Ph(i) }),
    ...(r && { trace: r }),
  };
}
function U5(n, e) {
  if (!e) return n;
  const t = n.sdk || {};
  return (
    (n.sdk = {
      ...t,
      name: t.name || e.name,
      version: t.version || e.version,
      integrations: [...(n.sdk?.integrations || []), ...(e.integrations || [])],
      packages: [...(n.sdk?.packages || []), ...(e.packages || [])],
      settings:
        n.sdk?.settings || e.settings
          ? { ...n.sdk?.settings, ...e.settings }
          : void 0,
    }),
    n
  );
}
function k5(n, e, t, i) {
  const r = DP(t),
    s = {
      sent_at: new Date().toISOString(),
      ...(r && { sdk: r }),
      ...(!!i && e && { dsn: Ph(e) }),
    },
    a =
      'aggregates' in n
        ? [{ type: 'sessions' }, n]
        : [{ type: 'session' }, n.toJSON()];
  return wc(s, [a]);
}
function B5(n, e, t, i) {
  const r = DP(t),
    s = n.type && n.type !== 'replay_event' ? n.type : 'event';
  U5(n, t?.sdk);
  const a = L5(n, r, i, e);
  return (delete n.sdkProcessingMetadata, wc(a, [[{ type: s }, n]]));
}
const c0 = 0,
  pA = 1,
  mA = 2;
function mm(n) {
  return new nh((e) => {
    e(n);
  });
}
function Lx(n) {
  return new nh((e, t) => {
    t(n);
  });
}
class nh {
  constructor(e) {
    ((this._state = c0), (this._handlers = []), this._runExecutor(e));
  }
  then(e, t) {
    return new nh((i, r) => {
      (this._handlers.push([
        !1,
        (s) => {
          if (!e) i(s);
          else
            try {
              i(e(s));
            } catch (a) {
              r(a);
            }
        },
        (s) => {
          if (!t) r(s);
          else
            try {
              i(t(s));
            } catch (a) {
              r(a);
            }
        },
      ]),
        this._executeHandlers());
    });
  }
  catch(e) {
    return this.then((t) => t, e);
  }
  finally(e) {
    return new nh((t, i) => {
      let r, s;
      return this.then(
        (a) => {
          ((s = !1), (r = a), e && e());
        },
        (a) => {
          ((s = !0), (r = a), e && e());
        }
      ).then(() => {
        if (s) {
          i(r);
          return;
        }
        t(r);
      });
    });
  }
  _executeHandlers() {
    if (this._state === c0) return;
    const e = this._handlers.slice();
    ((this._handlers = []),
      e.forEach((t) => {
        t[0] ||
          (this._state === pA && t[1](this._value),
          this._state === mA && t[2](this._value),
          (t[0] = !0));
      }));
  }
  _runExecutor(e) {
    const t = (s, a) => {
        if (this._state === c0) {
          if (Ch(a)) {
            a.then(i, r);
            return;
          }
          ((this._state = s), (this._value = a), this._executeHandlers());
        }
      },
      i = (s) => {
        t(pA, s);
      },
      r = (s) => {
        t(mA, s);
      };
    try {
      e(i, r);
    } catch (s) {
      r(s);
    }
  }
}
function N5(n, e, t, i = 0) {
  try {
    const r = T_(e, t, n, i);
    return Ch(r) ? r : mm(r);
  } catch (r) {
    return Lx(r);
  }
}
function T_(n, e, t, i) {
  const r = t[i];
  if (!n || !r) return n;
  const s = r({ ...n }, e);
  return (
    At &&
      s === null &&
      mt.log(`Event processor "${r.id || '?'}" dropped event`),
    Ch(s) ? s.then((a) => T_(a, e, t, i + 1)) : T_(s, e, t, i + 1)
  );
}
function F5(n, e) {
  const {
    fingerprint: t,
    span: i,
    breadcrumbs: r,
    sdkProcessingMetadata: s,
  } = e;
  (z5(n, e), i && G5(n, i), W5(n, t), V5(n, r), H5(n, s));
}
function gA(n, e) {
  const {
    extra: t,
    tags: i,
    user: r,
    contexts: s,
    level: a,
    sdkProcessingMetadata: o,
    breadcrumbs: l,
    fingerprint: c,
    eventProcessors: u,
    attachments: h,
    propagationContext: d,
    transactionName: f,
    span: p,
  } = e;
  (yd(n, 'extra', t),
    yd(n, 'tags', i),
    yd(n, 'user', r),
    yd(n, 'contexts', s),
    (n.sdkProcessingMetadata = Ih(n.sdkProcessingMetadata, o, 2)),
    a && (n.level = a),
    f && (n.transactionName = f),
    p && (n.span = p),
    l.length && (n.breadcrumbs = [...n.breadcrumbs, ...l]),
    c.length && (n.fingerprint = [...n.fingerprint, ...c]),
    u.length && (n.eventProcessors = [...n.eventProcessors, ...u]),
    h.length && (n.attachments = [...n.attachments, ...h]),
    (n.propagationContext = { ...n.propagationContext, ...d }));
}
function yd(n, e, t) {
  n[e] = Ih(n[e], t, 1);
}
function z5(n, e) {
  const {
    extra: t,
    tags: i,
    user: r,
    contexts: s,
    level: a,
    transactionName: o,
  } = e;
  (Object.keys(t).length && (n.extra = { ...t, ...n.extra }),
    Object.keys(i).length && (n.tags = { ...i, ...n.tags }),
    Object.keys(r).length && (n.user = { ...r, ...n.user }),
    Object.keys(s).length && (n.contexts = { ...s, ...n.contexts }),
    a && (n.level = a),
    o && n.type !== 'transaction' && (n.transaction = o));
}
function V5(n, e) {
  const t = [...(n.breadcrumbs || []), ...e];
  n.breadcrumbs = t.length ? t : void 0;
}
function H5(n, e) {
  n.sdkProcessingMetadata = { ...n.sdkProcessingMetadata, ...e };
}
function G5(n, e) {
  ((n.contexts = { trace: h5(e), ...n.contexts }),
    (n.sdkProcessingMetadata = {
      dynamicSamplingContext: w5(e),
      ...n.sdkProcessingMetadata,
    }));
  const t = RP(e),
    i = Dx(t).description;
  i && !n.transaction && n.type === 'transaction' && (n.transaction = i);
}
function W5(n, e) {
  ((n.fingerprint = n.fingerprint
    ? Array.isArray(n.fingerprint)
      ? n.fingerprint
      : [n.fingerprint]
    : []),
    e && (n.fingerprint = n.fingerprint.concat(e)),
    n.fingerprint.length || delete n.fingerprint);
}
let Ba, vA, _A, Es;
function j5(n) {
  const e = Jt._sentryDebugIds,
    t = Jt._debugIds;
  if (!e && !t) return {};
  const i = e ? Object.keys(e) : [],
    r = t ? Object.keys(t) : [];
  if (Es && i.length === vA && r.length === _A) return Es;
  ((vA = i.length), (_A = r.length), (Es = {}), Ba || (Ba = {}));
  const s = (a, o) => {
    for (const l of a) {
      const c = o[l],
        u = Ba?.[l];
      if (u && Es && c) ((Es[u[0]] = c), Ba && (Ba[l] = [u[0], c]));
      else if (c) {
        const h = n(l);
        for (let d = h.length - 1; d >= 0; d--) {
          const p = h[d]?.filename;
          if (p && Es && Ba) {
            ((Es[p] = c), (Ba[l] = [p, c]));
            break;
          }
        }
      }
    }
  };
  return (e && s(i, e), t && s(r, t), Es);
}
function X5(n, e, t, i, r, s) {
  const { normalizeDepth: a = 3, normalizeMaxBreadth: o = 1e3 } = n,
    l = {
      ...e,
      event_id: e.event_id || t.event_id || ar(),
      timestamp: e.timestamp || Rh(),
    },
    c = t.integrations || n.integrations.map((g) => g.name);
  (q5(l, n),
    J5(l, c),
    r && r.emit('applyFrameMetadata', e),
    e.type === void 0 && Y5(l, n.stackParser));
  const u = Z5(i, t.captureContext);
  t.mechanism && Jl(l, t.mechanism);
  const h = r ? r.getEventProcessors() : [],
    d = FH().getScopeData();
  if (s) {
    const g = s.getScopeData();
    gA(d, g);
  }
  if (u) {
    const g = u.getScopeData();
    gA(d, g);
  }
  const f = [...(t.attachments || []), ...d.attachments];
  (f.length && (t.attachments = f), F5(l, d));
  const p = [...h, ...d.eventProcessors];
  return N5(p, l, t).then(
    (g) => (g && K5(g), typeof a == 'number' && a > 0 ? Q5(g, a, o) : g)
  );
}
function q5(n, e) {
  const { environment: t, release: i, dist: r, maxValueLength: s } = e;
  ((n.environment = n.environment || t || Ox),
    !n.release && i && (n.release = i),
    !n.dist && r && (n.dist = r));
  const a = n.request;
  a?.url && (a.url = s ? rp(a.url, s) : a.url);
}
function Y5(n, e) {
  const t = j5(e);
  n.exception?.values?.forEach((i) => {
    i.stacktrace?.frames?.forEach((r) => {
      r.filename && (r.debug_id = t[r.filename]);
    });
  });
}
function K5(n) {
  const e = {};
  if (
    (n.exception?.values?.forEach((i) => {
      i.stacktrace?.frames?.forEach((r) => {
        r.debug_id &&
          (r.abs_path
            ? (e[r.abs_path] = r.debug_id)
            : r.filename && (e[r.filename] = r.debug_id),
          delete r.debug_id);
      });
    }),
    Object.keys(e).length === 0)
  )
    return;
  ((n.debug_meta = n.debug_meta || {}),
    (n.debug_meta.images = n.debug_meta.images || []));
  const t = n.debug_meta.images;
  Object.entries(e).forEach(([i, r]) => {
    t.push({ type: 'sourcemap', code_file: i, debug_id: r });
  });
}
function J5(n, e) {
  e.length > 0 &&
    ((n.sdk = n.sdk || {}),
    (n.sdk.integrations = [...(n.sdk.integrations || []), ...e]));
}
function Q5(n, e, t) {
  if (!n) return null;
  const i = {
    ...n,
    ...(n.breadcrumbs && {
      breadcrumbs: n.breadcrumbs.map((r) => ({
        ...r,
        ...(r.data && { data: as(r.data, e, t) }),
      })),
    }),
    ...(n.user && { user: as(n.user, e, t) }),
    ...(n.contexts && { contexts: as(n.contexts, e, t) }),
    ...(n.extra && { extra: as(n.extra, e, t) }),
  };
  return (
    n.contexts?.trace &&
      i.contexts &&
      ((i.contexts.trace = n.contexts.trace),
      n.contexts.trace.data &&
        (i.contexts.trace.data = as(n.contexts.trace.data, e, t))),
    n.spans &&
      (i.spans = n.spans.map((r) => ({
        ...r,
        ...(r.data && { data: as(r.data, e, t) }),
      }))),
    n.contexts?.flags &&
      i.contexts &&
      (i.contexts.flags = as(n.contexts.flags, 3, t)),
    i
  );
}
function Z5(n, e) {
  if (!e) return n;
  const t = n ? n.clone() : new _s();
  return (t.update(e), t);
}
function $5(n, e) {
  return oa().captureException(n, void 0);
}
function OP(n, e) {
  return oa().captureEvent(n, e);
}
function one(n, e) {
  Sc().setContext(n, e);
}
function yA(n) {
  const e = Sc(),
    t = oa(),
    { userAgent: i } = Jt.navigator || {},
    r = RH({
      user: t.getUser() || e.getUser(),
      ...(i && { userAgent: i }),
      ...n,
    }),
    s = e.getSession();
  return (
    s?.status === 'ok' && Ql(s, { status: 'exited' }),
    LP(),
    e.setSession(r),
    r
  );
}
function LP() {
  const n = Sc(),
    t = oa().getSession() || n.getSession();
  (t && IH(t), UP(), n.setSession());
}
function UP() {
  const n = Sc(),
    e = mi(),
    t = n.getSession();
  t && e && e.captureSession(t);
}
function xA(n = !1) {
  if (n) {
    LP();
    return;
  }
  UP();
}
const eG = '7';
function tG(n) {
  const e = n.protocol ? `${n.protocol}:` : '',
    t = n.port ? `:${n.port}` : '';
  return `${e}//${n.host}${t}${n.path ? `/${n.path}` : ''}/api/`;
}
function nG(n) {
  return `${tG(n)}${n.projectId}/envelope/`;
}
function iG(n, e) {
  const t = { sentry_version: eG };
  return (
    n.publicKey && (t.sentry_key = n.publicKey),
    e && (t.sentry_client = `${e.name}/${e.version}`),
    new URLSearchParams(t).toString()
  );
}
function rG(n, e, t) {
  return e || `${nG(n)}?${iG(n, t)}`;
}
const bA = [];
function sG(n) {
  const e = {};
  return (
    n.forEach((t) => {
      const { name: i } = t,
        r = e[i];
      (r && !r.isDefaultInstance && t.isDefaultInstance) || (e[i] = t);
    }),
    Object.values(e)
  );
}
function aG(n) {
  const e = n.defaultIntegrations || [],
    t = n.integrations;
  e.forEach((r) => {
    r.isDefaultInstance = !0;
  });
  let i;
  if (Array.isArray(t)) i = [...e, ...t];
  else if (typeof t == 'function') {
    const r = t(e);
    i = Array.isArray(r) ? r : [r];
  } else i = e;
  return sG(i);
}
function oG(n, e) {
  const t = {};
  return (
    e.forEach((i) => {
      i && kP(n, i, t);
    }),
    t
  );
}
function SA(n, e) {
  for (const t of e) t?.afterAllSetup && t.afterAllSetup(n);
}
function kP(n, e, t) {
  if (t[e.name]) {
    At &&
      mt.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (
    ((t[e.name] = e),
    bA.indexOf(e.name) === -1 &&
      typeof e.setupOnce == 'function' &&
      (e.setupOnce(), bA.push(e.name)),
    e.setup && typeof e.setup == 'function' && e.setup(n),
    typeof e.preprocessEvent == 'function')
  ) {
    const i = e.preprocessEvent.bind(e);
    n.on('preprocessEvent', (r, s) => i(r, s, n));
  }
  if (typeof e.processEvent == 'function') {
    const i = e.processEvent.bind(e),
      r = Object.assign((s, a) => i(s, a, n), { id: e.name });
    n.addEventProcessor(r);
  }
  At && mt.log(`Integration installed: ${e.name}`);
}
function lG(n) {
  return [
    {
      type: 'log',
      item_count: n.length,
      content_type: 'application/vnd.sentry.items.log+json',
    },
    { items: n },
  ];
}
function cG(n, e, t, i) {
  const r = {};
  return (
    e?.sdk && (r.sdk = { name: e.sdk.name, version: e.sdk.version }),
    t && i && (r.dsn = Ph(i)),
    wc(r, [lG(n)])
  );
}
function BP(n, e) {
  const t = e ?? uG(n) ?? [];
  if (t.length === 0) return;
  const i = n.getOptions(),
    r = cG(t, i._metadata, i.tunnel, n.getDsn());
  (NP().set(n, []), n.emit('flushLogs'), n.sendEnvelope(r));
}
function uG(n) {
  return NP().get(n);
}
function NP() {
  return yc('clientToLogBufferMap', () => new WeakMap());
}
function hG(n) {
  return [
    {
      type: 'trace_metric',
      item_count: n.length,
      content_type: 'application/vnd.sentry.items.trace-metric+json',
    },
    { items: n },
  ];
}
function dG(n, e, t, i) {
  const r = {};
  return (
    e?.sdk && (r.sdk = { name: e.sdk.name, version: e.sdk.version }),
    t && i && (r.dsn = Ph(i)),
    wc(r, [hG(n)])
  );
}
function FP(n, e) {
  const t = e ?? fG(n) ?? [];
  if (t.length === 0) return;
  const i = n.getOptions(),
    r = dG(t, i._metadata, i.tunnel, n.getDsn());
  (zP().set(n, []), n.emit('flushMetrics'), n.sendEnvelope(r));
}
function fG(n) {
  return zP().get(n);
}
function zP() {
  return yc('clientToMetricBufferMap', () => new WeakMap());
}
function pG(n, e, t) {
  const i = [
    { type: 'client_report' },
    { timestamp: Rh(), discarded_events: n },
  ];
  return wc(e ? { dsn: e } : {}, [i]);
}
function VP(n) {
  const e = [];
  n.message && e.push(n.message);
  try {
    const t = n.exception.values[n.exception.values.length - 1];
    t?.value && (e.push(t.value), t.type && e.push(`${t.type}: ${t.value}`));
  } catch {}
  return e;
}
function mG(n) {
  const {
    trace_id: e,
    parent_span_id: t,
    span_id: i,
    status: r,
    origin: s,
    data: a,
    op: o,
  } = n.contexts?.trace ?? {};
  return {
    data: a ?? {},
    description: n.transaction,
    op: o,
    parent_span_id: t,
    span_id: i ?? '',
    start_timestamp: n.start_timestamp ?? 0,
    status: r,
    timestamp: n.timestamp,
    trace_id: e ?? '',
    origin: s,
    profile_id: a?.[EP],
    exclusive_time: a?.[AP],
    measurements: n.measurements,
    is_segment: !0,
  };
}
function gG(n) {
  return {
    type: 'transaction',
    timestamp: n.timestamp,
    start_timestamp: n.start_timestamp,
    transaction: n.description,
    contexts: {
      trace: {
        trace_id: n.trace_id,
        span_id: n.span_id,
        parent_span_id: n.parent_span_id,
        op: n.op,
        status: n.status,
        origin: n.origin,
        data: {
          ...n.data,
          ...(n.profile_id && { [EP]: n.profile_id }),
          ...(n.exclusive_time && { [AP]: n.exclusive_time }),
        },
      },
    },
    measurements: n.measurements,
  };
}
const wA = "Not capturing exception because it's already been captured.",
  EA = 'Discarded session because of missing or non-string release',
  HP = Symbol.for('SentryInternalError'),
  GP = Symbol.for('SentryDoNotSendEventError'),
  vG = 5e3;
function If(n) {
  return { message: n, [HP]: !0 };
}
function u0(n) {
  return { message: n, [GP]: !0 };
}
function AA(n) {
  return !!n && typeof n == 'object' && HP in n;
}
function MA(n) {
  return !!n && typeof n == 'object' && GP in n;
}
function TA(n, e, t, i, r) {
  let s = 0,
    a;
  (n.on(t, () => {
    ((s = 0), clearTimeout(a));
  }),
    n.on(e, (o) => {
      ((s += i(o)),
        s >= 8e5
          ? r(n)
          : (clearTimeout(a),
            (a = setTimeout(() => {
              r(n);
            }, vG))));
    }),
    n.on('flush', () => {
      r(n);
    }));
}
class _G {
  constructor(e) {
    if (
      ((this._options = e),
      (this._integrations = {}),
      (this._numProcessing = 0),
      (this._outcomes = {}),
      (this._hooks = {}),
      (this._eventProcessors = []),
      e.dsn
        ? (this._dsn = c5(e.dsn))
        : At && mt.warn('No DSN provided, client will not send events.'),
      this._dsn)
    ) {
      const t = rG(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: t,
      });
    }
    (this._options.enableLogs &&
      TA(this, 'afterCaptureLog', 'flushLogs', SG, BP),
      this._options._experiments?.enableMetrics &&
        TA(this, 'afterCaptureMetric', 'flushMetrics', bG, FP));
  }
  captureException(e, t, i) {
    const r = ar();
    if ($E(e)) return (At && mt.log(wA), r);
    const s = { event_id: r, ...t };
    return (
      this._process(
        this.eventFromException(e, s).then((a) => this._captureEvent(a, s, i))
      ),
      s.event_id
    );
  }
  captureMessage(e, t, i, r) {
    const s = { event_id: ar(), ...i },
      a = Tx(e) ? e : String(e),
      o = dm(e)
        ? this.eventFromMessage(a, t, s)
        : this.eventFromException(e, s);
    return (
      this._process(o.then((l) => this._captureEvent(l, s, r))),
      s.event_id
    );
  }
  captureEvent(e, t, i) {
    const r = ar();
    if (t?.originalException && $E(t.originalException))
      return (At && mt.log(wA), r);
    const s = { event_id: r, ...t },
      a = e.sdkProcessingMetadata || {},
      o = a.capturedSpanScope,
      l = a.capturedSpanIsolationScope;
    return (this._process(this._captureEvent(e, s, o || i, l)), s.event_id);
  }
  captureSession(e) {
    (this.sendSession(e), Ql(e, { init: !1 }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  async flush(e) {
    const t = this._transport;
    if (!t) return !0;
    this.emit('flush');
    const i = await this._isClientDoneProcessing(e),
      r = await t.flush(e);
    return i && r;
  }
  async close(e) {
    const t = await this.flush(e);
    return ((this.getOptions().enabled = !1), this.emit('close'), t);
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  init() {
    (this._isEnabled() ||
      this._options.integrations.some(({ name: e }) =>
        e.startsWith('Spotlight')
      )) &&
      this._setupIntegrations();
  }
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  addIntegration(e) {
    const t = this._integrations[e.name];
    (kP(this, e, this._integrations), t || SA(this, [e]));
  }
  sendEvent(e, t = {}) {
    this.emit('beforeSendEvent', e, t);
    let i = B5(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const r of t.attachments || []) i = R5(i, D5(r));
    this.sendEnvelope(i).then((r) => this.emit('afterSendEvent', e, r));
  }
  sendSession(e) {
    const { release: t, environment: i = Ox } = this._options;
    if ('aggregates' in e) {
      const s = e.attrs || {};
      if (!s.release && !t) {
        At && mt.warn(EA);
        return;
      }
      ((s.release = s.release || t),
        (s.environment = s.environment || i),
        (e.attrs = s));
    } else {
      if (!e.release && !t) {
        At && mt.warn(EA);
        return;
      }
      ((e.release = e.release || t), (e.environment = e.environment || i));
    }
    this.emit('beforeSendSession', e);
    const r = k5(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(r);
  }
  recordDroppedEvent(e, t, i = 1) {
    if (this._options.sendClientReports) {
      const r = `${e}:${t}`;
      (At && mt.log(`Recording outcome: "${r}"${i > 1 ? ` (${i} times)` : ''}`),
        (this._outcomes[r] = (this._outcomes[r] || 0) + i));
    }
  }
  on(e, t) {
    const i = (this._hooks[e] = this._hooks[e] || new Set()),
      r = (...s) => t(...s);
    return (
      i.add(r),
      () => {
        i.delete(r);
      }
    );
  }
  emit(e, ...t) {
    const i = this._hooks[e];
    i && i.forEach((r) => r(...t));
  }
  async sendEnvelope(e) {
    if ((this.emit('beforeEnvelope', e), this._isEnabled() && this._transport))
      try {
        return await this._transport.send(e);
      } catch (t) {
        return (At && mt.error('Error while sending envelope:', t), {});
      }
    return (At && mt.error('Transport disabled'), {});
  }
  _setupIntegrations() {
    const { integrations: e } = this._options;
    ((this._integrations = oG(this, e)), SA(this, e));
  }
  _updateSessionFromEvent(e, t) {
    let i = t.level === 'fatal',
      r = !1;
    const s = t.exception?.values;
    if (s) {
      r = !0;
      for (const l of s)
        if (l.mechanism?.handled === !1) {
          i = !0;
          break;
        }
    }
    const a = e.status === 'ok';
    ((a && e.errors === 0) || (a && i)) &&
      (Ql(e, {
        ...(i && { status: 'crashed' }),
        errors: e.errors || Number(r || i),
      }),
      this.captureSession(e));
  }
  async _isClientDoneProcessing(e) {
    let t = 0;
    for (; !e || t < e; ) {
      if ((await new Promise((i) => setTimeout(i, 1)), !this._numProcessing))
        return !0;
      t++;
    }
    return !1;
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  _prepareEvent(e, t, i, r) {
    const s = this.getOptions(),
      a = Object.keys(this._integrations);
    return (
      !t.integrations && a?.length && (t.integrations = a),
      this.emit('preprocessEvent', e, t),
      e.type || r.setLastEventId(e.event_id || t.event_id),
      X5(s, e, t, i, this, r).then((o) => {
        if (o === null) return o;
        (this.emit('postprocessEvent', o, t),
          (o.contexts = { trace: VH(i), ...o.contexts }));
        const l = S5(this, i);
        return (
          (o.sdkProcessingMetadata = {
            dynamicSamplingContext: l,
            ...o.sdkProcessingMetadata,
          }),
          o
        );
      })
    );
  }
  _captureEvent(e, t = {}, i = oa(), r = Sc()) {
    return (
      At &&
        C_(e) &&
        mt.log(`Captured error event \`${VP(e)[0] || '<unknown>'}\``),
      this._processEvent(e, t, i, r).then(
        (s) => s.event_id,
        (s) => {
          At &&
            (MA(s)
              ? mt.log(s.message)
              : AA(s)
                ? mt.warn(s.message)
                : mt.warn(s));
        }
      )
    );
  }
  _processEvent(e, t, i, r) {
    const s = this.getOptions(),
      { sampleRate: a } = s,
      o = WP(e),
      l = C_(e),
      c = e.type || 'error',
      u = `before send for type \`${c}\``,
      h = typeof a > 'u' ? void 0 : u5(a);
    if (l && typeof h == 'number' && Math.random() > h)
      return (
        this.recordDroppedEvent('sample_rate', 'error'),
        Lx(
          u0(
            `Discarding event because it's not included in the random sample (sampling rate = ${a})`
          )
        )
      );
    const d = c === 'replay_event' ? 'replay' : c;
    return this._prepareEvent(e, t, i, r)
      .then((f) => {
        if (f === null)
          throw (
            this.recordDroppedEvent('event_processor', d),
            u0('An event processor returned `null`, will not send event.')
          );
        if (t.data && t.data.__sentry__ === !0) return f;
        const m = xG(this, s, f, t);
        return yG(m, u);
      })
      .then((f) => {
        if (f === null) {
          if ((this.recordDroppedEvent('before_send', d), o)) {
            const v = 1 + (e.spans || []).length;
            this.recordDroppedEvent('before_send', 'span', v);
          }
          throw u0(`${u} returned \`null\`, will not send event.`);
        }
        const p = i.getSession() || r.getSession();
        if ((l && p && this._updateSessionFromEvent(p, f), o)) {
          const g = f.sdkProcessingMetadata?.spanCountBeforeProcessing || 0,
            v = f.spans ? f.spans.length : 0,
            y = g - v;
          y > 0 && this.recordDroppedEvent('before_send', 'span', y);
        }
        const m = f.transaction_info;
        if (o && m && f.transaction !== e.transaction) {
          const g = 'custom';
          f.transaction_info = { ...m, source: g };
        }
        return (this.sendEvent(f, t), f);
      })
      .then(null, (f) => {
        throw MA(f) || AA(f)
          ? f
          : (this.captureException(f, {
              mechanism: { handled: !1, type: 'internal' },
              data: { __sentry__: !0 },
              originalException: f,
            }),
            If(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${f}`));
      });
  }
  _process(e) {
    (this._numProcessing++,
      e.then(
        (t) => (this._numProcessing--, t),
        (t) => (this._numProcessing--, t)
      ));
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return (
      (this._outcomes = {}),
      Object.entries(e).map(([t, i]) => {
        const [r, s] = t.split(':');
        return { reason: r, category: s, quantity: i };
      })
    );
  }
  _flushOutcomes() {
    At && mt.log('Flushing outcomes...');
    const e = this._clearOutcomes();
    if (e.length === 0) {
      At && mt.log('No outcomes to send');
      return;
    }
    if (!this._dsn) {
      At && mt.log('No dsn provided, will not send outcomes');
      return;
    }
    At && mt.log('Sending outcomes:', e);
    const t = pG(e, this._options.tunnel && Ph(this._dsn));
    this.sendEnvelope(t);
  }
}
function yG(n, e) {
  const t = `${e} must return \`null\` or a valid event.`;
  if (Ch(n))
    return n.then(
      (i) => {
        if (!th(i) && i !== null) throw If(t);
        return i;
      },
      (i) => {
        throw If(`${e} rejected with ${i}`);
      }
    );
  if (!th(n) && n !== null) throw If(t);
  return n;
}
function xG(n, e, t, i) {
  const {
    beforeSend: r,
    beforeSendTransaction: s,
    beforeSendSpan: a,
    ignoreSpans: o,
  } = e;
  let l = t;
  if (C_(l) && r) return r(l, i);
  if (WP(l)) {
    if (a || o) {
      const c = mG(l);
      if (o?.length && hA(c, o)) return null;
      if (a) {
        const u = a(c);
        u ? (l = Ih(t, gG(u))) : cA();
      }
      if (l.spans) {
        const u = [],
          h = l.spans;
        for (const f of h) {
          if (o?.length && hA(f, o)) {
            y5(h, f);
            continue;
          }
          if (a) {
            const p = a(f);
            p ? u.push(p) : (cA(), u.push(f));
          } else u.push(f);
        }
        const d = l.spans.length - u.length;
        (d && n.recordDroppedEvent('before_send', 'span', d), (l.spans = u));
      }
    }
    if (s) {
      if (l.spans) {
        const c = l.spans.length;
        l.sdkProcessingMetadata = {
          ...t.sdkProcessingMetadata,
          spanCountBeforeProcessing: c,
        };
      }
      return s(l, i);
    }
  }
  return l;
}
function C_(n) {
  return n.type === void 0;
}
function WP(n) {
  return n.type === 'transaction';
}
function bG(n) {
  let e = 0;
  return (
    n.name && (e += n.name.length * 2),
    typeof n.value == 'string' ? (e += n.value.length * 2) : (e += 8),
    e + jP(n.attributes)
  );
}
function SG(n) {
  let e = 0;
  return (n.message && (e += n.message.length * 2), e + jP(n.attributes));
}
function jP(n) {
  if (!n) return 0;
  let e = 0;
  return (
    Object.values(n).forEach((t) => {
      Array.isArray(t)
        ? (e += t.length * CA(t[0]))
        : dm(t)
          ? (e += CA(t))
          : (e += 100);
    }),
    e
  );
}
function CA(n) {
  return typeof n == 'string'
    ? n.length * 2
    : typeof n == 'number'
      ? 8
      : typeof n == 'boolean'
        ? 4
        : 0;
}
function wG(n, e) {
  (e.debug === !0 &&
    (At
      ? mt.enable()
      : xc(() => {
          console.warn(
            '[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.'
          );
        })),
    oa().update(e.initialScope));
  const i = new n(e);
  return (EG(i), i.init(), i);
}
function EG(n) {
  oa().setClient(n);
}
const XP = Symbol.for('SentryBufferFullError');
function qP(n = 100) {
  const e = new Set();
  function t() {
    return e.size < n;
  }
  function i(a) {
    e.delete(a);
  }
  function r(a) {
    if (!t()) return Lx(XP);
    const o = a();
    return (
      e.add(o),
      o.then(
        () => i(o),
        () => i(o)
      ),
      o
    );
  }
  function s(a) {
    if (!e.size) return mm(!0);
    const o = Promise.allSettled(Array.from(e)).then(() => !0);
    if (!a) return o;
    const l = [o, new Promise((c) => setTimeout(() => c(!1), a))];
    return Promise.race(l);
  }
  return {
    get $() {
      return Array.from(e);
    },
    add: r,
    drain: s,
  };
}
const AG = 60 * 1e3;
function MG(n, e = Date.now()) {
  const t = parseInt(`${n}`, 10);
  if (!isNaN(t)) return t * 1e3;
  const i = Date.parse(`${n}`);
  return isNaN(i) ? AG : i - e;
}
function TG(n, e) {
  return n[e] || n.all || 0;
}
function CG(n, e, t = Date.now()) {
  return TG(n, e) > t;
}
function RG(n, { statusCode: e, headers: t }, i = Date.now()) {
  const r = { ...n },
    s = t?.['x-sentry-rate-limits'],
    a = t?.['retry-after'];
  if (s)
    for (const o of s.trim().split(',')) {
      const [l, c, , , u] = o.split(':', 5),
        h = parseInt(l, 10),
        d = (isNaN(h) ? 60 : h) * 1e3;
      if (!c) r.all = i + d;
      else
        for (const f of c.split(';'))
          f === 'metric_bucket'
            ? (!u || u.split(';').includes('custom')) && (r[f] = i + d)
            : (r[f] = i + d);
    }
  else a ? (r.all = i + MG(a, i)) : e === 429 && (r.all = i + 60 * 1e3);
  return r;
}
const IG = 64;
function PG(n, e, t = qP(n.bufferSize || IG)) {
  let i = {};
  const r = (a) => t.drain(a);
  function s(a) {
    const o = [];
    if (
      (dA(a, (h, d) => {
        const f = fA(d);
        CG(i, f) ? n.recordDroppedEvent('ratelimit_backoff', f) : o.push(h);
      }),
      o.length === 0)
    )
      return Promise.resolve({});
    const l = wc(a[0], o),
      c = (h) => {
        dA(l, (d, f) => {
          n.recordDroppedEvent(h, fA(f));
        });
      },
      u = () =>
        e({ body: I5(l) }).then(
          (h) => (
            h.statusCode !== void 0 &&
              (h.statusCode < 200 || h.statusCode >= 300) &&
              At &&
              mt.warn(
                `Sentry responded with status code ${h.statusCode} to sent event.`
              ),
            (i = RG(i, h)),
            h
          ),
          (h) => {
            throw (
              c('network_error'),
              At && mt.error('Encountered error running transport request:', h),
              h
            );
          }
        );
    return t.add(u).then(
      (h) => h,
      (h) => {
        if (h === XP)
          return (
            At && mt.error('Skipped sending event because buffer is full.'),
            c('queue_overflow'),
            Promise.resolve({})
          );
        throw h;
      }
    );
  }
  return { send: s, flush: r };
}
function h0(n) {
  if (!n) return {};
  const e = n.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
  );
  if (!e) return {};
  const t = e[6] || '',
    i = e[8] || '';
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: t,
    hash: i,
    relative: e[5] + t + i,
  };
}
function DG(n) {
  'aggregates' in n
    ? n.attrs?.ip_address === void 0 &&
      (n.attrs = { ...n.attrs, ip_address: '{{auto}}' })
    : n.ipAddress === void 0 && (n.ipAddress = '{{auto}}');
}
function OG(n, e, t = [e], i = 'npm') {
  const r = n._metadata || {};
  (r.sdk ||
    (r.sdk = {
      name: `sentry.javascript.${e}`,
      packages: t.map((s) => ({ name: `${i}:@sentry/${s}`, version: So })),
      version: So,
    }),
    (n._metadata = r));
}
const LG = 100;
function Io(n, e) {
  const t = mi(),
    i = Sc();
  if (!t) return;
  const { beforeBreadcrumb: r = null, maxBreadcrumbs: s = LG } = t.getOptions();
  if (s <= 0) return;
  const o = { timestamp: Rh(), ...n },
    l = r ? xc(() => r(o, e)) : o;
  l !== null &&
    (t.emit && t.emit('beforeAddBreadcrumb', l, e), i.addBreadcrumb(l, s));
}
let RA;
const UG = 'FunctionToString',
  IA = new WeakMap(),
  kG = () => ({
    name: UG,
    setupOnce() {
      RA = Function.prototype.toString;
      try {
        Function.prototype.toString = function (...n) {
          const e = Ix(this),
            t = IA.has(mi()) && e !== void 0 ? e : this;
          return RA.apply(t, n);
        };
      } catch {}
    },
    setup(n) {
      IA.set(n, !0);
    },
  }),
  BG = kG,
  NG = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    /^Can't find variable: gmo$/,
    /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
    /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
    /^Java exception was raised during method invocation$/,
  ],
  FG = 'EventFilters',
  zG = (n = {}) => {
    let e;
    return {
      name: FG,
      setup(t) {
        const i = t.getOptions();
        e = PA(n, i);
      },
      processEvent(t, i, r) {
        if (!e) {
          const s = r.getOptions();
          e = PA(n, s);
        }
        return HG(t, e) ? null : t;
      },
    };
  },
  VG = (n = {}) => ({ ...zG(n), name: 'InboundFilters' });
function PA(n = {}, e = {}) {
  return {
    allowUrls: [...(n.allowUrls || []), ...(e.allowUrls || [])],
    denyUrls: [...(n.denyUrls || []), ...(e.denyUrls || [])],
    ignoreErrors: [
      ...(n.ignoreErrors || []),
      ...(e.ignoreErrors || []),
      ...(n.disableErrorDefaults ? [] : NG),
    ],
    ignoreTransactions: [
      ...(n.ignoreTransactions || []),
      ...(e.ignoreTransactions || []),
    ],
  };
}
function HG(n, e) {
  if (n.type) {
    if (n.type === 'transaction' && WG(n, e.ignoreTransactions))
      return (
        At &&
          mt.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${ro(n)}`),
        !0
      );
  } else {
    if (GG(n, e.ignoreErrors))
      return (
        At &&
          mt.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${ro(n)}`),
        !0
      );
    if (YG(n))
      return (
        At &&
          mt.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${ro(n)}`),
        !0
      );
    if (jG(n, e.denyUrls))
      return (
        At &&
          mt.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${ro(n)}.
Url: ${sp(n)}`),
        !0
      );
    if (!XG(n, e.allowUrls))
      return (
        At &&
          mt.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${ro(n)}.
Url: ${sp(n)}`),
        !0
      );
  }
  return !1;
}
function GG(n, e) {
  return e?.length ? VP(n).some((t) => pm(t, e)) : !1;
}
function WG(n, e) {
  if (!e?.length) return !1;
  const t = n.transaction;
  return t ? pm(t, e) : !1;
}
function jG(n, e) {
  if (!e?.length) return !1;
  const t = sp(n);
  return t ? pm(t, e) : !1;
}
function XG(n, e) {
  if (!e?.length) return !0;
  const t = sp(n);
  return t ? pm(t, e) : !0;
}
function qG(n = []) {
  for (let e = n.length - 1; e >= 0; e--) {
    const t = n[e];
    if (t && t.filename !== '<anonymous>' && t.filename !== '[native code]')
      return t.filename || null;
  }
  return null;
}
function sp(n) {
  try {
    const t = [...(n.exception?.values ?? [])]
      .reverse()
      .find(
        (i) => i.mechanism?.parent_id === void 0 && i.stacktrace?.frames?.length
      )?.stacktrace?.frames;
    return t ? qG(t) : null;
  } catch {
    return (At && mt.error(`Cannot extract url for event ${ro(n)}`), null);
  }
}
function YG(n) {
  return n.exception?.values?.length
    ? !n.message &&
        !n.exception.values.some(
          (e) => e.stacktrace || (e.type && e.type !== 'Error') || e.value
        )
    : !1;
}
function KG(n, e, t, i, r, s) {
  if (!r.exception?.values || !s || !$s(s.originalException, Error)) return;
  const a =
    r.exception.values.length > 0
      ? r.exception.values[r.exception.values.length - 1]
      : void 0;
  a &&
    (r.exception.values = R_(
      n,
      e,
      i,
      s.originalException,
      t,
      r.exception.values,
      a,
      0
    ));
}
function R_(n, e, t, i, r, s, a, o) {
  if (s.length >= t + 1) return s;
  let l = [...s];
  if ($s(i[r], Error)) {
    DA(a, o);
    const c = n(e, i[r]),
      u = l.length;
    (OA(c, r, u, o), (l = R_(n, e, t, i[r], r, [c, ...l], c, u)));
  }
  return (
    Array.isArray(i.errors) &&
      i.errors.forEach((c, u) => {
        if ($s(c, Error)) {
          DA(a, o);
          const h = n(e, c),
            d = l.length;
          (OA(h, `errors[${u}]`, d, o),
            (l = R_(n, e, t, c, r, [h, ...l], h, d)));
        }
      }),
    l
  );
}
function DA(n, e) {
  n.mechanism = {
    handled: !0,
    type: 'auto.core.linked_errors',
    ...n.mechanism,
    ...(n.type === 'AggregateError' && { is_exception_group: !0 }),
    exception_id: e,
  };
}
function OA(n, e, t, i) {
  n.mechanism = {
    handled: !0,
    ...n.mechanism,
    type: 'chained',
    source: e,
    exception_id: t,
    parent_id: i,
  };
}
function JG(n) {
  const e = 'console';
  (Fo(e, n), zo(e, QG));
}
function QG() {
  'console' in Jt &&
    iH.forEach(function (n) {
      n in Jt.console &&
        Vi(Jt.console, n, function (e) {
          return (
            (ip[n] = e),
            function (...t) {
              (Ar('console', { args: t, level: n }),
                ip[n]?.apply(Jt.console, t));
            }
          );
        });
    });
}
function ZG(n) {
  return n === 'warn'
    ? 'warning'
    : ['fatal', 'error', 'warning', 'log', 'info', 'debug'].includes(n)
      ? n
      : 'log';
}
const $G = 'Dedupe',
  e8 = () => {
    let n;
    return {
      name: $G,
      processEvent(e) {
        if (e.type) return e;
        try {
          if (n8(e, n))
            return (
              At &&
                mt.warn(
                  'Event dropped due to being a duplicate of previously captured event.'
                ),
              null
            );
        } catch {}
        return (n = e);
      },
    };
  },
  t8 = e8;
function n8(n, e) {
  return e ? !!(i8(n, e) || r8(n, e)) : !1;
}
function i8(n, e) {
  const t = n.message,
    i = e.message;
  return !(
    (!t && !i) ||
    (t && !i) ||
    (!t && i) ||
    t !== i ||
    !KP(n, e) ||
    !YP(n, e)
  );
}
function r8(n, e) {
  const t = LA(e),
    i = LA(n);
  return !(
    !t ||
    !i ||
    t.type !== i.type ||
    t.value !== i.value ||
    !KP(n, e) ||
    !YP(n, e)
  );
}
function YP(n, e) {
  let t = qE(n),
    i = qE(e);
  if (!t && !i) return !0;
  if ((t && !i) || (!t && i) || ((t = t), (i = i), i.length !== t.length))
    return !1;
  for (let r = 0; r < i.length; r++) {
    const s = i[r],
      a = t[r];
    if (
      s.filename !== a.filename ||
      s.lineno !== a.lineno ||
      s.colno !== a.colno ||
      s.function !== a.function
    )
      return !1;
  }
  return !0;
}
function KP(n, e) {
  let t = n.fingerprint,
    i = e.fingerprint;
  if (!t && !i) return !0;
  if ((t && !i) || (!t && i)) return !1;
  ((t = t), (i = i));
  try {
    return t.join('') === i.join('');
  } catch {
    return !1;
  }
}
function LA(n) {
  return n.exception?.values?.[0];
}
function JP(n) {
  if (n !== void 0)
    return n >= 400 && n < 500 ? 'warning' : n >= 500 ? 'error' : void 0;
}
const ih = Jt;
function s8() {
  return 'history' in ih && !!ih.history;
}
function a8() {
  if (!('fetch' in ih)) return !1;
  try {
    return (
      new Headers(),
      new Request('http://www.example.com'),
      new Response(),
      !0
    );
  } catch {
    return !1;
  }
}
function I_(n) {
  return (
    n && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(n.toString())
  );
}
function o8() {
  if (typeof EdgeRuntime == 'string') return !0;
  if (!a8()) return !1;
  if (I_(ih.fetch)) return !0;
  let n = !1;
  const e = ih.document;
  if (e && typeof e.createElement == 'function')
    try {
      const t = e.createElement('iframe');
      ((t.hidden = !0),
        e.head.appendChild(t),
        t.contentWindow?.fetch && (n = I_(t.contentWindow.fetch)),
        e.head.removeChild(t));
    } catch (t) {
      At &&
        mt.warn(
          'Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ',
          t
        );
    }
  return n;
}
function l8(n, e) {
  const t = 'fetch';
  (Fo(t, n), zo(t, () => c8(void 0, e)));
}
function c8(n, e = !1) {
  (e && !o8()) ||
    Vi(Jt, 'fetch', function (t) {
      return function (...i) {
        const r = new Error(),
          { method: s, url: a } = u8(i),
          o = {
            args: i,
            fetchData: { method: s, url: a },
            startTimestamp: hs() * 1e3,
            virtualError: r,
            headers: h8(i),
          };
        return (
          Ar('fetch', { ...o }),
          t.apply(Jt, i).then(
            async (l) => (
              Ar('fetch', { ...o, endTimestamp: hs() * 1e3, response: l }),
              l
            ),
            (l) => {
              if (
                (Ar('fetch', { ...o, endTimestamp: hs() * 1e3, error: l }),
                Mx(l) &&
                  l.stack === void 0 &&
                  ((l.stack = r.stack), Ro(l, 'framesToPop', 1)),
                l instanceof TypeError &&
                  (l.message === 'Failed to fetch' ||
                    l.message === 'Load failed' ||
                    l.message ===
                      'NetworkError when attempting to fetch resource.'))
              )
                try {
                  const c = new URL(o.fetchData.url);
                  l.message = `${l.message} (${c.host})`;
                } catch {}
              throw l;
            }
          )
        );
      };
    });
}
function P_(n, e) {
  return !!n && typeof n == 'object' && !!n[e];
}
function UA(n) {
  return typeof n == 'string'
    ? n
    : n
      ? P_(n, 'url')
        ? n.url
        : n.toString
          ? n.toString()
          : ''
      : '';
}
function u8(n) {
  if (n.length === 0) return { method: 'GET', url: '' };
  if (n.length === 2) {
    const [t, i] = n;
    return {
      url: UA(t),
      method: P_(i, 'method') ? String(i.method).toUpperCase() : 'GET',
    };
  }
  const e = n[0];
  return {
    url: UA(e),
    method: P_(e, 'method') ? String(e.method).toUpperCase() : 'GET',
  };
}
function h8(n) {
  const [e, t] = n;
  try {
    if (typeof t == 'object' && t !== null && 'headers' in t && t.headers)
      return new Headers(t.headers);
    if (xH(e)) return new Headers(e.headers);
  } catch {}
}
function d8() {
  return 'npm';
}
const bn = Jt;
let D_ = 0;
function QP() {
  return D_ > 0;
}
function f8() {
  (D_++,
    setTimeout(() => {
      D_--;
    }));
}
function $l(n, e = {}) {
  function t(r) {
    return typeof r == 'function';
  }
  if (!t(n)) return n;
  try {
    const r = n.__sentry_wrapped__;
    if (r) return typeof r == 'function' ? r : n;
    if (Ix(n)) return n;
  } catch {
    return n;
  }
  const i = function (...r) {
    try {
      const s = r.map((a) => $l(a, e));
      return n.apply(this, s);
    } catch (s) {
      throw (
        f8(),
        zH((a) => {
          (a.addEventProcessor(
            (o) => (
              e.mechanism && (w_(o, void 0), Jl(o, e.mechanism)),
              (o.extra = { ...o.extra, arguments: r }),
              o
            )
          ),
            $5(s));
        }),
        s
      );
    }
  };
  try {
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  } catch {}
  (yP(i, n), Ro(n, '__sentry_wrapped__', i));
  try {
    Object.getOwnPropertyDescriptor(i, 'name').configurable &&
      Object.defineProperty(i, 'name', {
        get() {
          return n.name;
        },
      });
  } catch {}
  return i;
}
function p8() {
  const n = Rx(),
    { referrer: e } = bn.document || {},
    { userAgent: t } = bn.navigator || {},
    i = { ...(e && { Referer: e }), ...(t && { 'User-Agent': t }) };
  return { url: n, headers: i };
}
function Ux(n, e) {
  const t = kx(n, e),
    i = { type: y8(e), value: x8(e) };
  return (
    t.length && (i.stacktrace = { frames: t }),
    i.type === void 0 &&
      i.value === '' &&
      (i.value = 'Unrecoverable error caught'),
    i
  );
}
function m8(n, e, t, i) {
  const s = mi()?.getOptions().normalizeDepth,
    a = A8(e),
    o = { __serialized__: PP(e, s) };
  if (a) return { exception: { values: [Ux(n, a)] }, extra: o };
  const l = {
    exception: {
      values: [
        {
          type: fm(e) ? e.constructor.name : i ? 'UnhandledRejection' : 'Error',
          value: w8(e, { isUnhandledRejection: i }),
        },
      ],
    },
    extra: o,
  };
  if (t) {
    const c = kx(n, t);
    c.length && (l.exception.values[0].stacktrace = { frames: c });
  }
  return l;
}
function d0(n, e) {
  return { exception: { values: [Ux(n, e)] } };
}
function kx(n, e) {
  const t = e.stacktrace || e.stack || '',
    i = v8(e),
    r = _8(e);
  try {
    return n(t, i, r);
  } catch {}
  return [];
}
const g8 = /Minified React error #\d+;/i;
function v8(n) {
  return n && g8.test(n.message) ? 1 : 0;
}
function _8(n) {
  return typeof n.framesToPop == 'number' ? n.framesToPop : 0;
}
function ZP(n) {
  return typeof WebAssembly < 'u' && typeof WebAssembly.Exception < 'u'
    ? n instanceof WebAssembly.Exception
    : !1;
}
function y8(n) {
  const e = n?.name;
  return !e && ZP(n)
    ? n.message && Array.isArray(n.message) && n.message.length == 2
      ? n.message[0]
      : 'WebAssembly.Exception'
    : e;
}
function x8(n) {
  const e = n?.message;
  return ZP(n)
    ? Array.isArray(n.message) && n.message.length == 2
      ? n.message[1]
      : 'wasm exception'
    : e
      ? e.error && typeof e.error.message == 'string'
        ? e.error.message
        : e
      : 'No error message';
}
function b8(n, e, t, i) {
  const r = t?.syntheticException || void 0,
    s = Bx(n, e, r, i);
  return (
    Jl(s),
    (s.level = 'error'),
    t?.event_id && (s.event_id = t.event_id),
    mm(s)
  );
}
function S8(n, e, t = 'info', i, r) {
  const s = i?.syntheticException || void 0,
    a = O_(n, e, s, r);
  return ((a.level = t), i?.event_id && (a.event_id = i.event_id), mm(a));
}
function Bx(n, e, t, i, r) {
  let s;
  if (gP(e) && e.error) return d0(n, e.error);
  if (KE(e) || gH(e)) {
    const a = e;
    if ('stack' in e) s = d0(n, e);
    else {
      const o = a.name || (KE(a) ? 'DOMError' : 'DOMException'),
        l = a.message ? `${o}: ${a.message}` : o;
      ((s = O_(n, l, t, i)), w_(s, l));
    }
    return (
      'code' in a && (s.tags = { ...s.tags, 'DOMException.code': `${a.code}` }),
      s
    );
  }
  return Mx(e)
    ? d0(n, e)
    : th(e) || fm(e)
      ? ((s = m8(n, e, t, r)), Jl(s, { synthetic: !0 }), s)
      : ((s = O_(n, e, t, i)), w_(s, `${e}`), Jl(s, { synthetic: !0 }), s);
}
function O_(n, e, t, i) {
  const r = {};
  if (i && t) {
    const s = kx(n, t);
    (s.length &&
      (r.exception = { values: [{ value: e, stacktrace: { frames: s } }] }),
      Jl(r, { synthetic: !0 }));
  }
  if (Tx(e)) {
    const { __sentry_template_string__: s, __sentry_template_values__: a } = e;
    return ((r.logentry = { message: s, params: a }), r);
  }
  return ((r.message = e), r);
}
function w8(n, { isUnhandledRejection: e }) {
  const t = EH(n),
    i = e ? 'promise rejection' : 'exception';
  return gP(n)
    ? `Event \`ErrorEvent\` captured as ${i} with message \`${n.message}\``
    : fm(n)
      ? `Event \`${E8(n)}\` (type=${n.type}) captured as ${i}`
      : `Object captured as ${i} with keys: ${t}`;
}
function E8(n) {
  try {
    const e = Object.getPrototypeOf(n);
    return e ? e.constructor.name : void 0;
  } catch {}
}
function A8(n) {
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e)) {
      const t = n[e];
      if (t instanceof Error) return t;
    }
}
class M8 extends _G {
  constructor(e) {
    const t = T8(e),
      i = bn.SENTRY_SDK_SOURCE || d8();
    (OG(t, 'browser', ['browser'], i),
      t._metadata?.sdk &&
        (t._metadata.sdk.settings = {
          infer_ip: t.sendDefaultPii ? 'auto' : 'never',
          ...t._metadata.sdk.settings,
        }),
      super(t));
    const {
      sendDefaultPii: r,
      sendClientReports: s,
      enableLogs: a,
      _experiments: o,
    } = this._options;
    (bn.document &&
      (s || a || o?.enableMetrics) &&
      bn.document.addEventListener('visibilitychange', () => {
        bn.document.visibilityState === 'hidden' &&
          (s && this._flushOutcomes(),
          a && BP(this),
          o?.enableMetrics && FP(this));
      }),
      r && this.on('beforeSendSession', DG));
  }
  eventFromException(e, t) {
    return b8(this._options.stackParser, e, t, this._options.attachStacktrace);
  }
  eventFromMessage(e, t = 'info', i) {
    return S8(
      this._options.stackParser,
      e,
      t,
      i,
      this._options.attachStacktrace
    );
  }
  _prepareEvent(e, t, i, r) {
    return (
      (e.platform = e.platform || 'javascript'),
      super._prepareEvent(e, t, i, r)
    );
  }
}
function T8(n) {
  return {
    release:
      typeof __SENTRY_RELEASE__ == 'string'
        ? __SENTRY_RELEASE__
        : bn.SENTRY_RELEASE?.id,
    sendClientReports: !0,
    parentSpanIsAlwaysRootSpan: !0,
    ...n,
  };
}
const C8 = typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__,
  di = Jt,
  R8 = 1e3;
let kA, L_, U_;
function I8(n) {
  (Fo('dom', n), zo('dom', P8));
}
function P8() {
  if (!di.document) return;
  const n = Ar.bind(null, 'dom'),
    e = BA(n, !0);
  (di.document.addEventListener('click', e, !1),
    di.document.addEventListener('keypress', e, !1),
    ['EventTarget', 'Node'].forEach((t) => {
      const r = di[t]?.prototype;
      r?.hasOwnProperty?.('addEventListener') &&
        (Vi(r, 'addEventListener', function (s) {
          return function (a, o, l) {
            if (a === 'click' || a == 'keypress')
              try {
                const c = (this.__sentry_instrumentation_handlers__ =
                    this.__sentry_instrumentation_handlers__ || {}),
                  u = (c[a] = c[a] || { refCount: 0 });
                if (!u.handler) {
                  const h = BA(n);
                  ((u.handler = h), s.call(this, a, h, l));
                }
                u.refCount++;
              } catch {}
            return s.call(this, a, o, l);
          };
        }),
        Vi(r, 'removeEventListener', function (s) {
          return function (a, o, l) {
            if (a === 'click' || a == 'keypress')
              try {
                const c = this.__sentry_instrumentation_handlers__ || {},
                  u = c[a];
                u &&
                  (u.refCount--,
                  u.refCount <= 0 &&
                    (s.call(this, a, u.handler, l),
                    (u.handler = void 0),
                    delete c[a]),
                  Object.keys(c).length === 0 &&
                    delete this.__sentry_instrumentation_handlers__);
              } catch {}
            return s.call(this, a, o, l);
          };
        }));
    }));
}
function D8(n) {
  if (n.type !== L_) return !1;
  try {
    if (!n.target || n.target._sentryId !== U_) return !1;
  } catch {}
  return !0;
}
function O8(n, e) {
  return n !== 'keypress'
    ? !1
    : e?.tagName
      ? !(
          e.tagName === 'INPUT' ||
          e.tagName === 'TEXTAREA' ||
          e.isContentEditable
        )
      : !0;
}
function BA(n, e = !1) {
  return (t) => {
    if (!t || t._sentryCaptured) return;
    const i = L8(t);
    if (O8(t.type, i)) return;
    (Ro(t, '_sentryCaptured', !0),
      i && !i._sentryId && Ro(i, '_sentryId', ar()));
    const r = t.type === 'keypress' ? 'input' : t.type;
    (D8(t) ||
      (n({ event: t, name: r, global: e }),
      (L_ = t.type),
      (U_ = i ? i._sentryId : void 0)),
      clearTimeout(kA),
      (kA = di.setTimeout(() => {
        ((U_ = void 0), (L_ = void 0));
      }, R8)));
  };
}
function L8(n) {
  try {
    return n.target;
  } catch {
    return null;
  }
}
let xd;
function $P(n) {
  const e = 'history';
  (Fo(e, n), zo(e, U8));
}
function U8() {
  if (
    (di.addEventListener('popstate', () => {
      const e = di.location.href,
        t = xd;
      if (((xd = e), t === e)) return;
      Ar('history', { from: t, to: e });
    }),
    !s8())
  )
    return;
  function n(e) {
    return function (...t) {
      const i = t.length > 2 ? t[2] : void 0;
      if (i) {
        const r = xd,
          s = k8(String(i));
        if (((xd = s), r === s)) return e.apply(this, t);
        Ar('history', { from: r, to: s });
      }
      return e.apply(this, t);
    };
  }
  (Vi(di.history, 'pushState', n), Vi(di.history, 'replaceState', n));
}
function k8(n) {
  try {
    return new URL(n, di.location.origin).toString();
  } catch {
    return n;
  }
}
const Pf = {};
function B8(n) {
  const e = Pf[n];
  if (e) return e;
  let t = di[n];
  if (I_(t)) return (Pf[n] = t.bind(di));
  const i = di.document;
  if (i && typeof i.createElement == 'function')
    try {
      const r = i.createElement('iframe');
      ((r.hidden = !0), i.head.appendChild(r));
      const s = r.contentWindow;
      (s?.[n] && (t = s[n]), i.head.removeChild(r));
    } catch (r) {
      C8 &&
        mt.warn(
          `Could not create sandbox iframe for ${n} check, bailing to window.${n}: `,
          r
        );
    }
  return t && (Pf[n] = t.bind(di));
}
function N8(n) {
  Pf[n] = void 0;
}
const fu = '__sentry_xhr_v3__';
function F8(n) {
  (Fo('xhr', n), zo('xhr', z8));
}
function z8() {
  if (!di.XMLHttpRequest) return;
  const n = XMLHttpRequest.prototype;
  ((n.open = new Proxy(n.open, {
    apply(e, t, i) {
      const r = new Error(),
        s = hs() * 1e3,
        a = us(i[0]) ? i[0].toUpperCase() : void 0,
        o = V8(i[1]);
      if (!a || !o) return e.apply(t, i);
      ((t[fu] = { method: a, url: o, request_headers: {} }),
        a === 'POST' &&
          o.match(/sentry_key/) &&
          (t.__sentry_own_request__ = !0));
      const l = () => {
        const c = t[fu];
        if (c && t.readyState === 4) {
          try {
            c.status_code = t.status;
          } catch {}
          const u = {
            endTimestamp: hs() * 1e3,
            startTimestamp: s,
            xhr: t,
            virtualError: r,
          };
          Ar('xhr', u);
        }
      };
      return (
        'onreadystatechange' in t && typeof t.onreadystatechange == 'function'
          ? (t.onreadystatechange = new Proxy(t.onreadystatechange, {
              apply(c, u, h) {
                return (l(), c.apply(u, h));
              },
            }))
          : t.addEventListener('readystatechange', l),
        (t.setRequestHeader = new Proxy(t.setRequestHeader, {
          apply(c, u, h) {
            const [d, f] = h,
              p = u[fu];
            return (
              p && us(d) && us(f) && (p.request_headers[d.toLowerCase()] = f),
              c.apply(u, h)
            );
          },
        })),
        e.apply(t, i)
      );
    },
  })),
    (n.send = new Proxy(n.send, {
      apply(e, t, i) {
        const r = t[fu];
        if (!r) return e.apply(t, i);
        i[0] !== void 0 && (r.body = i[0]);
        const s = { startTimestamp: hs() * 1e3, xhr: t };
        return (Ar('xhr', s), e.apply(t, i));
      },
    })));
}
function V8(n) {
  if (us(n)) return n;
  try {
    return n.toString();
  } catch {}
}
const H8 = 40;
function G8(n, e = B8('fetch')) {
  let t = 0,
    i = 0;
  async function r(s) {
    const a = s.body.length;
    ((t += a), i++);
    const o = {
      body: s.body,
      method: 'POST',
      referrerPolicy: 'strict-origin',
      headers: n.headers,
      keepalive: t <= 6e4 && i < 15,
      ...n.fetchOptions,
    };
    try {
      const l = await e(n.url, o);
      return {
        statusCode: l.status,
        headers: {
          'x-sentry-rate-limits': l.headers.get('X-Sentry-Rate-Limits'),
          'retry-after': l.headers.get('Retry-After'),
        },
      };
    } catch (l) {
      throw (N8('fetch'), l);
    } finally {
      ((t -= a), i--);
    }
  }
  return PG(n, r, qP(n.bufferSize || H8));
}
const W8 = 30,
  j8 = 50;
function k_(n, e, t, i) {
  const r = { filename: n, function: e === '<anonymous>' ? Co : e, in_app: !0 };
  return (t !== void 0 && (r.lineno = t), i !== void 0 && (r.colno = i), r);
}
const X8 = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  q8 =
    /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  Y8 = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  K8 = /at (.+?) ?\(data:(.+?),/,
  J8 = (n) => {
    const e = n.match(K8);
    if (e) return { filename: `<data:${e[2]}>`, function: e[1] };
    const t = X8.exec(n);
    if (t) {
      const [, r, s, a] = t;
      return k_(r, Co, +s, +a);
    }
    const i = q8.exec(n);
    if (i) {
      if (i[2] && i[2].indexOf('eval') === 0) {
        const o = Y8.exec(i[2]);
        o && ((i[2] = o[1]), (i[3] = o[2]), (i[4] = o[3]));
      }
      const [s, a] = eD(i[1] || Co, i[2]);
      return k_(a, s, i[3] ? +i[3] : void 0, i[4] ? +i[4] : void 0);
    }
  },
  Q8 = [W8, J8],
  Z8 =
    /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  $8 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  eW = (n) => {
    const e = Z8.exec(n);
    if (e) {
      if (e[3] && e[3].indexOf(' > eval') > -1) {
        const s = $8.exec(e[3]);
        s &&
          ((e[1] = e[1] || 'eval'), (e[3] = s[1]), (e[4] = s[2]), (e[5] = ''));
      }
      let i = e[3],
        r = e[1] || Co;
      return (
        ([r, i] = eD(r, i)),
        k_(i, r, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
      );
    }
  },
  tW = [j8, eW],
  nW = [Q8, tW],
  iW = pP(...nW),
  eD = (n, e) => {
    const t = n.indexOf('safari-extension') !== -1,
      i = n.indexOf('safari-web-extension') !== -1;
    return t || i
      ? [
          n.indexOf('@') !== -1 ? n.split('@')[0] : Co,
          t ? `safari-extension:${e}` : `safari-web-extension:${e}`,
        ]
      : [n, e];
  },
  gm = typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__,
  bd = 1024,
  rW = 'Breadcrumbs',
  sW = (n = {}) => {
    const e = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...n,
    };
    return {
      name: rW,
      setup(t) {
        (e.console && JG(cW(t)),
          e.dom && I8(lW(t, e.dom)),
          e.xhr && F8(uW(t)),
          e.fetch && l8(hW(t)),
          e.history && $P(dW(t)),
          e.sentry && t.on('beforeSendEvent', oW(t)));
      },
    };
  },
  aW = sW;
function oW(n) {
  return function (t) {
    mi() === n &&
      Io(
        {
          category: `sentry.${t.type === 'transaction' ? 'transaction' : 'event'}`,
          event_id: t.event_id,
          level: t.level,
          message: ro(t),
        },
        { event: t }
      );
  };
}
function lW(n, e) {
  return function (i) {
    if (mi() !== n) return;
    let r,
      s,
      a = typeof e == 'object' ? e.serializeAttribute : void 0,
      o =
        typeof e == 'object' && typeof e.maxStringLength == 'number'
          ? e.maxStringLength
          : void 0;
    (o &&
      o > bd &&
      (gm &&
        mt.warn(
          `\`dom.maxStringLength\` cannot exceed ${bd}, but a value of ${o} was configured. Sentry will use ${bd} instead.`
        ),
      (o = bd)),
      typeof a == 'string' && (a = [a]));
    try {
      const c = i.event,
        u = fW(c) ? c.target : c;
      ((r = _P(u, { keyAttrs: a, maxStringLength: o })), (s = wH(u)));
    } catch {
      r = '<unknown>';
    }
    if (r.length === 0) return;
    const l = { category: `ui.${i.name}`, message: r };
    (s && (l.data = { 'ui.component_name': s }),
      Io(l, { event: i.event, name: i.name, global: i.global }));
  };
}
function cW(n) {
  return function (t) {
    if (mi() !== n) return;
    const i = {
      category: 'console',
      data: { arguments: t.args, logger: 'console' },
      level: ZG(t.level),
      message: JE(t.args, ' '),
    };
    if (t.level === 'assert')
      if (t.args[0] === !1)
        ((i.message = `Assertion failed: ${JE(t.args.slice(1), ' ') || 'console.assert'}`),
          (i.data.arguments = t.args.slice(1)));
      else return;
    Io(i, { input: t.args, level: t.level });
  };
}
function uW(n) {
  return function (t) {
    if (mi() !== n) return;
    const { startTimestamp: i, endTimestamp: r } = t,
      s = t.xhr[fu];
    if (!i || !r || !s) return;
    const { method: a, url: o, status_code: l, body: c } = s,
      u = { method: a, url: o, status_code: l },
      h = { xhr: t.xhr, input: c, startTimestamp: i, endTimestamp: r },
      d = { category: 'xhr', data: u, type: 'http', level: JP(l) };
    (n.emit('beforeOutgoingRequestBreadcrumb', d, h), Io(d, h));
  };
}
function hW(n) {
  return function (t) {
    if (mi() !== n) return;
    const { startTimestamp: i, endTimestamp: r } = t;
    if (
      r &&
      !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === 'POST')
    )
      if ((t.fetchData.method, t.fetchData.url, t.error)) {
        const s = t.fetchData,
          a = {
            data: t.error,
            input: t.args,
            startTimestamp: i,
            endTimestamp: r,
          },
          o = { category: 'fetch', data: s, level: 'error', type: 'http' };
        (n.emit('beforeOutgoingRequestBreadcrumb', o, a), Io(o, a));
      } else {
        const s = t.response,
          a = { ...t.fetchData, status_code: s?.status };
        (t.fetchData.request_body_size,
          t.fetchData.response_body_size,
          s?.status);
        const o = {
            input: t.args,
            response: s,
            startTimestamp: i,
            endTimestamp: r,
          },
          l = {
            category: 'fetch',
            data: a,
            type: 'http',
            level: JP(a.status_code),
          };
        (n.emit('beforeOutgoingRequestBreadcrumb', l, o), Io(l, o));
      }
  };
}
function dW(n) {
  return function (t) {
    if (mi() !== n) return;
    let i = t.from,
      r = t.to;
    const s = h0(bn.location.href);
    let a = i ? h0(i) : void 0;
    const o = h0(r);
    (a?.path || (a = s),
      s.protocol === o.protocol && s.host === o.host && (r = o.relative),
      s.protocol === a.protocol && s.host === a.host && (i = a.relative),
      Io({ category: 'navigation', data: { from: i, to: r } }));
  };
}
function fW(n) {
  return !!n && !!n.target;
}
const pW = [
    'EventTarget',
    'Window',
    'Node',
    'ApplicationCache',
    'AudioTrackList',
    'BroadcastChannel',
    'ChannelMergerNode',
    'CryptoOperation',
    'EventSource',
    'FileReader',
    'HTMLUnknownElement',
    'IDBDatabase',
    'IDBRequest',
    'IDBTransaction',
    'KeyOperation',
    'MediaController',
    'MessagePort',
    'ModalWindow',
    'Notification',
    'SVGElementInstance',
    'Screen',
    'SharedWorker',
    'TextTrack',
    'TextTrackCue',
    'TextTrackList',
    'WebSocket',
    'WebSocketWorker',
    'Worker',
    'XMLHttpRequest',
    'XMLHttpRequestEventTarget',
    'XMLHttpRequestUpload',
  ],
  mW = 'BrowserApiErrors',
  gW = (n = {}) => {
    const e = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      unregisterOriginalCallbacks: !1,
      ...n,
    };
    return {
      name: mW,
      setupOnce() {
        (e.setTimeout && Vi(bn, 'setTimeout', NA),
          e.setInterval && Vi(bn, 'setInterval', NA),
          e.requestAnimationFrame && Vi(bn, 'requestAnimationFrame', _W),
          e.XMLHttpRequest &&
            'XMLHttpRequest' in bn &&
            Vi(XMLHttpRequest.prototype, 'send', yW));
        const t = e.eventTarget;
        t && (Array.isArray(t) ? t : pW).forEach((r) => xW(r, e));
      },
    };
  },
  vW = gW;
function NA(n) {
  return function (...e) {
    const t = e[0];
    return (
      (e[0] = $l(t, {
        mechanism: {
          handled: !1,
          type: `auto.browser.browserapierrors.${Zs(n)}`,
        },
      })),
      n.apply(this, e)
    );
  };
}
function _W(n) {
  return function (e) {
    return n.apply(this, [
      $l(e, {
        mechanism: {
          data: { handler: Zs(n) },
          handled: !1,
          type: 'auto.browser.browserapierrors.requestAnimationFrame',
        },
      }),
    ]);
  };
}
function yW(n) {
  return function (...e) {
    const t = this;
    return (
      ['onload', 'onerror', 'onprogress', 'onreadystatechange'].forEach((r) => {
        r in t &&
          typeof t[r] == 'function' &&
          Vi(t, r, function (s) {
            const a = {
                mechanism: {
                  data: { handler: Zs(s) },
                  handled: !1,
                  type: `auto.browser.browserapierrors.xhr.${r}`,
                },
              },
              o = Ix(s);
            return (o && (a.mechanism.data.handler = Zs(o)), $l(s, a));
          });
      }),
      n.apply(this, e)
    );
  };
}
function xW(n, e) {
  const i = bn[n]?.prototype;
  i?.hasOwnProperty?.('addEventListener') &&
    (Vi(i, 'addEventListener', function (r) {
      return function (s, a, o) {
        try {
          bW(a) &&
            (a.handleEvent = $l(a.handleEvent, {
              mechanism: {
                data: { handler: Zs(a), target: n },
                handled: !1,
                type: 'auto.browser.browserapierrors.handleEvent',
              },
            }));
        } catch {}
        return (
          e.unregisterOriginalCallbacks && SW(this, s, a),
          r.apply(this, [
            s,
            $l(a, {
              mechanism: {
                data: { handler: Zs(a), target: n },
                handled: !1,
                type: 'auto.browser.browserapierrors.addEventListener',
              },
            }),
            o,
          ])
        );
      };
    }),
    Vi(i, 'removeEventListener', function (r) {
      return function (s, a, o) {
        try {
          const l = a.__sentry_wrapped__;
          l && r.call(this, s, l, o);
        } catch {}
        return r.call(this, s, a, o);
      };
    }));
}
function bW(n) {
  return typeof n.handleEvent == 'function';
}
function SW(n, e, t) {
  n &&
    typeof n == 'object' &&
    'removeEventListener' in n &&
    typeof n.removeEventListener == 'function' &&
    n.removeEventListener(e, t);
}
const wW = () => ({
    name: 'BrowserSession',
    setupOnce() {
      if (typeof bn.document > 'u') {
        gm &&
          mt.warn(
            'Using the `browserSessionIntegration` in non-browser environments is not supported.'
          );
        return;
      }
      (yA({ ignoreDuration: !0 }),
        xA(),
        $P(({ from: n, to: e }) => {
          n !== void 0 && n !== e && (yA({ ignoreDuration: !0 }), xA());
        }));
    },
  }),
  EW = 'GlobalHandlers',
  AW = (n = {}) => {
    const e = { onerror: !0, onunhandledrejection: !0, ...n };
    return {
      name: EW,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(t) {
        (e.onerror && (TW(t), FA('onerror')),
          e.onunhandledrejection && (CW(t), FA('onunhandledrejection')));
      },
    };
  },
  MW = AW;
function TW(n) {
  dH((e) => {
    const { stackParser: t, attachStacktrace: i } = tD();
    if (mi() !== n || QP()) return;
    const { msg: r, url: s, line: a, column: o, error: l } = e,
      c = PW(Bx(t, l || r, void 0, i, !1), s, a, o);
    ((c.level = 'error'),
      OP(c, {
        originalException: l,
        mechanism: {
          handled: !1,
          type: 'auto.browser.global_handlers.onerror',
        },
      }));
  });
}
function CW(n) {
  pH((e) => {
    const { stackParser: t, attachStacktrace: i } = tD();
    if (mi() !== n || QP()) return;
    const r = RW(e),
      s = dm(r) ? IW(r) : Bx(t, r, void 0, i, !0);
    ((s.level = 'error'),
      OP(s, {
        originalException: r,
        mechanism: {
          handled: !1,
          type: 'auto.browser.global_handlers.onunhandledrejection',
        },
      }));
  });
}
function RW(n) {
  if (dm(n)) return n;
  try {
    if ('reason' in n) return n.reason;
    if ('detail' in n && 'reason' in n.detail) return n.detail.reason;
  } catch {}
  return n;
}
function IW(n) {
  return {
    exception: {
      values: [
        {
          type: 'UnhandledRejection',
          value: `Non-Error promise rejection captured with value: ${String(n)}`,
        },
      ],
    },
  };
}
function PW(n, e, t, i) {
  const r = (n.exception = n.exception || {}),
    s = (r.values = r.values || []),
    a = (s[0] = s[0] || {}),
    o = (a.stacktrace = a.stacktrace || {}),
    l = (o.frames = o.frames || []),
    c = i,
    u = t,
    h = DW(e) ?? Rx();
  return (
    l.length === 0 &&
      l.push({ colno: c, filename: h, function: Co, in_app: !0, lineno: u }),
    n
  );
}
function FA(n) {
  gm && mt.log(`Global Handler attached: ${n}`);
}
function tD() {
  return mi()?.getOptions() || { stackParser: () => [], attachStacktrace: !1 };
}
function DW(n) {
  if (!(!us(n) || n.length === 0)) {
    if (n.startsWith('data:')) {
      const e = n.match(/^data:([^;]+)/),
        t = e ? e[1] : 'text/javascript',
        i = n.includes('base64,');
      return `<data:${t}${i ? ',base64' : ''}>`;
    }
    return n.slice(0, 1024);
  }
}
const OW = () => ({
    name: 'HttpContext',
    preprocessEvent(n) {
      if (!bn.navigator && !bn.location && !bn.document) return;
      const e = p8(),
        t = { ...e.headers, ...n.request?.headers };
      n.request = { ...e, ...n.request, headers: t };
    },
  }),
  LW = 'cause',
  UW = 5,
  kW = 'LinkedErrors',
  BW = (n = {}) => {
    const e = n.limit || UW,
      t = n.key || LW;
    return {
      name: kW,
      preprocessEvent(i, r, s) {
        const a = s.getOptions();
        KG(Ux, a.stackParser, t, e, i, r);
      },
    };
  },
  NW = BW;
function FW() {
  return zW()
    ? (gm &&
        xc(() => {
          console.error(
            '[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/'
          );
        }),
      !0)
    : !1;
}
function zW() {
  if (typeof bn.window > 'u') return !1;
  const n = bn;
  if (n.nw || !(n.chrome || n.browser)?.runtime?.id) return !1;
  const t = Rx(),
    i = [
      'chrome-extension',
      'moz-extension',
      'ms-browser-extension',
      'safari-web-extension',
    ];
  return !(bn === bn.top && i.some((s) => t.startsWith(`${s}://`)));
}
function VW(n) {
  return [VG(), BG(), vW(), aW(), MW(), NW(), t8(), OW(), wW()];
}
function lne(n = {}) {
  const e = !n.skipBrowserExtensionCheck && FW(),
    t = {
      ...n,
      enabled: e ? !1 : n.enabled,
      stackParser: uH(n.stackParser || iW),
      integrations: aG({
        integrations: n.integrations,
        defaultIntegrations:
          n.defaultIntegrations == null ? VW() : n.defaultIntegrations,
      }),
      transport: n.transport || G8,
    };
  return wG(M8, t);
}
var Df = { exports: {} },
  HW = Df.exports,
  zA;
function GW() {
  return (
    zA ||
      ((zA = 1),
      (function (n, e) {
        (function (i, r) {
          n.exports = r();
        })(HW, function () {
          return (function () {
            var t = {
                './packages/@logrocket/console/src/index.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = void 0));
                  var u = c(
                      l('./packages/@logrocket/console/src/registerConsole.js')
                    ),
                    h = u.default;
                  o.default = h;
                },
                './packages/@logrocket/console/src/registerConsole.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = f));
                    var u = c(
                        l('./node_modules/@babel/runtime/helpers/typeof.js')
                      ),
                      h = c(
                        l('./packages/@logrocket/utils/src/enhanceFunc.ts')
                      ),
                      d = l('./packages/@logrocket/exceptions/src/index.js');
                    function f(p) {
                      var m = [],
                        g = ['log', 'warn', 'info', 'error', 'debug'];
                      return (
                        g.forEach(function (v) {
                          m.push(
                            (0, h.default)(console, v, function () {
                              for (
                                var y = arguments.length,
                                  _ = new Array(y),
                                  x = 0;
                                x < y;
                                x++
                              )
                                _[x] = arguments[x];
                              p.addEvent('lr.core.LogEvent', function () {
                                var S =
                                    arguments.length > 0 &&
                                    arguments[0] !== void 0
                                      ? arguments[0]
                                      : {},
                                  b = S.isEnabled;
                                if (
                                  ((0, u.default)(b) === 'object' &&
                                    b[v] === !1) ||
                                  b === !1
                                )
                                  return null;
                                if (
                                  v === 'error' &&
                                  S.shouldAggregateConsoleErrors
                                )
                                  if (_ && _.length >= 2 && _[0] === 'ERROR') {
                                    var A = '';
                                    try {
                                      A = ' '.concat(_[1]);
                                    } catch {}
                                    d.Capture.captureMessage(
                                      p,
                                      ''.concat(_[0]).concat(A),
                                      _,
                                      {},
                                      !0
                                    );
                                  } else
                                    d.Capture.captureMessage(
                                      p,
                                      _[0],
                                      _,
                                      {},
                                      !0
                                    );
                                return { logLevel: v.toUpperCase(), args: _ };
                              });
                            })
                          );
                        }),
                        function () {
                          m.forEach(function (v) {
                            return v();
                          });
                        }
                      );
                    }
                  },
                './packages/@logrocket/exceptions/src/Capture.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.captureMessage = f),
                    (o.captureException = p));
                  var u = l(
                      './packages/@logrocket/utils/src/scrubException.ts'
                    ),
                    h = c(l('./packages/@logrocket/utils/src/TraceKit.js')),
                    d = c(
                      l(
                        './packages/@logrocket/exceptions/src/stackTraceFromError.js'
                      )
                    );
                  function f(m, g, v) {
                    var y =
                        arguments.length > 3 && arguments[3] !== void 0
                          ? arguments[3]
                          : {},
                      _ =
                        arguments.length > 4 && arguments[4] !== void 0
                          ? arguments[4]
                          : !1,
                      x = {
                        exceptionType: _ ? 'CONSOLE' : 'MESSAGE',
                        message: g,
                        messageArgs: v,
                        browserHref: window.location
                          ? window.location.href
                          : '',
                      };
                    ((0, u.scrubException)(x, y),
                      m.addEvent('lr.core.Exception', function () {
                        return x;
                      }));
                  }
                  function p(m, g) {
                    var v =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : {},
                      y =
                        arguments.length > 3 && arguments[3] !== void 0
                          ? arguments[3]
                          : null,
                      _ =
                        arguments.length > 4 && arguments[4] !== void 0
                          ? arguments[4]
                          : 'WINDOW',
                      x = y || h.default.computeStackTrace(g),
                      S = {
                        exceptionType: _,
                        errorType: x.name,
                        message: x.message,
                        browserHref: window.location
                          ? window.location.href
                          : '',
                      };
                    (0, u.scrubException)(S, v);
                    var b = { _stackTrace: (0, d.default)(x) };
                    m.addEvent(
                      'lr.core.Exception',
                      function () {
                        return S;
                      },
                      b
                    );
                  }
                },
                './packages/@logrocket/exceptions/src/index.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    ),
                    u = l('./node_modules/@babel/runtime/helpers/typeof.js');
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    Object.defineProperty(o, 'registerExceptions', {
                      enumerable: !0,
                      get: function () {
                        return h.default;
                      },
                    }),
                    (o.Capture = void 0));
                  var h = c(
                      l(
                        './packages/@logrocket/exceptions/src/registerExceptions.js'
                      )
                    ),
                    d = p(l('./packages/@logrocket/exceptions/src/Capture.js'));
                  o.Capture = d;
                  function f(m) {
                    if (typeof WeakMap != 'function') return null;
                    var g = new WeakMap(),
                      v = new WeakMap();
                    return (f = function (_) {
                      return _ ? v : g;
                    })(m);
                  }
                  function p(m, g) {
                    if (m && m.__esModule) return m;
                    if (
                      m === null ||
                      (u(m) !== 'object' && typeof m != 'function')
                    )
                      return { default: m };
                    var v = f(g);
                    if (v && v.has(m)) return v.get(m);
                    var y = {},
                      _ =
                        Object.defineProperty &&
                        Object.getOwnPropertyDescriptor;
                    for (var x in m)
                      if (
                        x !== 'default' &&
                        Object.prototype.hasOwnProperty.call(m, x)
                      ) {
                        var S = _
                          ? Object.getOwnPropertyDescriptor(m, x)
                          : null;
                        S && (S.get || S.set)
                          ? Object.defineProperty(y, x, S)
                          : (y[x] = m[x]);
                      }
                    return ((y.default = m), v && v.set(m, y), y);
                  }
                },
                './packages/@logrocket/exceptions/src/raven/raven.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = void 0));
                    var u = c(
                        l(
                          './node_modules/@babel/runtime/helpers/classCallCheck.js'
                        )
                      ),
                      h = c(
                        l(
                          './node_modules/@babel/runtime/helpers/createClass.js'
                        )
                      ),
                      d = c(l('./packages/@logrocket/utils/src/TraceKit.js')),
                      f = Object.prototype;
                    function p(x) {
                      return x === void 0;
                    }
                    function m(x) {
                      return typeof x == 'function';
                    }
                    function g(x, S) {
                      return f.hasOwnProperty.call(x, S);
                    }
                    function v(x, S, b, A) {
                      var E = x[S];
                      ((x[S] = b(E)), A && A.push([x, S, E]));
                    }
                    var y =
                      typeof window < 'u'
                        ? window
                        : typeof l.g < 'u'
                          ? l.g
                          : typeof self < 'u'
                            ? self
                            : {};
                    y.document;
                    var _ = (function () {
                      function x(S) {
                        var b = S.captureException;
                        ((0, u.default)(this, x),
                          (this._errorHandler = this._errorHandler.bind(this)),
                          (this._ignoreOnError = 0),
                          (this._wrappedBuiltIns = []),
                          (this.captureException = b),
                          d.default.report.subscribe(this._errorHandler),
                          this._instrumentTryCatch());
                      }
                      return (
                        (0, h.default)(x, [
                          {
                            key: 'uninstall',
                            value: function () {
                              d.default.report.unsubscribe(this._errorHandler);
                              for (var b; this._wrappedBuiltIns.length; ) {
                                b = this._wrappedBuiltIns.shift();
                                var A = b[0],
                                  E = b[1],
                                  w = b[2];
                                A[E] = w;
                              }
                            },
                          },
                          {
                            key: '_errorHandler',
                            value: function (b) {
                              this._ignoreOnError || this.captureException(b);
                            },
                          },
                          {
                            key: '_ignoreNextOnError',
                            value: function () {
                              var b = this;
                              ((this._ignoreOnError += 1),
                                setTimeout(function () {
                                  b._ignoreOnError -= 1;
                                }));
                            },
                          },
                          {
                            key: 'context',
                            value: function (b, A, E) {
                              return (
                                m(b) && ((E = A || []), (A = b), (b = void 0)),
                                this.wrap(b, A).apply(this, E)
                              );
                            },
                          },
                          {
                            key: 'wrap',
                            value: function (b, A, E) {
                              var w = this;
                              if (p(A) && !m(b)) return b;
                              if ((m(b) && ((A = b), (b = void 0)), !m(A)))
                                return A;
                              try {
                                if (A.__lr__) return A;
                                if (A.__lr_wrapper__) return A.__lr_wrapper__;
                                if (!Object.isExtensible(A)) return A;
                              } catch {
                                return A;
                              }
                              function M() {
                                var D = [],
                                  L = arguments.length,
                                  O = !b || (b && b.deep !== !1);
                                for (
                                  E && m(E) && E.apply(this, arguments);
                                  L--;

                                )
                                  D[L] = O
                                    ? w.wrap(b, arguments[L])
                                    : arguments[L];
                                try {
                                  return A.apply(this, D);
                                } catch (z) {
                                  throw (
                                    w._ignoreNextOnError(),
                                    w.captureException(
                                      d.default.computeStackTrace(z),
                                      b
                                    ),
                                    z
                                  );
                                }
                              }
                              for (var T in A) g(A, T) && (M[T] = A[T]);
                              return (
                                (M.prototype = A.prototype),
                                (A.__lr_wrapper__ = M),
                                (M.__lr__ = !0),
                                (M.__inner__ = A),
                                M
                              );
                            },
                          },
                          {
                            key: '_instrumentTryCatch',
                            value: function () {
                              var b = this,
                                A = b._wrappedBuiltIns;
                              function E(L) {
                                return function (O, z) {
                                  for (
                                    var C = new Array(arguments.length), N = 0;
                                    N < C.length;
                                    ++N
                                  )
                                    C[N] = arguments[N];
                                  var U = C[0];
                                  return (
                                    m(U) && (C[0] = b.wrap(U)),
                                    L.apply ? L.apply(this, C) : L(C[0], C[1])
                                  );
                                };
                              }
                              function w(L) {
                                var O = y[L] && y[L].prototype;
                                O &&
                                  O.hasOwnProperty &&
                                  O.hasOwnProperty('addEventListener') &&
                                  (v(
                                    O,
                                    'addEventListener',
                                    function (z) {
                                      return function (C, N, U, W) {
                                        try {
                                          N &&
                                            N.handleEvent &&
                                            (N.handleEvent = b.wrap(
                                              N.handleEvent
                                            ));
                                        } catch {}
                                        var G;
                                        return z.call(
                                          this,
                                          C,
                                          b.wrap(N, void 0, G),
                                          U,
                                          W
                                        );
                                      };
                                    },
                                    A
                                  ),
                                  v(
                                    O,
                                    'removeEventListener',
                                    function (z) {
                                      return function (C, N, U, W) {
                                        try {
                                          var G = N?.__lr_wrapper__;
                                          G && z.call(this, C, G, U, W);
                                        } catch {}
                                        return z.call(this, C, N, U, W);
                                      };
                                    },
                                    void 0
                                  ));
                              }
                              (v(y, 'setTimeout', E, A),
                                v(y, 'setInterval', E, A),
                                y.requestAnimationFrame &&
                                  v(
                                    y,
                                    'requestAnimationFrame',
                                    function (L) {
                                      return function (O) {
                                        return L(b.wrap(O));
                                      };
                                    },
                                    A
                                  ));
                              for (
                                var M = [
                                    'EventTarget',
                                    'Window',
                                    'Node',
                                    'ApplicationCache',
                                    'AudioTrackList',
                                    'ChannelMergerNode',
                                    'CryptoOperation',
                                    'EventSource',
                                    'FileReader',
                                    'HTMLUnknownElement',
                                    'IDBDatabase',
                                    'IDBRequest',
                                    'IDBTransaction',
                                    'KeyOperation',
                                    'MediaController',
                                    'MessagePort',
                                    'ModalWindow',
                                    'Notification',
                                    'SVGElementInstance',
                                    'Screen',
                                    'TextTrack',
                                    'TextTrackCue',
                                    'TextTrackList',
                                    'WebSocket',
                                    'WebSocketWorker',
                                    'Worker',
                                    'XMLHttpRequest',
                                    'XMLHttpRequestEventTarget',
                                    'XMLHttpRequestUpload',
                                  ],
                                  T = 0;
                                T < M.length;
                                T++
                              )
                                w(M[T]);
                              var D = y.jQuery || y.$;
                              D &&
                                D.fn &&
                                D.fn.ready &&
                                v(
                                  D.fn,
                                  'ready',
                                  function (L) {
                                    return function (O) {
                                      return L.call(this, b.wrap(O));
                                    };
                                  },
                                  A
                                );
                            },
                          },
                        ]),
                        x
                      );
                    })();
                    o.default = _;
                  },
                './packages/@logrocket/exceptions/src/registerExceptions.js':
                  function (a, o, l) {
                    var c = l(
                        './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                      ),
                      u = l('./node_modules/@babel/runtime/helpers/typeof.js');
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = m));
                    var h = c(
                        l('./packages/@logrocket/exceptions/src/raven/raven.js')
                      ),
                      d = p(
                        l('./packages/@logrocket/exceptions/src/Capture.js')
                      );
                    function f(g) {
                      if (typeof WeakMap != 'function') return null;
                      var v = new WeakMap(),
                        y = new WeakMap();
                      return (f = function (x) {
                        return x ? y : v;
                      })(g);
                    }
                    function p(g, v) {
                      if (g && g.__esModule) return g;
                      if (
                        g === null ||
                        (u(g) !== 'object' && typeof g != 'function')
                      )
                        return { default: g };
                      var y = f(v);
                      if (y && y.has(g)) return y.get(g);
                      var _ = {},
                        x =
                          Object.defineProperty &&
                          Object.getOwnPropertyDescriptor;
                      for (var S in g)
                        if (
                          S !== 'default' &&
                          Object.prototype.hasOwnProperty.call(g, S)
                        ) {
                          var b = x
                            ? Object.getOwnPropertyDescriptor(g, S)
                            : null;
                          b && (b.get || b.set)
                            ? Object.defineProperty(_, S, b)
                            : (_[S] = g[S]);
                        }
                      return ((_.default = g), y && y.set(g, _), _);
                    }
                    function m(g) {
                      var v = new h.default({
                          captureException: function (x) {
                            d.captureException(g, null, null, x);
                          },
                        }),
                        y = function (x) {
                          x.reason instanceof Error
                            ? d.captureException(
                                g,
                                x.reason,
                                null,
                                null,
                                'UNHANDLED_REJECTION'
                              )
                            : g.addEvent('lr.core.Exception', function () {
                                return {
                                  exceptionType: 'UNHANDLED_REJECTION',
                                  message:
                                    x.reason || 'Unhandled Promise rejection',
                                };
                              });
                        };
                      return (
                        window.addEventListener('unhandledrejection', y),
                        function () {
                          (window.removeEventListener('unhandledrejection', y),
                            v.uninstall());
                        }
                      );
                    }
                  },
                './packages/@logrocket/exceptions/src/stackTraceFromError.js':
                  function (a, o) {
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = l));
                    function l(c) {
                      function u(h) {
                        return h === null ? void 0 : h;
                      }
                      return c.stack
                        ? c.stack.map(function (h) {
                            return {
                              lineNumber: u(h.line),
                              columnNumber: u(h.column),
                              fileName: u(h.url),
                              functionName: u(h.func),
                            };
                          })
                        : void 0;
                    }
                  },
                './packages/@logrocket/network/src/fetchIntercept.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = void 0));
                    var u = c(
                        l(
                          './node_modules/@babel/runtime/helpers/toConsumableArray.js'
                        )
                      ),
                      h = l('./packages/@logrocket/network/src/registerXHR.js'),
                      d = [];
                    function f(v, y) {
                      for (
                        var _ = d.reduce(function (E, w) {
                            return [w].concat(E);
                          }, []),
                          x = arguments.length,
                          S = new Array(x > 2 ? x - 2 : 0),
                          b = 2;
                        b < x;
                        b++
                      )
                        S[b - 2] = arguments[b];
                      var A = Promise.resolve(S);
                      return (
                        _.forEach(function (E) {
                          var w = E.request,
                            M = E.requestError;
                          (w || M) &&
                            (A = A.then(
                              function (T) {
                                return w.apply(
                                  void 0,
                                  [y].concat((0, u.default)(T))
                                );
                              },
                              function (T) {
                                return M.apply(
                                  void 0,
                                  [y].concat((0, u.default)(T))
                                );
                              }
                            ));
                        }),
                        (A = A.then(function (E) {
                          (0, h.setActive)(!1);
                          var w, M;
                          try {
                            w = v.apply(void 0, (0, u.default)(E));
                          } catch (T) {
                            M = T;
                          }
                          if (((0, h.setActive)(!0), M)) throw M;
                          return w;
                        })),
                        _.forEach(function (E) {
                          var w = E.response,
                            M = E.responseError;
                          (w || M) &&
                            (A = A.then(
                              function (T) {
                                return w(y, T);
                              },
                              function (T) {
                                return M && M(y, T);
                              }
                            ));
                        }),
                        A
                      );
                    }
                    function p(v) {
                      if (!(!v.fetch || !v.Promise)) {
                        var y = v.fetch.polyfill;
                        ((v.fetch = (function (_) {
                          var x = 0;
                          return function () {
                            for (
                              var S = arguments.length, b = new Array(S), A = 0;
                              A < S;
                              A++
                            )
                              b[A] = arguments[A];
                            return f.apply(void 0, [_, x++].concat(b));
                          };
                        })(v.fetch)),
                          y && (v.fetch.polyfill = y));
                      }
                    }
                    var m = !1,
                      g = {
                        register: function (y) {
                          return (
                            m || ((m = !0), p(window)),
                            d.push(y),
                            function () {
                              var _ = d.indexOf(y);
                              _ >= 0 && d.splice(_, 1);
                            }
                          );
                        },
                        clear: function () {
                          d = [];
                        },
                      };
                    o.default = g;
                  },
                './packages/@logrocket/network/src/index.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = _));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/defineProperty.js'
                      )
                    ),
                    h = c(l('./node_modules/@babel/runtime/helpers/typeof.js')),
                    d = c(
                      l('./packages/@logrocket/network/src/registerFetch.js')
                    ),
                    f = l('./packages/@logrocket/network/src/registerIonic.ts'),
                    p = c(
                      l(
                        './packages/@logrocket/network/src/registerNetworkInformation.js'
                      )
                    ),
                    m = c(
                      l('./packages/@logrocket/network/src/registerXHR.js')
                    ),
                    g = c(l('./packages/@logrocket/utils/src/mapValues.ts'));
                  function v(x, S) {
                    var b = Object.keys(x);
                    if (Object.getOwnPropertySymbols) {
                      var A = Object.getOwnPropertySymbols(x);
                      (S &&
                        (A = A.filter(function (E) {
                          return Object.getOwnPropertyDescriptor(x, E)
                            .enumerable;
                        })),
                        b.push.apply(b, A));
                    }
                    return b;
                  }
                  function y(x) {
                    for (var S = 1; S < arguments.length; S++) {
                      var b = arguments[S] != null ? arguments[S] : {};
                      S % 2
                        ? v(Object(b), !0).forEach(function (A) {
                            (0, u.default)(x, A, b[A]);
                          })
                        : Object.getOwnPropertyDescriptors
                          ? Object.defineProperties(
                              x,
                              Object.getOwnPropertyDescriptors(b)
                            )
                          : v(Object(b)).forEach(function (A) {
                              Object.defineProperty(
                                x,
                                A,
                                Object.getOwnPropertyDescriptor(b, A)
                              );
                            });
                    }
                    return x;
                  }
                  function _(x) {
                    var S =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : { isReactNative: !1, isDisabled: !1 };
                    if (S?.isDisabled === !0) return function () {};
                    var b = S.isReactNative,
                      A = S.shouldAugmentNPS,
                      E = S.shouldParseXHRBlob,
                      w = {},
                      M = function (W) {
                        var G = 4096e3,
                          ne = W;
                        if ((0, h.default)(W) === 'object' && W != null) {
                          var ve = Object.getPrototypeOf(W);
                          (ve === Object.prototype || ve === null) &&
                            (ne = JSON.stringify(W));
                        }
                        if (
                          ne &&
                          ne.length &&
                          ne.length > G &&
                          typeof ne == 'string'
                        ) {
                          var Se = ne.substring(0, 1e3);
                          return ''.concat(
                            Se,
                            ` ... LogRocket truncating to first 1000 characters.
      Keep data under 4MB to prevent truncation. https://docs.logrocket.com/reference/network`
                          );
                        }
                        return W;
                      },
                      T = function (W, G) {
                        var ne = G.method;
                        x.addEvent('lr.network.RequestEvent', function () {
                          var ve =
                              arguments.length > 0 && arguments[0] !== void 0
                                ? arguments[0]
                                : {},
                            Se = ve.isEnabled,
                            Ae = Se === void 0 ? !0 : Se,
                            Oe = ve.requestSanitizer,
                            Z =
                              Oe === void 0
                                ? function (K) {
                                    return K;
                                  }
                                : Oe;
                          if (!Ae) return null;
                          var J = null;
                          try {
                            J = Z(y(y({}, G), {}, { reqId: W }));
                          } catch (K) {
                            console.error(K);
                          }
                          if (J) {
                            var de = J.url;
                            if (
                              typeof document < 'u' &&
                              typeof document.createElement == 'function'
                            ) {
                              var fe = document.createElement('a');
                              ((fe.href = J.url), (de = fe.href));
                            }
                            return {
                              reqId: W,
                              url: de,
                              headers: (0, g.default)(J.headers, function (K) {
                                return ''.concat(K);
                              }),
                              body: M(J.body),
                              method: ne,
                              referrer: J.referrer || void 0,
                              mode: J.mode || void 0,
                              credentials: J.credentials || void 0,
                            };
                          }
                          return ((w[W] = !0), null);
                        });
                      },
                      D = function (W, G) {
                        var ne = G.method,
                          ve = G.status,
                          Se = G.responseType;
                        x.addEvent('lr.network.ResponseEvent', function () {
                          var Ae =
                              arguments.length > 0 && arguments[0] !== void 0
                                ? arguments[0]
                                : {},
                            Oe = Ae.isEnabled,
                            Z = Oe === void 0 ? !0 : Oe,
                            J = Ae.responseSanitizer,
                            de =
                              J === void 0
                                ? function (K) {
                                    return K;
                                  }
                                : J;
                          if (Z) {
                            if (w[W]) return (delete w[W], null);
                          } else return null;
                          var fe = null;
                          try {
                            fe = de(y(y({}, G), {}, { reqId: W }));
                          } catch (K) {
                            console.error(K);
                          }
                          return fe
                            ? {
                                reqId: W,
                                responseType: Se,
                                status: fe.status,
                                headers: (0, g.default)(
                                  fe.headers,
                                  function (K) {
                                    return ''.concat(K);
                                  }
                                ),
                                body: M(fe.body),
                                method: ne,
                              }
                            : {
                                reqId: W,
                                responseType: Se,
                                status: ve,
                                headers: {},
                                body: null,
                                method: ne,
                              };
                        });
                      },
                      L = function (W) {
                        return x.isDisabled || w[W] === !0;
                      },
                      O = (0, d.default)({
                        addRequest: T,
                        addResponse: D,
                        isIgnored: L,
                      }),
                      z = (0, m.default)({
                        addRequest: T,
                        addResponse: D,
                        isIgnored: L,
                        logger: x,
                        shouldAugmentNPS: A,
                        shouldParseXHRBlob: E,
                      }),
                      C = (0, f.registerIonic)({
                        addRequest: T,
                        addResponse: D,
                        isIgnored: L,
                      }),
                      N = b ? function () {} : (0, p.default)(x);
                    return function () {
                      (N(), O(), z(), C());
                    };
                  }
                },
                './packages/@logrocket/network/src/registerFetch.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = y));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/defineProperty.js'
                      )
                    ),
                    h = c(l('./packages/@logrocket/utils/src/mapValues.ts')),
                    d = c(
                      l('./packages/@logrocket/network/src/fetchIntercept.js')
                    );
                  function f(_, x) {
                    var S = Object.keys(_);
                    if (Object.getOwnPropertySymbols) {
                      var b = Object.getOwnPropertySymbols(_);
                      (x &&
                        (b = b.filter(function (A) {
                          return Object.getOwnPropertyDescriptor(_, A)
                            .enumerable;
                        })),
                        S.push.apply(S, b));
                    }
                    return S;
                  }
                  function p(_) {
                    for (var x = 1; x < arguments.length; x++) {
                      var S = arguments[x] != null ? arguments[x] : {};
                      x % 2
                        ? f(Object(S), !0).forEach(function (b) {
                            (0, u.default)(_, b, S[b]);
                          })
                        : Object.getOwnPropertyDescriptors
                          ? Object.defineProperties(
                              _,
                              Object.getOwnPropertyDescriptors(S)
                            )
                          : f(Object(S)).forEach(function (b) {
                              Object.defineProperty(
                                _,
                                b,
                                Object.getOwnPropertyDescriptor(S, b)
                              );
                            });
                    }
                    return _;
                  }
                  function m(_) {
                    if (_ == null || typeof _.forEach != 'function') return _;
                    var x = {};
                    return (
                      _.forEach(function (S, b) {
                        x[b]
                          ? (x[b] = ''.concat(x[b], ',').concat(S))
                          : (x[b] = ''.concat(S));
                      }),
                      x
                    );
                  }
                  var g = function (x) {
                    return (0, h.default)(m(x), function (S) {
                      return ''.concat(S);
                    });
                  };
                  function v() {
                    var _ =
                      arguments.length > 0 && arguments[0] !== void 0
                        ? arguments[0]
                        : {};
                    return {
                      url: _.url,
                      headers: g(_.headers),
                      method: _.method && _.method.toUpperCase(),
                      referrer: _.referrer || void 0,
                      mode: _.mode || void 0,
                      credentials: _.credentials || void 0,
                    };
                  }
                  function y(_) {
                    var x = _.addRequest,
                      S = _.addResponse,
                      b = _.isIgnored,
                      A = 'fetch-',
                      E = {},
                      w = d.default.register({
                        request: function (T) {
                          for (
                            var D = arguments.length,
                              L = new Array(D > 1 ? D - 1 : 0),
                              O = 1;
                            O < D;
                            O++
                          )
                            L[O - 1] = arguments[O];
                          var z;
                          if (typeof Request < 'u' && L[0] instanceof Request) {
                            var C;
                            try {
                              C = L[0].clone().text();
                            } catch (N) {
                              C = Promise.resolve(
                                'LogRocket fetch error: '.concat(N.message)
                              );
                            }
                            z = C.then(
                              function (N) {
                                return p(p({}, v(L[0])), {}, { body: N });
                              },
                              function (N) {
                                return p(
                                  p({}, v(L[0])),
                                  {},
                                  {
                                    body: 'LogRocket fetch error: '.concat(
                                      N.message
                                    ),
                                  }
                                );
                              }
                            );
                          } else
                            z = Promise.resolve(
                              p(
                                p({}, v(L[1])),
                                {},
                                {
                                  url: ''.concat(L[0]),
                                  body: (L[1] || {}).body,
                                }
                              )
                            );
                          return z.then(function (N) {
                            return (
                              (E[T] = N.method),
                              x(''.concat(A).concat(T), N),
                              L
                            );
                          });
                        },
                        requestError: function (T, D) {
                          return Promise.reject(D);
                        },
                        response: function (T, D) {
                          var L, O;
                          if (b(''.concat(A).concat(T))) return D;
                          if (
                            D.headers.get('content-type') ===
                            'text/event-stream'
                          )
                            O = Promise.resolve(
                              'LogRocket skipped consuming an event-stream body.'
                            );
                          else {
                            try {
                              L = D.clone();
                            } catch (W) {
                              var z = {
                                url: D.url,
                                responseType: D.type.toUpperCase(),
                                status: D.status,
                                headers: g(D.headers),
                                body: 'LogRocket fetch error: '.concat(
                                  W.message
                                ),
                                method: E[T],
                              };
                              return (
                                delete E[T],
                                S(''.concat(A).concat(T), z),
                                D
                              );
                            }
                            try {
                              if (window.TextDecoder && L.body) {
                                var C = L.body.getReader(),
                                  N = new window.TextDecoder('utf-8'),
                                  U = '';
                                O = C.read().then(function W(G) {
                                  var ne = G.done,
                                    ve = G.value;
                                  if (ne) return U;
                                  var Se = ve
                                    ? N.decode(ve, { stream: !0 })
                                    : '';
                                  return ((U += Se), C.read().then(W));
                                });
                              } else O = L.text();
                            } catch (W) {
                              O = Promise.resolve(
                                'LogRocket error reading body: '.concat(
                                  W.message
                                )
                              );
                            }
                          }
                          return (
                            O.catch(function (W) {
                              if (
                                !(
                                  W.name === 'AbortError' &&
                                  W instanceof DOMException
                                )
                              )
                                return 'LogRocket error reading body: '.concat(
                                  W.message
                                );
                            }).then(function (W) {
                              var G = {
                                url: D.url,
                                responseType: D.type.toUpperCase(),
                                status: D.status,
                                headers: g(D.headers),
                                body: W,
                                method: E[T],
                              };
                              (delete E[T], S(''.concat(A).concat(T), G));
                            }),
                            D
                          );
                        },
                        responseError: function (T, D) {
                          var L = {
                            url: void 0,
                            status: 0,
                            headers: {},
                            body: ''.concat(D),
                          };
                          return (
                            S(''.concat(A).concat(T), L),
                            Promise.reject(D)
                          );
                        },
                      });
                    return w;
                  }
                },
                './packages/@logrocket/network/src/registerIonic.ts': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.mergeHeaders = C),
                    (o.serializeQueryParams = ve),
                    (o.appendQueryParamsString = Se),
                    (o.processData = Z),
                    (o.registerIonic = fe));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/defineProperty.js'
                      )
                    ),
                    h = c(l('./node_modules/@babel/runtime/helpers/typeof.js')),
                    d = c(
                      l(
                        './node_modules/@babel/runtime/helpers/toConsumableArray.js'
                      )
                    ),
                    f = c(l('./packages/@logrocket/utils/src/protectFunc.ts'));
                  function p(K, oe) {
                    var he =
                      (typeof Symbol < 'u' && K[Symbol.iterator]) ||
                      K['@@iterator'];
                    if (!he) {
                      if (Array.isArray(K) || (he = m(K)) || oe) {
                        he && (K = he);
                        var xe = 0,
                          ee = function () {};
                        return {
                          s: ee,
                          n: function () {
                            return xe >= K.length
                              ? { done: !0 }
                              : { done: !1, value: K[xe++] };
                          },
                          e: function (Ee) {
                            throw Ee;
                          },
                          f: ee,
                        };
                      }
                      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                    }
                    var B = !0,
                      me = !1,
                      ye;
                    return {
                      s: function () {
                        he = he.call(K);
                      },
                      n: function () {
                        var Ee = he.next();
                        return ((B = Ee.done), Ee);
                      },
                      e: function (Ee) {
                        ((me = !0), (ye = Ee));
                      },
                      f: function () {
                        try {
                          !B && he.return != null && he.return();
                        } finally {
                          if (me) throw ye;
                        }
                      },
                    };
                  }
                  function m(K, oe) {
                    if (K) {
                      if (typeof K == 'string') return g(K, oe);
                      var he = Object.prototype.toString.call(K).slice(8, -1);
                      if (
                        (he === 'Object' &&
                          K.constructor &&
                          (he = K.constructor.name),
                        he === 'Map' || he === 'Set')
                      )
                        return Array.from(K);
                      if (
                        he === 'Arguments' ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(he)
                      )
                        return g(K, oe);
                    }
                  }
                  function g(K, oe) {
                    (oe == null || oe > K.length) && (oe = K.length);
                    for (var he = 0, xe = new Array(oe); he < oe; he++)
                      xe[he] = K[he];
                    return xe;
                  }
                  function v(K, oe) {
                    var he = Object.keys(K);
                    if (Object.getOwnPropertySymbols) {
                      var xe = Object.getOwnPropertySymbols(K);
                      (oe &&
                        (xe = xe.filter(function (ee) {
                          return Object.getOwnPropertyDescriptor(K, ee)
                            .enumerable;
                        })),
                        he.push.apply(he, xe));
                    }
                    return he;
                  }
                  function y(K) {
                    for (var oe = 1; oe < arguments.length; oe++) {
                      var he = arguments[oe] != null ? arguments[oe] : {};
                      oe % 2
                        ? v(Object(he), !0).forEach(function (xe) {
                            (0, u.default)(K, xe, he[xe]);
                          })
                        : Object.getOwnPropertyDescriptors
                          ? Object.defineProperties(
                              K,
                              Object.getOwnPropertyDescriptors(he)
                            )
                          : v(Object(he)).forEach(function (xe) {
                              Object.defineProperty(
                                K,
                                xe,
                                Object.getOwnPropertyDescriptor(he, xe)
                              );
                            });
                    }
                    return K;
                  }
                  var _ = new Set([
                      'get',
                      'put',
                      'post',
                      'patch',
                      'head',
                      'delete',
                      'options',
                      'upload',
                      'download',
                    ]),
                    x = new Set(['urlencoded', 'json', 'utf8']),
                    S = new Set(['raw', 'multipart']),
                    b = 'ionic-',
                    A = new Set(['desktop', 'mobileweb', 'pwa']),
                    E = new Set(['FormData']),
                    w = new Set(),
                    M = new Set(['string']),
                    T = new Set(['string', 'array']),
                    D = {
                      utf8: M,
                      urlencoded: new Set(['object']),
                      json: new Set(['array', 'object']),
                      raw: new Set(['Uint8Array', 'ArrayBuffer']),
                      default: w,
                    };
                  function L(K, oe, he) {
                    if (typeof oe != 'string')
                      throw new Error(
                        ''
                          .concat(he, ' must be one of: ')
                          .concat((0, d.default)(K).join(', '))
                      );
                    if (((oe = oe.trim().toLowerCase()), !K.has(oe)))
                      throw new Error(
                        ''
                          .concat(he, ' must be one of: ')
                          .concat((0, d.default)(K).join(', '))
                      );
                    return oe;
                  }
                  function O(K, oe, he) {
                    if ((0, h.default)(K) !== 'object') throw new Error(he);
                    for (
                      var xe = 0, ee = Object.keys(K);
                      xe < ee.length;
                      xe++
                    ) {
                      var B = ee[xe];
                      if (!oe.has((0, h.default)(K[B]))) throw new Error(he);
                    }
                    return K;
                  }
                  function z(K, oe) {
                    var he = new URL(K),
                      xe = he.host;
                    return oe.getHeaders(xe) || null;
                  }
                  function C(K, oe) {
                    return y(y({}, K), oe);
                  }
                  function N(K, oe, he) {
                    var xe = he.getHeaders('*') || {},
                      ee = z(K, he) || {};
                    return C(C(xe, ee), oe);
                  }
                  function U(K, oe) {
                    return oe ? encodeURIComponent(K) : K;
                  }
                  function W(K, oe, he) {
                    return K.length
                      ? he
                        ? ''
                            .concat(encodeURIComponent(K), '[')
                            .concat(encodeURIComponent(oe), ']')
                        : ''.concat(K, '[').concat(oe, ']')
                      : he
                        ? encodeURIComponent(oe)
                        : oe;
                  }
                  function G(K, oe, he) {
                    var xe = [],
                      ee = p(oe),
                      B;
                    try {
                      for (ee.s(); !(B = ee.n()).done; ) {
                        var me = B.value;
                        if (Array.isArray(me)) {
                          xe.push(G(''.concat(K, '[]'), me, he));
                          continue;
                        } else if ((0, h.default)(me) === 'object') {
                          xe.push(
                            ne(''.concat(K, '[]').concat(me), he, void 0)
                          );
                          continue;
                        }
                        xe.push(''.concat(W(K, '', he), '=').concat(U(me, he)));
                      }
                    } catch (ye) {
                      ee.e(ye);
                    } finally {
                      ee.f();
                    }
                    return xe.join('&');
                  }
                  function ne(K, oe, he) {
                    var xe = [];
                    for (var ee in oe)
                      if (oe.hasOwnProperty(ee)) {
                        var B = K.length
                          ? ''.concat(K, '[').concat(ee, ']')
                          : ee;
                        if (Array.isArray(oe[ee])) {
                          xe.push(G(B, oe[ee], he));
                          continue;
                        } else if (
                          (0, h.default)(oe[ee]) === 'object' &&
                          oe[ee] !== null
                        ) {
                          xe.push(ne(B, oe[ee], he));
                          continue;
                        }
                        xe.push(
                          ''.concat(W(K, ee, he), '=').concat(U(oe[ee], he))
                        );
                      }
                    return xe.join('&');
                  }
                  function ve(K, oe) {
                    return ne('', K, oe);
                  }
                  function Se(K, oe) {
                    if (!K.length || !oe.length) return K;
                    var he = new URL(K),
                      xe = he.host,
                      ee = he.pathname,
                      B = he.search,
                      me = he.hash,
                      ye = he.protocol;
                    return ''
                      .concat(ye, '//')
                      .concat(xe)
                      .concat(ee)
                      .concat(
                        B.length ? ''.concat(B, '&').concat(oe) : '?'.concat(oe)
                      )
                      .concat(me);
                  }
                  function Ae(K) {
                    return D[K] || D.default;
                  }
                  function Oe(K) {
                    return K === 'multipart' ? E : w;
                  }
                  function Z(K, oe) {
                    var he = (0, h.default)(K),
                      xe = Ae(oe),
                      ee = Oe(oe);
                    if (ee.size > 0) {
                      var B = !1;
                      if (
                        (ee.forEach(function (me) {
                          l.g[me] && K instanceof l.g[me] && (B = !0);
                        }),
                        !B)
                      )
                        throw new Error(
                          'INSTANCE_TYPE_MISMATCH_DATA '.concat(
                            (0, d.default)(ee).join(', ')
                          )
                        );
                    }
                    if (ee.size === 0 && !xe.has(he))
                      throw new Error(
                        'TYPE_MISMATCH_DATA '.concat(
                          (0, d.default)(xe).join(', ')
                        )
                      );
                    switch (oe) {
                      case 'utf8':
                        return K;
                      default:
                        return JSON.stringify(K, void 0, 2);
                    }
                  }
                  function J(K, oe) {
                    K = K || {};
                    var he,
                      xe = K.data;
                    try {
                      he = L(
                        x,
                        K.serializer || oe.getDataSerializer(),
                        'serializer / data payload type'
                      );
                    } catch {
                      ((he = L(
                        S,
                        K.serializer || oe.getDataSerializer(),
                        'serializer / data payload type'
                      )),
                        (xe = {}));
                    }
                    return {
                      data: xe,
                      filePath: K.filePath,
                      followRedirect: K.followRedirect,
                      headers: O(
                        K.headers || {},
                        M,
                        'Invalid header type, must be string'
                      ),
                      method: L(_, K.method || _[0], 'method'),
                      name: K.name,
                      params: O(
                        K.params || {},
                        T,
                        'Invalid param, must be of type string or array'
                      ),
                      responseType: K.responseType,
                      serializer: he,
                      connectTimeout: K.connectTimeout,
                      readTimeout: K.readTimeout,
                      timeout: K.timeout,
                    };
                  }
                  var de = 0;
                  function fe(K) {
                    var oe,
                      he,
                      xe,
                      ee = K.addRequest,
                      B = K.addResponse,
                      me = K.isIgnored,
                      ye =
                        (oe = window.cordova) === null ||
                        oe === void 0 ||
                        (he = oe.plugin) === null ||
                        he === void 0
                          ? void 0
                          : he.http,
                      Te = {},
                      Ee = !1;
                    if (typeof ye > 'u') return function () {};
                    var Xe =
                      (xe = window.ionic) === null || xe === void 0
                        ? void 0
                        : xe.platforms;
                    if (
                      typeof Xe < 'u' &&
                      typeof Xe.some == 'function' &&
                      Xe.some(function (F) {
                        return A.has(F);
                      })
                    )
                      return function () {};
                    var Ne = ye.sendRequest,
                      We = (0, f.default)(function (F, P, Q) {
                        if (!me(''.concat(b).concat(Q)))
                          try {
                            var le = {
                              url: F.url || '',
                              status:
                                F.status < 600 && F.status >= 100
                                  ? F.status
                                  : 0,
                              headers: F.headers || {},
                              body: P ? F.data : F.error,
                              method: Te[Q].toUpperCase(),
                            };
                            B(''.concat(b).concat(Q), le);
                          } catch (se) {
                            var ge = {
                              url: F.url || '',
                              status:
                                F.status < 600 && F.status >= 100
                                  ? F.status
                                  : 0,
                              headers: F.headers || {},
                              body: 'LogRocket fetch error: '.concat(
                                se.message
                              ),
                              method: Te[Q].toUpperCase(),
                            };
                            B(''.concat(b).concat(Q), ge);
                          }
                      });
                    return (
                      (ye.sendRequest = function (F, P, Q, le) {
                        var ge = ++de,
                          se = function (Le) {
                            (Ee || (We(Le, !0, ge), delete Te[ge]), Q(Le));
                          },
                          Ke = function (Le) {
                            (Ee || (We(Le, !1, ge), delete Te[ge]), le(Le));
                          };
                        if (!Ee)
                          try {
                            var Be = J(P, ye),
                              at = Se(F, ne('', Be.params, !0)),
                              Je = N(F, Be.headers, ye),
                              we = Be.method || 'get';
                            Te[ge] = we;
                            var Ce = {
                              url: at,
                              method: we.toUpperCase(),
                              headers: Je || {},
                              body: Z(Be.data || {}, Be.serializer),
                            };
                            ee(''.concat(b).concat(ge), Ce);
                          } catch (it) {
                            var ct = {
                              url: F,
                              method: (P.method || 'get').toUpperCase(),
                              headers: {},
                              body: 'LogRocket fetch error: '.concat(
                                it.message
                              ),
                            };
                            ee(''.concat(b).concat(ge), ct);
                          }
                        return Ne(F, P, se, Ke);
                      }),
                      function () {
                        ((Ee = !0), (ye.sendRequest = Ne), (Te = {}));
                      }
                    );
                  }
                },
                './packages/@logrocket/network/src/registerNetworkInformation.js':
                  function (a, o) {
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = c));
                    var l = {
                      'slow-2g': 'SLOW2G',
                      '2g': 'TWOG',
                      '3g': 'THREEG',
                      '4g': 'FOURG',
                    };
                    function c(u) {
                      var h = void 0;
                      function d() {
                        var f = {
                          online: window.navigator.onLine,
                          effectiveType: 'UNKOWN',
                        };
                        (window.navigator.onLine
                          ? window.navigator.connection &&
                            window.navigator.connection.effectiveType &&
                            (f.effectiveType =
                              l[window.navigator.connection.effectiveType] ||
                              'UNKNOWN')
                          : (f.effectiveType = 'NONE'),
                          !(
                            h &&
                            f.online === h.online &&
                            f.effectiveType === h.effectiveType
                          ) &&
                            ((h = f),
                            u.addEvent(
                              'lr.network.NetworkStatusEvent',
                              function () {
                                var p =
                                    arguments.length > 0 &&
                                    arguments[0] !== void 0
                                      ? arguments[0]
                                      : {},
                                  m = p.isEnabled,
                                  g = m === void 0 ? !0 : m;
                                return g ? f : null;
                              }
                            )));
                      }
                      return (
                        setTimeout(d),
                        window.navigator.connection &&
                          typeof window.navigator.connection.addEventListener ==
                            'function' &&
                          window.navigator.connection.addEventListener(
                            'change',
                            d
                          ),
                        window.addEventListener('online', d),
                        window.addEventListener('offline', d),
                        function () {
                          (window.removeEventListener('offline', d),
                            window.removeEventListener('online', d),
                            window.navigator.connection &&
                              typeof window.navigator.connection
                                .removeEventListener == 'function' &&
                              window.navigator.connection.removeEventListener(
                                'change',
                                d
                              ));
                        }
                      );
                    }
                  },
                './packages/@logrocket/network/src/registerXHR.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.setActive = v),
                    (o.default = _));
                  var u = c(l('./packages/@logrocket/utils/src/mapValues.ts')),
                    h = c(l('./packages/@logrocket/utils/src/enhanceFunc.ts')),
                    d = c(l('./packages/@logrocket/utils/src/protectFunc.ts')),
                    f = c(l('./packages/@logrocket/utils/src/startsWith.js')),
                    p = l('./packages/@logrocket/utils/src/constants/nps.js'),
                    m = l(
                      './packages/@logrocket/utils/src/constants/statusCodes.ts'
                    ),
                    g = !0;
                  function v(x) {
                    g = x;
                  }
                  var y = 0;
                  function _(x) {
                    var S = x.addRequest,
                      b = x.addResponse,
                      A = x.isIgnored,
                      E = x.logger,
                      w = x.shouldAugmentNPS,
                      M = w === void 0 ? !0 : w,
                      T = x.shouldParseXHRBlob,
                      D = T === void 0 ? !1 : T,
                      L = XMLHttpRequest,
                      O = new WeakMap(),
                      z = !1,
                      C = 'xhr-';
                    return (
                      (window._lrXMLHttpRequest = XMLHttpRequest),
                      (XMLHttpRequest = function (U, W) {
                        var G = new L(U, W);
                        if (!g) return G;
                        O.set(G, {
                          xhrId: ++y,
                          requestHeaders: {},
                          sent: !1,
                          done: !1,
                        });
                        var ne = G.open;
                        function ve() {
                          for (
                            var J = arguments.length, de = new Array(J), fe = 0;
                            fe < J;
                            fe++
                          )
                            de[fe] = arguments[fe];
                          try {
                            var K = de[1];
                            if (
                              window.URL &&
                              typeof window.URL == 'function' &&
                              K.search(p.WOOTRIC_RESPONSES_REGEX) === 0
                            ) {
                              var oe = new window.URL(E.recordingURL);
                              oe.searchParams.set('nps', 'wootric');
                              var he = new window.URL(K),
                                xe = he.searchParams.get('response[text]'),
                                ee = xe
                                  ? ''.concat(
                                      xe,
                                      `

`
                                    )
                                  : '';
                              (he.searchParams.set(
                                'response[text]',
                                ''
                                  .concat(ee, '<')
                                  .concat(oe.href, '|View LogRocket session>')
                              ),
                                (de[1] = he.href));
                            }
                          } catch {}
                          return ne.apply(this, de);
                        }
                        var Se = G.send;
                        function Ae() {
                          for (
                            var J = arguments.length, de = new Array(J), fe = 0;
                            fe < J;
                            fe++
                          )
                            de[fe] = arguments[fe];
                          try {
                            var K = O.get(G);
                            if (
                              window.URL &&
                              typeof window.URL == 'function' &&
                              K &&
                              K.url &&
                              K.url.search(p.DELIGHTED_RESPONSES_REGEX) === 0 &&
                              de.length &&
                              de[0].indexOf(p.DELIGHTED_FEEDBACK_PREFIX) !== -1
                            ) {
                              var oe = new window.URL(E.recordingURL);
                              oe.searchParams.set('nps', 'delighted');
                              var he = encodeURIComponent(oe.href),
                                xe = de[0]
                                  .split('&')
                                  .map(function (ee) {
                                    if (
                                      (0, f.default)(
                                        ee,
                                        p.DELIGHTED_FEEDBACK_PREFIX
                                      )
                                    ) {
                                      var B =
                                        ee === p.DELIGHTED_FEEDBACK_PREFIX;
                                      return ''
                                        .concat(ee)
                                        .concat(
                                          B
                                            ? ''
                                            : `

`,
                                          '<'
                                        )
                                        .concat(he, '|View LogRocket session>');
                                    }
                                    return ee;
                                  })
                                  .join('&');
                              de[0] = xe;
                            }
                          } catch {}
                          return Se.apply(this, de);
                        }
                        M && ((G.open = ve), (G.send = Ae));
                        var Oe = function () {
                          var de;
                          if (!z) {
                            var fe = O.get(G);
                            if (
                              !(!fe || A(''.concat(C).concat(fe.xhrId))) &&
                              !(!fe.sent || !fe.done)
                            ) {
                              var K =
                                fe.status || m.XHR_CUSTOM_STATUS_CODES.error;
                              K === m.XHR_CUSTOM_STATUS_CODES.error &&
                                ((de = window.navigator) === null ||
                                de === void 0
                                  ? void 0
                                  : de.onLine) === !1 &&
                                (K = m.XHR_CUSTOM_STATUS_CODES.offline);
                              var oe = {
                                url: fe.url,
                                status: K,
                                headers: fe.responseHeaders,
                                body: fe.responseBody,
                                method: (fe.method || '').toUpperCase(),
                              };
                              if (D && oe.body instanceof Blob) {
                                var he = new FileReader();
                                (he.readAsText(oe.body),
                                  (he.onload = function () {
                                    try {
                                      oe.body = JSON.parse(he.result);
                                    } catch {}
                                    b(''.concat(C).concat(fe.xhrId), oe);
                                  }));
                              } else b(''.concat(C).concat(fe.xhrId), oe);
                            }
                          }
                        };
                        ((0, h.default)(
                          G,
                          'open',
                          (0, d.default)(function (J, de) {
                            if (!z) {
                              var fe = O.get(G);
                              ((fe.method = J), (fe.url = de));
                            }
                          })
                        ),
                          (0, h.default)(
                            G,
                            'send',
                            (0, d.default)(function (J) {
                              if (!z) {
                                var de = O.get(G);
                                if (de) {
                                  var fe = {
                                    url: de.url,
                                    method:
                                      de.method && de.method.toUpperCase(),
                                    headers: (0, u.default)(
                                      de.requestHeaders || {},
                                      function (K) {
                                        return K.join(', ');
                                      }
                                    ),
                                    body: J,
                                  };
                                  (S(''.concat(C).concat(de.xhrId), fe),
                                    (de.sent = !0),
                                    Oe());
                                }
                              }
                            })
                          ),
                          (0, h.default)(
                            G,
                            'setRequestHeader',
                            (0, d.default)(function (J, de) {
                              if (!z) {
                                var fe = O.get(G);
                                fe &&
                                  ((fe.requestHeaders =
                                    fe.requestHeaders || {}),
                                  (fe.requestHeaders[J] =
                                    fe.requestHeaders[J] || []),
                                  fe.requestHeaders[J].push(de));
                              }
                            })
                          ));
                        var Z = {
                          readystatechange: (0, d.default)(function () {
                            if (!z && G.readyState === 4) {
                              var J = O.get(G);
                              if (!J || A(''.concat(C).concat(J.xhrId))) return;
                              var de = G.getAllResponseHeaders() || '';
                              J.responseHeaders = de
                                .split(/[\r\n]+/)
                                .reduce(function (K, oe) {
                                  var he = K,
                                    xe = oe.split(': ');
                                  if (xe.length > 0) {
                                    var ee = xe.shift(),
                                      B = xe.join(': ');
                                    K[ee]
                                      ? (he[ee] += ', '.concat(B))
                                      : (he[ee] = B);
                                  }
                                  return he;
                                }, {});
                              var fe;
                              try {
                                switch (G.responseType) {
                                  case 'json':
                                    fe = E._shouldCloneResponse
                                      ? JSON.parse(JSON.stringify(G.response))
                                      : G.response;
                                    break;
                                  case 'arraybuffer':
                                  case 'blob': {
                                    fe = G.response;
                                    break;
                                  }
                                  case 'document': {
                                    fe = G.responseXML;
                                    break;
                                  }
                                  case 'text':
                                  case '': {
                                    fe = G.responseText;
                                    break;
                                  }
                                  default:
                                    fe = '';
                                }
                              } catch {
                                fe = 'LogRocket: Error accessing response.';
                              }
                              ((J.responseBody = fe),
                                (J.status = G.status),
                                (J.done = !0));
                            }
                          }),
                          abort: (0, d.default)(function () {
                            var J = O.get(G);
                            J && (J.status = m.XHR_CUSTOM_STATUS_CODES.aborted);
                          }),
                          timeout: (0, d.default)(function () {
                            var J = O.get(G);
                            J && (J.status = m.XHR_CUSTOM_STATUS_CODES.timeout);
                          }),
                          loadend: (0, d.default)(function () {
                            Oe();
                          }),
                        };
                        return (
                          Object.keys(Z).forEach(function (J) {
                            G.addEventListener(J, Z[J]);
                          }),
                          G
                        );
                      }),
                      (XMLHttpRequest.prototype = L.prototype),
                      [
                        'UNSENT',
                        'OPENED',
                        'HEADERS_RECEIVED',
                        'LOADING',
                        'DONE',
                      ].forEach(function (N) {
                        XMLHttpRequest[N] = L[N];
                      }),
                      function () {
                        ((z = !0), (XMLHttpRequest = L));
                      }
                    );
                  }
                },
                './packages/@logrocket/now/src/index.js': function (a, o) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = void 0));
                  var l = Date.now.bind(Date),
                    c = l(),
                    u =
                      typeof performance < 'u' && performance.now
                        ? performance.now.bind(performance)
                        : function () {
                            return l() - c;
                          };
                  o.default = u;
                },
                './packages/@logrocket/redux/src/createEnhancer.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = m));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/defineProperty.js'
                      )
                    ),
                    h = c(l('./packages/@logrocket/now/src/index.js'));
                  function d(g, v) {
                    var y = Object.keys(g);
                    if (Object.getOwnPropertySymbols) {
                      var _ = Object.getOwnPropertySymbols(g);
                      (v &&
                        (_ = _.filter(function (x) {
                          return Object.getOwnPropertyDescriptor(g, x)
                            .enumerable;
                        })),
                        y.push.apply(y, _));
                    }
                    return y;
                  }
                  function f(g) {
                    for (var v = 1; v < arguments.length; v++) {
                      var y = arguments[v] != null ? arguments[v] : {};
                      v % 2
                        ? d(Object(y), !0).forEach(function (_) {
                            (0, u.default)(g, _, y[_]);
                          })
                        : Object.getOwnPropertyDescriptors
                          ? Object.defineProperties(
                              g,
                              Object.getOwnPropertyDescriptors(y)
                            )
                          : d(Object(y)).forEach(function (_) {
                              Object.defineProperty(
                                g,
                                _,
                                Object.getOwnPropertyDescriptor(y, _)
                              );
                            });
                    }
                    return g;
                  }
                  var p = 0;
                  function m(g) {
                    var v =
                        arguments.length > 1 && arguments[1] !== void 0
                          ? arguments[1]
                          : {},
                      y = v.stateSanitizer,
                      _ =
                        y === void 0
                          ? function (b) {
                              return b;
                            }
                          : y,
                      x = v.actionSanitizer,
                      S =
                        x === void 0
                          ? function (b) {
                              return b;
                            }
                          : x;
                    return function (b) {
                      return function (A, E, w) {
                        var M = b(A, E, w),
                          T = M.dispatch,
                          D = p++;
                        g.addEvent('lr.redux.InitialState', function () {
                          var O;
                          try {
                            O = _(M.getState());
                          } catch (z) {
                            console.error(z.toString());
                          }
                          return { state: O, storeId: D };
                        });
                        var L = function (z) {
                          var C = (0, h.default)(),
                            N,
                            U;
                          try {
                            U = T(z);
                          } catch (G) {
                            N = G;
                          } finally {
                            var W = (0, h.default)() - C;
                            g.addEvent('lr.redux.ReduxAction', function () {
                              var G = null,
                                ne = null;
                              try {
                                ((G = _(M.getState())), (ne = S(z)));
                              } catch (ve) {
                                console.error(ve.toString());
                              }
                              return G && ne
                                ? {
                                    storeId: D,
                                    action: ne,
                                    duration: W,
                                    stateDelta: G,
                                  }
                                : null;
                            });
                          }
                          if (N) throw N;
                          return U;
                        };
                        return f(f({}, M), {}, { dispatch: L });
                      };
                    };
                  }
                },
                './packages/@logrocket/redux/src/createMiddleware.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.default = d));
                    var u = c(l('./packages/@logrocket/now/src/index.js')),
                      h = 0;
                    function d(f) {
                      var p =
                          arguments.length > 1 && arguments[1] !== void 0
                            ? arguments[1]
                            : {},
                        m = p.stateSanitizer,
                        g =
                          m === void 0
                            ? function (_) {
                                return _;
                              }
                            : m,
                        v = p.actionSanitizer,
                        y =
                          v === void 0
                            ? function (_) {
                                return _;
                              }
                            : v;
                      return function (_) {
                        var x = h++;
                        return (
                          f.addEvent('lr.redux.InitialState', function () {
                            var S;
                            try {
                              S = g(_.getState());
                            } catch (b) {
                              console.error(b.toString());
                            }
                            return { state: S, storeId: x };
                          }),
                          function (S) {
                            return function (b) {
                              var A = (0, u.default)(),
                                E,
                                w;
                              try {
                                w = S(b);
                              } catch (T) {
                                E = T;
                              } finally {
                                var M = (0, u.default)() - A;
                                f.addEvent('lr.redux.ReduxAction', function () {
                                  var T = null,
                                    D = null;
                                  try {
                                    ((T = g(_.getState())), (D = y(b)));
                                  } catch (L) {
                                    console.error(L.toString());
                                  }
                                  return T && D
                                    ? {
                                        storeId: x,
                                        action: D,
                                        duration: M,
                                        stateDelta: T,
                                      }
                                    : null;
                                });
                              }
                              if (E) throw E;
                              return w;
                            };
                          }
                        );
                      };
                    }
                  },
                './packages/@logrocket/redux/src/index.js': function (a, o, l) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    Object.defineProperty(o, 'createEnhancer', {
                      enumerable: !0,
                      get: function () {
                        return u.default;
                      },
                    }),
                    Object.defineProperty(o, 'createMiddleware', {
                      enumerable: !0,
                      get: function () {
                        return h.default;
                      },
                    }));
                  var u = c(
                      l('./packages/@logrocket/redux/src/createEnhancer.js')
                    ),
                    h = c(
                      l('./packages/@logrocket/redux/src/createMiddleware.js')
                    );
                },
                './packages/@logrocket/utils/src/TraceKit.js': function (
                  a,
                  o,
                  l
                ) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = void 0));
                  var c = { collectWindowErrors: !0, debug: !1 },
                    u =
                      typeof window < 'u'
                        ? window
                        : typeof l.g < 'u'
                          ? l.g
                          : typeof self < 'u'
                            ? self
                            : {},
                    h = [].slice,
                    d = '?',
                    f =
                      /^(?:Uncaught (?:exception: )?)?((?:Eval|Internal|Range|Reference|Syntax|Type|URI)Error): ?(.*)$/;
                  function p() {
                    return typeof document > 'u' ||
                      typeof document.location > 'u'
                      ? ''
                      : document.location.href;
                  }
                  ((c.report = (function () {
                    var v = [],
                      y = null,
                      _ = null,
                      x = null;
                    function S(C) {
                      (D(), v.push(C));
                    }
                    function b(C) {
                      for (var N = v.length - 1; N >= 0; --N)
                        v[N] === C && v.splice(N, 1);
                    }
                    function A() {
                      (L(), (v = []));
                    }
                    function E(C, N) {
                      var U = null;
                      if (!(N && !c.collectWindowErrors)) {
                        for (var W in v)
                          if (v.hasOwnProperty(W))
                            try {
                              v[W].apply(
                                null,
                                [C].concat(h.call(arguments, 2))
                              );
                            } catch (G) {
                              U = G;
                            }
                        if (U) throw U;
                      }
                    }
                    var w, M;
                    function T(C, N, U, W, G) {
                      var ne = null;
                      if (x)
                        (c.computeStackTrace.augmentStackTraceWithInitialElement(
                          x,
                          N,
                          U,
                          C
                        ),
                          O());
                      else if (G) ((ne = c.computeStackTrace(G)), E(ne, !0));
                      else {
                        var ve = { url: N, line: U, column: W },
                          Se = void 0,
                          Ae = C,
                          Oe;
                        if ({}.toString.call(C) === '[object String]') {
                          var Oe = C.match(f);
                          Oe && ((Se = Oe[1]), (Ae = Oe[2]));
                        }
                        ((ve.func = d),
                          (ne = {
                            name: Se,
                            message: Ae,
                            url: p(),
                            stack: [ve],
                          }),
                          E(ne, !0));
                      }
                      return w ? w.apply(this, arguments) : !1;
                    }
                    function D() {
                      M || ((w = u.onerror), (u.onerror = T), (M = !0));
                    }
                    function L() {
                      M && ((u.onerror = w), (M = !1), (w = void 0));
                    }
                    function O() {
                      var C = x,
                        N = y;
                      ((y = null),
                        (x = null),
                        (_ = null),
                        E.apply(null, [C, !1].concat(N)));
                    }
                    function z(C, N) {
                      var U = h.call(arguments, 1);
                      if (x) {
                        if (_ === C) return;
                        O();
                      }
                      var W = c.computeStackTrace(C);
                      if (
                        ((x = W),
                        (_ = C),
                        (y = U),
                        setTimeout(
                          function () {
                            _ === C && O();
                          },
                          W.incomplete ? 2e3 : 0
                        ),
                        N !== !1)
                      )
                        throw C;
                    }
                    return (
                      (z.subscribe = S),
                      (z.unsubscribe = b),
                      (z.uninstall = A),
                      z
                    );
                  })()),
                    (c.computeStackTrace = (function () {
                      function v(S) {
                        if (!(typeof S.stack > 'u' || !S.stack)) {
                          var b =
                              /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
                            A =
                              /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|resource|\[native).*?)(?::(\d+))?(?::(\d+))?\s*$/i,
                            E =
                              /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
                            w = S.stack.split(`
`),
                            M = [],
                            T,
                            D;
                          /^(.*) is undefined$/.exec(S.message);
                          for (var L = 0, O = w.length; L < O; ++L) {
                            if ((T = b.exec(w[L]))) {
                              var z = T[2] && T[2].indexOf('native') !== -1;
                              D = {
                                url: z ? null : T[2],
                                func: T[1] || d,
                                args: z ? [T[2]] : [],
                                line: T[3] ? +T[3] : null,
                                column: T[4] ? +T[4] : null,
                              };
                            } else if ((T = E.exec(w[L])))
                              D = {
                                url: T[2],
                                func: T[1] || d,
                                args: [],
                                line: +T[3],
                                column: T[4] ? +T[4] : null,
                              };
                            else if ((T = A.exec(w[L])))
                              D = {
                                url: T[3],
                                func: T[1] || d,
                                args: T[2] ? T[2].split(',') : [],
                                line: T[4] ? +T[4] : null,
                                column: T[5] ? +T[5] : null,
                              };
                            else continue;
                            (!D.func && D.line && (D.func = d), M.push(D));
                          }
                          return M.length
                            ? (!M[0].column &&
                                typeof S.columnNumber < 'u' &&
                                (M[0].column = S.columnNumber + 1),
                              {
                                name: S.name,
                                message: S.message,
                                url: p(),
                                stack: M,
                              })
                            : null;
                        }
                      }
                      function y(S, b, A, E) {
                        var w = { url: b, line: A };
                        if (w.url && w.line) {
                          if (
                            ((S.incomplete = !1),
                            w.func || (w.func = d),
                            S.stack.length > 0 && S.stack[0].url === w.url)
                          ) {
                            if (S.stack[0].line === w.line) return !1;
                            if (!S.stack[0].line && S.stack[0].func === w.func)
                              return ((S.stack[0].line = w.line), !1);
                          }
                          return (S.stack.unshift(w), (S.partial = !0), !0);
                        } else S.incomplete = !0;
                        return !1;
                      }
                      function _(S, b) {
                        for (
                          var A =
                              /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
                            E = [],
                            w = {},
                            M = !1,
                            T,
                            D,
                            L = _.caller;
                          L && !M;
                          L = L.caller
                        )
                          if (!(L === x || L === c.report)) {
                            if (
                              ((D = {
                                url: null,
                                func: d,
                                line: null,
                                column: null,
                              }),
                              L.name
                                ? (D.func = L.name)
                                : (T = A.exec(L.toString())) && (D.func = T[1]),
                              typeof D.func > 'u')
                            )
                              try {
                                D.func = T.input.substring(
                                  0,
                                  T.input.indexOf('{')
                                );
                              } catch {}
                            (w['' + L] ? (M = !0) : (w['' + L] = !0),
                              E.push(D));
                          }
                        b && E.splice(0, b);
                        var O = {
                          name: S.name,
                          message: S.message,
                          url: p(),
                          stack: E,
                        };
                        return (
                          y(
                            O,
                            S.sourceURL || S.fileName,
                            S.line || S.lineNumber,
                            S.message || S.description
                          ),
                          O
                        );
                      }
                      function x(S, b) {
                        var A = null;
                        b = b == null ? 0 : +b;
                        try {
                          if (((A = v(S)), A)) return A;
                        } catch (E) {
                          if (c.debug) throw E;
                        }
                        try {
                          if (((A = _(S, b + 1)), A)) return A;
                        } catch (E) {
                          if (c.debug) throw E;
                        }
                        return { name: S.name, message: S.message, url: p() };
                      }
                      return (
                        (x.augmentStackTraceWithInitialElement = y),
                        (x.computeStackTraceFromStackProp = v),
                        x
                      );
                    })()));
                  var m = c;
                  o.default = m;
                },
                './packages/@logrocket/utils/src/constants/nps.js': function (
                  a,
                  o
                ) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.DELIGHTED_FEEDBACK_PREFIX =
                      o.DELIGHTED_RESPONSES_REGEX =
                      o.WOOTRIC_RESPONSES_REGEX =
                        void 0));
                  var l = /^https:\/\/production.wootric.com\/responses/;
                  o.WOOTRIC_RESPONSES_REGEX = l;
                  var c = /^https:\/\/web.delighted.com\/e\/[a-zA-Z-]*\/c/;
                  o.DELIGHTED_RESPONSES_REGEX = c;
                  var u = 'comment=';
                  o.DELIGHTED_FEEDBACK_PREFIX = u;
                },
                './packages/@logrocket/utils/src/constants/statusCodes.ts':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.getStatusText = m),
                      (o.XHR_CUSTOM_FAILURE_STATUSES =
                        o.XHR_CUSTOM_STATUS_CODES =
                        o.STATUS_CODES =
                          void 0));
                    var u = c(
                        l(
                          './node_modules/@babel/runtime/helpers/defineProperty.js'
                        )
                      ),
                      h,
                      d = {
                        0: '',
                        100: 'Continue',
                        101: 'Switching Protocol',
                        102: 'Processing',
                        103: 'Early Hints',
                        200: 'OK',
                        201: 'Created',
                        202: 'Accepted',
                        203: 'Non-Authoritative Information',
                        204: 'No Content',
                        205: 'Reset Content',
                        206: 'Partial Content',
                        207: 'Multi-Status',
                        208: 'Already Reported',
                        226: 'IM Used',
                        300: 'Multiple Choices',
                        301: 'Moved Permanently',
                        302: 'Found',
                        303: 'See Other',
                        304: 'Not Modified',
                        305: 'Use Proxy',
                        306: 'unused',
                        307: 'Temporary Redirect',
                        308: 'Permanent Redirect',
                        400: 'Bad Request',
                        401: 'Unauthorized',
                        402: 'Payment Required',
                        403: 'Forbidden',
                        404: 'Not Found',
                        405: 'Method Not Allowed',
                        406: 'Not Acceptable',
                        407: 'Proxy Authentication Required',
                        408: 'Request Timeout',
                        409: 'Conflict',
                        410: 'Gone',
                        411: 'Length Required',
                        412: 'Precondition Failed',
                        413: 'Payload Too Large',
                        414: 'URI Too Long',
                        415: 'Unsupported Media Type',
                        416: 'Range Not Satisfiable',
                        417: 'Expectation Failed',
                        418: "I'm a teapot",
                        421: 'Misdirected Request',
                        422: 'Unprocessable Entity',
                        423: 'Locked',
                        424: 'Failed Dependency',
                        425: 'Too Early',
                        426: 'Upgrade Required',
                        428: 'Precondition Required',
                        429: 'Too Many Requests',
                        431: 'Request Header Fields Too Large',
                        451: 'Unavailable For Legal Reasons',
                        500: 'Internal Server Error',
                        501: 'Not Implemented',
                        502: 'Bad Gateway',
                        503: 'Service Unavailable',
                        504: 'Gateway Timeout',
                        505: 'HTTP Version Not Supported',
                        506: 'Variant Also Negotiates',
                        507: 'Insufficient Storage',
                        508: 'Loop Detected',
                        510: 'Not Extended',
                        511: 'Network Authentication Required',
                      };
                    o.STATUS_CODES = d;
                    var f = {
                      error: 0,
                      timeout: 444,
                      aborted: 499,
                      offline: 1001,
                    };
                    o.XHR_CUSTOM_STATUS_CODES = f;
                    var p =
                      ((h = {}),
                      (0, u.default)(h, f.error, 'Error'),
                      (0, u.default)(h, f.timeout, 'Timeout'),
                      (0, u.default)(h, f.aborted, 'Aborted'),
                      (0, u.default)(h, f.offline, 'Offline'),
                      h);
                    o.XHR_CUSTOM_FAILURE_STATUSES = p;
                    function m(g) {
                      return d[String(g)];
                    }
                  },
                './packages/@logrocket/utils/src/createUnsubListener.ts':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.createUnsubListener = f),
                      (o.Handler = void 0));
                    var u = c(
                        l(
                          './node_modules/@babel/runtime/helpers/classCallCheck.js'
                        )
                      ),
                      h = c(
                        l(
                          './node_modules/@babel/runtime/helpers/createClass.js'
                        )
                      ),
                      d = (function () {
                        function p(m) {
                          ((0, u.default)(this, p),
                            (this._value = void 0),
                            (this._value = m));
                        }
                        return (
                          (0, h.default)(p, [
                            {
                              key: 'get',
                              value: function () {
                                return this._value;
                              },
                            },
                            {
                              key: 'clear',
                              value: function () {
                                this._value = void 0;
                              },
                            },
                          ]),
                          p
                        );
                      })();
                    o.Handler = d;
                    function f(p) {
                      return function () {
                        p.clear();
                      };
                    }
                  },
                './packages/@logrocket/utils/src/enhanceFunc.ts': function (
                  a,
                  o,
                  l
                ) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = h));
                  var c = l(
                      './packages/@logrocket/utils/src/createUnsubListener.ts'
                    ),
                    u = function () {};
                  function h(d, f, p) {
                    if (typeof d[f] != 'function') return u;
                    try {
                      var m = function () {
                          for (
                            var _,
                              x = arguments.length,
                              S = new Array(x),
                              b = 0;
                            b < x;
                            b++
                          )
                            S[b] = arguments[b];
                          var A = g.apply(this, S);
                          return (
                            (_ = v.get()) === null ||
                              _ === void 0 ||
                              _.apply(this, S),
                            A
                          );
                        },
                        g = d[f],
                        v = new c.Handler(p);
                      return (
                        (d[f] = m),
                        function () {
                          (v.clear(), d[f] === m && (d[f] = g));
                        }
                      );
                    } catch {
                      return u;
                    }
                  }
                },
                './packages/@logrocket/utils/src/logError.js': function (a, o) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = void 0));
                  var l =
                      typeof console < 'u' &&
                      console.error &&
                      console.error.bind,
                    c = l ? console.error.bind(console) : function () {},
                    u = c;
                  o.default = u;
                },
                './packages/@logrocket/utils/src/mapValues.ts': function (
                  a,
                  o
                ) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = l));
                  function l(c, u) {
                    if (c == null) return {};
                    var h = {};
                    return (
                      Object.keys(c).forEach(function (d) {
                        h[d] = u(c[d]);
                      }),
                      h
                    );
                  }
                },
                './packages/@logrocket/utils/src/protectFunc.ts': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = d));
                  var u = c(
                      l('./packages/@logrocket/utils/src/sendTelemetryData.js')
                    ),
                    h = c(l('./packages/@logrocket/utils/src/logError.js'));
                  function d(f) {
                    var p =
                      arguments.length > 1 && arguments[1] !== void 0
                        ? arguments[1]
                        : function () {};
                    return function () {
                      var m;
                      try {
                        m = f.apply(void 0, arguments);
                      } catch (v) {
                        if (typeof window < 'u' && window._lrdebug) throw v;
                        var g = p(v);
                        ((0, h.default)('LogRocket', v), (0, u.default)(v, g));
                      }
                      return m;
                    };
                  }
                },
                './packages/@logrocket/utils/src/scrubException.ts': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.scrubException = v));
                  var u = c(
                    l('./node_modules/@babel/runtime/helpers/typeof.js')
                  );
                  function h(y, _) {
                    var x =
                      (typeof Symbol < 'u' && y[Symbol.iterator]) ||
                      y['@@iterator'];
                    if (!x) {
                      if (Array.isArray(y) || (x = d(y)) || _) {
                        x && (y = x);
                        var S = 0,
                          b = function () {};
                        return {
                          s: b,
                          n: function () {
                            return S >= y.length
                              ? { done: !0 }
                              : { done: !1, value: y[S++] };
                          },
                          e: function (T) {
                            throw T;
                          },
                          f: b,
                        };
                      }
                      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                    }
                    var A = !0,
                      E = !1,
                      w;
                    return {
                      s: function () {
                        x = x.call(y);
                      },
                      n: function () {
                        var T = x.next();
                        return ((A = T.done), T);
                      },
                      e: function (T) {
                        ((E = !0), (w = T));
                      },
                      f: function () {
                        try {
                          !A && x.return != null && x.return();
                        } finally {
                          if (E) throw w;
                        }
                      },
                    };
                  }
                  function d(y, _) {
                    if (y) {
                      if (typeof y == 'string') return f(y, _);
                      var x = Object.prototype.toString.call(y).slice(8, -1);
                      if (
                        (x === 'Object' &&
                          y.constructor &&
                          (x = y.constructor.name),
                        x === 'Map' || x === 'Set')
                      )
                        return Array.from(y);
                      if (
                        x === 'Arguments' ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x)
                      )
                        return f(y, _);
                    }
                  }
                  function f(y, _) {
                    (_ == null || _ > y.length) && (_ = y.length);
                    for (var x = 0, S = new Array(_); x < _; x++) S[x] = y[x];
                    return S;
                  }
                  function p(y) {
                    return /boolean|number|string/.test((0, u.default)(y));
                  }
                  var m = ['level', 'logger'],
                    g = ['tags', 'extra'];
                  function v(y, _) {
                    if (_) {
                      var x = h(m),
                        S;
                      try {
                        for (x.s(); !(S = x.n()).done; ) {
                          var b = S.value,
                            A = _[b];
                          p(A) && (y[b] = A.toString());
                        }
                      } catch (N) {
                        x.e(N);
                      } finally {
                        x.f();
                      }
                      var E = h(g),
                        w;
                      try {
                        for (E.s(); !(w = E.n()).done; ) {
                          for (
                            var M = w.value,
                              T = _[M] || {},
                              D = {},
                              L = 0,
                              O = Object.keys(T);
                            L < O.length;
                            L++
                          ) {
                            var z = O[L],
                              C = T[z];
                            p(C) && (D[z.toString()] = C.toString());
                          }
                          y[M] = D;
                        }
                      } catch (N) {
                        E.e(N);
                      } finally {
                        E.f();
                      }
                    }
                  }
                },
                './packages/@logrocket/utils/src/sendTelemetryData.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                    );
                    (Object.defineProperty(o, '__esModule', { value: !0 }),
                      (o.sendTelemetry = v),
                      (o.default = y));
                    var u = c(
                        l(
                          './node_modules/@babel/runtime/helpers/defineProperty.js'
                        )
                      ),
                      h = c(l('./packages/@logrocket/utils/src/logError.js')),
                      d = c(l('./packages/@logrocket/utils/src/TraceKit.js'));
                    function f(_, x) {
                      var S = Object.keys(_);
                      if (Object.getOwnPropertySymbols) {
                        var b = Object.getOwnPropertySymbols(_);
                        (x &&
                          (b = b.filter(function (A) {
                            return Object.getOwnPropertyDescriptor(_, A)
                              .enumerable;
                          })),
                          S.push.apply(S, b));
                      }
                      return S;
                    }
                    function p(_) {
                      for (var x = 1; x < arguments.length; x++) {
                        var S = arguments[x] != null ? arguments[x] : {};
                        x % 2
                          ? f(Object(S), !0).forEach(function (b) {
                              (0, u.default)(_, b, S[b]);
                            })
                          : Object.getOwnPropertyDescriptors
                            ? Object.defineProperties(
                                _,
                                Object.getOwnPropertyDescriptors(S)
                              )
                            : f(Object(S)).forEach(function (b) {
                                Object.defineProperty(
                                  _,
                                  b,
                                  Object.getOwnPropertyDescriptor(S, b)
                                );
                              });
                      }
                      return _;
                    }
                    var m = '8304d923ee86bbba88df4d491ccbc1c75ecfbe70';
                    function g(_) {
                      try {
                        var x,
                          S,
                          b = _.message,
                          A =
                            'https://e.logrocket.com/api/3/store/?sentry_version=7&sentry_client=http%2F3.8.0&sentry_key=b64162b4187a4c5caae8a68a7e291793',
                          E = JSON.stringify(
                            p(
                              {
                                message: b,
                                logger: 'javascript',
                                platform: 'javascript',
                                request: {
                                  headers: {
                                    'User-Agent':
                                      typeof navigator < 'u' &&
                                      navigator.userAgent,
                                  },
                                  url: typeof location < 'u' && location.href,
                                },
                                release: m,
                                environment:
                                  ((x = window) === null ||
                                  x === void 0 ||
                                  (S = x.__SDKCONFIG__) === null ||
                                  S === void 0
                                    ? void 0
                                    : S.scriptEnv) || 'prod',
                              },
                              _
                            )
                          );
                        if (typeof window < 'u') {
                          var w = window._lrXMLHttpRequest || XMLHttpRequest,
                            M = new w();
                          (M.open('POST', A), M.send(E));
                        } else
                          typeof fetch < 'u' &&
                            fetch(A, { method: 'POST', body: E }).catch(
                              function (T) {
                                (0, h.default)('Failed to send via fetch', T);
                              }
                            );
                      } catch (T) {
                        (0, h.default)('Failed to send', T);
                      }
                    }
                    function v(_, x) {
                      if (typeof window < 'u' && window._lrdebug)
                        return void (0, h.default)(_);
                      (x &&
                        x.extra &&
                        x.extra.appID &&
                        typeof x.extra.appID.indexOf == 'function' &&
                        x.extra.appID.indexOf('au2drp/') === 0 &&
                        Math.random() >= 0.25) ||
                        g(p({ message: _ }, x));
                    }
                    function y(_, x) {
                      try {
                        var S = _.message,
                          b;
                        try {
                          b = JSON.stringify(x).slice(0, 1e3);
                        } catch {
                          try {
                            b = 'Could not stringify payload: '.concat(
                              Object.prototype.toString.call(x)
                            );
                          } catch {}
                        }
                        var A;
                        try {
                          A = d.default
                            .computeStackTrace(_)
                            .stack.map(function (E) {
                              return {
                                filename: E.url,
                                lineno: E.line,
                                colno: E.column,
                                function: E.func || '?',
                              };
                            });
                        } catch {}
                        g({
                          message: S,
                          extra: { stringPayload: b },
                          exception: {
                            values: [
                              {
                                type: _.type,
                                value: S,
                                stacktrace: { frames: A },
                              },
                            ],
                          },
                        });
                      } catch (E) {
                        (0, h.default)('Failed to send', E);
                      }
                    }
                  },
                './packages/@logrocket/utils/src/startsWith.js': function (
                  a,
                  o
                ) {
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = l));
                  function l(c, u) {
                    var h =
                      arguments.length > 2 && arguments[2] !== void 0
                        ? arguments[2]
                        : 0;
                    return c && u && c.substring(h, h + u.length) === u;
                  }
                },
                './packages/logrocket/src/LogRocket.js': function (a, o, l) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = o.MAX_QUEUE_SIZE = void 0));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/classCallCheck.js'
                      )
                    ),
                    h = c(
                      l('./node_modules/@babel/runtime/helpers/createClass.js')
                    ),
                    d = c(
                      l(
                        './node_modules/@babel/runtime/helpers/defineProperty.js'
                      )
                    ),
                    f = c(
                      l(
                        './node_modules/@babel/runtime/helpers/objectWithoutProperties.js'
                      )
                    ),
                    p = c(l('./packages/@logrocket/network/src/index.js')),
                    m = l('./packages/@logrocket/exceptions/src/index.js'),
                    g = c(l('./packages/@logrocket/console/src/index.js')),
                    v = l('./packages/@logrocket/redux/src/index.js');
                  function y(A, E) {
                    var w = Object.keys(A);
                    if (Object.getOwnPropertySymbols) {
                      var M = Object.getOwnPropertySymbols(A);
                      (E &&
                        (M = M.filter(function (T) {
                          return Object.getOwnPropertyDescriptor(A, T)
                            .enumerable;
                        })),
                        w.push.apply(w, M));
                    }
                    return w;
                  }
                  function _(A) {
                    for (var E = 1; E < arguments.length; E++) {
                      var w = arguments[E] != null ? arguments[E] : {};
                      E % 2
                        ? y(Object(w), !0).forEach(function (M) {
                            (0, d.default)(A, M, w[M]);
                          })
                        : Object.getOwnPropertyDescriptors
                          ? Object.defineProperties(
                              A,
                              Object.getOwnPropertyDescriptors(w)
                            )
                          : y(Object(w)).forEach(function (M) {
                              Object.defineProperty(
                                A,
                                M,
                                Object.getOwnPropertyDescriptor(w, M)
                              );
                            });
                    }
                    return A;
                  }
                  var x = 1e3;
                  o.MAX_QUEUE_SIZE = x;
                  var S = function () {
                      var E =
                          arguments.length > 0 && arguments[0] !== void 0
                            ? arguments[0]
                            : {},
                        w = E.ingestServer,
                        M = (0, f.default)(E, ['ingestServer']);
                      return w
                        ? _(
                            {
                              serverURL: ''.concat(w, '/i'),
                              statsURL: ''.concat(w, '/s'),
                            },
                            M
                          )
                        : M;
                    },
                    b = (function () {
                      function A() {
                        var E = this;
                        ((0, u.default)(this, A),
                          (this._buffer = []),
                          ['log', 'info', 'warn', 'error', 'debug'].forEach(
                            function (w) {
                              E[w] = function () {
                                for (
                                  var M = arguments.length,
                                    T = new Array(M),
                                    D = 0;
                                  D < M;
                                  D++
                                )
                                  T[D] = arguments[D];
                                E.addEvent(
                                  'lr.core.LogEvent',
                                  function () {
                                    var L =
                                      arguments.length > 0 &&
                                      arguments[0] !== void 0
                                        ? arguments[0]
                                        : {};
                                    return (
                                      w === 'error' &&
                                        L.shouldAggregateConsoleErrors &&
                                        m.Capture.captureMessage(
                                          E,
                                          T[0],
                                          T,
                                          {},
                                          !0
                                        ),
                                      { logLevel: w.toUpperCase(), args: T }
                                    );
                                  },
                                  { shouldCaptureStackTrace: !0 }
                                );
                              };
                            }
                          ),
                          (this._isInitialized = !1),
                          (this._installed = []),
                          (window._lr_surl_cb = this.getSessionURL.bind(this)));
                      }
                      return (
                        (0, h.default)(A, [
                          {
                            key: 'addEvent',
                            value: function (w, M) {
                              var T =
                                  arguments.length > 2 &&
                                  arguments[2] !== void 0
                                    ? arguments[2]
                                    : {},
                                D = Date.now();
                              this._run(function (L) {
                                L.addEvent(
                                  w,
                                  M,
                                  _(_({}, T), {}, { timeOverride: D })
                                );
                              });
                            },
                          },
                          {
                            key: 'onLogger',
                            value: function (w) {
                              for (
                                this._logger = w;
                                this._buffer.length > 0;

                              ) {
                                var M = this._buffer.shift();
                                M(this._logger);
                              }
                            },
                          },
                          {
                            key: '_run',
                            value: function (w) {
                              if (!this._isDisabled)
                                if (this._logger) w(this._logger);
                                else {
                                  if (this._buffer.length >= x) {
                                    ((this._isDisabled = !0),
                                      console.warn(
                                        'LogRocket: script did not load. Check that you have a valid network connection.'
                                      ),
                                      this.uninstall());
                                    return;
                                  }
                                  this._buffer.push(w.bind(this));
                                }
                            },
                          },
                          {
                            key: 'init',
                            value: function (w) {
                              var M =
                                arguments.length > 1 && arguments[1] !== void 0
                                  ? arguments[1]
                                  : {};
                              if (!this._isInitialized) {
                                var T,
                                  D = M.shouldAugmentNPS,
                                  L = D === void 0 ? !0 : D,
                                  O = M.shouldParseXHRBlob,
                                  z = O === void 0 ? !1 : O,
                                  C = M.shouldDetectExceptions,
                                  N = C === void 0 ? !0 : C;
                                (N &&
                                  this._installed.push(
                                    (0, m.registerExceptions)(this)
                                  ),
                                  this._installed.push(
                                    (0, p.default)(this, {
                                      shouldAugmentNPS: !!L,
                                      shouldParseXHRBlob: !!z,
                                      isDisabled:
                                        (M == null ||
                                        (T = M.network) === null ||
                                        T === void 0
                                          ? void 0
                                          : T.isEnabled) === !1,
                                    })
                                  ),
                                  this._installed.push((0, g.default)(this)),
                                  (this._isInitialized = !0),
                                  this._run(function (U) {
                                    U.init(w, S(M));
                                  }));
                              }
                            },
                          },
                          {
                            key: 'start',
                            value: function () {
                              this._run(function (w) {
                                w.start();
                              });
                            },
                          },
                          {
                            key: 'uninstall',
                            value: function () {
                              (this._installed.forEach(function (w) {
                                return w();
                              }),
                                (this._buffer = []),
                                this._run(function (w) {
                                  w.uninstall();
                                }));
                            },
                          },
                          {
                            key: 'identify',
                            value: function (w, M) {
                              this._run(function (T) {
                                T.identify(w, M);
                              });
                            },
                          },
                          {
                            key: 'startNewSession',
                            value: function () {
                              this._run(function (w) {
                                w.startNewSession();
                              });
                            },
                          },
                          {
                            key: 'track',
                            value: function (w, M) {
                              this._run(function (T) {
                                T.track(w, M);
                              });
                            },
                          },
                          {
                            key: 'getSessionURL',
                            value: function (w) {
                              if (typeof w != 'function')
                                throw new Error(
                                  'LogRocket: must pass callback to getSessionURL()'
                                );
                              this._run(function (M) {
                                M.getSessionURL
                                  ? M.getSessionURL(w)
                                  : w(M.recordingURL);
                              });
                            },
                          },
                          {
                            key: 'trackScrollEvent',
                            value: function (w) {
                              this._logger && this._logger.trackScrollEvent(w);
                            },
                          },
                          {
                            key: 'getVersion',
                            value: function (w) {
                              this._run(function (M) {
                                w(M.version);
                              });
                            },
                          },
                          {
                            key: 'captureMessage',
                            value: function (w) {
                              var M =
                                arguments.length > 1 && arguments[1] !== void 0
                                  ? arguments[1]
                                  : {};
                              m.Capture.captureMessage(this, w, [w], M);
                            },
                          },
                          {
                            key: 'captureException',
                            value: function (w) {
                              var M =
                                arguments.length > 1 && arguments[1] !== void 0
                                  ? arguments[1]
                                  : {};
                              m.Capture.captureException(this, w, M);
                            },
                          },
                          {
                            key: 'version',
                            get: function () {
                              return this._logger && this._logger.version;
                            },
                          },
                          {
                            key: 'sessionURL',
                            get: function () {
                              return this._logger && this._logger.recordingURL;
                            },
                          },
                          {
                            key: 'recordingURL',
                            get: function () {
                              return this._logger && this._logger.recordingURL;
                            },
                          },
                          {
                            key: 'recordingID',
                            get: function () {
                              return this._logger && this._logger.recordingID;
                            },
                          },
                          {
                            key: 'threadID',
                            get: function () {
                              return this._logger && this._logger.threadID;
                            },
                          },
                          {
                            key: 'tabID',
                            get: function () {
                              return this._logger && this._logger.tabID;
                            },
                          },
                          {
                            key: 'reduxEnhancer',
                            value: function () {
                              var w =
                                arguments.length > 0 && arguments[0] !== void 0
                                  ? arguments[0]
                                  : {};
                              return (0, v.createEnhancer)(this, w);
                            },
                          },
                          {
                            key: 'reduxMiddleware',
                            value: function () {
                              var w =
                                arguments.length > 0 && arguments[0] !== void 0
                                  ? arguments[0]
                                  : {};
                              return (0, v.createMiddleware)(this, w);
                            },
                          },
                          {
                            key: 'isDisabled',
                            get: function () {
                              return !!(
                                this._isDisabled ||
                                (this._logger && this._logger._isDisabled)
                              );
                            },
                          },
                        ]),
                        A
                      );
                    })();
                  o.default = b;
                },
                './packages/logrocket/src/makeLogRocket.js': function (
                  a,
                  o,
                  l
                ) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.default = f));
                  var u = c(l('./packages/logrocket/src/LogRocket.js')),
                    h =
                      'LogRocket on React Native requires the LogRocket React Native specific SDK. See setup guide here https://docs.logrocket.com/reference/react-native.',
                    d = function () {
                      return {
                        init: function () {},
                        uninstall: function () {},
                        log: function () {},
                        info: function () {},
                        warn: function () {},
                        error: function () {},
                        debug: function () {},
                        addEvent: function () {},
                        identify: function () {},
                        start: function () {},
                        get threadID() {
                          return null;
                        },
                        get recordingID() {
                          return null;
                        },
                        get recordingURL() {
                          return null;
                        },
                        reduxEnhancer: function () {
                          return function (g) {
                            return function () {
                              return g.apply(void 0, arguments);
                            };
                          };
                        },
                        reduxMiddleware: function () {
                          return function () {
                            return function (g) {
                              return function (v) {
                                return g(v);
                              };
                            };
                          };
                        },
                        track: function () {},
                        getSessionURL: function () {},
                        getVersion: function () {},
                        startNewSession: function () {},
                        onLogger: function () {},
                        setClock: function () {},
                        captureMessage: function () {},
                        captureException: function () {},
                      };
                    };
                  function f() {
                    var p =
                        arguments.length > 0 && arguments[0] !== void 0
                          ? arguments[0]
                          : function () {},
                      m =
                        arguments.length > 1 && arguments[1] !== void 0
                          ? arguments[1]
                          : d,
                      g =
                        arguments.length > 2 && arguments[2] !== void 0
                          ? arguments[2]
                          : function () {
                              return new u.default();
                            };
                    if (
                      typeof navigator < 'u' &&
                      navigator.product === 'ReactNative'
                    )
                      throw new Error(h);
                    if (typeof window < 'u') {
                      if (window._disableLogRocket) return m();
                      if (window.MutationObserver && window.WeakMap) {
                        window._lrMutationObserver = window.MutationObserver;
                        var v = g();
                        return (p(v), v);
                      }
                    }
                    return d();
                  }
                },
                './packages/logrocket/src/setup.js': function (a, o, l) {
                  var c = l(
                    './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                  );
                  (Object.defineProperty(o, '__esModule', { value: !0 }),
                    (o.getDomainsAndEnv = p),
                    (o.setupBaseSDKCONFIG = m),
                    (o.default = g));
                  var u = c(
                      l(
                        './node_modules/@babel/runtime/helpers/objectWithoutProperties.js'
                      )
                    ),
                    h = c(l('./packages/logrocket/src/makeLogRocket.js')),
                    d = {
                      'cdn.logrocket.com': 'https://r.logrocket.io',
                      'cdn.logrocket.io': 'https://r.logrocket.io',
                      'cdn.lr-ingest.io': 'https://r.lr-ingest.io',
                      'cdn.lr-in.com': 'https://r.lr-in.com',
                      'cdn.lr-in-prod.com': 'https://r.lr-in-prod.com',
                      'cdn.lr-ingest.com': 'https://r.lr-ingest.com',
                      'cdn.ingest-lr.com': 'https://r.ingest-lr.com',
                      'cdn.lr-intake.com': 'https://r.lr-intake.com',
                      'cdn.intake-lr.com': 'https://r.intake-lr.com',
                      'cdn.logr-ingest.com': 'https://r.logr-ingest.com',
                      'cdn.lrkt-in.com': 'https://r.lrkt-in.com',
                      'cdn.lgrckt-in.com': 'https://r.lgrckt-in.com',
                      'cdn-staging.logrocket.io':
                        'https://staging-i.logrocket.io',
                      'cdn-staging.lr-ingest.io':
                        'https://staging-i.lr-ingest.io',
                      'cdn-staging.lr-in.com': 'https://staging-i.lr-in.com',
                      'cdn-staging.lr-in-prod.com':
                        'https://staging-i.lr-in-prod.com',
                      'cdn-staging.lr-ingest.com':
                        'https://staging-i.lr-ingest.com',
                      'cdn-staging.ingest-lr.com':
                        'https://staging-i.ingest-lr.com',
                      'cdn-staging.lr-intake.com':
                        'https://staging-i.lr-intake.com',
                      'cdn-staging.intake-lr.com':
                        'https://staging-i.intake-lr.com',
                      'cdn-staging.logr-ingest.com':
                        'https://staging-i.logr-ingest.com',
                      'cdn-staging.lrkt-in.com':
                        'https://staging-i.lrkt-in.com',
                      'cdn-staging.lgrckt-in.com':
                        'https://staging-i.lgrckt-in.com',
                    };
                  function f(v) {
                    return v.startsWith('cdn-staging')
                      ? 'staging'
                      : v.startsWith('localhost')
                        ? 'development'
                        : 'prod';
                  }
                  function p(v) {
                    if (v === 'script' || v === 'shopify-pixel') {
                      try {
                        var y = document.currentScript,
                          _ = y.src.match(/^(https?:\/\/([^\\]+))\/.+$/),
                          x = _ && _[2];
                        if (x && d[x])
                          return {
                            scriptEnv: f(x),
                            scriptOrigin: _ && _[1],
                            scriptIngest: d[x],
                          };
                      } catch {}
                      return {
                        scriptEnv: 'prod',
                        scriptOrigin: 'https://cdn.logrocket.io',
                      };
                    } else
                      return {
                        scriptEnv: void 0,
                        scriptOrigin: 'https://cdn.lgrckt-in.com',
                        scriptIngest: 'https://r.lgrckt-in.com',
                      };
                  }
                  function m(v) {
                    (typeof window.__SDKCONFIG__ > 'u' &&
                      (window.__SDKCONFIG__ = {}),
                      (window.__SDKCONFIG__.serverURL = ''.concat(v, '/i')),
                      (window.__SDKCONFIG__.statsURL = ''.concat(v, '/s')));
                  }
                  function g() {
                    var v =
                        arguments.length > 0 && arguments[0] !== void 0
                          ? arguments[0]
                          : {},
                      y = v.enterpriseServer,
                      _ = v.sdkVersion,
                      x = _ === void 0 ? '10.1.0' : _,
                      S = (0, u.default)(v, ['enterpriseServer', 'sdkVersion']),
                      b = p(x),
                      A = b.scriptEnv,
                      E = b.scriptOrigin,
                      w = b.scriptIngest,
                      M = S.sdkServer || y,
                      T = S.ingestServer || y || w,
                      D = (0, h.default)(function () {
                        var L = document.createElement('script');
                        (T && (m(T), (window.__SDKCONFIG__.scriptEnv = A)),
                          M
                            ? (L.src = ''.concat(M, '/logger.min.js'))
                            : window.__SDKCONFIG__ &&
                                window.__SDKCONFIG__.loggerURL
                              ? (L.src = window.__SDKCONFIG__.loggerURL)
                              : window._lrAsyncScript
                                ? (L.src = window._lrAsyncScript)
                                : (L.src = ''.concat(E, '/logger-1.min.js')),
                          (L.async = !0),
                          document.head.appendChild(L),
                          (L.onload = function () {
                            typeof window._LRLogger == 'function'
                              ? setTimeout(function () {
                                  D.onLogger(
                                    new window._LRLogger({ sdkVersion: x })
                                  );
                                })
                              : (console.warn(
                                  'LogRocket: script execution has been blocked by a product or service.'
                                ),
                                D.uninstall());
                          }),
                          (L.onerror = function () {
                            (console.warn(
                              'LogRocket: script could not load. Check that you have a valid network connection.'
                            ),
                              D.uninstall());
                          }));
                      });
                    return D;
                  }
                },
                './node_modules/@babel/runtime/helpers/arrayLikeToArray.js':
                  function (a) {
                    function o(l, c) {
                      (c == null || c > l.length) && (c = l.length);
                      for (var u = 0, h = new Array(c); u < c; u++) h[u] = l[u];
                      return h;
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/arrayWithoutHoles.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/arrayLikeToArray.js'
                    );
                    function u(h) {
                      if (Array.isArray(h)) return c(h);
                    }
                    ((a.exports = u),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/classCallCheck.js':
                  function (a) {
                    function o(l, c) {
                      if (!(l instanceof c))
                        throw new TypeError(
                          'Cannot call a class as a function'
                        );
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/createClass.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/toPropertyKey.js'
                    );
                    function u(d, f) {
                      for (var p = 0; p < f.length; p++) {
                        var m = f[p];
                        ((m.enumerable = m.enumerable || !1),
                          (m.configurable = !0),
                          'value' in m && (m.writable = !0),
                          Object.defineProperty(d, c(m.key), m));
                      }
                    }
                    function h(d, f, p) {
                      return (
                        f && u(d.prototype, f),
                        p && u(d, p),
                        Object.defineProperty(d, 'prototype', { writable: !1 }),
                        d
                      );
                    }
                    ((a.exports = h),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/defineProperty.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/toPropertyKey.js'
                    );
                    function u(h, d, f) {
                      return (
                        (d = c(d)),
                        d in h
                          ? Object.defineProperty(h, d, {
                              value: f,
                              enumerable: !0,
                              configurable: !0,
                              writable: !0,
                            })
                          : (h[d] = f),
                        h
                      );
                    }
                    ((a.exports = u),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/interopRequireDefault.js':
                  function (a) {
                    function o(l) {
                      return l && l.__esModule ? l : { default: l };
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/iterableToArray.js':
                  function (a) {
                    function o(l) {
                      if (
                        (typeof Symbol < 'u' && l[Symbol.iterator] != null) ||
                        l['@@iterator'] != null
                      )
                        return Array.from(l);
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/nonIterableSpread.js':
                  function (a) {
                    function o() {
                      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/objectWithoutProperties.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js'
                    );
                    function u(h, d) {
                      if (h == null) return {};
                      var f = c(h, d),
                        p,
                        m;
                      if (Object.getOwnPropertySymbols) {
                        var g = Object.getOwnPropertySymbols(h);
                        for (m = 0; m < g.length; m++)
                          ((p = g[m]),
                            !(d.indexOf(p) >= 0) &&
                              Object.prototype.propertyIsEnumerable.call(
                                h,
                                p
                              ) &&
                              (f[p] = h[p]));
                      }
                      return f;
                    }
                    ((a.exports = u),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js':
                  function (a) {
                    function o(l, c) {
                      if (l == null) return {};
                      var u = {},
                        h = Object.keys(l),
                        d,
                        f;
                      for (f = 0; f < h.length; f++)
                        ((d = h[f]), !(c.indexOf(d) >= 0) && (u[d] = l[d]));
                      return u;
                    }
                    ((a.exports = o),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/toConsumableArray.js':
                  function (a, o, l) {
                    var c = l(
                        './node_modules/@babel/runtime/helpers/arrayWithoutHoles.js'
                      ),
                      u = l(
                        './node_modules/@babel/runtime/helpers/iterableToArray.js'
                      ),
                      h = l(
                        './node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js'
                      ),
                      d = l(
                        './node_modules/@babel/runtime/helpers/nonIterableSpread.js'
                      );
                    function f(p) {
                      return c(p) || u(p) || h(p) || d();
                    }
                    ((a.exports = f),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/toPrimitive.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/typeof.js'
                    ).default;
                    function u(h, d) {
                      if (c(h) !== 'object' || h === null) return h;
                      var f = h[Symbol.toPrimitive];
                      if (f !== void 0) {
                        var p = f.call(h, d || 'default');
                        if (c(p) !== 'object') return p;
                        throw new TypeError(
                          '@@toPrimitive must return a primitive value.'
                        );
                      }
                      return (d === 'string' ? String : Number)(h);
                    }
                    ((a.exports = u),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/toPropertyKey.js':
                  function (a, o, l) {
                    var c = l(
                        './node_modules/@babel/runtime/helpers/typeof.js'
                      ).default,
                      u = l(
                        './node_modules/@babel/runtime/helpers/toPrimitive.js'
                      );
                    function h(d) {
                      var f = u(d, 'string');
                      return c(f) === 'symbol' ? f : String(f);
                    }
                    ((a.exports = h),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
                './node_modules/@babel/runtime/helpers/typeof.js': function (
                  a
                ) {
                  function o(l) {
                    '@babel/helpers - typeof';
                    return (
                      (a.exports = o =
                        typeof Symbol == 'function' &&
                        typeof Symbol.iterator == 'symbol'
                          ? function (c) {
                              return typeof c;
                            }
                          : function (c) {
                              return c &&
                                typeof Symbol == 'function' &&
                                c.constructor === Symbol &&
                                c !== Symbol.prototype
                                ? 'symbol'
                                : typeof c;
                            }),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports),
                      o(l)
                    );
                  }
                  ((a.exports = o),
                    (a.exports.__esModule = !0),
                    (a.exports.default = a.exports));
                },
                './node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js':
                  function (a, o, l) {
                    var c = l(
                      './node_modules/@babel/runtime/helpers/arrayLikeToArray.js'
                    );
                    function u(h, d) {
                      if (h) {
                        if (typeof h == 'string') return c(h, d);
                        var f = Object.prototype.toString.call(h).slice(8, -1);
                        if (
                          (f === 'Object' &&
                            h.constructor &&
                            (f = h.constructor.name),
                          f === 'Map' || f === 'Set')
                        )
                          return Array.from(h);
                        if (
                          f === 'Arguments' ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(f)
                        )
                          return c(h, d);
                      }
                    }
                    ((a.exports = u),
                      (a.exports.__esModule = !0),
                      (a.exports.default = a.exports));
                  },
              },
              i = {};
            function r(a) {
              var o = i[a];
              if (o !== void 0) return o.exports;
              var l = (i[a] = { exports: {} });
              return (t[a](l, l.exports, r), l.exports);
            }
            (function () {
              r.g = (function () {
                if (typeof globalThis == 'object') return globalThis;
                try {
                  return this || new Function('return this')();
                } catch {
                  if (typeof window == 'object') return window;
                }
              })();
            })();
            var s = {};
            return (
              (function () {
                var a = s;
                var o = r(
                  './node_modules/@babel/runtime/helpers/interopRequireDefault.js'
                );
                (Object.defineProperty(a, '__esModule', { value: !0 }),
                  (a.default = void 0));
                var l = o(r('./packages/logrocket/src/setup.js')),
                  c = (0, l.default)(),
                  u = c;
                a.default = u;
              })(),
              (s = s.default),
              s
            );
          })();
        });
      })(Df)),
    Df.exports
  );
}
var WW = GW();
const cne = cy(WW);
var jW = 1e-6,
  pi = typeof Float32Array < 'u' ? Float32Array : Array;
function XW() {
  var n = new pi(9);
  return (
    pi != Float32Array &&
      ((n[1] = 0), (n[2] = 0), (n[3] = 0), (n[5] = 0), (n[6] = 0), (n[7] = 0)),
    (n[0] = 1),
    (n[4] = 1),
    (n[8] = 1),
    n
  );
}
function une() {
  var n = new pi(16);
  return (
    pi != Float32Array &&
      ((n[1] = 0),
      (n[2] = 0),
      (n[3] = 0),
      (n[4] = 0),
      (n[6] = 0),
      (n[7] = 0),
      (n[8] = 0),
      (n[9] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0)),
    (n[0] = 1),
    (n[5] = 1),
    (n[10] = 1),
    (n[15] = 1),
    n
  );
}
function hne(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[3]),
    (n[4] = e[4]),
    (n[5] = e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    (n[9] = e[9]),
    (n[10] = e[10]),
    (n[11] = e[11]),
    (n[12] = e[12]),
    (n[13] = e[13]),
    (n[14] = e[14]),
    (n[15] = e[15]),
    n
  );
}
function dne(n, e) {
  var t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    u = e[8],
    h = e[9],
    d = e[10],
    f = e[11],
    p = e[12],
    m = e[13],
    g = e[14],
    v = e[15],
    y = t * o - i * a,
    _ = t * l - r * a,
    x = t * c - s * a,
    S = i * l - r * o,
    b = i * c - s * o,
    A = r * c - s * l,
    E = u * m - h * p,
    w = u * g - d * p,
    M = u * v - f * p,
    T = h * g - d * m,
    D = h * v - f * m,
    L = d * v - f * g,
    O = y * L - _ * D + x * T + S * M - b * w + A * E;
  return O
    ? ((O = 1 / O),
      (n[0] = (o * L - l * D + c * T) * O),
      (n[1] = (r * D - i * L - s * T) * O),
      (n[2] = (m * A - g * b + v * S) * O),
      (n[3] = (d * b - h * A - f * S) * O),
      (n[4] = (l * M - a * L - c * w) * O),
      (n[5] = (t * L - r * M + s * w) * O),
      (n[6] = (g * x - p * A - v * _) * O),
      (n[7] = (u * A - d * x + f * _) * O),
      (n[8] = (a * D - o * M + c * E) * O),
      (n[9] = (i * M - t * D - s * E) * O),
      (n[10] = (p * b - m * x + v * y) * O),
      (n[11] = (h * x - u * b - f * y) * O),
      (n[12] = (o * w - a * T - l * E) * O),
      (n[13] = (t * T - i * w + r * E) * O),
      (n[14] = (m * _ - p * S - g * y) * O),
      (n[15] = (u * S - h * _ + d * y) * O),
      n)
    : null;
}
function fne(n, e, t) {
  var i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    u = e[7],
    h = e[8],
    d = e[9],
    f = e[10],
    p = e[11],
    m = e[12],
    g = e[13],
    v = e[14],
    y = e[15],
    _ = t[0],
    x = t[1],
    S = t[2],
    b = t[3];
  return (
    (n[0] = _ * i + x * o + S * h + b * m),
    (n[1] = _ * r + x * l + S * d + b * g),
    (n[2] = _ * s + x * c + S * f + b * v),
    (n[3] = _ * a + x * u + S * p + b * y),
    (_ = t[4]),
    (x = t[5]),
    (S = t[6]),
    (b = t[7]),
    (n[4] = _ * i + x * o + S * h + b * m),
    (n[5] = _ * r + x * l + S * d + b * g),
    (n[6] = _ * s + x * c + S * f + b * v),
    (n[7] = _ * a + x * u + S * p + b * y),
    (_ = t[8]),
    (x = t[9]),
    (S = t[10]),
    (b = t[11]),
    (n[8] = _ * i + x * o + S * h + b * m),
    (n[9] = _ * r + x * l + S * d + b * g),
    (n[10] = _ * s + x * c + S * f + b * v),
    (n[11] = _ * a + x * u + S * p + b * y),
    (_ = t[12]),
    (x = t[13]),
    (S = t[14]),
    (b = t[15]),
    (n[12] = _ * i + x * o + S * h + b * m),
    (n[13] = _ * r + x * l + S * d + b * g),
    (n[14] = _ * s + x * c + S * f + b * v),
    (n[15] = _ * a + x * u + S * p + b * y),
    n
  );
}
function pne(n, e) {
  return (
    (n[0] = 1),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = 1),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = 1),
    (n[11] = 0),
    (n[12] = e[0]),
    (n[13] = e[1]),
    (n[14] = e[2]),
    (n[15] = 1),
    n
  );
}
function mne(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = e[1]),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = e[2]),
    (n[11] = 0),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 0),
    (n[15] = 1),
    n
  );
}
function qW(n, e, t, i, r) {
  var s = 1 / Math.tan(e / 2);
  if (
    ((n[0] = s / t),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = s),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[11] = -1),
    (n[12] = 0),
    (n[13] = 0),
    (n[15] = 0),
    r != null && r !== 1 / 0)
  ) {
    var a = 1 / (i - r);
    ((n[10] = (r + i) * a), (n[14] = 2 * r * i * a));
  } else ((n[10] = -1), (n[14] = -2 * i));
  return n;
}
var gne = qW;
function vne(n, e, t, i) {
  var r = e[0],
    s = e[1],
    a = e[2],
    o = i[0],
    l = i[1],
    c = i[2],
    u = r - t[0],
    h = s - t[1],
    d = a - t[2],
    f = u * u + h * h + d * d;
  f > 0 && ((f = 1 / Math.sqrt(f)), (u *= f), (h *= f), (d *= f));
  var p = l * d - c * h,
    m = c * u - o * d,
    g = o * h - l * u;
  return (
    (f = p * p + m * m + g * g),
    f > 0 && ((f = 1 / Math.sqrt(f)), (p *= f), (m *= f), (g *= f)),
    (n[0] = p),
    (n[1] = m),
    (n[2] = g),
    (n[3] = 0),
    (n[4] = h * g - d * m),
    (n[5] = d * p - u * g),
    (n[6] = u * m - h * p),
    (n[7] = 0),
    (n[8] = u),
    (n[9] = h),
    (n[10] = d),
    (n[11] = 0),
    (n[12] = r),
    (n[13] = s),
    (n[14] = a),
    (n[15] = 1),
    n
  );
}
function nD() {
  var n = new pi(3);
  return (pi != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)), n);
}
function YW(n) {
  var e = n[0],
    t = n[1],
    i = n[2];
  return Math.sqrt(e * e + t * t + i * i);
}
function VA(n, e, t) {
  var i = new pi(3);
  return ((i[0] = n), (i[1] = e), (i[2] = t), i);
}
function _ne(n, e, t) {
  return ((n[0] = e[0] * t), (n[1] = e[1] * t), (n[2] = e[2] * t), n);
}
function yne(n, e) {
  var t = e[0] - n[0],
    i = e[1] - n[1],
    r = e[2] - n[2];
  return t * t + i * i + r * r;
}
function xne(n, e) {
  return ((n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), n);
}
function KW(n, e) {
  var t = e[0],
    i = e[1],
    r = e[2],
    s = t * t + i * i + r * r;
  return (
    s > 0 && (s = 1 / Math.sqrt(s)),
    (n[0] = e[0] * s),
    (n[1] = e[1] * s),
    (n[2] = e[2] * s),
    n
  );
}
function JW(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function f0(n, e, t) {
  var i = e[0],
    r = e[1],
    s = e[2],
    a = t[0],
    o = t[1],
    l = t[2];
  return (
    (n[0] = r * l - s * o),
    (n[1] = s * a - i * l),
    (n[2] = i * o - r * a),
    n
  );
}
function bne(n, e, t) {
  var i = t[0],
    r = t[1],
    s = t[2],
    a = t[3],
    o = e[0],
    l = e[1],
    c = e[2],
    u = r * c - s * l,
    h = s * o - i * c,
    d = i * l - r * o;
  return (
    (u = u + u),
    (h = h + h),
    (d = d + d),
    (n[0] = o + a * u + r * d - s * h),
    (n[1] = l + a * h + s * u - i * d),
    (n[2] = c + a * d + i * h - r * u),
    n
  );
}
var QW = YW;
(function () {
  var n = nD();
  return function (e, t, i, r, s, a) {
    var o, l;
    for (
      t || (t = 3),
        i || (i = 0),
        r ? (l = Math.min(r * t + i, e.length)) : (l = e.length),
        o = i;
      o < l;
      o += t
    )
      ((n[0] = e[o]),
        (n[1] = e[o + 1]),
        (n[2] = e[o + 2]),
        s(n, n, a),
        (e[o] = n[0]),
        (e[o + 1] = n[1]),
        (e[o + 2] = n[2]));
    return e;
  };
})();
function ZW() {
  var n = new pi(4);
  return (
    pi != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 0)),
    n
  );
}
function $W(n, e) {
  var t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = t * t + i * i + r * r + s * s;
  return (
    a > 0 && (a = 1 / Math.sqrt(a)),
    (n[0] = t * a),
    (n[1] = i * a),
    (n[2] = r * a),
    (n[3] = s * a),
    n
  );
}
(function () {
  var n = ZW();
  return function (e, t, i, r, s, a) {
    var o, l;
    for (
      t || (t = 4),
        i || (i = 0),
        r ? (l = Math.min(r * t + i, e.length)) : (l = e.length),
        o = i;
      o < l;
      o += t
    )
      ((n[0] = e[o]),
        (n[1] = e[o + 1]),
        (n[2] = e[o + 2]),
        (n[3] = e[o + 3]),
        s(n, n, a),
        (e[o] = n[0]),
        (e[o + 1] = n[1]),
        (e[o + 2] = n[2]),
        (e[o + 3] = n[3]));
    return e;
  };
})();
function HA() {
  var n = new pi(4);
  return (
    pi != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
    (n[3] = 1),
    n
  );
}
function e6(n, e, t) {
  t = t * 0.5;
  var i = Math.sin(t);
  return (
    (n[0] = i * e[0]),
    (n[1] = i * e[1]),
    (n[2] = i * e[2]),
    (n[3] = Math.cos(t)),
    n
  );
}
function Sne(n, e, t) {
  var i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = t[0],
    l = t[1],
    c = t[2],
    u = t[3];
  return (
    (n[0] = i * u + a * o + r * c - s * l),
    (n[1] = r * u + a * l + s * o - i * c),
    (n[2] = s * u + a * c + i * l - r * o),
    (n[3] = a * u - i * o - r * l - s * c),
    n
  );
}
function p0(n, e, t, i) {
  var r = e[0],
    s = e[1],
    a = e[2],
    o = e[3],
    l = t[0],
    c = t[1],
    u = t[2],
    h = t[3],
    d,
    f,
    p,
    m,
    g;
  return (
    (f = r * l + s * c + a * u + o * h),
    f < 0 && ((f = -f), (l = -l), (c = -c), (u = -u), (h = -h)),
    1 - f > jW
      ? ((d = Math.acos(f)),
        (p = Math.sin(d)),
        (m = Math.sin((1 - i) * d) / p),
        (g = Math.sin(i * d) / p))
      : ((m = 1 - i), (g = i)),
    (n[0] = m * r + g * l),
    (n[1] = m * s + g * c),
    (n[2] = m * a + g * u),
    (n[3] = m * o + g * h),
    n
  );
}
function wne(n, e) {
  return ((n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), (n[3] = e[3]), n);
}
function t6(n, e) {
  var t = e[0] + e[4] + e[8],
    i;
  if (t > 0)
    ((i = Math.sqrt(t + 1)),
      (n[3] = 0.5 * i),
      (i = 0.5 / i),
      (n[0] = (e[5] - e[7]) * i),
      (n[1] = (e[6] - e[2]) * i),
      (n[2] = (e[1] - e[3]) * i));
  else {
    var r = 0;
    (e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2));
    var s = (r + 1) % 3,
      a = (r + 2) % 3;
    ((i = Math.sqrt(e[r * 3 + r] - e[s * 3 + s] - e[a * 3 + a] + 1)),
      (n[r] = 0.5 * i),
      (i = 0.5 / i),
      (n[3] = (e[s * 3 + a] - e[a * 3 + s]) * i),
      (n[s] = (e[s * 3 + r] + e[r * 3 + s]) * i),
      (n[a] = (e[a * 3 + r] + e[r * 3 + a]) * i));
  }
  return n;
}
var iD = $W;
(function () {
  var n = nD(),
    e = VA(1, 0, 0),
    t = VA(0, 1, 0);
  return function (i, r, s) {
    var a = JW(r, s);
    return a < -0.999999
      ? (f0(n, e, r),
        QW(n) < 1e-6 && f0(n, t, r),
        KW(n, n),
        e6(i, n, Math.PI),
        i)
      : a > 0.999999
        ? ((i[0] = 0), (i[1] = 0), (i[2] = 0), (i[3] = 1), i)
        : (f0(n, r, s),
          (i[0] = n[0]),
          (i[1] = n[1]),
          (i[2] = n[2]),
          (i[3] = 1 + a),
          iD(i, i));
  };
})();
(function () {
  var n = HA(),
    e = HA();
  return function (t, i, r, s, a, o) {
    return (p0(n, i, a, o), p0(e, r, s, o), p0(t, n, e, 2 * o * (1 - o)), t);
  };
})();
(function () {
  var n = XW();
  return function (e, t, i, r) {
    return (
      (n[0] = i[0]),
      (n[3] = i[1]),
      (n[6] = i[2]),
      (n[1] = r[0]),
      (n[4] = r[1]),
      (n[7] = r[2]),
      (n[2] = -t[0]),
      (n[5] = -t[1]),
      (n[8] = -t[2]),
      iD(e, t6(e, n))
    );
  };
})();
function n6() {
  var n = new pi(2);
  return (pi != Float32Array && ((n[0] = 0), (n[1] = 0)), n);
}
function Ene(n) {
  var e = new pi(2);
  return ((e[0] = n[0]), (e[1] = n[1]), e);
}
function Ane(n, e) {
  var t = new pi(2);
  return ((t[0] = n), (t[1] = e), t);
}
function Mne(n, e) {
  return ((n[0] = e[0]), (n[1] = e[1]), n);
}
function Tne(n, e, t) {
  return ((n[0] = e), (n[1] = t), n);
}
function Cne(n, e, t) {
  return ((n[0] = e[0] + t[0]), (n[1] = e[1] + t[1]), n);
}
function i6(n, e, t) {
  return ((n[0] = e[0] - t[0]), (n[1] = e[1] - t[1]), n);
}
function Rne(n, e, t) {
  return ((n[0] = e[0] * t), (n[1] = e[1] * t), n);
}
function r6(n) {
  var e = n[0],
    t = n[1];
  return e * e + t * t;
}
var Ine = i6,
  Pne = r6;
(function () {
  var n = n6();
  return function (e, t, i, r, s, a) {
    var o, l;
    for (
      t || (t = 2),
        i || (i = 0),
        r ? (l = Math.min(r * t + i, e.length)) : (l = e.length),
        o = i;
      o < l;
      o += t
    )
      ((n[0] = e[o]),
        (n[1] = e[o + 1]),
        s(n, n, a),
        (e[o] = n[0]),
        (e[o + 1] = n[1]));
    return e;
  };
})();
function rD(n, e) {
  return function () {
    return n.apply(e, arguments);
  };
}
const { toString: s6 } = Object.prototype,
  { getPrototypeOf: Nx } = Object,
  { iterator: vm, toStringTag: sD } = Symbol,
  _m = ((n) => (e) => {
    const t = s6.call(e);
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  Tr = (n) => ((n = n.toLowerCase()), (e) => _m(e) === n),
  ym = (n) => (e) => typeof e === n,
  { isArray: Ec } = Array,
  ec = ym('undefined');
function Dh(n) {
  return (
    n !== null &&
    !ec(n) &&
    n.constructor !== null &&
    !ec(n.constructor) &&
    Ci(n.constructor.isBuffer) &&
    n.constructor.isBuffer(n)
  );
}
const aD = Tr('ArrayBuffer');
function a6(n) {
  let e;
  return (
    typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(n))
      : (e = n && n.buffer && aD(n.buffer)),
    e
  );
}
const o6 = ym('string'),
  Ci = ym('function'),
  oD = ym('number'),
  Oh = (n) => n !== null && typeof n == 'object',
  l6 = (n) => n === !0 || n === !1,
  Of = (n) => {
    if (_m(n) !== 'object') return !1;
    const e = Nx(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(sD in n) &&
      !(vm in n)
    );
  },
  c6 = (n) => {
    if (!Oh(n) || Dh(n)) return !1;
    try {
      return (
        Object.keys(n).length === 0 &&
        Object.getPrototypeOf(n) === Object.prototype
      );
    } catch {
      return !1;
    }
  },
  u6 = Tr('Date'),
  h6 = Tr('File'),
  d6 = Tr('Blob'),
  f6 = Tr('FileList'),
  p6 = (n) => Oh(n) && Ci(n.pipe),
  m6 = (n) => {
    let e;
    return (
      n &&
      ((typeof FormData == 'function' && n instanceof FormData) ||
        (Ci(n.append) &&
          ((e = _m(n)) === 'formdata' ||
            (e === 'object' &&
              Ci(n.toString) &&
              n.toString() === '[object FormData]'))))
    );
  },
  g6 = Tr('URLSearchParams'),
  [v6, _6, y6, x6] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(
    Tr
  ),
  b6 = (n) =>
    n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
function Lh(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > 'u') return;
  let i, r;
  if ((typeof n != 'object' && (n = [n]), Ec(n)))
    for (i = 0, r = n.length; i < r; i++) e.call(null, n[i], i, n);
  else {
    if (Dh(n)) return;
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
      a = s.length;
    let o;
    for (i = 0; i < a; i++) ((o = s[i]), e.call(null, n[o], o, n));
  }
}
function lD(n, e) {
  if (Dh(n)) return null;
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length,
    r;
  for (; i-- > 0; ) if (((r = t[i]), e === r.toLowerCase())) return r;
  return null;
}
const uo =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : global,
  cD = (n) => !ec(n) && n !== uo;
function B_() {
  const { caseless: n, skipUndefined: e } = (cD(this) && this) || {},
    t = {},
    i = (r, s) => {
      const a = (n && lD(t, s)) || s;
      Of(t[a]) && Of(r)
        ? (t[a] = B_(t[a], r))
        : Of(r)
          ? (t[a] = B_({}, r))
          : Ec(r)
            ? (t[a] = r.slice())
            : (!e || !ec(r)) && (t[a] = r);
    };
  for (let r = 0, s = arguments.length; r < s; r++)
    arguments[r] && Lh(arguments[r], i);
  return t;
}
const S6 = (n, e, t, { allOwnKeys: i } = {}) => (
    Lh(
      e,
      (r, s) => {
        t && Ci(r) ? (n[s] = rD(r, t)) : (n[s] = r);
      },
      { allOwnKeys: i }
    ),
    n
  ),
  w6 = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
  E6 = (n, e, t, i) => {
    ((n.prototype = Object.create(e.prototype, i)),
      (n.prototype.constructor = n),
      Object.defineProperty(n, 'super', { value: e.prototype }),
      t && Object.assign(n.prototype, t));
  },
  A6 = (n, e, t, i) => {
    let r, s, a;
    const o = {};
    if (((e = e || {}), n == null)) return e;
    do {
      for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
        ((a = r[s]),
          (!i || i(a, n, e)) && !o[a] && ((e[a] = n[a]), (o[a] = !0)));
      n = t !== !1 && Nx(n);
    } while (n && (!t || t(n, e)) && n !== Object.prototype);
    return e;
  },
  M6 = (n, e, t) => {
    ((n = String(n)),
      (t === void 0 || t > n.length) && (t = n.length),
      (t -= e.length));
    const i = n.indexOf(e, t);
    return i !== -1 && i === t;
  },
  T6 = (n) => {
    if (!n) return null;
    if (Ec(n)) return n;
    let e = n.length;
    if (!oD(e)) return null;
    const t = new Array(e);
    for (; e-- > 0; ) t[e] = n[e];
    return t;
  },
  C6 = (
    (n) => (e) =>
      n && e instanceof n
  )(typeof Uint8Array < 'u' && Nx(Uint8Array)),
  R6 = (n, e) => {
    const i = (n && n[vm]).call(n);
    let r;
    for (; (r = i.next()) && !r.done; ) {
      const s = r.value;
      e.call(n, s[0], s[1]);
    }
  },
  I6 = (n, e) => {
    let t;
    const i = [];
    for (; (t = n.exec(e)) !== null; ) i.push(t);
    return i;
  },
  P6 = Tr('HTMLFormElement'),
  D6 = (n) =>
    n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, i, r) {
      return i.toUpperCase() + r;
    }),
  GA = (
    ({ hasOwnProperty: n }) =>
    (e, t) =>
      n.call(e, t)
  )(Object.prototype),
  O6 = Tr('RegExp'),
  uD = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n),
      i = {};
    (Lh(t, (r, s) => {
      let a;
      (a = e(r, s, n)) !== !1 && (i[s] = a || r);
    }),
      Object.defineProperties(n, i));
  },
  L6 = (n) => {
    uD(n, (e, t) => {
      if (Ci(n) && ['arguments', 'caller', 'callee'].indexOf(t) !== -1)
        return !1;
      const i = n[t];
      if (Ci(i)) {
        if (((e.enumerable = !1), 'writable' in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'");
          });
      }
    });
  },
  U6 = (n, e) => {
    const t = {},
      i = (r) => {
        r.forEach((s) => {
          t[s] = !0;
        });
      };
    return (Ec(n) ? i(n) : i(String(n).split(e)), t);
  },
  k6 = () => {},
  B6 = (n, e) => (n != null && Number.isFinite((n = +n)) ? n : e);
function N6(n) {
  return !!(n && Ci(n.append) && n[sD] === 'FormData' && n[vm]);
}
const F6 = (n) => {
    const e = new Array(10),
      t = (i, r) => {
        if (Oh(i)) {
          if (e.indexOf(i) >= 0) return;
          if (Dh(i)) return i;
          if (!('toJSON' in i)) {
            e[r] = i;
            const s = Ec(i) ? [] : {};
            return (
              Lh(i, (a, o) => {
                const l = t(a, r + 1);
                !ec(l) && (s[o] = l);
              }),
              (e[r] = void 0),
              s
            );
          }
        }
        return i;
      };
    return t(n, 0);
  },
  z6 = Tr('AsyncFunction'),
  V6 = (n) => n && (Oh(n) || Ci(n)) && Ci(n.then) && Ci(n.catch),
  hD = ((n, e) =>
    n
      ? setImmediate
      : e
        ? ((t, i) => (
            uo.addEventListener(
              'message',
              ({ source: r, data: s }) => {
                r === uo && s === t && i.length && i.shift()();
              },
              !1
            ),
            (r) => {
              (i.push(r), uo.postMessage(t, '*'));
            }
          ))(`axios@${Math.random()}`, [])
        : (t) => setTimeout(t))(
    typeof setImmediate == 'function',
    Ci(uo.postMessage)
  ),
  H6 =
    typeof queueMicrotask < 'u'
      ? queueMicrotask.bind(uo)
      : (typeof process < 'u' && process.nextTick) || hD,
  G6 = (n) => n != null && Ci(n[vm]),
  ie = {
    isArray: Ec,
    isArrayBuffer: aD,
    isBuffer: Dh,
    isFormData: m6,
    isArrayBufferView: a6,
    isString: o6,
    isNumber: oD,
    isBoolean: l6,
    isObject: Oh,
    isPlainObject: Of,
    isEmptyObject: c6,
    isReadableStream: v6,
    isRequest: _6,
    isResponse: y6,
    isHeaders: x6,
    isUndefined: ec,
    isDate: u6,
    isFile: h6,
    isBlob: d6,
    isRegExp: O6,
    isFunction: Ci,
    isStream: p6,
    isURLSearchParams: g6,
    isTypedArray: C6,
    isFileList: f6,
    forEach: Lh,
    merge: B_,
    extend: S6,
    trim: b6,
    stripBOM: w6,
    inherits: E6,
    toFlatObject: A6,
    kindOf: _m,
    kindOfTest: Tr,
    endsWith: M6,
    toArray: T6,
    forEachEntry: R6,
    matchAll: I6,
    isHTMLForm: P6,
    hasOwnProperty: GA,
    hasOwnProp: GA,
    reduceDescriptors: uD,
    freezeMethods: L6,
    toObjectSet: U6,
    toCamelCase: D6,
    noop: k6,
    toFiniteNumber: B6,
    findKey: lD,
    global: uo,
    isContextDefined: cD,
    isSpecCompliantForm: N6,
    toJSONObject: F6,
    isAsyncFn: z6,
    isThenable: V6,
    setImmediate: hD,
    asap: H6,
    isIterable: G6,
  };
function St(n, e, t, i, r) {
  (Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = n),
    (this.name = 'AxiosError'),
    e && (this.code = e),
    t && (this.config = t),
    i && (this.request = i),
    r && ((this.response = r), (this.status = r.status ? r.status : null)));
}
ie.inherits(St, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: ie.toJSONObject(this.config),
      code: this.code,
      status: this.status,
    };
  },
});
const dD = St.prototype,
  fD = {};
[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL',
].forEach((n) => {
  fD[n] = { value: n };
});
Object.defineProperties(St, fD);
Object.defineProperty(dD, 'isAxiosError', { value: !0 });
St.from = (n, e, t, i, r, s) => {
  const a = Object.create(dD);
  ie.toFlatObject(
    n,
    a,
    function (u) {
      return u !== Error.prototype;
    },
    (c) => c !== 'isAxiosError'
  );
  const o = n && n.message ? n.message : 'Error',
    l = e == null && n ? n.code : e;
  return (
    St.call(a, o, l, t, i, r),
    n &&
      a.cause == null &&
      Object.defineProperty(a, 'cause', { value: n, configurable: !0 }),
    (a.name = (n && n.name) || 'Error'),
    s && Object.assign(a, s),
    a
  );
};
const W6 = null;
function N_(n) {
  return ie.isPlainObject(n) || ie.isArray(n);
}
function pD(n) {
  return ie.endsWith(n, '[]') ? n.slice(0, -2) : n;
}
function WA(n, e, t) {
  return n
    ? n
        .concat(e)
        .map(function (r, s) {
          return ((r = pD(r)), !t && s ? '[' + r + ']' : r);
        })
        .join(t ? '.' : '')
    : e;
}
function j6(n) {
  return ie.isArray(n) && !n.some(N_);
}
const X6 = ie.toFlatObject(ie, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function xm(n, e, t) {
  if (!ie.isObject(n)) throw new TypeError('target must be an object');
  ((e = e || new FormData()),
    (t = ie.toFlatObject(
      t,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (m, g) {
        return !ie.isUndefined(g[m]);
      }
    )));
  const i = t.metaTokens,
    r = t.visitor || u,
    s = t.dots,
    a = t.indexes,
    l = (t.Blob || (typeof Blob < 'u' && Blob)) && ie.isSpecCompliantForm(e);
  if (!ie.isFunction(r)) throw new TypeError('visitor must be a function');
  function c(p) {
    if (p === null) return '';
    if (ie.isDate(p)) return p.toISOString();
    if (ie.isBoolean(p)) return p.toString();
    if (!l && ie.isBlob(p))
      throw new St('Blob is not supported. Use a Buffer instead.');
    return ie.isArrayBuffer(p) || ie.isTypedArray(p)
      ? l && typeof Blob == 'function'
        ? new Blob([p])
        : Buffer.from(p)
      : p;
  }
  function u(p, m, g) {
    let v = p;
    if (p && !g && typeof p == 'object') {
      if (ie.endsWith(m, '{}'))
        ((m = i ? m : m.slice(0, -2)), (p = JSON.stringify(p)));
      else if (
        (ie.isArray(p) && j6(p)) ||
        ((ie.isFileList(p) || ie.endsWith(m, '[]')) && (v = ie.toArray(p)))
      )
        return (
          (m = pD(m)),
          v.forEach(function (_, x) {
            !(ie.isUndefined(_) || _ === null) &&
              e.append(
                a === !0 ? WA([m], x, s) : a === null ? m : m + '[]',
                c(_)
              );
          }),
          !1
        );
    }
    return N_(p) ? !0 : (e.append(WA(g, m, s), c(p)), !1);
  }
  const h = [],
    d = Object.assign(X6, {
      defaultVisitor: u,
      convertValue: c,
      isVisitable: N_,
    });
  function f(p, m) {
    if (!ie.isUndefined(p)) {
      if (h.indexOf(p) !== -1)
        throw Error('Circular reference detected in ' + m.join('.'));
      (h.push(p),
        ie.forEach(p, function (v, y) {
          (!(ie.isUndefined(v) || v === null) &&
            r.call(e, v, ie.isString(y) ? y.trim() : y, m, d)) === !0 &&
            f(v, m ? m.concat(y) : [y]);
        }),
        h.pop());
    }
  }
  if (!ie.isObject(n)) throw new TypeError('data must be an object');
  return (f(n), e);
}
function jA(n) {
  const e = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\0',
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (i) {
    return e[i];
  });
}
function Fx(n, e) {
  ((this._pairs = []), n && xm(n, this, e));
}
const mD = Fx.prototype;
mD.append = function (e, t) {
  this._pairs.push([e, t]);
};
mD.toString = function (e) {
  const t = e
    ? function (i) {
        return e.call(this, i, jA);
      }
    : jA;
  return this._pairs
    .map(function (r) {
      return t(r[0]) + '=' + t(r[1]);
    }, '')
    .join('&');
};
function q6(n) {
  return encodeURIComponent(n)
    .replace(/%3A/gi, ':')
    .replace(/%24/g, '$')
    .replace(/%2C/gi, ',')
    .replace(/%20/g, '+');
}
function gD(n, e, t) {
  if (!e) return n;
  const i = (t && t.encode) || q6;
  ie.isFunction(t) && (t = { serialize: t });
  const r = t && t.serialize;
  let s;
  if (
    (r
      ? (s = r(e, t))
      : (s = ie.isURLSearchParams(e) ? e.toString() : new Fx(e, t).toString(i)),
    s)
  ) {
    const a = n.indexOf('#');
    (a !== -1 && (n = n.slice(0, a)),
      (n += (n.indexOf('?') === -1 ? '?' : '&') + s));
  }
  return n;
}
class XA {
  constructor() {
    this.handlers = [];
  }
  use(e, t, i) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: i ? i.synchronous : !1,
        runWhen: i ? i.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    ie.forEach(this.handlers, function (i) {
      i !== null && e(i);
    });
  }
}
const vD = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  Y6 = typeof URLSearchParams < 'u' ? URLSearchParams : Fx,
  K6 = typeof FormData < 'u' ? FormData : null,
  J6 = typeof Blob < 'u' ? Blob : null,
  Q6 = {
    isBrowser: !0,
    classes: { URLSearchParams: Y6, FormData: K6, Blob: J6 },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data'],
  },
  zx = typeof window < 'u' && typeof document < 'u',
  F_ = (typeof navigator == 'object' && navigator) || void 0,
  Z6 =
    zx &&
    (!F_ || ['ReactNative', 'NativeScript', 'NS'].indexOf(F_.product) < 0),
  $6 =
    typeof WorkerGlobalScope < 'u' &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == 'function',
  ej = (zx && window.location.href) || 'http://localhost',
  tj = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: zx,
        hasStandardBrowserEnv: Z6,
        hasStandardBrowserWebWorkerEnv: $6,
        navigator: F_,
        origin: ej,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ti = { ...tj, ...Q6 };
function nj(n, e) {
  return xm(n, new ti.classes.URLSearchParams(), {
    visitor: function (t, i, r, s) {
      return ti.isNode && ie.isBuffer(t)
        ? (this.append(i, t.toString('base64')), !1)
        : s.defaultVisitor.apply(this, arguments);
    },
    ...e,
  });
}
function ij(n) {
  return ie
    .matchAll(/\w+|\[(\w*)]/g, n)
    .map((e) => (e[0] === '[]' ? '' : e[1] || e[0]));
}
function rj(n) {
  const e = {},
    t = Object.keys(n);
  let i;
  const r = t.length;
  let s;
  for (i = 0; i < r; i++) ((s = t[i]), (e[s] = n[s]));
  return e;
}
function _D(n) {
  function e(t, i, r, s) {
    let a = t[s++];
    if (a === '__proto__') return !0;
    const o = Number.isFinite(+a),
      l = s >= t.length;
    return (
      (a = !a && ie.isArray(r) ? r.length : a),
      l
        ? (ie.hasOwnProp(r, a) ? (r[a] = [r[a], i]) : (r[a] = i), !o)
        : ((!r[a] || !ie.isObject(r[a])) && (r[a] = []),
          e(t, i, r[a], s) && ie.isArray(r[a]) && (r[a] = rj(r[a])),
          !o)
    );
  }
  if (ie.isFormData(n) && ie.isFunction(n.entries)) {
    const t = {};
    return (
      ie.forEachEntry(n, (i, r) => {
        e(ij(i), r, t, 0);
      }),
      t
    );
  }
  return null;
}
function sj(n, e, t) {
  if (ie.isString(n))
    try {
      return ((e || JSON.parse)(n), ie.trim(n));
    } catch (i) {
      if (i.name !== 'SyntaxError') throw i;
    }
  return (t || JSON.stringify)(n);
}
const Uh = {
  transitional: vD,
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [
    function (e, t) {
      const i = t.getContentType() || '',
        r = i.indexOf('application/json') > -1,
        s = ie.isObject(e);
      if ((s && ie.isHTMLForm(e) && (e = new FormData(e)), ie.isFormData(e)))
        return r ? JSON.stringify(_D(e)) : e;
      if (
        ie.isArrayBuffer(e) ||
        ie.isBuffer(e) ||
        ie.isStream(e) ||
        ie.isFile(e) ||
        ie.isBlob(e) ||
        ie.isReadableStream(e)
      )
        return e;
      if (ie.isArrayBufferView(e)) return e.buffer;
      if (ie.isURLSearchParams(e))
        return (
          t.setContentType(
            'application/x-www-form-urlencoded;charset=utf-8',
            !1
          ),
          e.toString()
        );
      let o;
      if (s) {
        if (i.indexOf('application/x-www-form-urlencoded') > -1)
          return nj(e, this.formSerializer).toString();
        if ((o = ie.isFileList(e)) || i.indexOf('multipart/form-data') > -1) {
          const l = this.env && this.env.FormData;
          return xm(
            o ? { 'files[]': e } : e,
            l && new l(),
            this.formSerializer
          );
        }
      }
      return s || r ? (t.setContentType('application/json', !1), sj(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || Uh.transitional,
        i = t && t.forcedJSONParsing,
        r = this.responseType === 'json';
      if (ie.isResponse(e) || ie.isReadableStream(e)) return e;
      if (e && ie.isString(e) && ((i && !this.responseType) || r)) {
        const a = !(t && t.silentJSONParsing) && r;
        try {
          return JSON.parse(e, this.parseReviver);
        } catch (o) {
          if (a)
            throw o.name === 'SyntaxError'
              ? St.from(o, St.ERR_BAD_RESPONSE, this, null, this.response)
              : o;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: ti.classes.FormData, Blob: ti.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': void 0,
    },
  },
};
ie.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (n) => {
  Uh.headers[n] = {};
});
const aj = ie.toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent',
  ]),
  oj = (n) => {
    const e = {};
    let t, i, r;
    return (
      n &&
        n
          .split(
            `
`
          )
          .forEach(function (a) {
            ((r = a.indexOf(':')),
              (t = a.substring(0, r).trim().toLowerCase()),
              (i = a.substring(r + 1).trim()),
              !(!t || (e[t] && aj[t])) &&
                (t === 'set-cookie'
                  ? e[t]
                    ? e[t].push(i)
                    : (e[t] = [i])
                  : (e[t] = e[t] ? e[t] + ', ' + i : i)));
          }),
      e
    );
  },
  qA = Symbol('internals');
function Xc(n) {
  return n && String(n).trim().toLowerCase();
}
function Lf(n) {
  return n === !1 || n == null ? n : ie.isArray(n) ? n.map(Lf) : String(n);
}
function lj(n) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; (i = t.exec(n)); ) e[i[1]] = i[2];
  return e;
}
const cj = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function m0(n, e, t, i, r) {
  if (ie.isFunction(i)) return i.call(this, e, t);
  if ((r && (e = t), !!ie.isString(e))) {
    if (ie.isString(i)) return e.indexOf(i) !== -1;
    if (ie.isRegExp(i)) return i.test(e);
  }
}
function uj(n) {
  return n
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function hj(n, e) {
  const t = ie.toCamelCase(' ' + e);
  ['get', 'set', 'has'].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function (r, s, a) {
        return this[i].call(this, e, r, s, a);
      },
      configurable: !0,
    });
  });
}
let Ri = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function s(o, l, c) {
      const u = Xc(l);
      if (!u) throw new Error('header name must be a non-empty string');
      const h = ie.findKey(r, u);
      (!h || r[h] === void 0 || c === !0 || (c === void 0 && r[h] !== !1)) &&
        (r[h || l] = Lf(o));
    }
    const a = (o, l) => ie.forEach(o, (c, u) => s(c, u, l));
    if (ie.isPlainObject(e) || e instanceof this.constructor) a(e, t);
    else if (ie.isString(e) && (e = e.trim()) && !cj(e)) a(oj(e), t);
    else if (ie.isObject(e) && ie.isIterable(e)) {
      let o = {},
        l,
        c;
      for (const u of e) {
        if (!ie.isArray(u))
          throw TypeError('Object iterator must return a key-value pair');
        o[(c = u[0])] = (l = o[c])
          ? ie.isArray(l)
            ? [...l, u[1]]
            : [l, u[1]]
          : u[1];
      }
      a(o, t);
    } else e != null && s(t, e, i);
    return this;
  }
  get(e, t) {
    if (((e = Xc(e)), e)) {
      const i = ie.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t) return r;
        if (t === !0) return lj(r);
        if (ie.isFunction(t)) return t.call(this, r, i);
        if (ie.isRegExp(t)) return t.exec(r);
        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }
  has(e, t) {
    if (((e = Xc(e)), e)) {
      const i = ie.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || m0(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function s(a) {
      if (((a = Xc(a)), a)) {
        const o = ie.findKey(i, a);
        o && (!t || m0(i, i[o], o, t)) && (delete i[o], (r = !0));
      }
    }
    return (ie.isArray(e) ? e.forEach(s) : s(e), r);
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length,
      r = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || m0(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
    }
    return r;
  }
  normalize(e) {
    const t = this,
      i = {};
    return (
      ie.forEach(this, (r, s) => {
        const a = ie.findKey(i, s);
        if (a) {
          ((t[a] = Lf(r)), delete t[s]);
          return;
        }
        const o = e ? uj(s) : String(s).trim();
        (o !== s && delete t[s], (t[o] = Lf(r)), (i[o] = !0));
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = Object.create(null);
    return (
      ie.forEach(this, (i, r) => {
        i != null && i !== !1 && (t[r] = e && ie.isArray(i) ? i.join(', ') : i);
      }),
      t
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ': ' + t).join(`
`);
  }
  getSetCookie() {
    return this.get('set-cookie') || [];
  }
  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return (t.forEach((r) => i.set(r)), i);
  }
  static accessor(e) {
    const i = (this[qA] = this[qA] = { accessors: {} }).accessors,
      r = this.prototype;
    function s(a) {
      const o = Xc(a);
      i[o] || (hj(r, a), (i[o] = !0));
    }
    return (ie.isArray(e) ? e.forEach(s) : s(e), this);
  }
};
Ri.accessor([
  'Content-Type',
  'Content-Length',
  'Accept',
  'Accept-Encoding',
  'User-Agent',
  'Authorization',
]);
ie.reduceDescriptors(Ri.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => n,
    set(i) {
      this[t] = i;
    },
  };
});
ie.freezeMethods(Ri);
function g0(n, e) {
  const t = this || Uh,
    i = e || t,
    r = Ri.from(i.headers);
  let s = i.data;
  return (
    ie.forEach(n, function (o) {
      s = o.call(t, s, r.normalize(), e ? e.status : void 0);
    }),
    r.normalize(),
    s
  );
}
function yD(n) {
  return !!(n && n.__CANCEL__);
}
function Ac(n, e, t) {
  (St.call(this, n ?? 'canceled', St.ERR_CANCELED, e, t),
    (this.name = 'CanceledError'));
}
ie.inherits(Ac, St, { __CANCEL__: !0 });
function xD(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status)
    ? n(t)
    : e(
        new St(
          'Request failed with status code ' + t.status,
          [St.ERR_BAD_REQUEST, St.ERR_BAD_RESPONSE][
            Math.floor(t.status / 100) - 4
          ],
          t.config,
          t.request,
          t
        )
      );
}
function dj(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return (e && e[1]) || '';
}
function fj(n, e) {
  n = n || 10;
  const t = new Array(n),
    i = new Array(n);
  let r = 0,
    s = 0,
    a;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const c = Date.now(),
        u = i[s];
      (a || (a = c), (t[r] = l), (i[r] = c));
      let h = s,
        d = 0;
      for (; h !== r; ) ((d += t[h++]), (h = h % n));
      if (((r = (r + 1) % n), r === s && (s = (s + 1) % n), c - a < e)) return;
      const f = u && c - u;
      return f ? Math.round((d * 1e3) / f) : void 0;
    }
  );
}
function pj(n, e) {
  let t = 0,
    i = 1e3 / e,
    r,
    s;
  const a = (c, u = Date.now()) => {
    ((t = u), (r = null), s && (clearTimeout(s), (s = null)), n(...c));
  };
  return [
    (...c) => {
      const u = Date.now(),
        h = u - t;
      h >= i
        ? a(c, u)
        : ((r = c),
          s ||
            (s = setTimeout(() => {
              ((s = null), a(r));
            }, i - h)));
    },
    () => r && a(r),
  ];
}
const ap = (n, e, t = 3) => {
    let i = 0;
    const r = fj(50, 250);
    return pj((s) => {
      const a = s.loaded,
        o = s.lengthComputable ? s.total : void 0,
        l = a - i,
        c = r(l),
        u = a <= o;
      i = a;
      const h = {
        loaded: a,
        total: o,
        progress: o ? a / o : void 0,
        bytes: l,
        rate: c || void 0,
        estimated: c && o && u ? (o - a) / c : void 0,
        event: s,
        lengthComputable: o != null,
        [e ? 'download' : 'upload']: !0,
      };
      n(h);
    }, t);
  },
  YA = (n, e) => {
    const t = n != null;
    return [(i) => e[0]({ lengthComputable: t, total: n, loaded: i }), e[1]];
  },
  KA =
    (n) =>
    (...e) =>
      ie.asap(() => n(...e)),
  mj = ti.hasStandardBrowserEnv
    ? ((n, e) => (t) => (
        (t = new URL(t, ti.origin)),
        n.protocol === t.protocol &&
          n.host === t.host &&
          (e || n.port === t.port)
      ))(
        new URL(ti.origin),
        ti.navigator && /(msie|trident)/i.test(ti.navigator.userAgent)
      )
    : () => !0,
  gj = ti.hasStandardBrowserEnv
    ? {
        write(n, e, t, i, r, s, a) {
          if (typeof document > 'u') return;
          const o = [`${n}=${encodeURIComponent(e)}`];
          (ie.isNumber(t) && o.push(`expires=${new Date(t).toUTCString()}`),
            ie.isString(i) && o.push(`path=${i}`),
            ie.isString(r) && o.push(`domain=${r}`),
            s === !0 && o.push('secure'),
            ie.isString(a) && o.push(`SameSite=${a}`),
            (document.cookie = o.join('; ')));
        },
        read(n) {
          if (typeof document > 'u') return null;
          const e = document.cookie.match(
            new RegExp('(?:^|; )' + n + '=([^;]*)')
          );
          return e ? decodeURIComponent(e[1]) : null;
        },
        remove(n) {
          this.write(n, '', Date.now() - 864e5, '/');
        },
      }
    : {
        write() {},
        read() {
          return null;
        },
        remove() {},
      };
function vj(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function _j(n, e) {
  return e ? n.replace(/\/?\/$/, '') + '/' + e.replace(/^\/+/, '') : n;
}
function bD(n, e, t) {
  let i = !vj(e);
  return n && (i || t == !1) ? _j(n, e) : e;
}
const JA = (n) => (n instanceof Ri ? { ...n } : n);
function Po(n, e) {
  e = e || {};
  const t = {};
  function i(c, u, h, d) {
    return ie.isPlainObject(c) && ie.isPlainObject(u)
      ? ie.merge.call({ caseless: d }, c, u)
      : ie.isPlainObject(u)
        ? ie.merge({}, u)
        : ie.isArray(u)
          ? u.slice()
          : u;
  }
  function r(c, u, h, d) {
    if (ie.isUndefined(u)) {
      if (!ie.isUndefined(c)) return i(void 0, c, h, d);
    } else return i(c, u, h, d);
  }
  function s(c, u) {
    if (!ie.isUndefined(u)) return i(void 0, u);
  }
  function a(c, u) {
    if (ie.isUndefined(u)) {
      if (!ie.isUndefined(c)) return i(void 0, c);
    } else return i(void 0, u);
  }
  function o(c, u, h) {
    if (h in e) return i(c, u);
    if (h in n) return i(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: a,
    transformRequest: a,
    transformResponse: a,
    paramsSerializer: a,
    timeout: a,
    timeoutMessage: a,
    withCredentials: a,
    withXSRFToken: a,
    adapter: a,
    responseType: a,
    xsrfCookieName: a,
    xsrfHeaderName: a,
    onUploadProgress: a,
    onDownloadProgress: a,
    decompress: a,
    maxContentLength: a,
    maxBodyLength: a,
    beforeRedirect: a,
    transport: a,
    httpAgent: a,
    httpsAgent: a,
    cancelToken: a,
    socketPath: a,
    responseEncoding: a,
    validateStatus: o,
    headers: (c, u, h) => r(JA(c), JA(u), h, !0),
  };
  return (
    ie.forEach(Object.keys({ ...n, ...e }), function (u) {
      const h = l[u] || r,
        d = h(n[u], e[u], u);
      (ie.isUndefined(d) && h !== o) || (t[u] = d);
    }),
    t
  );
}
const SD = (n) => {
    const e = Po({}, n);
    let {
      data: t,
      withXSRFToken: i,
      xsrfHeaderName: r,
      xsrfCookieName: s,
      headers: a,
      auth: o,
    } = e;
    if (
      ((e.headers = a = Ri.from(a)),
      (e.url = gD(
        bD(e.baseURL, e.url, e.allowAbsoluteUrls),
        n.params,
        n.paramsSerializer
      )),
      o &&
        a.set(
          'Authorization',
          'Basic ' +
            btoa(
              (o.username || '') +
                ':' +
                (o.password ? unescape(encodeURIComponent(o.password)) : '')
            )
        ),
      ie.isFormData(t))
    ) {
      if (ti.hasStandardBrowserEnv || ti.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if (ie.isFunction(t.getHeaders)) {
        const l = t.getHeaders(),
          c = ['content-type', 'content-length'];
        Object.entries(l).forEach(([u, h]) => {
          c.includes(u.toLowerCase()) && a.set(u, h);
        });
      }
    }
    if (
      ti.hasStandardBrowserEnv &&
      (i && ie.isFunction(i) && (i = i(e)), i || (i !== !1 && mj(e.url)))
    ) {
      const l = r && s && gj.read(s);
      l && a.set(r, l);
    }
    return e;
  },
  yj = typeof XMLHttpRequest < 'u',
  xj =
    yj &&
    function (n) {
      return new Promise(function (t, i) {
        const r = SD(n);
        let s = r.data;
        const a = Ri.from(r.headers).normalize();
        let { responseType: o, onUploadProgress: l, onDownloadProgress: c } = r,
          u,
          h,
          d,
          f,
          p;
        function m() {
          (f && f(),
            p && p(),
            r.cancelToken && r.cancelToken.unsubscribe(u),
            r.signal && r.signal.removeEventListener('abort', u));
        }
        let g = new XMLHttpRequest();
        (g.open(r.method.toUpperCase(), r.url, !0), (g.timeout = r.timeout));
        function v() {
          if (!g) return;
          const _ = Ri.from(
              'getAllResponseHeaders' in g && g.getAllResponseHeaders()
            ),
            S = {
              data:
                !o || o === 'text' || o === 'json'
                  ? g.responseText
                  : g.response,
              status: g.status,
              statusText: g.statusText,
              headers: _,
              config: n,
              request: g,
            };
          (xD(
            function (A) {
              (t(A), m());
            },
            function (A) {
              (i(A), m());
            },
            S
          ),
            (g = null));
        }
        ('onloadend' in g
          ? (g.onloadend = v)
          : (g.onreadystatechange = function () {
              !g ||
                g.readyState !== 4 ||
                (g.status === 0 &&
                  !(g.responseURL && g.responseURL.indexOf('file:') === 0)) ||
                setTimeout(v);
            }),
          (g.onabort = function () {
            g &&
              (i(new St('Request aborted', St.ECONNABORTED, n, g)), (g = null));
          }),
          (g.onerror = function (x) {
            const S = x && x.message ? x.message : 'Network Error',
              b = new St(S, St.ERR_NETWORK, n, g);
            ((b.event = x || null), i(b), (g = null));
          }),
          (g.ontimeout = function () {
            let x = r.timeout
              ? 'timeout of ' + r.timeout + 'ms exceeded'
              : 'timeout exceeded';
            const S = r.transitional || vD;
            (r.timeoutErrorMessage && (x = r.timeoutErrorMessage),
              i(
                new St(
                  x,
                  S.clarifyTimeoutError ? St.ETIMEDOUT : St.ECONNABORTED,
                  n,
                  g
                )
              ),
              (g = null));
          }),
          s === void 0 && a.setContentType(null),
          'setRequestHeader' in g &&
            ie.forEach(a.toJSON(), function (x, S) {
              g.setRequestHeader(S, x);
            }),
          ie.isUndefined(r.withCredentials) ||
            (g.withCredentials = !!r.withCredentials),
          o && o !== 'json' && (g.responseType = r.responseType),
          c && (([d, p] = ap(c, !0)), g.addEventListener('progress', d)),
          l &&
            g.upload &&
            (([h, f] = ap(l)),
            g.upload.addEventListener('progress', h),
            g.upload.addEventListener('loadend', f)),
          (r.cancelToken || r.signal) &&
            ((u = (_) => {
              g &&
                (i(!_ || _.type ? new Ac(null, n, g) : _),
                g.abort(),
                (g = null));
            }),
            r.cancelToken && r.cancelToken.subscribe(u),
            r.signal &&
              (r.signal.aborted
                ? u()
                : r.signal.addEventListener('abort', u))));
        const y = dj(r.url);
        if (y && ti.protocols.indexOf(y) === -1) {
          i(new St('Unsupported protocol ' + y + ':', St.ERR_BAD_REQUEST, n));
          return;
        }
        g.send(s || null);
      });
    },
  bj = (n, e) => {
    const { length: t } = (n = n ? n.filter(Boolean) : []);
    if (e || t) {
      let i = new AbortController(),
        r;
      const s = function (c) {
        if (!r) {
          ((r = !0), o());
          const u = c instanceof Error ? c : this.reason;
          i.abort(
            u instanceof St ? u : new Ac(u instanceof Error ? u.message : u)
          );
        }
      };
      let a =
        e &&
        setTimeout(() => {
          ((a = null), s(new St(`timeout ${e} of ms exceeded`, St.ETIMEDOUT)));
        }, e);
      const o = () => {
        n &&
          (a && clearTimeout(a),
          (a = null),
          n.forEach((c) => {
            c.unsubscribe
              ? c.unsubscribe(s)
              : c.removeEventListener('abort', s);
          }),
          (n = null));
      };
      n.forEach((c) => c.addEventListener('abort', s));
      const { signal: l } = i;
      return ((l.unsubscribe = () => ie.asap(o)), l);
    }
  },
  Sj = function* (n, e) {
    let t = n.byteLength;
    if (t < e) {
      yield n;
      return;
    }
    let i = 0,
      r;
    for (; i < t; ) ((r = i + e), yield n.slice(i, r), (i = r));
  },
  wj = async function* (n, e) {
    for await (const t of Ej(n)) yield* Sj(t, e);
  },
  Ej = async function* (n) {
    if (n[Symbol.asyncIterator]) {
      yield* n;
      return;
    }
    const e = n.getReader();
    try {
      for (;;) {
        const { done: t, value: i } = await e.read();
        if (t) break;
        yield i;
      }
    } finally {
      await e.cancel();
    }
  },
  QA = (n, e, t, i) => {
    const r = wj(n, e);
    let s = 0,
      a,
      o = (l) => {
        a || ((a = !0), i && i(l));
      };
    return new ReadableStream(
      {
        async pull(l) {
          try {
            const { done: c, value: u } = await r.next();
            if (c) {
              (o(), l.close());
              return;
            }
            let h = u.byteLength;
            if (t) {
              let d = (s += h);
              t(d);
            }
            l.enqueue(new Uint8Array(u));
          } catch (c) {
            throw (o(c), c);
          }
        },
        cancel(l) {
          return (o(l), r.return());
        },
      },
      { highWaterMark: 2 }
    );
  },
  ZA = 64 * 1024,
  { isFunction: Sd } = ie,
  Aj = (({ Request: n, Response: e }) => ({ Request: n, Response: e }))(
    ie.global
  ),
  { ReadableStream: $A, TextEncoder: e1 } = ie.global,
  t1 = (n, ...e) => {
    try {
      return !!n(...e);
    } catch {
      return !1;
    }
  },
  Mj = (n) => {
    n = ie.merge.call({ skipUndefined: !0 }, Aj, n);
    const { fetch: e, Request: t, Response: i } = n,
      r = e ? Sd(e) : typeof fetch == 'function',
      s = Sd(t),
      a = Sd(i);
    if (!r) return !1;
    const o = r && Sd($A),
      l =
        r &&
        (typeof e1 == 'function'
          ? (
              (p) => (m) =>
                p.encode(m)
            )(new e1())
          : async (p) => new Uint8Array(await new t(p).arrayBuffer())),
      c =
        s &&
        o &&
        t1(() => {
          let p = !1;
          const m = new t(ti.origin, {
            body: new $A(),
            method: 'POST',
            get duplex() {
              return ((p = !0), 'half');
            },
          }).headers.has('Content-Type');
          return p && !m;
        }),
      u = a && o && t1(() => ie.isReadableStream(new i('').body)),
      h = { stream: u && ((p) => p.body) };
    r &&
      ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach((p) => {
        !h[p] &&
          (h[p] = (m, g) => {
            let v = m && m[p];
            if (v) return v.call(m);
            throw new St(
              `Response type '${p}' is not supported`,
              St.ERR_NOT_SUPPORT,
              g
            );
          });
      });
    const d = async (p) => {
        if (p == null) return 0;
        if (ie.isBlob(p)) return p.size;
        if (ie.isSpecCompliantForm(p))
          return (
            await new t(ti.origin, { method: 'POST', body: p }).arrayBuffer()
          ).byteLength;
        if (ie.isArrayBufferView(p) || ie.isArrayBuffer(p)) return p.byteLength;
        if ((ie.isURLSearchParams(p) && (p = p + ''), ie.isString(p)))
          return (await l(p)).byteLength;
      },
      f = async (p, m) => {
        const g = ie.toFiniteNumber(p.getContentLength());
        return g ?? d(m);
      };
    return async (p) => {
      let {
          url: m,
          method: g,
          data: v,
          signal: y,
          cancelToken: _,
          timeout: x,
          onDownloadProgress: S,
          onUploadProgress: b,
          responseType: A,
          headers: E,
          withCredentials: w = 'same-origin',
          fetchOptions: M,
        } = SD(p),
        T = e || fetch;
      A = A ? (A + '').toLowerCase() : 'text';
      let D = bj([y, _ && _.toAbortSignal()], x),
        L = null;
      const O =
        D &&
        D.unsubscribe &&
        (() => {
          D.unsubscribe();
        });
      let z;
      try {
        if (
          b &&
          c &&
          g !== 'get' &&
          g !== 'head' &&
          (z = await f(E, v)) !== 0
        ) {
          let ne = new t(m, { method: 'POST', body: v, duplex: 'half' }),
            ve;
          if (
            (ie.isFormData(v) &&
              (ve = ne.headers.get('content-type')) &&
              E.setContentType(ve),
            ne.body)
          ) {
            const [Se, Ae] = YA(z, ap(KA(b)));
            v = QA(ne.body, ZA, Se, Ae);
          }
        }
        ie.isString(w) || (w = w ? 'include' : 'omit');
        const C = s && 'credentials' in t.prototype,
          N = {
            ...M,
            signal: D,
            method: g.toUpperCase(),
            headers: E.normalize().toJSON(),
            body: v,
            duplex: 'half',
            credentials: C ? w : void 0,
          };
        L = s && new t(m, N);
        let U = await (s ? T(L, M) : T(m, N));
        const W = u && (A === 'stream' || A === 'response');
        if (u && (S || (W && O))) {
          const ne = {};
          ['status', 'statusText', 'headers'].forEach((Oe) => {
            ne[Oe] = U[Oe];
          });
          const ve = ie.toFiniteNumber(U.headers.get('content-length')),
            [Se, Ae] = (S && YA(ve, ap(KA(S), !0))) || [];
          U = new i(
            QA(U.body, ZA, Se, () => {
              (Ae && Ae(), O && O());
            }),
            ne
          );
        }
        A = A || 'text';
        let G = await h[ie.findKey(h, A) || 'text'](U, p);
        return (
          !W && O && O(),
          await new Promise((ne, ve) => {
            xD(ne, ve, {
              data: G,
              headers: Ri.from(U.headers),
              status: U.status,
              statusText: U.statusText,
              config: p,
              request: L,
            });
          })
        );
      } catch (C) {
        throw (
          O && O(),
          C && C.name === 'TypeError' && /Load failed|fetch/i.test(C.message)
            ? Object.assign(new St('Network Error', St.ERR_NETWORK, p, L), {
                cause: C.cause || C,
              })
            : St.from(C, C && C.code, p, L)
        );
      }
    };
  },
  Tj = new Map(),
  wD = (n) => {
    let e = (n && n.env) || {};
    const { fetch: t, Request: i, Response: r } = e,
      s = [i, r, t];
    let a = s.length,
      o = a,
      l,
      c,
      u = Tj;
    for (; o--; )
      ((l = s[o]),
        (c = u.get(l)),
        c === void 0 && u.set(l, (c = o ? new Map() : Mj(e))),
        (u = c));
    return c;
  };
wD();
const Vx = { http: W6, xhr: xj, fetch: { get: wD } };
ie.forEach(Vx, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, 'name', { value: e });
    } catch {}
    Object.defineProperty(n, 'adapterName', { value: e });
  }
});
const n1 = (n) => `- ${n}`,
  Cj = (n) => ie.isFunction(n) || n === null || n === !1;
function Rj(n, e) {
  n = ie.isArray(n) ? n : [n];
  const { length: t } = n;
  let i, r;
  const s = {};
  for (let a = 0; a < t; a++) {
    i = n[a];
    let o;
    if (
      ((r = i),
      !Cj(i) && ((r = Vx[(o = String(i)).toLowerCase()]), r === void 0))
    )
      throw new St(`Unknown adapter '${o}'`);
    if (r && (ie.isFunction(r) || (r = r.get(e)))) break;
    s[o || '#' + a] = r;
  }
  if (!r) {
    const a = Object.entries(s).map(
      ([l, c]) =>
        `adapter ${l} ` +
        (c === !1
          ? 'is not supported by the environment'
          : 'is not available in the build')
    );
    let o = t
      ? a.length > 1
        ? `since :
` +
          a.map(n1).join(`
`)
        : ' ' + n1(a[0])
      : 'as no adapter specified';
    throw new St(
      'There is no suitable adapter to dispatch the request ' + o,
      'ERR_NOT_SUPPORT'
    );
  }
  return r;
}
const ED = { getAdapter: Rj, adapters: Vx };
function v0(n) {
  if (
    (n.cancelToken && n.cancelToken.throwIfRequested(),
    n.signal && n.signal.aborted)
  )
    throw new Ac(null, n);
}
function i1(n) {
  return (
    v0(n),
    (n.headers = Ri.from(n.headers)),
    (n.data = g0.call(n, n.transformRequest)),
    ['post', 'put', 'patch'].indexOf(n.method) !== -1 &&
      n.headers.setContentType('application/x-www-form-urlencoded', !1),
    ED.getAdapter(
      n.adapter || Uh.adapter,
      n
    )(n).then(
      function (i) {
        return (
          v0(n),
          (i.data = g0.call(n, n.transformResponse, i)),
          (i.headers = Ri.from(i.headers)),
          i
        );
      },
      function (i) {
        return (
          yD(i) ||
            (v0(n),
            i &&
              i.response &&
              ((i.response.data = g0.call(n, n.transformResponse, i.response)),
              (i.response.headers = Ri.from(i.response.headers)))),
          Promise.reject(i)
        );
      }
    )
  );
}
const AD = '1.13.2',
  bm = {};
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(
  (n, e) => {
    bm[n] = function (i) {
      return typeof i === n || 'a' + (e < 1 ? 'n ' : ' ') + n;
    };
  }
);
const r1 = {};
bm.transitional = function (e, t, i) {
  function r(s, a) {
    return (
      '[Axios v' +
      AD +
      "] Transitional option '" +
      s +
      "'" +
      a +
      (i ? '. ' + i : '')
    );
  }
  return (s, a, o) => {
    if (e === !1)
      throw new St(
        r(a, ' has been removed' + (t ? ' in ' + t : '')),
        St.ERR_DEPRECATED
      );
    return (
      t &&
        !r1[a] &&
        ((r1[a] = !0),
        console.warn(
          r(
            a,
            ' has been deprecated since v' +
              t +
              ' and will be removed in the near future'
          )
        )),
      e ? e(s, a, o) : !0
    );
  };
};
bm.spelling = function (e) {
  return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0);
};
function Ij(n, e, t) {
  if (typeof n != 'object')
    throw new St('options must be an object', St.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r],
      a = e[s];
    if (a) {
      const o = n[s],
        l = o === void 0 || a(o, s, n);
      if (l !== !0)
        throw new St('option ' + s + ' must be ' + l, St.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0) throw new St('Unknown option ' + s, St.ERR_BAD_OPTION);
  }
}
const Uf = { assertOptions: Ij, validators: bm },
  Rr = Uf.validators;
let wo = class {
  constructor(e) {
    ((this.defaults = e || {}),
      (this.interceptors = { request: new XA(), response: new XA() }));
  }
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let r = {};
        Error.captureStackTrace
          ? Error.captureStackTrace(r)
          : (r = new Error());
        const s = r.stack ? r.stack.replace(/^.+\n/, '') : '';
        try {
          i.stack
            ? s &&
              !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, '')) &&
              (i.stack +=
                `
` + s)
            : (i.stack = s);
        } catch {}
      }
      throw i;
    }
  }
  _request(e, t) {
    (typeof e == 'string' ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = Po(this.defaults, t)));
    const { transitional: i, paramsSerializer: r, headers: s } = t;
    (i !== void 0 &&
      Uf.assertOptions(
        i,
        {
          silentJSONParsing: Rr.transitional(Rr.boolean),
          forcedJSONParsing: Rr.transitional(Rr.boolean),
          clarifyTimeoutError: Rr.transitional(Rr.boolean),
        },
        !1
      ),
      r != null &&
        (ie.isFunction(r)
          ? (t.paramsSerializer = { serialize: r })
          : Uf.assertOptions(
              r,
              { encode: Rr.function, serialize: Rr.function },
              !0
            )),
      t.allowAbsoluteUrls !== void 0 ||
        (this.defaults.allowAbsoluteUrls !== void 0
          ? (t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls)
          : (t.allowAbsoluteUrls = !0)),
      Uf.assertOptions(
        t,
        {
          baseUrl: Rr.spelling('baseURL'),
          withXsrfToken: Rr.spelling('withXSRFToken'),
        },
        !0
      ),
      (t.method = (t.method || this.defaults.method || 'get').toLowerCase()));
    let a = s && ie.merge(s.common, s[t.method]);
    (s &&
      ie.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        (p) => {
          delete s[p];
        }
      ),
      (t.headers = Ri.concat(a, s)));
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function (m) {
      (typeof m.runWhen == 'function' && m.runWhen(t) === !1) ||
        ((l = l && m.synchronous), o.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function (m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u,
      h = 0,
      d;
    if (!l) {
      const p = [i1.bind(this), void 0];
      for (
        p.unshift(...o), p.push(...c), d = p.length, u = Promise.resolve(t);
        h < d;

      )
        u = u.then(p[h++], p[h++]);
      return u;
    }
    d = o.length;
    let f = t;
    for (; h < d; ) {
      const p = o[h++],
        m = o[h++];
      try {
        f = p(f);
      } catch (g) {
        m.call(this, g);
        break;
      }
    }
    try {
      u = i1.call(this, f);
    } catch (p) {
      return Promise.reject(p);
    }
    for (h = 0, d = c.length; h < d; ) u = u.then(c[h++], c[h++]);
    return u;
  }
  getUri(e) {
    e = Po(this.defaults, e);
    const t = bD(e.baseURL, e.url, e.allowAbsoluteUrls);
    return gD(t, e.params, e.paramsSerializer);
  }
};
ie.forEach(['delete', 'get', 'head', 'options'], function (e) {
  wo.prototype[e] = function (t, i) {
    return this.request(
      Po(i || {}, { method: e, url: t, data: (i || {}).data })
    );
  };
});
ie.forEach(['post', 'put', 'patch'], function (e) {
  function t(i) {
    return function (s, a, o) {
      return this.request(
        Po(o || {}, {
          method: e,
          headers: i ? { 'Content-Type': 'multipart/form-data' } : {},
          url: s,
          data: a,
        })
      );
    };
  }
  ((wo.prototype[e] = t()), (wo.prototype[e + 'Form'] = t(!0)));
});
let Pj = class MD {
  constructor(e) {
    if (typeof e != 'function')
      throw new TypeError('executor must be a function.');
    let t;
    this.promise = new Promise(function (s) {
      t = s;
    });
    const i = this;
    (this.promise.then((r) => {
      if (!i._listeners) return;
      let s = i._listeners.length;
      for (; s-- > 0; ) i._listeners[s](r);
      i._listeners = null;
    }),
      (this.promise.then = (r) => {
        let s;
        const a = new Promise((o) => {
          (i.subscribe(o), (s = o));
        }).then(r);
        return (
          (a.cancel = function () {
            i.unsubscribe(s);
          }),
          a
        );
      }),
      e(function (s, a, o) {
        i.reason || ((i.reason = new Ac(s, a, o)), t(i.reason));
      }));
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(),
      t = (i) => {
        e.abort(i);
      };
    return (
      this.subscribe(t),
      (e.signal.unsubscribe = () => this.unsubscribe(t)),
      e.signal
    );
  }
  static source() {
    let e;
    return {
      token: new MD(function (r) {
        e = r;
      }),
      cancel: e,
    };
  }
};
function Dj(n) {
  return function (t) {
    return n.apply(null, t);
  };
}
function Oj(n) {
  return ie.isObject(n) && n.isAxiosError === !0;
}
const z_ = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526,
};
Object.entries(z_).forEach(([n, e]) => {
  z_[e] = n;
});
function TD(n) {
  const e = new wo(n),
    t = rD(wo.prototype.request, e);
  return (
    ie.extend(t, wo.prototype, e, { allOwnKeys: !0 }),
    ie.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (r) {
      return TD(Po(n, r));
    }),
    t
  );
}
const In = TD(Uh);
In.Axios = wo;
In.CanceledError = Ac;
In.CancelToken = Pj;
In.isCancel = yD;
In.VERSION = AD;
In.toFormData = xm;
In.AxiosError = St;
In.Cancel = In.CanceledError;
In.all = function (e) {
  return Promise.all(e);
};
In.spread = Dj;
In.isAxiosError = Oj;
In.mergeConfig = Po;
In.AxiosHeaders = Ri;
In.formToJSON = (n) => _D(ie.isHTMLForm(n) ? new FormData(n) : n);
In.getAdapter = ED.getAdapter;
In.HttpStatusCode = z_;
In.default = In;
const {
  Axios: Lne,
  AxiosError: Une,
  CanceledError: kne,
  isCancel: Bne,
  CancelToken: Nne,
  VERSION: Fne,
  all: zne,
  Cancel: Vne,
  isAxiosError: Hne,
  spread: Gne,
  toFormData: Wne,
  AxiosHeaders: jne,
  HttpStatusCode: Xne,
  formToJSON: qne,
  getAdapter: Yne,
  mergeConfig: Kne,
} = In;
function Ru(n) {
  let e = n[0],
    t = n[1],
    i = n[2];
  return Math.sqrt(e * e + t * t + i * i);
}
function V_(n, e) {
  return ((n[0] = e[0]), (n[1] = e[1]), (n[2] = e[2]), n);
}
function Lj(n, e, t, i) {
  return ((n[0] = e), (n[1] = t), (n[2] = i), n);
}
function s1(n, e, t) {
  return ((n[0] = e[0] + t[0]), (n[1] = e[1] + t[1]), (n[2] = e[2] + t[2]), n);
}
function a1(n, e, t) {
  return ((n[0] = e[0] - t[0]), (n[1] = e[1] - t[1]), (n[2] = e[2] - t[2]), n);
}
function Uj(n, e, t) {
  return ((n[0] = e[0] * t[0]), (n[1] = e[1] * t[1]), (n[2] = e[2] * t[2]), n);
}
function kj(n, e, t) {
  return ((n[0] = e[0] / t[0]), (n[1] = e[1] / t[1]), (n[2] = e[2] / t[2]), n);
}
function _0(n, e, t) {
  return ((n[0] = e[0] * t), (n[1] = e[1] * t), (n[2] = e[2] * t), n);
}
function Bj(n, e) {
  let t = e[0] - n[0],
    i = e[1] - n[1],
    r = e[2] - n[2];
  return Math.sqrt(t * t + i * i + r * r);
}
function Nj(n, e) {
  let t = e[0] - n[0],
    i = e[1] - n[1],
    r = e[2] - n[2];
  return t * t + i * i + r * r;
}
function o1(n) {
  let e = n[0],
    t = n[1],
    i = n[2];
  return e * e + t * t + i * i;
}
function Fj(n, e) {
  return ((n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), n);
}
function zj(n, e) {
  return ((n[0] = 1 / e[0]), (n[1] = 1 / e[1]), (n[2] = 1 / e[2]), n);
}
function H_(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = t * t + i * i + r * r;
  return (
    s > 0 && (s = 1 / Math.sqrt(s)),
    (n[0] = e[0] * s),
    (n[1] = e[1] * s),
    (n[2] = e[2] * s),
    n
  );
}
function CD(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function l1(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = t[0],
    o = t[1],
    l = t[2];
  return (
    (n[0] = r * l - s * o),
    (n[1] = s * a - i * l),
    (n[2] = i * o - r * a),
    n
  );
}
function Vj(n, e, t, i) {
  let r = e[0],
    s = e[1],
    a = e[2];
  return (
    (n[0] = r + i * (t[0] - r)),
    (n[1] = s + i * (t[1] - s)),
    (n[2] = a + i * (t[2] - a)),
    n
  );
}
function Hj(n, e, t, i, r) {
  const s = Math.exp(-i * r);
  let a = e[0],
    o = e[1],
    l = e[2];
  return (
    (n[0] = t[0] + (a - t[0]) * s),
    (n[1] = t[1] + (o - t[1]) * s),
    (n[2] = t[2] + (l - t[2]) * s),
    n
  );
}
function Gj(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = t[3] * i + t[7] * r + t[11] * s + t[15];
  return (
    (a = a || 1),
    (n[0] = (t[0] * i + t[4] * r + t[8] * s + t[12]) / a),
    (n[1] = (t[1] * i + t[5] * r + t[9] * s + t[13]) / a),
    (n[2] = (t[2] * i + t[6] * r + t[10] * s + t[14]) / a),
    n
  );
}
function Wj(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = t[3] * i + t[7] * r + t[11] * s + t[15];
  return (
    (a = a || 1),
    (n[0] = (t[0] * i + t[4] * r + t[8] * s) / a),
    (n[1] = (t[1] * i + t[5] * r + t[9] * s) / a),
    (n[2] = (t[2] * i + t[6] * r + t[10] * s) / a),
    n
  );
}
function jj(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2];
  return (
    (n[0] = i * t[0] + r * t[3] + s * t[6]),
    (n[1] = i * t[1] + r * t[4] + s * t[7]),
    (n[2] = i * t[2] + r * t[5] + s * t[8]),
    n
  );
}
function Xj(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = t[0],
    o = t[1],
    l = t[2],
    c = t[3],
    u = o * s - l * r,
    h = l * i - a * s,
    d = a * r - o * i,
    f = o * d - l * h,
    p = l * u - a * d,
    m = a * h - o * u,
    g = c * 2;
  return (
    (u *= g),
    (h *= g),
    (d *= g),
    (f *= 2),
    (p *= 2),
    (m *= 2),
    (n[0] = i + u + f),
    (n[1] = r + h + p),
    (n[2] = s + d + m),
    n
  );
}
const qj = (function () {
  const n = [0, 0, 0],
    e = [0, 0, 0];
  return function (t, i) {
    (V_(n, t), V_(e, i), H_(n, n), H_(e, e));
    let r = CD(n, e);
    return r > 1 ? 0 : r < -1 ? Math.PI : Math.acos(r);
  };
})();
function Yj(n, e) {
  return n[0] === e[0] && n[1] === e[1] && n[2] === e[2];
}
class Cn extends Array {
  constructor(e = 0, t = e, i = e) {
    return (super(e, t, i), this);
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  set x(e) {
    this[0] = e;
  }
  set y(e) {
    this[1] = e;
  }
  set z(e) {
    this[2] = e;
  }
  set(e, t = e, i = e) {
    return e.length ? this.copy(e) : (Lj(this, e, t, i), this);
  }
  copy(e) {
    return (V_(this, e), this);
  }
  add(e, t) {
    return (t ? s1(this, e, t) : s1(this, this, e), this);
  }
  sub(e, t) {
    return (t ? a1(this, e, t) : a1(this, this, e), this);
  }
  multiply(e) {
    return (e.length ? Uj(this, this, e) : _0(this, this, e), this);
  }
  divide(e) {
    return (e.length ? kj(this, this, e) : _0(this, this, 1 / e), this);
  }
  inverse(e = this) {
    return (zj(this, e), this);
  }
  len() {
    return Ru(this);
  }
  distance(e) {
    return e ? Bj(this, e) : Ru(this);
  }
  squaredLen() {
    return o1(this);
  }
  squaredDistance(e) {
    return e ? Nj(this, e) : o1(this);
  }
  negate(e = this) {
    return (Fj(this, e), this);
  }
  cross(e, t) {
    return (t ? l1(this, e, t) : l1(this, this, e), this);
  }
  scale(e) {
    return (_0(this, this, e), this);
  }
  normalize() {
    return (H_(this, this), this);
  }
  dot(e) {
    return CD(this, e);
  }
  equals(e) {
    return Yj(this, e);
  }
  applyMatrix3(e) {
    return (jj(this, this, e), this);
  }
  applyMatrix4(e) {
    return (Gj(this, this, e), this);
  }
  scaleRotateMatrix4(e) {
    return (Wj(this, this, e), this);
  }
  applyQuaternion(e) {
    return (Xj(this, this, e), this);
  }
  angle(e) {
    return qj(this, e);
  }
  lerp(e, t) {
    return (Vj(this, this, e, t), this);
  }
  smoothLerp(e, t, i) {
    return (Hj(this, this, e, t, i), this);
  }
  clone() {
    return new Cn(this[0], this[1], this[2]);
  }
  fromArray(e, t = 0) {
    return ((this[0] = e[t]), (this[1] = e[t + 1]), (this[2] = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), e);
  }
  transformDirection(e) {
    const t = this[0],
      i = this[1],
      r = this[2];
    return (
      (this[0] = e[0] * t + e[4] * i + e[8] * r),
      (this[1] = e[1] * t + e[5] * i + e[9] * r),
      (this[2] = e[2] * t + e[6] * i + e[10] * r),
      this.normalize()
    );
  }
}
const c1 = new Cn();
let Kj = 1,
  Jj = 1,
  u1 = !1;
class Qj {
  constructor(e, t = {}) {
    (e.canvas || console.error('gl not passed as first argument to Geometry'),
      (this.gl = e),
      (this.attributes = t),
      (this.id = Kj++),
      (this.VAOs = {}),
      (this.drawRange = { start: 0, count: 0 }),
      (this.instancedCount = 0),
      this.gl.renderer.bindVertexArray(null),
      (this.gl.renderer.currentGeometry = null),
      (this.glState = this.gl.renderer.state));
    for (let i in t) this.addAttribute(i, t[i]);
  }
  addAttribute(e, t) {
    if (
      ((this.attributes[e] = t),
      (t.id = Jj++),
      (t.size = t.size || 1),
      (t.type =
        t.type ||
        (t.data.constructor === Float32Array
          ? this.gl.FLOAT
          : t.data.constructor === Uint16Array
            ? this.gl.UNSIGNED_SHORT
            : this.gl.UNSIGNED_INT)),
      (t.target =
        e === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER),
      (t.normalized = t.normalized || !1),
      (t.stride = t.stride || 0),
      (t.offset = t.offset || 0),
      (t.count =
        t.count ||
        (t.stride ? t.data.byteLength / t.stride : t.data.length / t.size)),
      (t.divisor = t.instanced || 0),
      (t.needsUpdate = !1),
      (t.usage = t.usage || this.gl.STATIC_DRAW),
      t.buffer || this.updateAttribute(t),
      t.divisor)
    ) {
      if (
        ((this.isInstanced = !0),
        this.instancedCount && this.instancedCount !== t.count * t.divisor)
      )
        return (
          console.warn(
            'geometry has multiple instanced buffers of different length'
          ),
          (this.instancedCount = Math.min(
            this.instancedCount,
            t.count * t.divisor
          ))
        );
      this.instancedCount = t.count * t.divisor;
    } else
      e === 'index'
        ? (this.drawRange.count = t.count)
        : this.attributes.index ||
          (this.drawRange.count = Math.max(this.drawRange.count, t.count));
  }
  updateAttribute(e) {
    const t = !e.buffer;
    (t && (e.buffer = this.gl.createBuffer()),
      this.glState.boundBuffer !== e.buffer &&
        (this.gl.bindBuffer(e.target, e.buffer),
        (this.glState.boundBuffer = e.buffer)),
      t
        ? this.gl.bufferData(e.target, e.data, e.usage)
        : this.gl.bufferSubData(e.target, 0, e.data),
      (e.needsUpdate = !1));
  }
  setIndex(e) {
    this.addAttribute('index', e);
  }
  setDrawRange(e, t) {
    ((this.drawRange.start = e), (this.drawRange.count = t));
  }
  setInstancedCount(e) {
    this.instancedCount = e;
  }
  createVAO(e) {
    ((this.VAOs[e.attributeOrder] = this.gl.renderer.createVertexArray()),
      this.gl.renderer.bindVertexArray(this.VAOs[e.attributeOrder]),
      this.bindAttributes(e));
  }
  bindAttributes(e) {
    (e.attributeLocations.forEach((t, { name: i, type: r }) => {
      if (!this.attributes[i]) {
        console.warn(`active attribute ${i} not being supplied`);
        return;
      }
      const s = this.attributes[i];
      (this.gl.bindBuffer(s.target, s.buffer),
        (this.glState.boundBuffer = s.buffer));
      let a = 1;
      (r === 35674 && (a = 2), r === 35675 && (a = 3), r === 35676 && (a = 4));
      const o = s.size / a,
        l = a === 1 ? 0 : a * a * 4,
        c = a === 1 ? 0 : a * 4;
      for (let u = 0; u < a; u++)
        (this.gl.vertexAttribPointer(
          t + u,
          o,
          s.type,
          s.normalized,
          s.stride + l,
          s.offset + u * c
        ),
          this.gl.enableVertexAttribArray(t + u),
          this.gl.renderer.vertexAttribDivisor(t + u, s.divisor));
    }),
      this.attributes.index &&
        this.gl.bindBuffer(
          this.gl.ELEMENT_ARRAY_BUFFER,
          this.attributes.index.buffer
        ));
  }
  draw({ program: e, mode: t = this.gl.TRIANGLES }) {
    (this.gl.renderer.currentGeometry !== `${this.id}_${e.attributeOrder}` &&
      (this.VAOs[e.attributeOrder] || this.createVAO(e),
      this.gl.renderer.bindVertexArray(this.VAOs[e.attributeOrder]),
      (this.gl.renderer.currentGeometry = `${this.id}_${e.attributeOrder}`)),
      e.attributeLocations.forEach((r, { name: s }) => {
        const a = this.attributes[s];
        a.needsUpdate && this.updateAttribute(a);
      }));
    let i = 2;
    (this.attributes.index?.type === this.gl.UNSIGNED_INT && (i = 4),
      this.isInstanced
        ? this.attributes.index
          ? this.gl.renderer.drawElementsInstanced(
              t,
              this.drawRange.count,
              this.attributes.index.type,
              this.attributes.index.offset + this.drawRange.start * i,
              this.instancedCount
            )
          : this.gl.renderer.drawArraysInstanced(
              t,
              this.drawRange.start,
              this.drawRange.count,
              this.instancedCount
            )
        : this.attributes.index
          ? this.gl.drawElements(
              t,
              this.drawRange.count,
              this.attributes.index.type,
              this.attributes.index.offset + this.drawRange.start * i
            )
          : this.gl.drawArrays(t, this.drawRange.start, this.drawRange.count));
  }
  getPosition() {
    const e = this.attributes.position;
    if (e.data) return e;
    if (!u1)
      return (
        console.warn('No position buffer data found to compute bounds'),
        (u1 = !0)
      );
  }
  computeBoundingBox(e) {
    e || (e = this.getPosition());
    const t = e.data,
      i = e.size;
    this.bounds ||
      (this.bounds = {
        min: new Cn(),
        max: new Cn(),
        center: new Cn(),
        scale: new Cn(),
        radius: 1 / 0,
      });
    const r = this.bounds.min,
      s = this.bounds.max,
      a = this.bounds.center,
      o = this.bounds.scale;
    (r.set(1 / 0), s.set(-1 / 0));
    for (let l = 0, c = t.length; l < c; l += i) {
      const u = t[l],
        h = t[l + 1],
        d = t[l + 2];
      ((r.x = Math.min(u, r.x)),
        (r.y = Math.min(h, r.y)),
        (r.z = Math.min(d, r.z)),
        (s.x = Math.max(u, s.x)),
        (s.y = Math.max(h, s.y)),
        (s.z = Math.max(d, s.z)));
    }
    (o.sub(s, r), a.add(r, s).divide(2));
  }
  computeBoundingSphere(e) {
    e || (e = this.getPosition());
    const t = e.data,
      i = e.size;
    this.bounds || this.computeBoundingBox(e);
    let r = 0;
    for (let s = 0, a = t.length; s < a; s += i)
      (c1.fromArray(t, s),
        (r = Math.max(r, this.bounds.center.squaredDistance(c1))));
    this.bounds.radius = Math.sqrt(r);
  }
  remove() {
    for (let e in this.VAOs)
      (this.gl.renderer.deleteVertexArray(this.VAOs[e]), delete this.VAOs[e]);
    for (let e in this.attributes)
      (this.gl.deleteBuffer(this.attributes[e].buffer),
        delete this.attributes[e]);
  }
}
let Zj = 1;
const h1 = {};
class Jne {
  constructor(
    e,
    {
      vertex: t,
      fragment: i,
      uniforms: r = {},
      transparent: s = !1,
      cullFace: a = e.BACK,
      frontFace: o = e.CCW,
      depthTest: l = !0,
      depthWrite: c = !0,
      depthFunc: u = e.LEQUAL,
    } = {}
  ) {
    (e.canvas || console.error('gl not passed as first argument to Program'),
      (this.gl = e),
      (this.uniforms = r),
      (this.id = Zj++),
      t || console.warn('vertex shader not supplied'),
      i || console.warn('fragment shader not supplied'),
      (this.transparent = s),
      (this.cullFace = a),
      (this.frontFace = o),
      (this.depthTest = l),
      (this.depthWrite = c),
      (this.depthFunc = u),
      (this.blendFunc = {}),
      (this.blendEquation = {}),
      (this.stencilFunc = {}),
      (this.stencilOp = {}),
      this.transparent &&
        !this.blendFunc.src &&
        (this.gl.renderer.premultipliedAlpha
          ? this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA)
          : this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA)),
      (this.vertexShader = e.createShader(e.VERTEX_SHADER)),
      (this.fragmentShader = e.createShader(e.FRAGMENT_SHADER)),
      (this.program = e.createProgram()),
      e.attachShader(this.program, this.vertexShader),
      e.attachShader(this.program, this.fragmentShader),
      this.setShaders({ vertex: t, fragment: i }));
  }
  setShaders({ vertex: e, fragment: t }) {
    if (
      (e &&
        (this.gl.shaderSource(this.vertexShader, e),
        this.gl.compileShader(this.vertexShader),
        this.gl.getShaderInfoLog(this.vertexShader) !== '' &&
          console.warn(`${this.gl.getShaderInfoLog(this.vertexShader)}
Vertex Shader
${d1(e)}`)),
      t &&
        (this.gl.shaderSource(this.fragmentShader, t),
        this.gl.compileShader(this.fragmentShader),
        this.gl.getShaderInfoLog(this.fragmentShader) !== '' &&
          console.warn(`${this.gl.getShaderInfoLog(this.fragmentShader)}
Fragment Shader
${d1(t)}`)),
      this.gl.linkProgram(this.program),
      !this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS))
    )
      return console.warn(this.gl.getProgramInfoLog(this.program));
    this.uniformLocations = new Map();
    let i = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);
    for (let a = 0; a < i; a++) {
      let o = this.gl.getActiveUniform(this.program, a);
      this.uniformLocations.set(
        o,
        this.gl.getUniformLocation(this.program, o.name)
      );
      const l = o.name.match(/(\w+)/g);
      ((o.uniformName = l[0]), (o.nameComponents = l.slice(1)));
    }
    this.attributeLocations = new Map();
    const r = [],
      s = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
    for (let a = 0; a < s; a++) {
      const o = this.gl.getActiveAttrib(this.program, a),
        l = this.gl.getAttribLocation(this.program, o.name);
      l !== -1 && ((r[l] = o.name), this.attributeLocations.set(o, l));
    }
    this.attributeOrder = r.join('');
  }
  setBlendFunc(e, t, i, r) {
    ((this.blendFunc.src = e),
      (this.blendFunc.dst = t),
      (this.blendFunc.srcAlpha = i),
      (this.blendFunc.dstAlpha = r),
      e && (this.transparent = !0));
  }
  setBlendEquation(e, t) {
    ((this.blendEquation.modeRGB = e), (this.blendEquation.modeAlpha = t));
  }
  setStencilFunc(e, t, i) {
    ((this.stencilRef = t),
      (this.stencilFunc.func = e),
      (this.stencilFunc.ref = t),
      (this.stencilFunc.mask = i));
  }
  setStencilOp(e, t, i) {
    ((this.stencilOp.stencilFail = e),
      (this.stencilOp.depthFail = t),
      (this.stencilOp.depthPass = i));
  }
  applyState() {
    (this.depthTest
      ? this.gl.renderer.enable(this.gl.DEPTH_TEST)
      : this.gl.renderer.disable(this.gl.DEPTH_TEST),
      this.cullFace
        ? this.gl.renderer.enable(this.gl.CULL_FACE)
        : this.gl.renderer.disable(this.gl.CULL_FACE),
      this.blendFunc.src
        ? this.gl.renderer.enable(this.gl.BLEND)
        : this.gl.renderer.disable(this.gl.BLEND),
      this.cullFace && this.gl.renderer.setCullFace(this.cullFace),
      this.gl.renderer.setFrontFace(this.frontFace),
      this.gl.renderer.setDepthMask(this.depthWrite),
      this.gl.renderer.setDepthFunc(this.depthFunc),
      this.blendFunc.src &&
        this.gl.renderer.setBlendFunc(
          this.blendFunc.src,
          this.blendFunc.dst,
          this.blendFunc.srcAlpha,
          this.blendFunc.dstAlpha
        ),
      this.gl.renderer.setBlendEquation(
        this.blendEquation.modeRGB,
        this.blendEquation.modeAlpha
      ),
      this.stencilFunc.func || this.stencilOp.stencilFail
        ? this.gl.renderer.enable(this.gl.STENCIL_TEST)
        : this.gl.renderer.disable(this.gl.STENCIL_TEST),
      this.gl.renderer.setStencilFunc(
        this.stencilFunc.func,
        this.stencilFunc.ref,
        this.stencilFunc.mask
      ),
      this.gl.renderer.setStencilOp(
        this.stencilOp.stencilFail,
        this.stencilOp.depthFail,
        this.stencilOp.depthPass
      ));
  }
  use({ flipFaces: e = !1 } = {}) {
    let t = -1;
    (this.gl.renderer.state.currentProgram === this.id ||
      (this.gl.useProgram(this.program),
      (this.gl.renderer.state.currentProgram = this.id)),
      this.uniformLocations.forEach((r, s) => {
        let a = this.uniforms[s.uniformName];
        for (const o of s.nameComponents) {
          if (!a) break;
          if (o in a) a = a[o];
          else {
            if (Array.isArray(a.value)) break;
            a = void 0;
            break;
          }
        }
        if (!a) return f1(`Active uniform ${s.name} has not been supplied`);
        if (a && a.value === void 0)
          return f1(`${s.name} uniform is missing a value parameter`);
        if (a.value.texture)
          return ((t = t + 1), a.value.update(t), y0(this.gl, s.type, r, t));
        if (a.value.length && a.value[0].texture) {
          const o = [];
          return (
            a.value.forEach((l) => {
              ((t = t + 1), l.update(t), o.push(t));
            }),
            y0(this.gl, s.type, r, o)
          );
        }
        y0(this.gl, s.type, r, a.value);
      }),
      this.applyState(),
      e &&
        this.gl.renderer.setFrontFace(
          this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW
        ));
  }
  remove() {
    this.gl.deleteProgram(this.program);
  }
}
function y0(n, e, t, i) {
  i = i.length ? $j(i) : i;
  const r = n.renderer.state.uniformLocations.get(t);
  if (i.length)
    if (r === void 0 || r.length !== i.length)
      n.renderer.state.uniformLocations.set(t, i.slice(0));
    else {
      if (e9(r, i)) return;
      (r.set ? r.set(i) : t9(r, i),
        n.renderer.state.uniformLocations.set(t, r));
    }
  else {
    if (r === i) return;
    n.renderer.state.uniformLocations.set(t, i);
  }
  switch (e) {
    case 5126:
      return i.length ? n.uniform1fv(t, i) : n.uniform1f(t, i);
    case 35664:
      return n.uniform2fv(t, i);
    case 35665:
      return n.uniform3fv(t, i);
    case 35666:
      return n.uniform4fv(t, i);
    case 35670:
    case 5124:
    case 35678:
    case 36306:
    case 35680:
    case 36289:
      return i.length ? n.uniform1iv(t, i) : n.uniform1i(t, i);
    case 35671:
    case 35667:
      return n.uniform2iv(t, i);
    case 35672:
    case 35668:
      return n.uniform3iv(t, i);
    case 35673:
    case 35669:
      return n.uniform4iv(t, i);
    case 35674:
      return n.uniformMatrix2fv(t, !1, i);
    case 35675:
      return n.uniformMatrix3fv(t, !1, i);
    case 35676:
      return n.uniformMatrix4fv(t, !1, i);
  }
}
function d1(n) {
  let e = n.split(`
`);
  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ': ' + e[t];
  return e.join(`
`);
}
function $j(n) {
  const e = n.length,
    t = n[0].length;
  if (t === void 0) return n;
  const i = e * t;
  let r = h1[i];
  r || (h1[i] = r = new Float32Array(i));
  for (let s = 0; s < e; s++) r.set(n[s], s * t);
  return r;
}
function e9(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function t9(n, e) {
  for (let t = 0, i = n.length; t < i; t++) n[t] = e[t];
}
let x0 = 0;
function f1(n) {
  x0 > 100 ||
    (console.warn(n),
    x0++,
    x0 > 100 &&
      console.warn('More than 100 program warnings - stopping logs.'));
}
const b0 = new Cn();
let n9 = 1;
class Qne {
  constructor({
    canvas: e = document.createElement('canvas'),
    width: t = 300,
    height: i = 150,
    dpr: r = 1,
    alpha: s = !1,
    depth: a = !0,
    stencil: o = !1,
    antialias: l = !1,
    premultipliedAlpha: c = !1,
    preserveDrawingBuffer: u = !1,
    powerPreference: h = 'default',
    autoClear: d = !0,
    webgl: f = 2,
  } = {}) {
    const p = {
      alpha: s,
      depth: a,
      stencil: o,
      antialias: l,
      premultipliedAlpha: c,
      preserveDrawingBuffer: u,
      powerPreference: h,
    };
    ((this.dpr = r),
      (this.alpha = s),
      (this.color = !0),
      (this.depth = a),
      (this.stencil = o),
      (this.premultipliedAlpha = c),
      (this.autoClear = d),
      (this.id = n9++),
      f === 2 && (this.gl = e.getContext('webgl2', p)),
      (this.isWebgl2 = !!this.gl),
      this.gl || (this.gl = e.getContext('webgl', p)),
      this.gl || console.error('unable to create webgl context'),
      (this.gl.renderer = this),
      this.setSize(t, i),
      (this.state = {}),
      (this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO }),
      (this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD }),
      (this.state.cullFace = !1),
      (this.state.frontFace = this.gl.CCW),
      (this.state.depthMask = !0),
      (this.state.depthFunc = this.gl.LEQUAL),
      (this.state.premultiplyAlpha = !1),
      (this.state.flipY = !1),
      (this.state.unpackAlignment = 4),
      (this.state.framebuffer = null),
      (this.state.viewport = { x: 0, y: 0, width: null, height: null }),
      (this.state.textureUnits = []),
      (this.state.activeTextureUnit = 0),
      (this.state.boundBuffer = null),
      (this.state.uniformLocations = new Map()),
      (this.state.currentProgram = null),
      (this.extensions = {}),
      this.isWebgl2
        ? (this.getExtension('EXT_color_buffer_float'),
          this.getExtension('OES_texture_float_linear'))
        : (this.getExtension('OES_texture_float'),
          this.getExtension('OES_texture_float_linear'),
          this.getExtension('OES_texture_half_float'),
          this.getExtension('OES_texture_half_float_linear'),
          this.getExtension('OES_element_index_uint'),
          this.getExtension('OES_standard_derivatives'),
          this.getExtension('EXT_sRGB'),
          this.getExtension('WEBGL_depth_texture'),
          this.getExtension('WEBGL_draw_buffers')),
      this.getExtension('WEBGL_compressed_texture_astc'),
      this.getExtension('EXT_texture_compression_bptc'),
      this.getExtension('WEBGL_compressed_texture_s3tc'),
      this.getExtension('WEBGL_compressed_texture_etc1'),
      this.getExtension('WEBGL_compressed_texture_pvrtc'),
      this.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
      (this.vertexAttribDivisor = this.getExtension(
        'ANGLE_instanced_arrays',
        'vertexAttribDivisor',
        'vertexAttribDivisorANGLE'
      )),
      (this.drawArraysInstanced = this.getExtension(
        'ANGLE_instanced_arrays',
        'drawArraysInstanced',
        'drawArraysInstancedANGLE'
      )),
      (this.drawElementsInstanced = this.getExtension(
        'ANGLE_instanced_arrays',
        'drawElementsInstanced',
        'drawElementsInstancedANGLE'
      )),
      (this.createVertexArray = this.getExtension(
        'OES_vertex_array_object',
        'createVertexArray',
        'createVertexArrayOES'
      )),
      (this.bindVertexArray = this.getExtension(
        'OES_vertex_array_object',
        'bindVertexArray',
        'bindVertexArrayOES'
      )),
      (this.deleteVertexArray = this.getExtension(
        'OES_vertex_array_object',
        'deleteVertexArray',
        'deleteVertexArrayOES'
      )),
      (this.drawBuffers = this.getExtension(
        'WEBGL_draw_buffers',
        'drawBuffers',
        'drawBuffersWEBGL'
      )),
      (this.parameters = {}),
      (this.parameters.maxTextureUnits = this.gl.getParameter(
        this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS
      )),
      (this.parameters.maxAnisotropy = this.getExtension(
        'EXT_texture_filter_anisotropic'
      )
        ? this.gl.getParameter(
            this.getExtension('EXT_texture_filter_anisotropic')
              .MAX_TEXTURE_MAX_ANISOTROPY_EXT
          )
        : 0));
  }
  setSize(e, t) {
    ((this.width = e),
      (this.height = t),
      (this.gl.canvas.width = e * this.dpr),
      (this.gl.canvas.height = t * this.dpr),
      this.gl.canvas.style &&
        Object.assign(this.gl.canvas.style, {
          width: e + 'px',
          height: t + 'px',
        }));
  }
  setViewport(e, t, i = 0, r = 0) {
    (this.state.viewport.width === e && this.state.viewport.height === t) ||
      ((this.state.viewport.width = e),
      (this.state.viewport.height = t),
      (this.state.viewport.x = i),
      (this.state.viewport.y = r),
      this.gl.viewport(i, r, e, t));
  }
  setScissor(e, t, i = 0, r = 0) {
    this.gl.scissor(i, r, e, t);
  }
  enable(e) {
    this.state[e] !== !0 && (this.gl.enable(e), (this.state[e] = !0));
  }
  disable(e) {
    this.state[e] !== !1 && (this.gl.disable(e), (this.state[e] = !1));
  }
  setBlendFunc(e, t, i, r) {
    (this.state.blendFunc.src === e &&
      this.state.blendFunc.dst === t &&
      this.state.blendFunc.srcAlpha === i &&
      this.state.blendFunc.dstAlpha === r) ||
      ((this.state.blendFunc.src = e),
      (this.state.blendFunc.dst = t),
      (this.state.blendFunc.srcAlpha = i),
      (this.state.blendFunc.dstAlpha = r),
      i !== void 0
        ? this.gl.blendFuncSeparate(e, t, i, r)
        : this.gl.blendFunc(e, t));
  }
  setBlendEquation(e, t) {
    ((e = e || this.gl.FUNC_ADD),
      !(
        this.state.blendEquation.modeRGB === e &&
        this.state.blendEquation.modeAlpha === t
      ) &&
        ((this.state.blendEquation.modeRGB = e),
        (this.state.blendEquation.modeAlpha = t),
        t !== void 0
          ? this.gl.blendEquationSeparate(e, t)
          : this.gl.blendEquation(e)));
  }
  setCullFace(e) {
    this.state.cullFace !== e &&
      ((this.state.cullFace = e), this.gl.cullFace(e));
  }
  setFrontFace(e) {
    this.state.frontFace !== e &&
      ((this.state.frontFace = e), this.gl.frontFace(e));
  }
  setDepthMask(e) {
    this.state.depthMask !== e &&
      ((this.state.depthMask = e), this.gl.depthMask(e));
  }
  setDepthFunc(e) {
    this.state.depthFunc !== e &&
      ((this.state.depthFunc = e), this.gl.depthFunc(e));
  }
  setStencilMask(e) {
    this.state.stencilMask !== e &&
      ((this.state.stencilMask = e), this.gl.stencilMask(e));
  }
  setStencilFunc(e, t, i) {
    (this.state.stencilFunc === e &&
      this.state.stencilRef === t &&
      this.state.stencilFuncMask === i) ||
      ((this.state.stencilFunc = e || this.gl.ALWAYS),
      (this.state.stencilRef = t || 0),
      (this.state.stencilFuncMask = i || 0),
      this.gl.stencilFunc(e || this.gl.ALWAYS, t || 0, i || 0));
  }
  setStencilOp(e, t, i) {
    (this.state.stencilFail === e &&
      this.state.stencilDepthFail === t &&
      this.state.stencilDepthPass === i) ||
      ((this.state.stencilFail = e),
      (this.state.stencilDepthFail = t),
      (this.state.stencilDepthPass = i),
      this.gl.stencilOp(e, t, i));
  }
  activeTexture(e) {
    this.state.activeTextureUnit !== e &&
      ((this.state.activeTextureUnit = e),
      this.gl.activeTexture(this.gl.TEXTURE0 + e));
  }
  bindFramebuffer({ target: e = this.gl.FRAMEBUFFER, buffer: t = null } = {}) {
    this.state.framebuffer !== t &&
      ((this.state.framebuffer = t), this.gl.bindFramebuffer(e, t));
  }
  getExtension(e, t, i) {
    return t && this.gl[t]
      ? this.gl[t].bind(this.gl)
      : (this.extensions[e] || (this.extensions[e] = this.gl.getExtension(e)),
        t
          ? this.extensions[e]
            ? this.extensions[e][i].bind(this.extensions[e])
            : null
          : this.extensions[e]);
  }
  sortOpaque(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.program.id !== t.program.id
        ? e.program.id - t.program.id
        : e.zDepth !== t.zDepth
          ? e.zDepth - t.zDepth
          : t.id - e.id;
  }
  sortTransparent(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.zDepth !== t.zDepth
        ? t.zDepth - e.zDepth
        : t.id - e.id;
  }
  sortUI(e, t) {
    return e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.program.id !== t.program.id
        ? e.program.id - t.program.id
        : t.id - e.id;
  }
  getRenderList({ scene: e, camera: t, frustumCull: i, sort: r }) {
    let s = [];
    if (
      (t && i && t.updateFrustum(),
      e.traverse((a) => {
        if (!a.visible) return !0;
        a.draw &&
          ((i && a.frustumCulled && t && !t.frustumIntersectsMesh(a)) ||
            s.push(a));
      }),
      r)
    ) {
      const a = [],
        o = [],
        l = [];
      (s.forEach((c) => {
        (c.program.transparent
          ? c.program.depthTest
            ? o.push(c)
            : l.push(c)
          : a.push(c),
          (c.zDepth = 0),
          !(c.renderOrder !== 0 || !c.program.depthTest || !t) &&
            (c.worldMatrix.getTranslation(b0),
            b0.applyMatrix4(t.projectionViewMatrix),
            (c.zDepth = b0.z)));
      }),
        a.sort(this.sortOpaque),
        o.sort(this.sortTransparent),
        l.sort(this.sortUI),
        (s = a.concat(o, l)));
    }
    return s;
  }
  render({
    scene: e,
    camera: t,
    target: i = null,
    update: r = !0,
    sort: s = !0,
    frustumCull: a = !0,
    clear: o,
  }) {
    (i === null
      ? (this.bindFramebuffer(),
        this.setViewport(this.width * this.dpr, this.height * this.dpr))
      : (this.bindFramebuffer(i), this.setViewport(i.width, i.height)),
      (o || (this.autoClear && o !== !1)) &&
        (this.depth &&
          (!i || i.depth) &&
          (this.enable(this.gl.DEPTH_TEST), this.setDepthMask(!0)),
        (this.stencil || !i || i.stencil) &&
          (this.enable(this.gl.STENCIL_TEST), this.setStencilMask(255)),
        this.gl.clear(
          (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |
            (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |
            (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)
        )),
      r && e.updateMatrixWorld(),
      t && t.updateMatrixWorld(),
      this.getRenderList({
        scene: e,
        camera: t,
        frustumCull: a,
        sort: s,
      }).forEach((c) => {
        c.draw({ camera: t });
      }));
  }
}
function i9(n, e) {
  return ((n[0] = e[0]), (n[1] = e[1]), (n[2] = e[2]), (n[3] = e[3]), n);
}
function r9(n, e, t, i, r) {
  return ((n[0] = e), (n[1] = t), (n[2] = i), (n[3] = r), n);
}
function s9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = t * t + i * i + r * r + s * s;
  return (
    a > 0 && (a = 1 / Math.sqrt(a)),
    (n[0] = t * a),
    (n[1] = i * a),
    (n[2] = r * a),
    (n[3] = s * a),
    n
  );
}
function a9(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] * e[3];
}
function o9(n) {
  return ((n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 1), n);
}
function l9(n, e, t) {
  t = t * 0.5;
  let i = Math.sin(t);
  return (
    (n[0] = i * e[0]),
    (n[1] = i * e[1]),
    (n[2] = i * e[2]),
    (n[3] = Math.cos(t)),
    n
  );
}
function p1(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = t[0],
    l = t[1],
    c = t[2],
    u = t[3];
  return (
    (n[0] = i * u + a * o + r * c - s * l),
    (n[1] = r * u + a * l + s * o - i * c),
    (n[2] = s * u + a * c + i * l - r * o),
    (n[3] = a * u - i * o - r * l - s * c),
    n
  );
}
function c9(n, e, t) {
  t *= 0.5;
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = i * l + a * o),
    (n[1] = r * l + s * o),
    (n[2] = s * l - r * o),
    (n[3] = a * l - i * o),
    n
  );
}
function u9(n, e, t) {
  t *= 0.5;
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = i * l - s * o),
    (n[1] = r * l + a * o),
    (n[2] = s * l + i * o),
    (n[3] = a * l - r * o),
    n
  );
}
function h9(n, e, t) {
  t *= 0.5;
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = Math.sin(t),
    l = Math.cos(t);
  return (
    (n[0] = i * l + r * o),
    (n[1] = r * l - i * o),
    (n[2] = s * l + a * o),
    (n[3] = a * l - s * o),
    n
  );
}
function d9(n, e, t, i) {
  let r = e[0],
    s = e[1],
    a = e[2],
    o = e[3],
    l = t[0],
    c = t[1],
    u = t[2],
    h = t[3],
    d,
    f,
    p,
    m,
    g;
  return (
    (f = r * l + s * c + a * u + o * h),
    f < 0 && ((f = -f), (l = -l), (c = -c), (u = -u), (h = -h)),
    1 - f > 1e-6
      ? ((d = Math.acos(f)),
        (p = Math.sin(d)),
        (m = Math.sin((1 - i) * d) / p),
        (g = Math.sin(i * d) / p))
      : ((m = 1 - i), (g = i)),
    (n[0] = m * r + g * l),
    (n[1] = m * s + g * c),
    (n[2] = m * a + g * u),
    (n[3] = m * o + g * h),
    n
  );
}
function f9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = t * t + i * i + r * r + s * s,
    o = a ? 1 / a : 0;
  return ((n[0] = -t * o), (n[1] = -i * o), (n[2] = -r * o), (n[3] = s * o), n);
}
function p9(n, e) {
  return ((n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), (n[3] = e[3]), n);
}
function m9(n, e) {
  let t = e[0] + e[4] + e[8],
    i;
  if (t > 0)
    ((i = Math.sqrt(t + 1)),
      (n[3] = 0.5 * i),
      (i = 0.5 / i),
      (n[0] = (e[5] - e[7]) * i),
      (n[1] = (e[6] - e[2]) * i),
      (n[2] = (e[1] - e[3]) * i));
  else {
    let r = 0;
    (e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2));
    let s = (r + 1) % 3,
      a = (r + 2) % 3;
    ((i = Math.sqrt(e[r * 3 + r] - e[s * 3 + s] - e[a * 3 + a] + 1)),
      (n[r] = 0.5 * i),
      (i = 0.5 / i),
      (n[3] = (e[s * 3 + a] - e[a * 3 + s]) * i),
      (n[s] = (e[s * 3 + r] + e[r * 3 + s]) * i),
      (n[a] = (e[a * 3 + r] + e[r * 3 + a]) * i));
  }
  return n;
}
function g9(n, e, t = 'YXZ') {
  let i = Math.sin(e[0] * 0.5),
    r = Math.cos(e[0] * 0.5),
    s = Math.sin(e[1] * 0.5),
    a = Math.cos(e[1] * 0.5),
    o = Math.sin(e[2] * 0.5),
    l = Math.cos(e[2] * 0.5);
  return (
    t === 'XYZ'
      ? ((n[0] = i * a * l + r * s * o),
        (n[1] = r * s * l - i * a * o),
        (n[2] = r * a * o + i * s * l),
        (n[3] = r * a * l - i * s * o))
      : t === 'YXZ'
        ? ((n[0] = i * a * l + r * s * o),
          (n[1] = r * s * l - i * a * o),
          (n[2] = r * a * o - i * s * l),
          (n[3] = r * a * l + i * s * o))
        : t === 'ZXY'
          ? ((n[0] = i * a * l - r * s * o),
            (n[1] = r * s * l + i * a * o),
            (n[2] = r * a * o + i * s * l),
            (n[3] = r * a * l - i * s * o))
          : t === 'ZYX'
            ? ((n[0] = i * a * l - r * s * o),
              (n[1] = r * s * l + i * a * o),
              (n[2] = r * a * o - i * s * l),
              (n[3] = r * a * l + i * s * o))
            : t === 'YZX'
              ? ((n[0] = i * a * l + r * s * o),
                (n[1] = r * s * l + i * a * o),
                (n[2] = r * a * o - i * s * l),
                (n[3] = r * a * l - i * s * o))
              : t === 'XZY' &&
                ((n[0] = i * a * l - r * s * o),
                (n[1] = r * s * l - i * a * o),
                (n[2] = r * a * o + i * s * l),
                (n[3] = r * a * l + i * s * o)),
    n
  );
}
const v9 = i9,
  _9 = r9,
  y9 = a9,
  x9 = s9;
class b9 extends Array {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (super(e, t, i, r), (this.onChange = () => {}), (this._target = this));
    const s = ['0', '1', '2', '3'];
    return new Proxy(this, {
      set(a, o) {
        const l = Reflect.set(...arguments);
        return (l && s.includes(o) && a.onChange(), l);
      },
    });
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  get w() {
    return this[3];
  }
  set x(e) {
    ((this._target[0] = e), this.onChange());
  }
  set y(e) {
    ((this._target[1] = e), this.onChange());
  }
  set z(e) {
    ((this._target[2] = e), this.onChange());
  }
  set w(e) {
    ((this._target[3] = e), this.onChange());
  }
  identity() {
    return (o9(this._target), this.onChange(), this);
  }
  set(e, t, i, r) {
    return e.length
      ? this.copy(e)
      : (_9(this._target, e, t, i, r), this.onChange(), this);
  }
  rotateX(e) {
    return (c9(this._target, this._target, e), this.onChange(), this);
  }
  rotateY(e) {
    return (u9(this._target, this._target, e), this.onChange(), this);
  }
  rotateZ(e) {
    return (h9(this._target, this._target, e), this.onChange(), this);
  }
  inverse(e = this._target) {
    return (f9(this._target, e), this.onChange(), this);
  }
  conjugate(e = this._target) {
    return (p9(this._target, e), this.onChange(), this);
  }
  copy(e) {
    return (v9(this._target, e), this.onChange(), this);
  }
  normalize(e = this._target) {
    return (x9(this._target, e), this.onChange(), this);
  }
  multiply(e, t) {
    return (
      t ? p1(this._target, e, t) : p1(this._target, this._target, e),
      this.onChange(),
      this
    );
  }
  dot(e) {
    return y9(this._target, e);
  }
  fromMatrix3(e) {
    return (m9(this._target, e), this.onChange(), this);
  }
  fromEuler(e, t) {
    return (g9(this._target, e, e.order), t || this.onChange(), this);
  }
  fromAxisAngle(e, t) {
    return (l9(this._target, e, t), this.onChange(), this);
  }
  slerp(e, t) {
    return (d9(this._target, this._target, e, t), this.onChange(), this);
  }
  fromArray(e, t = 0) {
    return (
      (this._target[0] = e[t]),
      (this._target[1] = e[t + 1]),
      (this._target[2] = e[t + 2]),
      (this._target[3] = e[t + 3]),
      this.onChange(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this[0]),
      (e[t + 1] = this[1]),
      (e[t + 2] = this[2]),
      (e[t + 3] = this[3]),
      e
    );
  }
}
const S9 = 1e-6;
function w9(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[3]),
    (n[4] = e[4]),
    (n[5] = e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    (n[9] = e[9]),
    (n[10] = e[10]),
    (n[11] = e[11]),
    (n[12] = e[12]),
    (n[13] = e[13]),
    (n[14] = e[14]),
    (n[15] = e[15]),
    n
  );
}
function E9(n, e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g) {
  return (
    (n[0] = e),
    (n[1] = t),
    (n[2] = i),
    (n[3] = r),
    (n[4] = s),
    (n[5] = a),
    (n[6] = o),
    (n[7] = l),
    (n[8] = c),
    (n[9] = u),
    (n[10] = h),
    (n[11] = d),
    (n[12] = f),
    (n[13] = p),
    (n[14] = m),
    (n[15] = g),
    n
  );
}
function A9(n) {
  return (
    (n[0] = 1),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = 1),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = 1),
    (n[11] = 0),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 0),
    (n[15] = 1),
    n
  );
}
function M9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    u = e[8],
    h = e[9],
    d = e[10],
    f = e[11],
    p = e[12],
    m = e[13],
    g = e[14],
    v = e[15],
    y = t * o - i * a,
    _ = t * l - r * a,
    x = t * c - s * a,
    S = i * l - r * o,
    b = i * c - s * o,
    A = r * c - s * l,
    E = u * m - h * p,
    w = u * g - d * p,
    M = u * v - f * p,
    T = h * g - d * m,
    D = h * v - f * m,
    L = d * v - f * g,
    O = y * L - _ * D + x * T + S * M - b * w + A * E;
  return O
    ? ((O = 1 / O),
      (n[0] = (o * L - l * D + c * T) * O),
      (n[1] = (r * D - i * L - s * T) * O),
      (n[2] = (m * A - g * b + v * S) * O),
      (n[3] = (d * b - h * A - f * S) * O),
      (n[4] = (l * M - a * L - c * w) * O),
      (n[5] = (t * L - r * M + s * w) * O),
      (n[6] = (g * x - p * A - v * _) * O),
      (n[7] = (u * A - d * x + f * _) * O),
      (n[8] = (a * D - o * M + c * E) * O),
      (n[9] = (i * M - t * D - s * E) * O),
      (n[10] = (p * b - m * x + v * y) * O),
      (n[11] = (h * x - u * b - f * y) * O),
      (n[12] = (o * w - a * T - l * E) * O),
      (n[13] = (t * T - i * w + r * E) * O),
      (n[14] = (m * _ - p * S - g * y) * O),
      (n[15] = (u * S - h * _ + d * y) * O),
      n)
    : null;
}
function RD(n) {
  let e = n[0],
    t = n[1],
    i = n[2],
    r = n[3],
    s = n[4],
    a = n[5],
    o = n[6],
    l = n[7],
    c = n[8],
    u = n[9],
    h = n[10],
    d = n[11],
    f = n[12],
    p = n[13],
    m = n[14],
    g = n[15],
    v = e * a - t * s,
    y = e * o - i * s,
    _ = e * l - r * s,
    x = t * o - i * a,
    S = t * l - r * a,
    b = i * l - r * o,
    A = c * p - u * f,
    E = c * m - h * f,
    w = c * g - d * f,
    M = u * m - h * p,
    T = u * g - d * p,
    D = h * g - d * m;
  return v * D - y * T + _ * M + x * w - S * E + b * A;
}
function m1(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    u = e[7],
    h = e[8],
    d = e[9],
    f = e[10],
    p = e[11],
    m = e[12],
    g = e[13],
    v = e[14],
    y = e[15],
    _ = t[0],
    x = t[1],
    S = t[2],
    b = t[3];
  return (
    (n[0] = _ * i + x * o + S * h + b * m),
    (n[1] = _ * r + x * l + S * d + b * g),
    (n[2] = _ * s + x * c + S * f + b * v),
    (n[3] = _ * a + x * u + S * p + b * y),
    (_ = t[4]),
    (x = t[5]),
    (S = t[6]),
    (b = t[7]),
    (n[4] = _ * i + x * o + S * h + b * m),
    (n[5] = _ * r + x * l + S * d + b * g),
    (n[6] = _ * s + x * c + S * f + b * v),
    (n[7] = _ * a + x * u + S * p + b * y),
    (_ = t[8]),
    (x = t[9]),
    (S = t[10]),
    (b = t[11]),
    (n[8] = _ * i + x * o + S * h + b * m),
    (n[9] = _ * r + x * l + S * d + b * g),
    (n[10] = _ * s + x * c + S * f + b * v),
    (n[11] = _ * a + x * u + S * p + b * y),
    (_ = t[12]),
    (x = t[13]),
    (S = t[14]),
    (b = t[15]),
    (n[12] = _ * i + x * o + S * h + b * m),
    (n[13] = _ * r + x * l + S * d + b * g),
    (n[14] = _ * s + x * c + S * f + b * v),
    (n[15] = _ * a + x * u + S * p + b * y),
    n
  );
}
function T9(n, e, t) {
  let i = t[0],
    r = t[1],
    s = t[2],
    a,
    o,
    l,
    c,
    u,
    h,
    d,
    f,
    p,
    m,
    g,
    v;
  return (
    e === n
      ? ((n[12] = e[0] * i + e[4] * r + e[8] * s + e[12]),
        (n[13] = e[1] * i + e[5] * r + e[9] * s + e[13]),
        (n[14] = e[2] * i + e[6] * r + e[10] * s + e[14]),
        (n[15] = e[3] * i + e[7] * r + e[11] * s + e[15]))
      : ((a = e[0]),
        (o = e[1]),
        (l = e[2]),
        (c = e[3]),
        (u = e[4]),
        (h = e[5]),
        (d = e[6]),
        (f = e[7]),
        (p = e[8]),
        (m = e[9]),
        (g = e[10]),
        (v = e[11]),
        (n[0] = a),
        (n[1] = o),
        (n[2] = l),
        (n[3] = c),
        (n[4] = u),
        (n[5] = h),
        (n[6] = d),
        (n[7] = f),
        (n[8] = p),
        (n[9] = m),
        (n[10] = g),
        (n[11] = v),
        (n[12] = a * i + u * r + p * s + e[12]),
        (n[13] = o * i + h * r + m * s + e[13]),
        (n[14] = l * i + d * r + g * s + e[14]),
        (n[15] = c * i + f * r + v * s + e[15])),
    n
  );
}
function C9(n, e, t) {
  let i = t[0],
    r = t[1],
    s = t[2];
  return (
    (n[0] = e[0] * i),
    (n[1] = e[1] * i),
    (n[2] = e[2] * i),
    (n[3] = e[3] * i),
    (n[4] = e[4] * r),
    (n[5] = e[5] * r),
    (n[6] = e[6] * r),
    (n[7] = e[7] * r),
    (n[8] = e[8] * s),
    (n[9] = e[9] * s),
    (n[10] = e[10] * s),
    (n[11] = e[11] * s),
    (n[12] = e[12]),
    (n[13] = e[13]),
    (n[14] = e[14]),
    (n[15] = e[15]),
    n
  );
}
function R9(n, e, t, i) {
  let r = i[0],
    s = i[1],
    a = i[2],
    o = Math.hypot(r, s, a),
    l,
    c,
    u,
    h,
    d,
    f,
    p,
    m,
    g,
    v,
    y,
    _,
    x,
    S,
    b,
    A,
    E,
    w,
    M,
    T,
    D,
    L,
    O,
    z;
  return Math.abs(o) < S9
    ? null
    : ((o = 1 / o),
      (r *= o),
      (s *= o),
      (a *= o),
      (l = Math.sin(t)),
      (c = Math.cos(t)),
      (u = 1 - c),
      (h = e[0]),
      (d = e[1]),
      (f = e[2]),
      (p = e[3]),
      (m = e[4]),
      (g = e[5]),
      (v = e[6]),
      (y = e[7]),
      (_ = e[8]),
      (x = e[9]),
      (S = e[10]),
      (b = e[11]),
      (A = r * r * u + c),
      (E = s * r * u + a * l),
      (w = a * r * u - s * l),
      (M = r * s * u - a * l),
      (T = s * s * u + c),
      (D = a * s * u + r * l),
      (L = r * a * u + s * l),
      (O = s * a * u - r * l),
      (z = a * a * u + c),
      (n[0] = h * A + m * E + _ * w),
      (n[1] = d * A + g * E + x * w),
      (n[2] = f * A + v * E + S * w),
      (n[3] = p * A + y * E + b * w),
      (n[4] = h * M + m * T + _ * D),
      (n[5] = d * M + g * T + x * D),
      (n[6] = f * M + v * T + S * D),
      (n[7] = p * M + y * T + b * D),
      (n[8] = h * L + m * O + _ * z),
      (n[9] = d * L + g * O + x * z),
      (n[10] = f * L + v * O + S * z),
      (n[11] = p * L + y * O + b * z),
      e !== n &&
        ((n[12] = e[12]), (n[13] = e[13]), (n[14] = e[14]), (n[15] = e[15])),
      n);
}
function I9(n, e) {
  return ((n[0] = e[12]), (n[1] = e[13]), (n[2] = e[14]), n);
}
function ID(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[4],
    a = e[5],
    o = e[6],
    l = e[8],
    c = e[9],
    u = e[10];
  return (
    (n[0] = Math.hypot(t, i, r)),
    (n[1] = Math.hypot(s, a, o)),
    (n[2] = Math.hypot(l, c, u)),
    n
  );
}
function P9(n) {
  let e = n[0],
    t = n[1],
    i = n[2],
    r = n[4],
    s = n[5],
    a = n[6],
    o = n[8],
    l = n[9],
    c = n[10];
  const u = e * e + t * t + i * i,
    h = r * r + s * s + a * a,
    d = o * o + l * l + c * c;
  return Math.sqrt(Math.max(u, h, d));
}
const PD = (function () {
  const n = [1, 1, 1];
  return function (e, t) {
    let i = n;
    ID(i, t);
    let r = 1 / i[0],
      s = 1 / i[1],
      a = 1 / i[2],
      o = t[0] * r,
      l = t[1] * s,
      c = t[2] * a,
      u = t[4] * r,
      h = t[5] * s,
      d = t[6] * a,
      f = t[8] * r,
      p = t[9] * s,
      m = t[10] * a,
      g = o + h + m,
      v = 0;
    return (
      g > 0
        ? ((v = Math.sqrt(g + 1) * 2),
          (e[3] = 0.25 * v),
          (e[0] = (d - p) / v),
          (e[1] = (f - c) / v),
          (e[2] = (l - u) / v))
        : o > h && o > m
          ? ((v = Math.sqrt(1 + o - h - m) * 2),
            (e[3] = (d - p) / v),
            (e[0] = 0.25 * v),
            (e[1] = (l + u) / v),
            (e[2] = (f + c) / v))
          : h > m
            ? ((v = Math.sqrt(1 + h - o - m) * 2),
              (e[3] = (f - c) / v),
              (e[0] = (l + u) / v),
              (e[1] = 0.25 * v),
              (e[2] = (d + p) / v))
            : ((v = Math.sqrt(1 + m - o - h) * 2),
              (e[3] = (l - u) / v),
              (e[0] = (f + c) / v),
              (e[1] = (d + p) / v),
              (e[2] = 0.25 * v)),
      e
    );
  };
})();
function D9(n, e, t, i) {
  let r = Ru([n[0], n[1], n[2]]);
  const s = Ru([n[4], n[5], n[6]]),
    a = Ru([n[8], n[9], n[10]]);
  (RD(n) < 0 && (r = -r), (t[0] = n[12]), (t[1] = n[13]), (t[2] = n[14]));
  const l = n.slice(),
    c = 1 / r,
    u = 1 / s,
    h = 1 / a;
  ((l[0] *= c),
    (l[1] *= c),
    (l[2] *= c),
    (l[4] *= u),
    (l[5] *= u),
    (l[6] *= u),
    (l[8] *= h),
    (l[9] *= h),
    (l[10] *= h),
    PD(e, l),
    (i[0] = r),
    (i[1] = s),
    (i[2] = a));
}
function O9(n, e, t, i) {
  const r = n,
    s = e[0],
    a = e[1],
    o = e[2],
    l = e[3],
    c = s + s,
    u = a + a,
    h = o + o,
    d = s * c,
    f = s * u,
    p = s * h,
    m = a * u,
    g = a * h,
    v = o * h,
    y = l * c,
    _ = l * u,
    x = l * h,
    S = i[0],
    b = i[1],
    A = i[2];
  return (
    (r[0] = (1 - (m + v)) * S),
    (r[1] = (f + x) * S),
    (r[2] = (p - _) * S),
    (r[3] = 0),
    (r[4] = (f - x) * b),
    (r[5] = (1 - (d + v)) * b),
    (r[6] = (g + y) * b),
    (r[7] = 0),
    (r[8] = (p + _) * A),
    (r[9] = (g - y) * A),
    (r[10] = (1 - (d + m)) * A),
    (r[11] = 0),
    (r[12] = t[0]),
    (r[13] = t[1]),
    (r[14] = t[2]),
    (r[15] = 1),
    r
  );
}
function L9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = t + t,
    o = i + i,
    l = r + r,
    c = t * a,
    u = i * a,
    h = i * o,
    d = r * a,
    f = r * o,
    p = r * l,
    m = s * a,
    g = s * o,
    v = s * l;
  return (
    (n[0] = 1 - h - p),
    (n[1] = u + v),
    (n[2] = d - g),
    (n[3] = 0),
    (n[4] = u - v),
    (n[5] = 1 - c - p),
    (n[6] = f + m),
    (n[7] = 0),
    (n[8] = d + g),
    (n[9] = f - m),
    (n[10] = 1 - c - h),
    (n[11] = 0),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 0),
    (n[15] = 1),
    n
  );
}
function U9(n, e, t, i, r) {
  let s = 1 / Math.tan(e / 2),
    a = 1 / (i - r);
  return (
    (n[0] = s / t),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = s),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = (r + i) * a),
    (n[11] = -1),
    (n[12] = 0),
    (n[13] = 0),
    (n[14] = 2 * r * i * a),
    (n[15] = 0),
    n
  );
}
function k9(n, e, t, i, r, s, a) {
  let o = 1 / (e - t),
    l = 1 / (i - r),
    c = 1 / (s - a);
  return (
    (n[0] = -2 * o),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 0),
    (n[5] = -2 * l),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 0),
    (n[9] = 0),
    (n[10] = 2 * c),
    (n[11] = 0),
    (n[12] = (e + t) * o),
    (n[13] = (r + i) * l),
    (n[14] = (a + s) * c),
    (n[15] = 1),
    n
  );
}
function B9(n, e, t, i) {
  let r = e[0],
    s = e[1],
    a = e[2],
    o = i[0],
    l = i[1],
    c = i[2],
    u = r - t[0],
    h = s - t[1],
    d = a - t[2],
    f = u * u + h * h + d * d;
  f === 0 ? (d = 1) : ((f = 1 / Math.sqrt(f)), (u *= f), (h *= f), (d *= f));
  let p = l * d - c * h,
    m = c * u - o * d,
    g = o * h - l * u;
  return (
    (f = p * p + m * m + g * g),
    f === 0 &&
      (c ? (o += 1e-6) : l ? (c += 1e-6) : (l += 1e-6),
      (p = l * d - c * h),
      (m = c * u - o * d),
      (g = o * h - l * u),
      (f = p * p + m * m + g * g)),
    (f = 1 / Math.sqrt(f)),
    (p *= f),
    (m *= f),
    (g *= f),
    (n[0] = p),
    (n[1] = m),
    (n[2] = g),
    (n[3] = 0),
    (n[4] = h * g - d * m),
    (n[5] = d * p - u * g),
    (n[6] = u * m - h * p),
    (n[7] = 0),
    (n[8] = u),
    (n[9] = h),
    (n[10] = d),
    (n[11] = 0),
    (n[12] = r),
    (n[13] = s),
    (n[14] = a),
    (n[15] = 1),
    n
  );
}
function g1(n, e, t) {
  return (
    (n[0] = e[0] + t[0]),
    (n[1] = e[1] + t[1]),
    (n[2] = e[2] + t[2]),
    (n[3] = e[3] + t[3]),
    (n[4] = e[4] + t[4]),
    (n[5] = e[5] + t[5]),
    (n[6] = e[6] + t[6]),
    (n[7] = e[7] + t[7]),
    (n[8] = e[8] + t[8]),
    (n[9] = e[9] + t[9]),
    (n[10] = e[10] + t[10]),
    (n[11] = e[11] + t[11]),
    (n[12] = e[12] + t[12]),
    (n[13] = e[13] + t[13]),
    (n[14] = e[14] + t[14]),
    (n[15] = e[15] + t[15]),
    n
  );
}
function v1(n, e, t) {
  return (
    (n[0] = e[0] - t[0]),
    (n[1] = e[1] - t[1]),
    (n[2] = e[2] - t[2]),
    (n[3] = e[3] - t[3]),
    (n[4] = e[4] - t[4]),
    (n[5] = e[5] - t[5]),
    (n[6] = e[6] - t[6]),
    (n[7] = e[7] - t[7]),
    (n[8] = e[8] - t[8]),
    (n[9] = e[9] - t[9]),
    (n[10] = e[10] - t[10]),
    (n[11] = e[11] - t[11]),
    (n[12] = e[12] - t[12]),
    (n[13] = e[13] - t[13]),
    (n[14] = e[14] - t[14]),
    (n[15] = e[15] - t[15]),
    n
  );
}
function N9(n, e, t) {
  return (
    (n[0] = e[0] * t),
    (n[1] = e[1] * t),
    (n[2] = e[2] * t),
    (n[3] = e[3] * t),
    (n[4] = e[4] * t),
    (n[5] = e[5] * t),
    (n[6] = e[6] * t),
    (n[7] = e[7] * t),
    (n[8] = e[8] * t),
    (n[9] = e[9] * t),
    (n[10] = e[10] * t),
    (n[11] = e[11] * t),
    (n[12] = e[12] * t),
    (n[13] = e[13] * t),
    (n[14] = e[14] * t),
    (n[15] = e[15] * t),
    n
  );
}
class qs extends Array {
  constructor(
    e = 1,
    t = 0,
    i = 0,
    r = 0,
    s = 0,
    a = 1,
    o = 0,
    l = 0,
    c = 0,
    u = 0,
    h = 1,
    d = 0,
    f = 0,
    p = 0,
    m = 0,
    g = 1
  ) {
    return (super(e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g), this);
  }
  get x() {
    return this[12];
  }
  get y() {
    return this[13];
  }
  get z() {
    return this[14];
  }
  get w() {
    return this[15];
  }
  set x(e) {
    this[12] = e;
  }
  set y(e) {
    this[13] = e;
  }
  set z(e) {
    this[14] = e;
  }
  set w(e) {
    this[15] = e;
  }
  set(e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g) {
    return e.length
      ? this.copy(e)
      : (E9(this, e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g), this);
  }
  translate(e, t = this) {
    return (T9(this, t, e), this);
  }
  rotate(e, t, i = this) {
    return (R9(this, i, e, t), this);
  }
  scale(e, t = this) {
    return (C9(this, t, typeof e == 'number' ? [e, e, e] : e), this);
  }
  add(e, t) {
    return (t ? g1(this, e, t) : g1(this, this, e), this);
  }
  sub(e, t) {
    return (t ? v1(this, e, t) : v1(this, this, e), this);
  }
  multiply(e, t) {
    return (
      e.length ? (t ? m1(this, e, t) : m1(this, this, e)) : N9(this, this, e),
      this
    );
  }
  identity() {
    return (A9(this), this);
  }
  copy(e) {
    return (w9(this, e), this);
  }
  fromPerspective({ fov: e, aspect: t, near: i, far: r } = {}) {
    return (U9(this, e, t, i, r), this);
  }
  fromOrthogonal({ left: e, right: t, bottom: i, top: r, near: s, far: a }) {
    return (k9(this, e, t, i, r, s, a), this);
  }
  fromQuaternion(e) {
    return (L9(this, e), this);
  }
  setPosition(e) {
    return ((this.x = e[0]), (this.y = e[1]), (this.z = e[2]), this);
  }
  inverse(e = this) {
    return (M9(this, e), this);
  }
  compose(e, t, i) {
    return (O9(this, e, t, i), this);
  }
  decompose(e, t, i) {
    return (D9(this, e, t, i), this);
  }
  getRotation(e) {
    return (PD(e, this), this);
  }
  getTranslation(e) {
    return (I9(e, this), this);
  }
  getScaling(e) {
    return (ID(e, this), this);
  }
  getMaxScaleOnAxis() {
    return P9(this);
  }
  lookAt(e, t, i) {
    return (B9(this, e, t, i), this);
  }
  determinant() {
    return RD(this);
  }
  fromArray(e, t = 0) {
    return (
      (this[0] = e[t]),
      (this[1] = e[t + 1]),
      (this[2] = e[t + 2]),
      (this[3] = e[t + 3]),
      (this[4] = e[t + 4]),
      (this[5] = e[t + 5]),
      (this[6] = e[t + 6]),
      (this[7] = e[t + 7]),
      (this[8] = e[t + 8]),
      (this[9] = e[t + 9]),
      (this[10] = e[t + 10]),
      (this[11] = e[t + 11]),
      (this[12] = e[t + 12]),
      (this[13] = e[t + 13]),
      (this[14] = e[t + 14]),
      (this[15] = e[t + 15]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this[0]),
      (e[t + 1] = this[1]),
      (e[t + 2] = this[2]),
      (e[t + 3] = this[3]),
      (e[t + 4] = this[4]),
      (e[t + 5] = this[5]),
      (e[t + 6] = this[6]),
      (e[t + 7] = this[7]),
      (e[t + 8] = this[8]),
      (e[t + 9] = this[9]),
      (e[t + 10] = this[10]),
      (e[t + 11] = this[11]),
      (e[t + 12] = this[12]),
      (e[t + 13] = this[13]),
      (e[t + 14] = this[14]),
      (e[t + 15] = this[15]),
      e
    );
  }
}
function F9(n, e, t = 'YXZ') {
  return (
    t === 'XYZ'
      ? ((n[1] = Math.asin(Math.min(Math.max(e[8], -1), 1))),
        Math.abs(e[8]) < 0.99999
          ? ((n[0] = Math.atan2(-e[9], e[10])),
            (n[2] = Math.atan2(-e[4], e[0])))
          : ((n[0] = Math.atan2(e[6], e[5])), (n[2] = 0)))
      : t === 'YXZ'
        ? ((n[0] = Math.asin(-Math.min(Math.max(e[9], -1), 1))),
          Math.abs(e[9]) < 0.99999
            ? ((n[1] = Math.atan2(e[8], e[10])),
              (n[2] = Math.atan2(e[1], e[5])))
            : ((n[1] = Math.atan2(-e[2], e[0])), (n[2] = 0)))
        : t === 'ZXY'
          ? ((n[0] = Math.asin(Math.min(Math.max(e[6], -1), 1))),
            Math.abs(e[6]) < 0.99999
              ? ((n[1] = Math.atan2(-e[2], e[10])),
                (n[2] = Math.atan2(-e[4], e[5])))
              : ((n[1] = 0), (n[2] = Math.atan2(e[1], e[0]))))
          : t === 'ZYX'
            ? ((n[1] = Math.asin(-Math.min(Math.max(e[2], -1), 1))),
              Math.abs(e[2]) < 0.99999
                ? ((n[0] = Math.atan2(e[6], e[10])),
                  (n[2] = Math.atan2(e[1], e[0])))
                : ((n[0] = 0), (n[2] = Math.atan2(-e[4], e[5]))))
            : t === 'YZX'
              ? ((n[2] = Math.asin(Math.min(Math.max(e[1], -1), 1))),
                Math.abs(e[1]) < 0.99999
                  ? ((n[0] = Math.atan2(-e[9], e[5])),
                    (n[1] = Math.atan2(-e[2], e[0])))
                  : ((n[0] = 0), (n[1] = Math.atan2(e[8], e[10]))))
              : t === 'XZY' &&
                ((n[2] = Math.asin(-Math.min(Math.max(e[4], -1), 1))),
                Math.abs(e[4]) < 0.99999
                  ? ((n[0] = Math.atan2(e[6], e[5])),
                    (n[1] = Math.atan2(e[8], e[0])))
                  : ((n[0] = Math.atan2(-e[9], e[10])), (n[1] = 0))),
    n
  );
}
const _1 = new qs();
let z9 = class extends Array {
  constructor(e = 0, t = e, i = e, r = 'YXZ') {
    (super(e, t, i),
      (this.order = r),
      (this.onChange = () => {}),
      (this._target = this));
    const s = ['0', '1', '2'];
    return new Proxy(this, {
      set(a, o) {
        const l = Reflect.set(...arguments);
        return (l && s.includes(o) && a.onChange(), l);
      },
    });
  }
  get x() {
    return this[0];
  }
  get y() {
    return this[1];
  }
  get z() {
    return this[2];
  }
  set x(e) {
    ((this._target[0] = e), this.onChange());
  }
  set y(e) {
    ((this._target[1] = e), this.onChange());
  }
  set z(e) {
    ((this._target[2] = e), this.onChange());
  }
  set(e, t = e, i = e) {
    return e.length
      ? this.copy(e)
      : ((this._target[0] = e),
        (this._target[1] = t),
        (this._target[2] = i),
        this.onChange(),
        this);
  }
  copy(e) {
    return (
      (this._target[0] = e[0]),
      (this._target[1] = e[1]),
      (this._target[2] = e[2]),
      this.onChange(),
      this
    );
  }
  reorder(e) {
    return ((this._target.order = e), this.onChange(), this);
  }
  fromRotationMatrix(e, t = this.order) {
    return (F9(this._target, e, t), this.onChange(), this);
  }
  fromQuaternion(e, t = this.order, i) {
    return (
      _1.fromQuaternion(e),
      this._target.fromRotationMatrix(_1, t),
      i || this.onChange(),
      this
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._target[0] = e[t]),
      (this._target[1] = e[t + 1]),
      (this._target[2] = e[t + 2]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this[0]), (e[t + 1] = this[1]), (e[t + 2] = this[2]), e);
  }
};
class DD {
  constructor() {
    ((this.parent = null),
      (this.children = []),
      (this.visible = !0),
      (this.matrix = new qs()),
      (this.worldMatrix = new qs()),
      (this.matrixAutoUpdate = !0),
      (this.worldMatrixNeedsUpdate = !1),
      (this.position = new Cn()),
      (this.quaternion = new b9()),
      (this.scale = new Cn(1)),
      (this.rotation = new z9()),
      (this.up = new Cn(0, 1, 0)),
      (this.rotation._target.onChange = () =>
        this.quaternion.fromEuler(this.rotation, !0)),
      (this.quaternion._target.onChange = () =>
        this.rotation.fromQuaternion(this.quaternion, void 0, !0)));
  }
  setParent(e, t = !0) {
    (this.parent && e !== this.parent && this.parent.removeChild(this, !1),
      (this.parent = e),
      t && e && e.addChild(this, !1));
  }
  addChild(e, t = !0) {
    (~this.children.indexOf(e) || this.children.push(e),
      t && e.setParent(this, !1));
  }
  removeChild(e, t = !0) {
    (~this.children.indexOf(e) &&
      this.children.splice(this.children.indexOf(e), 1),
      t && e.setParent(null, !1));
  }
  updateMatrixWorld(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      (this.worldMatrixNeedsUpdate || e) &&
        (this.parent === null
          ? this.worldMatrix.copy(this.matrix)
          : this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix),
        (this.worldMatrixNeedsUpdate = !1),
        (e = !0)));
    for (let t = 0, i = this.children.length; t < i; t++)
      this.children[t].updateMatrixWorld(e);
  }
  updateMatrix() {
    (this.matrix.compose(this.quaternion, this.position, this.scale),
      (this.worldMatrixNeedsUpdate = !0));
  }
  traverse(e) {
    if (!e(this))
      for (let t = 0, i = this.children.length; t < i; t++)
        this.children[t].traverse(e);
  }
  decompose() {
    (this.matrix.decompose(this.quaternion._target, this.position, this.scale),
      this.rotation.fromQuaternion(this.quaternion));
  }
  lookAt(e, t = !1) {
    (t
      ? this.matrix.lookAt(this.position, e, this.up)
      : this.matrix.lookAt(e, this.position, this.up),
      this.matrix.getRotation(this.quaternion._target),
      this.rotation.fromQuaternion(this.quaternion));
  }
}
const V9 = new qs(),
  H9 = new Cn(),
  G9 = new Cn();
let $ne = class extends DD {
  constructor(
    e,
    {
      near: t = 0.1,
      far: i = 100,
      fov: r = 45,
      aspect: s = 1,
      left: a,
      right: o,
      bottom: l,
      top: c,
      zoom: u = 1,
    } = {}
  ) {
    (super(),
      Object.assign(this, {
        near: t,
        far: i,
        fov: r,
        aspect: s,
        left: a,
        right: o,
        bottom: l,
        top: c,
        zoom: u,
      }),
      (this.projectionMatrix = new qs()),
      (this.viewMatrix = new qs()),
      (this.projectionViewMatrix = new qs()),
      (this.worldPosition = new Cn()),
      (this.type = a || o ? 'orthographic' : 'perspective'),
      this.type === 'orthographic' ? this.orthographic() : this.perspective());
  }
  perspective({
    near: e = this.near,
    far: t = this.far,
    fov: i = this.fov,
    aspect: r = this.aspect,
  } = {}) {
    return (
      Object.assign(this, { near: e, far: t, fov: i, aspect: r }),
      this.projectionMatrix.fromPerspective({
        fov: i * (Math.PI / 180),
        aspect: r,
        near: e,
        far: t,
      }),
      (this.type = 'perspective'),
      this
    );
  }
  orthographic({
    near: e = this.near,
    far: t = this.far,
    left: i = this.left || -1,
    right: r = this.right || 1,
    bottom: s = this.bottom || -1,
    top: a = this.top || 1,
    zoom: o = this.zoom,
  } = {}) {
    return (
      Object.assign(this, {
        near: e,
        far: t,
        left: i,
        right: r,
        bottom: s,
        top: a,
        zoom: o,
      }),
      (i /= o),
      (r /= o),
      (s /= o),
      (a /= o),
      this.projectionMatrix.fromOrthogonal({
        left: i,
        right: r,
        bottom: s,
        top: a,
        near: e,
        far: t,
      }),
      (this.type = 'orthographic'),
      this
    );
  }
  updateMatrixWorld() {
    return (
      super.updateMatrixWorld(),
      this.viewMatrix.inverse(this.worldMatrix),
      this.worldMatrix.getTranslation(this.worldPosition),
      this.projectionViewMatrix.multiply(
        this.projectionMatrix,
        this.viewMatrix
      ),
      this
    );
  }
  updateProjectionMatrix() {
    return this.type === 'perspective'
      ? this.perspective()
      : this.orthographic();
  }
  lookAt(e) {
    return (super.lookAt(e, !0), this);
  }
  project(e) {
    return (
      e.applyMatrix4(this.viewMatrix),
      e.applyMatrix4(this.projectionMatrix),
      this
    );
  }
  unproject(e) {
    return (
      e.applyMatrix4(V9.inverse(this.projectionMatrix)),
      e.applyMatrix4(this.worldMatrix),
      this
    );
  }
  updateFrustum() {
    this.frustum ||
      (this.frustum = [
        new Cn(),
        new Cn(),
        new Cn(),
        new Cn(),
        new Cn(),
        new Cn(),
      ]);
    const e = this.projectionViewMatrix;
    ((this.frustum[0].set(e[3] - e[0], e[7] - e[4], e[11] - e[8]).constant =
      e[15] - e[12]),
      (this.frustum[1].set(e[3] + e[0], e[7] + e[4], e[11] + e[8]).constant =
        e[15] + e[12]),
      (this.frustum[2].set(e[3] + e[1], e[7] + e[5], e[11] + e[9]).constant =
        e[15] + e[13]),
      (this.frustum[3].set(e[3] - e[1], e[7] - e[5], e[11] - e[9]).constant =
        e[15] - e[13]),
      (this.frustum[4].set(e[3] - e[2], e[7] - e[6], e[11] - e[10]).constant =
        e[15] - e[14]),
      (this.frustum[5].set(e[3] + e[2], e[7] + e[6], e[11] + e[10]).constant =
        e[15] + e[14]));
    for (let t = 0; t < 6; t++) {
      const i = 1 / this.frustum[t].distance();
      (this.frustum[t].multiply(i), (this.frustum[t].constant *= i));
    }
  }
  frustumIntersectsMesh(e, t = e.worldMatrix) {
    if (
      !e.geometry.attributes.position ||
      ((!e.geometry.bounds || e.geometry.bounds.radius === 1 / 0) &&
        e.geometry.computeBoundingSphere(),
      !e.geometry.bounds)
    )
      return !0;
    const i = H9;
    (i.copy(e.geometry.bounds.center), i.applyMatrix4(t));
    const r = e.geometry.bounds.radius * t.getMaxScaleOnAxis();
    return this.frustumIntersectsSphere(i, r);
  }
  frustumIntersectsSphere(e, t) {
    const i = G9;
    for (let r = 0; r < 6; r++) {
      const s = this.frustum[r];
      if (i.copy(s).dot(e) + s.constant < -t) return !1;
    }
    return !0;
  }
};
function W9(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[4]),
    (n[4] = e[5]),
    (n[5] = e[6]),
    (n[6] = e[8]),
    (n[7] = e[9]),
    (n[8] = e[10]),
    n
  );
}
function j9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = t + t,
    o = i + i,
    l = r + r,
    c = t * a,
    u = i * a,
    h = i * o,
    d = r * a,
    f = r * o,
    p = r * l,
    m = s * a,
    g = s * o,
    v = s * l;
  return (
    (n[0] = 1 - h - p),
    (n[3] = u - v),
    (n[6] = d + g),
    (n[1] = u + v),
    (n[4] = 1 - c - p),
    (n[7] = f - m),
    (n[2] = d - g),
    (n[5] = f + m),
    (n[8] = 1 - c - h),
    n
  );
}
function X9(n, e) {
  return (
    (n[0] = e[0]),
    (n[1] = e[1]),
    (n[2] = e[2]),
    (n[3] = e[3]),
    (n[4] = e[4]),
    (n[5] = e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    n
  );
}
function q9(n, e, t, i, r, s, a, o, l, c) {
  return (
    (n[0] = e),
    (n[1] = t),
    (n[2] = i),
    (n[3] = r),
    (n[4] = s),
    (n[5] = a),
    (n[6] = o),
    (n[7] = l),
    (n[8] = c),
    n
  );
}
function Y9(n) {
  return (
    (n[0] = 1),
    (n[1] = 0),
    (n[2] = 0),
    (n[3] = 0),
    (n[4] = 1),
    (n[5] = 0),
    (n[6] = 0),
    (n[7] = 0),
    (n[8] = 1),
    n
  );
}
function K9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    u = e[8],
    h = u * a - o * c,
    d = -u * s + o * l,
    f = c * s - a * l,
    p = t * h + i * d + r * f;
  return p
    ? ((p = 1 / p),
      (n[0] = h * p),
      (n[1] = (-u * i + r * c) * p),
      (n[2] = (o * i - r * a) * p),
      (n[3] = d * p),
      (n[4] = (u * t - r * l) * p),
      (n[5] = (-o * t + r * s) * p),
      (n[6] = f * p),
      (n[7] = (-c * t + i * l) * p),
      (n[8] = (a * t - i * s) * p),
      n)
    : null;
}
function y1(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    u = e[7],
    h = e[8],
    d = t[0],
    f = t[1],
    p = t[2],
    m = t[3],
    g = t[4],
    v = t[5],
    y = t[6],
    _ = t[7],
    x = t[8];
  return (
    (n[0] = d * i + f * a + p * c),
    (n[1] = d * r + f * o + p * u),
    (n[2] = d * s + f * l + p * h),
    (n[3] = m * i + g * a + v * c),
    (n[4] = m * r + g * o + v * u),
    (n[5] = m * s + g * l + v * h),
    (n[6] = y * i + _ * a + x * c),
    (n[7] = y * r + _ * o + x * u),
    (n[8] = y * s + _ * l + x * h),
    n
  );
}
function J9(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    u = e[7],
    h = e[8],
    d = t[0],
    f = t[1];
  return (
    (n[0] = i),
    (n[1] = r),
    (n[2] = s),
    (n[3] = a),
    (n[4] = o),
    (n[5] = l),
    (n[6] = d * i + f * a + c),
    (n[7] = d * r + f * o + u),
    (n[8] = d * s + f * l + h),
    n
  );
}
function Q9(n, e, t) {
  let i = e[0],
    r = e[1],
    s = e[2],
    a = e[3],
    o = e[4],
    l = e[5],
    c = e[6],
    u = e[7],
    h = e[8],
    d = Math.sin(t),
    f = Math.cos(t);
  return (
    (n[0] = f * i + d * a),
    (n[1] = f * r + d * o),
    (n[2] = f * s + d * l),
    (n[3] = f * a - d * i),
    (n[4] = f * o - d * r),
    (n[5] = f * l - d * s),
    (n[6] = c),
    (n[7] = u),
    (n[8] = h),
    n
  );
}
function Z9(n, e, t) {
  let i = t[0],
    r = t[1];
  return (
    (n[0] = i * e[0]),
    (n[1] = i * e[1]),
    (n[2] = i * e[2]),
    (n[3] = r * e[3]),
    (n[4] = r * e[4]),
    (n[5] = r * e[5]),
    (n[6] = e[6]),
    (n[7] = e[7]),
    (n[8] = e[8]),
    n
  );
}
function $9(n, e) {
  let t = e[0],
    i = e[1],
    r = e[2],
    s = e[3],
    a = e[4],
    o = e[5],
    l = e[6],
    c = e[7],
    u = e[8],
    h = e[9],
    d = e[10],
    f = e[11],
    p = e[12],
    m = e[13],
    g = e[14],
    v = e[15],
    y = t * o - i * a,
    _ = t * l - r * a,
    x = t * c - s * a,
    S = i * l - r * o,
    b = i * c - s * o,
    A = r * c - s * l,
    E = u * m - h * p,
    w = u * g - d * p,
    M = u * v - f * p,
    T = h * g - d * m,
    D = h * v - f * m,
    L = d * v - f * g,
    O = y * L - _ * D + x * T + S * M - b * w + A * E;
  return O
    ? ((O = 1 / O),
      (n[0] = (o * L - l * D + c * T) * O),
      (n[1] = (l * M - a * L - c * w) * O),
      (n[2] = (a * D - o * M + c * E) * O),
      (n[3] = (r * D - i * L - s * T) * O),
      (n[4] = (t * L - r * M + s * w) * O),
      (n[5] = (i * M - t * D - s * E) * O),
      (n[6] = (m * A - g * b + v * S) * O),
      (n[7] = (g * x - p * A - v * _) * O),
      (n[8] = (p * b - m * x + v * y) * O),
      n)
    : null;
}
class eX extends Array {
  constructor(e = 1, t = 0, i = 0, r = 0, s = 1, a = 0, o = 0, l = 0, c = 1) {
    return (super(e, t, i, r, s, a, o, l, c), this);
  }
  set(e, t, i, r, s, a, o, l, c) {
    return e.length
      ? this.copy(e)
      : (q9(this, e, t, i, r, s, a, o, l, c), this);
  }
  translate(e, t = this) {
    return (J9(this, t, e), this);
  }
  rotate(e, t = this) {
    return (Q9(this, t, e), this);
  }
  scale(e, t = this) {
    return (Z9(this, t, e), this);
  }
  multiply(e, t) {
    return (t ? y1(this, e, t) : y1(this, this, e), this);
  }
  identity() {
    return (Y9(this), this);
  }
  copy(e) {
    return (X9(this, e), this);
  }
  fromMatrix4(e) {
    return (W9(this, e), this);
  }
  fromQuaternion(e) {
    return (j9(this, e), this);
  }
  fromBasis(e, t, i) {
    return (
      this.set(e[0], e[1], e[2], t[0], t[1], t[2], i[0], i[1], i[2]),
      this
    );
  }
  inverse(e = this) {
    return (K9(this, e), this);
  }
  getNormalMatrix(e) {
    return ($9(this, e), this);
  }
}
let tX = 0,
  tie = class extends DD {
    constructor(
      e,
      {
        geometry: t,
        program: i,
        mode: r = e.TRIANGLES,
        frustumCulled: s = !0,
        renderOrder: a = 0,
      } = {}
    ) {
      (super(),
        e.canvas || console.error('gl not passed as first argument to Mesh'),
        (this.gl = e),
        (this.id = tX++),
        (this.geometry = t),
        (this.program = i),
        (this.mode = r),
        (this.frustumCulled = s),
        (this.renderOrder = a),
        (this.modelViewMatrix = new qs()),
        (this.normalMatrix = new eX()),
        (this.beforeRenderCallbacks = []),
        (this.afterRenderCallbacks = []));
    }
    onBeforeRender(e) {
      return (this.beforeRenderCallbacks.push(e), this);
    }
    onAfterRender(e) {
      return (this.afterRenderCallbacks.push(e), this);
    }
    draw({ camera: e } = {}) {
      (e &&
        (this.program.uniforms.modelMatrix ||
          Object.assign(this.program.uniforms, {
            modelMatrix: { value: null },
            viewMatrix: { value: null },
            modelViewMatrix: { value: null },
            normalMatrix: { value: null },
            projectionMatrix: { value: null },
            cameraPosition: { value: null },
          }),
        (this.program.uniforms.projectionMatrix.value = e.projectionMatrix),
        (this.program.uniforms.cameraPosition.value = e.worldPosition),
        (this.program.uniforms.viewMatrix.value = e.viewMatrix),
        this.modelViewMatrix.multiply(e.viewMatrix, this.worldMatrix),
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix),
        (this.program.uniforms.modelMatrix.value = this.worldMatrix),
        (this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix),
        (this.program.uniforms.normalMatrix.value = this.normalMatrix)),
        this.beforeRenderCallbacks.forEach(
          (i) => i && i({ mesh: this, camera: e })
        ));
      let t = this.program.cullFace && this.worldMatrix.determinant() < 0;
      (this.program.use({ flipFaces: t }),
        this.geometry.draw({ mode: this.mode, program: this.program }),
        this.afterRenderCallbacks.forEach(
          (i) => i && i({ mesh: this, camera: e })
        ));
    }
  };
const x1 = new Uint8Array(4);
function b1(n) {
  return (n & (n - 1)) === 0;
}
let nX = 1,
  iie = class {
    constructor(
      e,
      {
        image: t,
        target: i = e.TEXTURE_2D,
        type: r = e.UNSIGNED_BYTE,
        format: s = e.RGBA,
        internalFormat: a = s,
        wrapS: o = e.CLAMP_TO_EDGE,
        wrapT: l = e.CLAMP_TO_EDGE,
        wrapR: c = e.CLAMP_TO_EDGE,
        generateMipmaps: u = i === (e.TEXTURE_2D || e.TEXTURE_CUBE_MAP),
        minFilter: h = u ? e.NEAREST_MIPMAP_LINEAR : e.LINEAR,
        magFilter: d = e.LINEAR,
        premultiplyAlpha: f = !1,
        unpackAlignment: p = 4,
        flipY: m = i == (e.TEXTURE_2D || e.TEXTURE_3D),
        anisotropy: g = 0,
        level: v = 0,
        width: y,
        height: _ = y,
        length: x = 1,
      } = {}
    ) {
      ((this.gl = e),
        (this.id = nX++),
        (this.image = t),
        (this.target = i),
        (this.type = r),
        (this.format = s),
        (this.internalFormat = a),
        (this.minFilter = h),
        (this.magFilter = d),
        (this.wrapS = o),
        (this.wrapT = l),
        (this.wrapR = c),
        (this.generateMipmaps = u),
        (this.premultiplyAlpha = f),
        (this.unpackAlignment = p),
        (this.flipY = m),
        (this.anisotropy = Math.min(
          g,
          this.gl.renderer.parameters.maxAnisotropy
        )),
        (this.level = v),
        (this.width = y),
        (this.height = _),
        (this.length = x),
        (this.texture = this.gl.createTexture()),
        (this.store = { image: null }),
        (this.glState = this.gl.renderer.state),
        (this.state = {}),
        (this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR),
        (this.state.magFilter = this.gl.LINEAR),
        (this.state.wrapS = this.gl.REPEAT),
        (this.state.wrapT = this.gl.REPEAT),
        (this.state.anisotropy = 0));
    }
    bind() {
      this.glState.textureUnits[this.glState.activeTextureUnit] !== this.id &&
        (this.gl.bindTexture(this.target, this.texture),
        (this.glState.textureUnits[this.glState.activeTextureUnit] = this.id));
    }
    update(e = 0) {
      const t = !(this.image === this.store.image && !this.needsUpdate);
      if (
        ((t || this.glState.textureUnits[e] !== this.id) &&
          (this.gl.renderer.activeTexture(e), this.bind()),
        !!t)
      ) {
        if (
          ((this.needsUpdate = !1),
          this.flipY !== this.glState.flipY &&
            (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY),
            (this.glState.flipY = this.flipY)),
          this.premultiplyAlpha !== this.glState.premultiplyAlpha &&
            (this.gl.pixelStorei(
              this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              this.premultiplyAlpha
            ),
            (this.glState.premultiplyAlpha = this.premultiplyAlpha)),
          this.unpackAlignment !== this.glState.unpackAlignment &&
            (this.gl.pixelStorei(
              this.gl.UNPACK_ALIGNMENT,
              this.unpackAlignment
            ),
            (this.glState.unpackAlignment = this.unpackAlignment)),
          this.minFilter !== this.state.minFilter &&
            (this.gl.texParameteri(
              this.target,
              this.gl.TEXTURE_MIN_FILTER,
              this.minFilter
            ),
            (this.state.minFilter = this.minFilter)),
          this.magFilter !== this.state.magFilter &&
            (this.gl.texParameteri(
              this.target,
              this.gl.TEXTURE_MAG_FILTER,
              this.magFilter
            ),
            (this.state.magFilter = this.magFilter)),
          this.wrapS !== this.state.wrapS &&
            (this.gl.texParameteri(
              this.target,
              this.gl.TEXTURE_WRAP_S,
              this.wrapS
            ),
            (this.state.wrapS = this.wrapS)),
          this.wrapT !== this.state.wrapT &&
            (this.gl.texParameteri(
              this.target,
              this.gl.TEXTURE_WRAP_T,
              this.wrapT
            ),
            (this.state.wrapT = this.wrapT)),
          this.wrapR !== this.state.wrapR &&
            (this.gl.texParameteri(
              this.target,
              this.gl.TEXTURE_WRAP_R,
              this.wrapR
            ),
            (this.state.wrapR = this.wrapR)),
          this.anisotropy &&
            this.anisotropy !== this.state.anisotropy &&
            (this.gl.texParameterf(
              this.target,
              this.gl.renderer.getExtension('EXT_texture_filter_anisotropic')
                .TEXTURE_MAX_ANISOTROPY_EXT,
              this.anisotropy
            ),
            (this.state.anisotropy = this.anisotropy)),
          this.image)
        ) {
          if (
            (this.image.width &&
              ((this.width = this.image.width),
              (this.height = this.image.height)),
            this.target === this.gl.TEXTURE_CUBE_MAP)
          )
            for (let i = 0; i < 6; i++)
              this.gl.texImage2D(
                this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                this.level,
                this.internalFormat,
                this.format,
                this.type,
                this.image[i]
              );
          else if (ArrayBuffer.isView(this.image))
            this.target === this.gl.TEXTURE_2D
              ? this.gl.texImage2D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.width,
                  this.height,
                  0,
                  this.format,
                  this.type,
                  this.image
                )
              : (this.target === this.gl.TEXTURE_2D_ARRAY ||
                  this.target === this.gl.TEXTURE_3D) &&
                this.gl.texImage3D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.width,
                  this.height,
                  this.length,
                  0,
                  this.format,
                  this.type,
                  this.image
                );
          else if (this.image.isCompressedTexture)
            for (let i = 0; i < this.image.length; i++)
              this.gl.compressedTexImage2D(
                this.target,
                i,
                this.internalFormat,
                this.image[i].width,
                this.image[i].height,
                0,
                this.image[i].data
              );
          else
            this.target === this.gl.TEXTURE_2D
              ? this.gl.texImage2D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.format,
                  this.type,
                  this.image
                )
              : this.gl.texImage3D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.width,
                  this.height,
                  this.length,
                  0,
                  this.format,
                  this.type,
                  this.image
                );
          (this.generateMipmaps &&
            (!this.gl.renderer.isWebgl2 &&
            (!b1(this.image.width) || !b1(this.image.height))
              ? ((this.generateMipmaps = !1),
                (this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE),
                (this.minFilter = this.gl.LINEAR))
              : this.gl.generateMipmap(this.target)),
            this.onUpdate && this.onUpdate());
        } else if (this.target === this.gl.TEXTURE_CUBE_MAP)
          for (let i = 0; i < 6; i++)
            this.gl.texImage2D(
              this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              0,
              this.gl.RGBA,
              1,
              1,
              0,
              this.gl.RGBA,
              this.gl.UNSIGNED_BYTE,
              x1
            );
        else
          this.width
            ? this.target === this.gl.TEXTURE_2D
              ? this.gl.texImage2D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.width,
                  this.height,
                  0,
                  this.format,
                  this.type,
                  null
                )
              : this.gl.texImage3D(
                  this.target,
                  this.level,
                  this.internalFormat,
                  this.width,
                  this.height,
                  this.length,
                  0,
                  this.format,
                  this.type,
                  null
                )
            : this.gl.texImage2D(
                this.target,
                0,
                this.gl.RGBA,
                1,
                1,
                0,
                this.gl.RGBA,
                this.gl.UNSIGNED_BYTE,
                x1
              );
        this.store.image = this.image;
      }
    }
  },
  sie = class OD extends Qj {
    constructor(
      e,
      {
        width: t = 1,
        height: i = 1,
        widthSegments: r = 1,
        heightSegments: s = 1,
        attributes: a = {},
      } = {}
    ) {
      const o = r,
        l = s,
        c = (o + 1) * (l + 1),
        u = o * l * 6,
        h = new Float32Array(c * 3),
        d = new Float32Array(c * 3),
        f = new Float32Array(c * 2),
        p = u > 65536 ? new Uint32Array(u) : new Uint16Array(u);
      (OD.buildPlane(h, d, f, p, t, i, 0, o, l),
        Object.assign(a, {
          position: { size: 3, data: h },
          normal: { size: 3, data: d },
          uv: { size: 2, data: f },
          index: { data: p },
        }),
        super(e, a));
    }
    static buildPlane(
      e,
      t,
      i,
      r,
      s,
      a,
      o,
      l,
      c,
      u = 0,
      h = 1,
      d = 2,
      f = 1,
      p = -1,
      m = 0,
      g = 0
    ) {
      const v = m,
        y = s / l,
        _ = a / c;
      for (let x = 0; x <= c; x++) {
        let S = x * _ - a / 2;
        for (let b = 0; b <= l; b++, m++) {
          let A = b * y - s / 2;
          if (
            ((e[m * 3 + u] = A * f),
            (e[m * 3 + h] = S * p),
            (e[m * 3 + d] = o / 2),
            (t[m * 3 + u] = 0),
            (t[m * 3 + h] = 0),
            (t[m * 3 + d] = o >= 0 ? 1 : -1),
            (i[m * 2] = b / l),
            (i[m * 2 + 1] = 1 - x / c),
            x === c || b === l)
          )
            continue;
          let E = v + b + x * (l + 1),
            w = v + b + (x + 1) * (l + 1),
            M = v + b + (x + 1) * (l + 1) + 1,
            T = v + b + x * (l + 1) + 1;
          ((r[g * 6] = E),
            (r[g * 6 + 1] = w),
            (r[g * 6 + 2] = T),
            (r[g * 6 + 3] = w),
            (r[g * 6 + 4] = M),
            (r[g * 6 + 5] = T),
            g++);
        }
      }
    }
  };
const S1 = (n) => (typeof n == 'boolean' ? `${n}` : n === 0 ? '0' : n),
  w1 = xV,
  aie = (n, e) => (t) => {
    var i;
    if (e?.variants == null) return w1(n, t?.class, t?.className);
    const { variants: r, defaultVariants: s } = e,
      a = Object.keys(r).map((c) => {
        const u = t?.[c],
          h = s?.[c];
        if (u === null) return null;
        const d = S1(u) || S1(h);
        return r[c][d];
      }),
      o =
        t &&
        Object.entries(t).reduce((c, u) => {
          let [h, d] = u;
          return (d === void 0 || (c[h] = d), c);
        }, {}),
      l =
        e == null || (i = e.compoundVariants) === null || i === void 0
          ? void 0
          : i.reduce((c, u) => {
              let { class: h, className: d, ...f } = u;
              return Object.entries(f).every((p) => {
                let [m, g] = p;
                return Array.isArray(g)
                  ? g.includes({ ...s, ...o }[m])
                  : { ...s, ...o }[m] === g;
              })
                ? [...c, h, d]
                : c;
            }, []);
    return w1(n, a, l, t?.class, t?.className);
  };
const la = '181',
  iX = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  rX = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  LD = 0,
  G_ = 1,
  UD = 2,
  sX = 3,
  aX = 0,
  Hx = 1,
  kD = 2,
  Dr = 3,
  Wr = 0,
  On = 1,
  ci = 2,
  Ln = 0,
  Eo = 1,
  W_ = 2,
  j_ = 3,
  X_ = 4,
  BD = 5,
  Bs = 100,
  ND = 101,
  FD = 102,
  zD = 103,
  VD = 104,
  HD = 200,
  GD = 201,
  WD = 202,
  jD = 203,
  op = 204,
  lp = 205,
  XD = 206,
  qD = 207,
  YD = 208,
  KD = 209,
  JD = 210,
  QD = 211,
  ZD = 212,
  $D = 213,
  e2 = 214,
  cp = 0,
  up = 1,
  hp = 2,
  Do = 3,
  dp = 4,
  fp = 5,
  pp = 6,
  mp = 7,
  kh = 0,
  t2 = 1,
  n2 = 2,
  ds = 0,
  i2 = 1,
  r2 = 2,
  s2 = 3,
  a2 = 4,
  o2 = 5,
  l2 = 6,
  c2 = 7,
  q_ = 'attached',
  u2 = 'detached',
  ea = 300,
  ys = 301,
  ta = 302,
  rh = 303,
  sh = 304,
  Mc = 306,
  ah = 1e3,
  mn = 1001,
  oh = 1002,
  Un = 1003,
  Gx = 1004,
  oX = 1004,
  Dl = 1005,
  lX = 1005,
  Dt = 1006,
  Iu = 1007,
  cX = 1007,
  kr = 1008,
  Y_ = 1008,
  gn = 1009,
  Sm = 1010,
  wm = 1011,
  tc = 1012,
  Bh = 1013,
  Mr = 1014,
  un = 1015,
  Gn = 1016,
  Em = 1017,
  Am = 1018,
  Oo = 1020,
  Wx = 35902,
  jx = 35899,
  Xx = 1021,
  qx = 1022,
  Rn = 1023,
  nc = 1026,
  Lo = 1027,
  Nh = 1028,
  Fh = 1029,
  Mm = 1030,
  Tm = 1031,
  uX = 1032,
  Cm = 1033,
  Pu = 33776,
  Du = 33777,
  Ou = 33778,
  Lu = 33779,
  gp = 35840,
  vp = 35841,
  _p = 35842,
  yp = 35843,
  xp = 36196,
  bp = 37492,
  Sp = 37496,
  wp = 37808,
  Ep = 37809,
  Ap = 37810,
  Mp = 37811,
  Tp = 37812,
  Cp = 37813,
  Rp = 37814,
  Ip = 37815,
  Pp = 37816,
  Dp = 37817,
  Op = 37818,
  Lp = 37819,
  Up = 37820,
  kp = 37821,
  Bp = 36492,
  Np = 36494,
  Fp = 36495,
  zp = 36283,
  Vp = 36284,
  Hp = 36285,
  Gp = 36286,
  h2 = 2200,
  d2 = 2201,
  f2 = 2202,
  lh = 2300,
  Wp = 2301,
  kf = 2302,
  ho = 2400,
  fo = 2401,
  ch = 2402,
  Rm = 2500,
  Yx = 2501,
  hX = 0,
  dX = 1,
  fX = 2,
  ca = 3200,
  p2 = 3201,
  pX = 3202,
  mX = 3203,
  ua = 0,
  m2 = 1,
  Sr = '',
  Wt = 'srgb',
  cr = 'srgb-linear',
  uh = 'linear',
  Yt = 'srgb',
  gX = 0,
  to = 7680,
  vX = 7681,
  _X = 7682,
  yX = 7683,
  xX = 34055,
  bX = 34056,
  SX = 5386,
  wX = 512,
  EX = 513,
  AX = 514,
  MX = 515,
  TX = 516,
  CX = 517,
  RX = 518,
  K_ = 519,
  g2 = 512,
  v2 = 513,
  _2 = 514,
  Kx = 515,
  y2 = 516,
  x2 = 517,
  b2 = 518,
  S2 = 519,
  hh = 35044,
  IX = 35048,
  PX = 35040,
  DX = 35045,
  OX = 35049,
  LX = 35041,
  UX = 35046,
  kX = 35050,
  BX = 35042,
  NX = '100',
  J_ = '300 es',
  Hi = 2e3,
  ic = 2001,
  FX = { COMPUTE: 'compute', RENDER: 'render' },
  zX = { PERSPECTIVE: 'perspective', LINEAR: 'linear', FLAT: 'flat' },
  VX = {
    NORMAL: 'normal',
    CENTROID: 'centroid',
    SAMPLE: 'sample',
    FIRST: 'first',
    EITHER: 'either',
  };
function w2(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const HX = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ol(n, e) {
  return new HX[n](e);
}
function dh(n) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', n);
}
function E2() {
  const n = dh('canvas');
  return ((n.style.display = 'block'), n);
}
const E1 = {};
let na = null;
function GX(n) {
  na = n;
}
function WX() {
  return na;
}
function fh(...n) {
  const e = 'THREE.' + n.shift();
  na ? na('log', e, ...n) : console.log(e, ...n);
}
function Ge(...n) {
  const e = 'THREE.' + n.shift();
  na ? na('warn', e, ...n) : console.warn(e, ...n);
}
function gt(...n) {
  const e = 'THREE.' + n.shift();
  na ? na('error', e, ...n) : console.error(e, ...n);
}
function rc(...n) {
  const e = n.join(' ');
  e in E1 || ((E1[e] = !0), Ge(...n));
}
function jX(n, e, t) {
  return new Promise(function (i, r) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          r();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          i();
      }
    }
    setTimeout(s, t);
  });
}
class Ki {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    (i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t));
  }
  hasEventListener(e, t) {
    const i = this._listeners;
    return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const i = this._listeners;
    if (i === void 0) return;
    const r = i[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const i = t[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const Jn = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
];
let A1 = 1234567;
const Ao = Math.PI / 180,
  sc = 180 / Math.PI;
function Wi() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    Jn[n & 255] +
    Jn[(n >> 8) & 255] +
    Jn[(n >> 16) & 255] +
    Jn[(n >> 24) & 255] +
    '-' +
    Jn[e & 255] +
    Jn[(e >> 8) & 255] +
    '-' +
    Jn[((e >> 16) & 15) | 64] +
    Jn[(e >> 24) & 255] +
    '-' +
    Jn[(t & 63) | 128] +
    Jn[(t >> 8) & 255] +
    '-' +
    Jn[(t >> 16) & 255] +
    Jn[(t >> 24) & 255] +
    Jn[i & 255] +
    Jn[(i >> 8) & 255] +
    Jn[(i >> 16) & 255] +
    Jn[(i >> 24) & 255]
  ).toLowerCase();
}
function ut(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Jx(n, e) {
  return ((n % e) + e) % e;
}
function XX(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function qX(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Uu(n, e, t) {
  return (1 - t) * n + t * e;
}
function YX(n, e, t, i) {
  return Uu(n, e, 1 - Math.exp(-t * i));
}
function KX(n, e = 1) {
  return e - Math.abs(Jx(n, e * 2) - e);
}
function JX(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function QX(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function ZX(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function $X(n, e) {
  return n + Math.random() * (e - n);
}
function eq(n) {
  return n * (0.5 - Math.random());
}
function tq(n) {
  n !== void 0 && (A1 = n);
  let e = (A1 += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function nq(n) {
  return n * Ao;
}
function iq(n) {
  return n * sc;
}
function rq(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function sq(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function aq(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function oq(n, e, t, i, r) {
  const s = Math.cos,
    a = Math.sin,
    o = s(t / 2),
    l = a(t / 2),
    c = s((e + i) / 2),
    u = a((e + i) / 2),
    h = s((e - i) / 2),
    d = a((e - i) / 2),
    f = s((i - e) / 2),
    p = a((i - e) / 2);
  switch (r) {
    case 'XYX':
      n.set(o * u, l * h, l * d, o * c);
      break;
    case 'YZY':
      n.set(l * d, o * u, l * h, o * c);
      break;
    case 'ZXZ':
      n.set(l * h, l * d, o * u, o * c);
      break;
    case 'XZX':
      n.set(o * u, l * p, l * f, o * c);
      break;
    case 'YXY':
      n.set(l * f, o * u, l * p, o * c);
      break;
    case 'ZYZ':
      n.set(l * p, l * f, o * u, o * c);
      break;
    default:
      Ge(
        'MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          r
      );
  }
}
function ui(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error('Invalid component type.');
  }
}
function bt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error('Invalid component type.');
  }
}
const lq = {
  DEG2RAD: Ao,
  RAD2DEG: sc,
  generateUUID: Wi,
  clamp: ut,
  euclideanModulo: Jx,
  mapLinear: XX,
  inverseLerp: qX,
  lerp: Uu,
  damp: YX,
  pingpong: KX,
  smoothstep: JX,
  smootherstep: QX,
  randInt: ZX,
  randFloat: $X,
  randFloatSpread: eq,
  seededRandom: tq,
  degToRad: nq,
  radToDeg: iq,
  isPowerOfTwo: rq,
  ceilPowerOfTwo: sq,
  floorPowerOfTwo: aq,
  setQuaternionFromProperEuler: oq,
  normalize: bt,
  denormalize: ui,
};
class pe {
  constructor(e = 0, t = 0) {
    ((pe.prototype.isVector2 = !0), (this.x = e), (this.y = t));
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return ((this.x = e), (this.y = t), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), this);
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), this);
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), this);
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), this);
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), this);
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), this);
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ut(this.x, e.x, t.x)),
      (this.y = ut(this.y, e.y, t.y)),
      this
    );
  }
  clampScalar(e, t) {
    return ((this.x = ut(this.x, e, t)), (this.y = ut(this.y, e, t)), this);
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(ut(i, e, t));
  }
  floor() {
    return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this);
  }
  ceil() {
    return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this);
  }
  round() {
    return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this);
  }
  roundToZero() {
    return ((this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this);
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(ut(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), e);
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), this);
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (
      (this.x = s * i - a * r + e.x),
      (this.y = s * r + a * i + e.y),
      this
    );
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), this);
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y);
  }
}
class Ii {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r));
  }
  static slerpFlat(e, t, i, r, s, a, o) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      h = i[r + 3],
      d = s[a + 0],
      f = s[a + 1],
      p = s[a + 2],
      m = s[a + 3];
    if (o <= 0) {
      ((e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h));
      return;
    }
    if (o >= 1) {
      ((e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = p), (e[t + 3] = m));
      return;
    }
    if (h !== m || l !== d || c !== f || u !== p) {
      let g = l * d + c * f + u * p + h * m;
      g < 0 && ((d = -d), (f = -f), (p = -p), (m = -m), (g = -g));
      let v = 1 - o;
      if (g < 0.9995) {
        const y = Math.acos(g),
          _ = Math.sin(y);
        ((v = Math.sin(v * y) / _),
          (o = Math.sin(o * y) / _),
          (l = l * v + d * o),
          (c = c * v + f * o),
          (u = u * v + p * o),
          (h = h * v + m * o));
      } else {
        ((l = l * v + d * o),
          (c = c * v + f * o),
          (u = u * v + p * o),
          (h = h * v + m * o));
        const y = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        ((l *= y), (c *= y), (u *= y), (h *= y));
      }
    }
    ((e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h));
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, a) {
    const o = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      h = s[a],
      d = s[a + 1],
      f = s[a + 2],
      p = s[a + 3];
    return (
      (e[t] = o * p + u * h + l * f - c * d),
      (e[t + 1] = l * p + u * d + c * h - o * f),
      (e[t + 2] = c * p + u * f + o * d - l * h),
      (e[t + 3] = u * p - o * h - l * d - c * f),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get w() {
    return this._w;
  }
  set w(e) {
    ((this._w = e), this._onChangeCallback());
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(i / 2),
      u = o(r / 2),
      h = o(s / 2),
      d = l(i / 2),
      f = l(r / 2),
      p = l(s / 2);
    switch (a) {
      case 'XYZ':
        ((this._x = d * u * h + c * f * p),
          (this._y = c * f * h - d * u * p),
          (this._z = c * u * p + d * f * h),
          (this._w = c * u * h - d * f * p));
        break;
      case 'YXZ':
        ((this._x = d * u * h + c * f * p),
          (this._y = c * f * h - d * u * p),
          (this._z = c * u * p - d * f * h),
          (this._w = c * u * h + d * f * p));
        break;
      case 'ZXY':
        ((this._x = d * u * h - c * f * p),
          (this._y = c * f * h + d * u * p),
          (this._z = c * u * p + d * f * h),
          (this._w = c * u * h - d * f * p));
        break;
      case 'ZYX':
        ((this._x = d * u * h - c * f * p),
          (this._y = c * f * h + d * u * p),
          (this._z = c * u * p - d * f * h),
          (this._w = c * u * h + d * f * p));
        break;
      case 'YZX':
        ((this._x = d * u * h + c * f * p),
          (this._y = c * f * h + d * u * p),
          (this._z = c * u * p - d * f * h),
          (this._w = c * u * h - d * f * p));
        break;
      case 'XZY':
        ((this._x = d * u * h - c * f * p),
          (this._y = c * f * h - d * u * p),
          (this._z = c * u * p + d * f * h),
          (this._w = c * u * h + d * f * p));
        break;
      default:
        Ge('Quaternion: .setFromEuler() encountered an unknown order: ' + a);
    }
    return (t === !0 && this._onChangeCallback(), this);
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      a = t[1],
      o = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      h = t[10],
      d = i + o + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      ((this._w = 0.25 / f),
        (this._x = (u - l) * f),
        (this._y = (s - c) * f),
        (this._z = (a - r) * f));
    } else if (i > o && i > h) {
      const f = 2 * Math.sqrt(1 + i - o - h);
      ((this._w = (u - l) / f),
        (this._x = 0.25 * f),
        (this._y = (r + a) / f),
        (this._z = (s + c) / f));
    } else if (o > h) {
      const f = 2 * Math.sqrt(1 + o - i - h);
      ((this._w = (s - c) / f),
        (this._x = (r + a) / f),
        (this._y = 0.25 * f),
        (this._z = (l + u) / f));
    } else {
      const f = 2 * Math.sqrt(1 + h - i - o);
      ((this._w = (a - r) / f),
        (this._x = (s + c) / f),
        (this._y = (l + u) / f),
        (this._z = 0.25 * f));
    }
    return (this._onChangeCallback(), this);
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < 1e-8
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ut(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return (this.slerp(e, r), this);
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      a = e._w,
      o = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = i * u + a * o + r * c - s * l),
      (this._y = r * u + a * l + s * o - i * c),
      (this._z = s * u + a * c + i * l - r * o),
      (this._w = a * u - i * o - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t <= 0) return this;
    if (t >= 1) return this.copy(e);
    let i = e._x,
      r = e._y,
      s = e._z,
      a = e._w,
      o = this.dot(e);
    o < 0 && ((i = -i), (r = -r), (s = -s), (a = -a), (o = -o));
    let l = 1 - t;
    if (o < 0.9995) {
      const c = Math.acos(o),
        u = Math.sin(c);
      ((l = Math.sin(l * c) / u),
        (t = Math.sin(t * c) / u),
        (this._x = this._x * l + i * t),
        (this._y = this._y * l + r * t),
        (this._z = this._z * l + s * t),
        (this._w = this._w * l + a * t),
        this._onChangeCallback());
    } else
      ((this._x = this._x * l + i * t),
        (this._y = this._y * l + r * t),
        (this._z = this._z * l + s * t),
        (this._w = this._w * l + a * t),
        this.normalize());
    return this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._w);
  }
}
class V {
  constructor(e = 0, t = 0, i = 0) {
    ((V.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i));
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), (this.z = e.z), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      this
    );
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      this
    );
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), this);
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x),
      (this.y = e.y * t.y),
      (this.z = e.z * t.z),
      this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(M1.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(M1.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = 2 * (a * r - o * i),
      u = 2 * (o * t - s * r),
      h = 2 * (s * i - a * t);
    return (
      (this.x = t + l * c + a * h - o * u),
      (this.y = i + l * u + o * c - s * h),
      (this.z = r + l * h + s * u - a * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ut(this.x, e.x, t.x)),
      (this.y = ut(this.y, e.y, t.y)),
      (this.z = ut(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = ut(this.x, e, t)),
      (this.y = ut(this.y, e, t)),
      (this.z = ut(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(ut(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      a = t.x,
      o = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * o),
      (this.y = s * a - i * l),
      (this.z = i * o - r * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return (S0.copy(this).projectOnVector(e), this.sub(S0));
  }
  reflect(e) {
    return this.sub(S0.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(ut(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)),
      (this.y = i),
      (this.z = e * Math.cos(t)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this);
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return ((this.x = t), (this.y = i), (this.z = r), this);
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return ((this.x = e._x), (this.y = e._y), (this.z = e._z), this);
  }
  setFromColor(e) {
    return ((this.x = e.r), (this.y = e.g), (this.z = e.b), this);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      i = Math.sqrt(1 - t * t);
    return (
      (this.x = i * Math.cos(e)),
      (this.y = t),
      (this.z = i * Math.sin(e)),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z);
  }
}
const S0 = new V(),
  M1 = new Ii();
class xt {
  constructor(e, t, i, r, s, a, o, l, c) {
    ((xt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, a, o, l, c));
  }
  set(e, t, i, r, s, a, o, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = o),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      a = i[0],
      o = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      h = i[7],
      d = i[2],
      f = i[5],
      p = i[8],
      m = r[0],
      g = r[3],
      v = r[6],
      y = r[1],
      _ = r[4],
      x = r[7],
      S = r[2],
      b = r[5],
      A = r[8];
    return (
      (s[0] = a * m + o * y + l * S),
      (s[3] = a * g + o * _ + l * b),
      (s[6] = a * v + o * x + l * A),
      (s[1] = c * m + u * y + h * S),
      (s[4] = c * g + u * _ + h * b),
      (s[7] = c * v + u * x + h * A),
      (s[2] = d * m + f * y + p * S),
      (s[5] = d * g + f * _ + p * b),
      (s[8] = d * v + f * x + p * A),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * a * u - t * o * c - i * s * u + i * o * l + r * s * c - r * a * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = u * a - o * c,
      d = o * l - u * s,
      f = c * s - a * l,
      p = t * h + i * d + r * f;
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / p;
    return (
      (e[0] = h * m),
      (e[1] = (r * c - u * i) * m),
      (e[2] = (o * i - r * a) * m),
      (e[3] = d * m),
      (e[4] = (u * t - r * l) * m),
      (e[5] = (r * s - o * t) * m),
      (e[6] = f * m),
      (e[7] = (i * l - c * t) * m),
      (e[8] = (a * t - i * s) * m),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * a + c * o) + a + e,
        -r * c,
        r * l,
        -r * (-c * a + l * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return (this.premultiply(w0.makeScale(e, t)), this);
  }
  rotate(e) {
    return (this.premultiply(w0.makeRotation(-e)), this);
  }
  translate(e, t) {
    return (this.premultiply(w0.makeTranslation(e, t)), this);
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, i, t, 0, 0, 0, 1), this);
  }
  makeScale(e, t) {
    return (this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this);
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const w0 = new xt(),
  T1 = new xt().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  C1 = new xt().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function cq() {
  const n = {
      enabled: !0,
      workingColorSpace: cr,
      spaces: {},
      convert: function (r, s, a) {
        return (
          this.enabled === !1 ||
            s === a ||
            !s ||
            !a ||
            (this.spaces[s].transfer === Yt &&
              ((r.r = fs(r.r)), (r.g = fs(r.g)), (r.b = fs(r.b))),
            this.spaces[s].primaries !== this.spaces[a].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[a].fromXYZ)),
            this.spaces[a].transfer === Yt &&
              ((r.r = zl(r.r)), (r.g = zl(r.g)), (r.b = zl(r.b)))),
          r
        );
      },
      workingToColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s);
      },
      colorSpaceToWorking: function (r, s) {
        return this.convert(r, s, this.workingColorSpace);
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries;
      },
      getTransfer: function (r) {
        return r === Sr ? uh : this.spaces[r].transfer;
      },
      getToneMappingMode: function (r) {
        return (
          this.spaces[r].outputColorSpaceConfig.toneMappingMode || 'standard'
        );
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (r) {
        Object.assign(this.spaces, r);
      },
      _getMatrix: function (r, s, a) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
      },
      fromWorkingColorSpace: function (r, s) {
        return (
          rc(
            'ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().'
          ),
          n.workingToColorSpace(r, s)
        );
      },
      toWorkingColorSpace: function (r, s) {
        return (
          rc(
            'ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().'
          ),
          n.colorSpaceToWorking(r, s)
        );
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    i = [0.3127, 0.329];
  return (
    n.define({
      [cr]: {
        primaries: e,
        whitePoint: i,
        transfer: uh,
        toXYZ: T1,
        fromXYZ: C1,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Wt },
        outputColorSpaceConfig: { drawingBufferColorSpace: Wt },
      },
      [Wt]: {
        primaries: e,
        whitePoint: i,
        transfer: Yt,
        toXYZ: T1,
        fromXYZ: C1,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Wt },
      },
    }),
    n
  );
}
const kt = cq();
function fs(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function zl(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let $o;
class A2 {
  static getDataURL(e, t = 'image/png') {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src;
    let i;
    if (e instanceof HTMLCanvasElement) i = e;
    else {
      ($o === void 0 && ($o = dh('canvas')),
        ($o.width = e.width),
        ($o.height = e.height));
      const r = $o.getContext('2d');
      (e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (i = $o));
    }
    return i.toDataURL(t);
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
    ) {
      const t = dh('canvas');
      ((t.width = e.width), (t.height = e.height));
      const i = t.getContext('2d');
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let a = 0; a < s.length; a++) s[a] = fs(s[a] / 255) * 255;
      return (i.putImageData(r, 0, 0), t);
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(fs(t[i] / 255) * 255))
          : (t[i] = fs(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        Ge(
          'ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'
        ),
        e
      );
  }
}
let uq = 0;
class Vs {
  constructor(e = null) {
    ((this.isSource = !0),
      Object.defineProperty(this, 'id', { value: uq++ }),
      (this.uuid = Wi()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0));
  }
  getSize(e) {
    const t = this.data;
    return (
      typeof HTMLVideoElement < 'u' && t instanceof HTMLVideoElement
        ? e.set(t.videoWidth, t.videoHeight, 0)
        : t instanceof VideoFrame
          ? e.set(t.displayHeight, t.displayWidth, 0)
          : t !== null
            ? e.set(t.width, t.height, t.depth || 0)
            : e.set(0, 0, 0),
      e
    );
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: '' },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(E0(r[a].image)) : s.push(E0(r[a]));
      } else s = E0(r);
      i.url = s;
    }
    return (t || (e.images[this.uuid] = i), i);
  }
}
function E0(n) {
  return (typeof HTMLImageElement < 'u' && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && n instanceof ImageBitmap)
    ? A2.getDataURL(n)
    : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (Ge('Texture: Unable to serialize Texture.'), {});
}
let hq = 0;
const A0 = new V();
class Vt extends Ki {
  constructor(
    e = Vt.DEFAULT_IMAGE,
    t = Vt.DEFAULT_MAPPING,
    i = mn,
    r = mn,
    s = Dt,
    a = kr,
    o = Rn,
    l = gn,
    c = Vt.DEFAULT_ANISOTROPY,
    u = Sr
  ) {
    (super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', { value: hq++ }),
      (this.uuid = Wi()),
      (this.name = ''),
      (this.source = new Vs(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new pe(0, 0)),
      (this.repeat = new pe(1, 1)),
      (this.center = new pe(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new xt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.updateRanges = []),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isArrayTexture = !!(e && e.depth && e.depth > 1)),
      (this.pmremVersion = 0));
  }
  get width() {
    return this.source.getSize(A0).x;
  }
  get height() {
    return this.source.getSize(A0).y;
  }
  get depth() {
    return this.source.getSize(A0).z;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.isArrayTexture = e.isArrayTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  setValues(e) {
    for (const t in e) {
      const i = e[t];
      if (i === void 0) {
        Ge(`Texture.setValues(): parameter '${t}' has value of undefined.`);
        continue;
      }
      const r = this[t];
      if (r === void 0) {
        Ge(`Texture.setValues(): property '${t}' does not exist.`);
        continue;
      }
      (r && i && r.isVector2 && i.isVector2) ||
      (r && i && r.isVector3 && i.isVector3) ||
      (r && i && r.isMatrix3 && i.isMatrix3)
        ? r.copy(i)
        : (this[t] = i);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.7, type: 'Texture', generator: 'Texture.toJSON' },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  transformUv(e) {
    if (this.mapping !== ea) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case ah:
          e.x = e.x - Math.floor(e.x);
          break;
        case mn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case oh:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case ah:
          e.y = e.y - Math.floor(e.y);
          break;
        case mn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case oh:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return (this.flipY && (e.y = 1 - e.y), e);
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Vt.DEFAULT_IMAGE = null;
Vt.DEFAULT_MAPPING = ea;
Vt.DEFAULT_ANISOTROPY = 1;
class Lt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((Lt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r));
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return ((this.x = e), (this.y = t), (this.z = i), (this.w = r), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), (this.w = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setW(e) {
    return ((this.w = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error('index is out of range: ' + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error('index is out of range: ' + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x),
      (this.y += e.y),
      (this.z += e.z),
      (this.w += e.w),
      this
    );
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), (this.w += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x),
      (this.y -= e.y),
      (this.z -= e.z),
      (this.w -= e.w),
      this
    );
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x),
      (this.y *= e.y),
      (this.z *= e.z),
      (this.w *= e.w),
      this
    );
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this);
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s),
      (this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s),
      (this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s),
      (this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x),
      (this.y /= e.y),
      (this.z /= e.z),
      (this.w /= e.w),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      h = l[8],
      d = l[1],
      f = l[5],
      p = l[9],
      m = l[2],
      g = l[6],
      v = l[10];
    if (
      Math.abs(u - d) < 0.01 &&
      Math.abs(h - m) < 0.01 &&
      Math.abs(p - g) < 0.01
    ) {
      if (
        Math.abs(u + d) < 0.1 &&
        Math.abs(h + m) < 0.1 &&
        Math.abs(p + g) < 0.1 &&
        Math.abs(c + f + v - 3) < 0.1
      )
        return (this.set(1, 0, 0, 0), this);
      t = Math.PI;
      const _ = (c + 1) / 2,
        x = (f + 1) / 2,
        S = (v + 1) / 2,
        b = (u + d) / 4,
        A = (h + m) / 4,
        E = (p + g) / 4;
      return (
        _ > x && _ > S
          ? _ < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(_)), (r = b / i), (s = A / i))
          : x > S
            ? x < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(x)), (i = b / r), (s = E / r))
            : S < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(S)), (i = A / s), (r = E / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let y = Math.sqrt(
      (g - p) * (g - p) + (h - m) * (h - m) + (d - u) * (d - u)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (g - p) / y),
      (this.y = (h - m) / y),
      (this.z = (d - u) / y),
      (this.w = Math.acos((c + f + v - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = ut(this.x, e.x, t.x)),
      (this.y = ut(this.y, e.y, t.y)),
      (this.z = ut(this.z, e.z, t.z)),
      (this.w = ut(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = ut(this.x, e, t)),
      (this.y = ut(this.y, e, t)),
      (this.z = ut(this.z, e, t)),
      (this.w = ut(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(ut(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z, yield this.w);
  }
}
class Qx extends Ki {
  constructor(e = 1, t = 1, i = {}) {
    (super(),
      (i = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Dt,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
          depth: 1,
          multiview: !1,
        },
        i
      )),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = i.depth),
      (this.scissor = new Lt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Lt(0, 0, e, t)));
    const r = { width: e, height: t, depth: i.depth },
      s = new Vt(r);
    this.textures = [];
    const a = i.count;
    for (let o = 0; o < a; o++)
      ((this.textures[o] = s.clone()),
        (this.textures[o].isRenderTargetTexture = !0),
        (this.textures[o].renderTarget = this));
    (this._setTextureOptions(i),
      (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples),
      (this.multiview = i.multiview));
  }
  _setTextureOptions(e = {}) {
    const t = {
      minFilter: Dt,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null,
    };
    (e.mapping !== void 0 && (t.mapping = e.mapping),
      e.wrapS !== void 0 && (t.wrapS = e.wrapS),
      e.wrapT !== void 0 && (t.wrapT = e.wrapT),
      e.wrapR !== void 0 && (t.wrapR = e.wrapR),
      e.magFilter !== void 0 && (t.magFilter = e.magFilter),
      e.minFilter !== void 0 && (t.minFilter = e.minFilter),
      e.format !== void 0 && (t.format = e.format),
      e.type !== void 0 && (t.type = e.type),
      e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
      e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
      e.flipY !== void 0 && (t.flipY = e.flipY),
      e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
      e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat));
    for (let i = 0; i < this.textures.length; i++)
      this.textures[i].setValues(t);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    (this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e));
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ((this.width = e), (this.height = t), (this.depth = i));
      for (let r = 0, s = this.textures.length; r < s; r++)
        ((this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = i),
          this.textures[r].isData3DTexture !== !0 &&
            (this.textures[r].isArrayTexture =
              this.textures[r].image.depth > 1));
      this.dispose();
    }
    (this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0));
    for (let t = 0, i = e.textures.length; t < i; t++) {
      ((this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0),
        (this.textures[t].renderTarget = this));
      const r = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new Vs(r);
    }
    return (
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
class Sn extends Qx {
  constructor(e = 1, t = 1, i = {}) {
    (super(e, t, i), (this.isWebGLRenderTarget = !0));
  }
}
class Im extends Vt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = Un),
      (this.minFilter = Un),
      (this.wrapR = mn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set()));
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class dq extends Sn {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    (super(e, t, r),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Im(null, e, t, i)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class Pm extends Vt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = Un),
      (this.minFilter = Un),
      (this.wrapR = mn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
class fq extends Sn {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    (super(e, t, r),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Pm(null, e, t, i)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class ii {
  constructor(
    e = new V(1 / 0, 1 / 0, 1 / 0),
    t = new V(-1 / 0, -1 / 0, -1 / 0)
  ) {
    ((this.isBox3 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(dr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(dr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = dr.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this);
  }
  setFromObject(e, t = !1) {
    return (this.makeEmpty(), this.expandByObject(e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute('position');
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          (e.isMesh === !0
            ? e.getVertexPosition(a, dr)
            : dr.fromBufferAttribute(s, a),
            dr.applyMatrix4(e.matrixWorld),
            this.expandByPoint(dr));
      else
        (e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            wd.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            wd.copy(i.boundingBox)),
          wd.applyMatrix4(e.matrixWorld),
          this.union(wd));
    }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, dr),
      dr.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    (this.getCenter(qc),
      Ed.subVectors(this.max, qc),
      el.subVectors(e.a, qc),
      tl.subVectors(e.b, qc),
      nl.subVectors(e.c, qc),
      As.subVectors(tl, el),
      Ms.subVectors(nl, tl),
      Na.subVectors(el, nl));
    let t = [
      0,
      -As.z,
      As.y,
      0,
      -Ms.z,
      Ms.y,
      0,
      -Na.z,
      Na.y,
      As.z,
      0,
      -As.x,
      Ms.z,
      0,
      -Ms.x,
      Na.z,
      0,
      -Na.x,
      -As.y,
      As.x,
      0,
      -Ms.y,
      Ms.x,
      0,
      -Na.y,
      Na.x,
      0,
    ];
    return !M0(t, el, tl, nl, Ed) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !M0(t, el, tl, nl, Ed))
      ? !1
      : (Ad.crossVectors(As, Ms),
        (t = [Ad.x, Ad.y, Ad.z]),
        M0(t, el, tl, nl, Ed));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, dr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(dr).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Qr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Qr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Qr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Qr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Qr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Qr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Qr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Qr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Qr),
        this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  toJSON() {
    return { min: this.min.toArray(), max: this.max.toArray() };
  }
  fromJSON(e) {
    return (this.min.fromArray(e.min), this.max.fromArray(e.max), this);
  }
}
const Qr = [
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
    new V(),
  ],
  dr = new V(),
  wd = new ii(),
  el = new V(),
  tl = new V(),
  nl = new V(),
  As = new V(),
  Ms = new V(),
  Na = new V(),
  qc = new V(),
  Ed = new V(),
  Ad = new V(),
  Fa = new V();
function M0(n, e, t, i, r) {
  for (let s = 0, a = n.length - 3; s <= a; s += 3) {
    Fa.fromArray(n, s);
    const o =
        r.x * Math.abs(Fa.x) + r.y * Math.abs(Fa.y) + r.z * Math.abs(Fa.z),
      l = e.dot(Fa),
      c = t.dot(Fa),
      u = i.dot(Fa);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
  }
  return !0;
}
const pq = new ii(),
  Yc = new V(),
  T0 = new V();
class Yn {
  constructor(e = new V(), t = -1) {
    ((this.isSphere = !0), (this.center = e), (this.radius = t));
  }
  set(e, t) {
    return (this.center.copy(e), (this.radius = t), this);
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : pq.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return ((this.radius = Math.sqrt(r)), this);
  }
  copy(e) {
    return (this.center.copy(e.center), (this.radius = e.radius), this);
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return (this.center.set(0, 0, 0), (this.radius = -1), this);
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return (this.center.add(e), this);
  }
  expandByPoint(e) {
    if (this.isEmpty()) return (this.center.copy(e), (this.radius = 0), this);
    Yc.subVectors(e, this.center);
    const t = Yc.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      (this.center.addScaledVector(Yc, r / i), (this.radius += r));
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (T0.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Yc.copy(e.center).add(T0)),
              this.expandByPoint(Yc.copy(e.center).sub(T0))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    return { radius: this.radius, center: this.center.toArray() };
  }
  fromJSON(e) {
    return ((this.radius = e.radius), this.center.fromArray(e.center), this);
  }
}
const Zr = new V(),
  C0 = new V(),
  Md = new V(),
  Ts = new V(),
  R0 = new V(),
  Td = new V(),
  I0 = new V();
class Tc {
  constructor(e = new V(), t = new V(0, 0, -1)) {
    ((this.origin = e), (this.direction = t));
  }
  set(e, t) {
    return (this.origin.copy(e), this.direction.copy(t), this);
  }
  copy(e) {
    return (this.origin.copy(e.origin), this.direction.copy(e.direction), this);
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return (this.direction.copy(e).sub(this.origin).normalize(), this);
  }
  recast(e) {
    return (this.origin.copy(this.at(e, Zr)), this);
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Zr.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Zr.copy(this.origin).addScaledVector(this.direction, t),
        Zr.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    (C0.copy(e).add(t).multiplyScalar(0.5),
      Md.copy(t).sub(e).normalize(),
      Ts.copy(this.origin).sub(C0));
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(Md),
      o = Ts.dot(this.direction),
      l = -Ts.dot(Md),
      c = Ts.lengthSq(),
      u = Math.abs(1 - a * a);
    let h, d, f, p;
    if (u > 0)
      if (((h = a * l - o), (d = a * o - l), (p = s * u), h >= 0))
        if (d >= -p)
          if (d <= p) {
            const m = 1 / u;
            ((h *= m),
              (d *= m),
              (f = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + c));
          } else
            ((d = s),
              (h = Math.max(0, -(a * d + o))),
              (f = -h * h + d * (d + 2 * l) + c));
        else
          ((d = -s),
            (h = Math.max(0, -(a * d + o))),
            (f = -h * h + d * (d + 2 * l) + c));
      else
        d <= -p
          ? ((h = Math.max(0, -(-a * s + o))),
            (d = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (f = -h * h + d * (d + 2 * l) + c))
          : d <= p
            ? ((h = 0),
              (d = Math.min(Math.max(-s, -l), s)),
              (f = d * (d + 2 * l) + c))
            : ((h = Math.max(0, -(a * s + o))),
              (d = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
              (f = -h * h + d * (d + 2 * l) + c));
    else
      ((d = a > 0 ? -s : s),
        (h = Math.max(0, -(a * d + o))),
        (f = -h * h + d * (d + 2 * l) + c));
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, h),
      r && r.copy(C0).addScaledVector(Md, d),
      f
    );
  }
  intersectSphere(e, t) {
    Zr.subVectors(e.center, this.origin);
    const i = Zr.dot(this.direction),
      r = Zr.dot(Zr) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const a = Math.sqrt(s - r),
      o = i - a,
      l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return e.radius < 0
      ? !1
      : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, a, o, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      h = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c))
        : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
      u >= 0
        ? ((s = (e.min.y - d.y) * u), (a = (e.max.y - d.y) * u))
        : ((s = (e.max.y - d.y) * u), (a = (e.min.y - d.y) * u)),
      i > a ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (a < r || isNaN(r)) && (r = a),
      h >= 0
        ? ((o = (e.min.z - d.z) * h), (l = (e.max.z - d.z) * h))
        : ((o = (e.max.z - d.z) * h), (l = (e.min.z - d.z) * h)),
      i > l || o > r) ||
      ((o > i || i !== i) && (i = o), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Zr) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    (R0.subVectors(t, e), Td.subVectors(i, e), I0.crossVectors(R0, Td));
    let a = this.direction.dot(I0),
      o;
    if (a > 0) {
      if (r) return null;
      o = 1;
    } else if (a < 0) ((o = -1), (a = -a));
    else return null;
    Ts.subVectors(this.origin, e);
    const l = o * this.direction.dot(Td.crossVectors(Ts, Td));
    if (l < 0) return null;
    const c = o * this.direction.dot(R0.cross(Ts));
    if (c < 0 || l + c > a) return null;
    const u = -o * Ts.dot(I0);
    return u < 0 ? null : this.at(u / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e),
      this.direction.transformDirection(e),
      this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class pt {
  constructor(e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g) {
    ((pt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g));
  }
  set(e, t, i, r, s, a, o, l, c, u, h, d, f, p, m, g) {
    const v = this.elements;
    return (
      (v[0] = e),
      (v[4] = t),
      (v[8] = i),
      (v[12] = r),
      (v[1] = s),
      (v[5] = a),
      (v[9] = o),
      (v[13] = l),
      (v[2] = c),
      (v[6] = u),
      (v[10] = h),
      (v[14] = d),
      (v[3] = f),
      (v[7] = p),
      (v[11] = m),
      (v[15] = g),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  clone() {
    return new pt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return ((t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this);
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / il.setFromMatrixColumn(e, 0).length(),
      s = 1 / il.setFromMatrixColumn(e, 1).length(),
      a = 1 / il.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * a),
      (t[9] = i[9] * a),
      (t[10] = i[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      a = Math.cos(i),
      o = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      h = Math.sin(s);
    if (e.order === 'XYZ') {
      const d = a * u,
        f = a * h,
        p = o * u,
        m = o * h;
      ((t[0] = l * u),
        (t[4] = -l * h),
        (t[8] = c),
        (t[1] = f + p * c),
        (t[5] = d - m * c),
        (t[9] = -o * l),
        (t[2] = m - d * c),
        (t[6] = p + f * c),
        (t[10] = a * l));
    } else if (e.order === 'YXZ') {
      const d = l * u,
        f = l * h,
        p = c * u,
        m = c * h;
      ((t[0] = d + m * o),
        (t[4] = p * o - f),
        (t[8] = a * c),
        (t[1] = a * h),
        (t[5] = a * u),
        (t[9] = -o),
        (t[2] = f * o - p),
        (t[6] = m + d * o),
        (t[10] = a * l));
    } else if (e.order === 'ZXY') {
      const d = l * u,
        f = l * h,
        p = c * u,
        m = c * h;
      ((t[0] = d - m * o),
        (t[4] = -a * h),
        (t[8] = p + f * o),
        (t[1] = f + p * o),
        (t[5] = a * u),
        (t[9] = m - d * o),
        (t[2] = -a * c),
        (t[6] = o),
        (t[10] = a * l));
    } else if (e.order === 'ZYX') {
      const d = a * u,
        f = a * h,
        p = o * u,
        m = o * h;
      ((t[0] = l * u),
        (t[4] = p * c - f),
        (t[8] = d * c + m),
        (t[1] = l * h),
        (t[5] = m * c + d),
        (t[9] = f * c - p),
        (t[2] = -c),
        (t[6] = o * l),
        (t[10] = a * l));
    } else if (e.order === 'YZX') {
      const d = a * l,
        f = a * c,
        p = o * l,
        m = o * c;
      ((t[0] = l * u),
        (t[4] = m - d * h),
        (t[8] = p * h + f),
        (t[1] = h),
        (t[5] = a * u),
        (t[9] = -o * u),
        (t[2] = -c * u),
        (t[6] = f * h + p),
        (t[10] = d - m * h));
    } else if (e.order === 'XZY') {
      const d = a * l,
        f = a * c,
        p = o * l,
        m = o * c;
      ((t[0] = l * u),
        (t[4] = -h),
        (t[8] = c * u),
        (t[1] = d * h + m),
        (t[5] = a * u),
        (t[9] = f * h - p),
        (t[2] = p * h - f),
        (t[6] = o * u),
        (t[10] = m * h + d));
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(mq, e, gq);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      Li.subVectors(e, t),
      Li.lengthSq() === 0 && (Li.z = 1),
      Li.normalize(),
      Cs.crossVectors(i, Li),
      Cs.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Li.x += 1e-4) : (Li.z += 1e-4),
        Li.normalize(),
        Cs.crossVectors(i, Li)),
      Cs.normalize(),
      Cd.crossVectors(Li, Cs),
      (r[0] = Cs.x),
      (r[4] = Cd.x),
      (r[8] = Li.x),
      (r[1] = Cs.y),
      (r[5] = Cd.y),
      (r[9] = Li.y),
      (r[2] = Cs.z),
      (r[6] = Cd.z),
      (r[10] = Li.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      a = i[0],
      o = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      h = i[5],
      d = i[9],
      f = i[13],
      p = i[2],
      m = i[6],
      g = i[10],
      v = i[14],
      y = i[3],
      _ = i[7],
      x = i[11],
      S = i[15],
      b = r[0],
      A = r[4],
      E = r[8],
      w = r[12],
      M = r[1],
      T = r[5],
      D = r[9],
      L = r[13],
      O = r[2],
      z = r[6],
      C = r[10],
      N = r[14],
      U = r[3],
      W = r[7],
      G = r[11],
      ne = r[15];
    return (
      (s[0] = a * b + o * M + l * O + c * U),
      (s[4] = a * A + o * T + l * z + c * W),
      (s[8] = a * E + o * D + l * C + c * G),
      (s[12] = a * w + o * L + l * N + c * ne),
      (s[1] = u * b + h * M + d * O + f * U),
      (s[5] = u * A + h * T + d * z + f * W),
      (s[9] = u * E + h * D + d * C + f * G),
      (s[13] = u * w + h * L + d * N + f * ne),
      (s[2] = p * b + m * M + g * O + v * U),
      (s[6] = p * A + m * T + g * z + v * W),
      (s[10] = p * E + m * D + g * C + v * G),
      (s[14] = p * w + m * L + g * N + v * ne),
      (s[3] = y * b + _ * M + x * O + S * U),
      (s[7] = y * A + _ * T + x * z + S * W),
      (s[11] = y * E + _ * D + x * C + S * G),
      (s[15] = y * w + _ * L + x * N + S * ne),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      h = e[6],
      d = e[10],
      f = e[14],
      p = e[3],
      m = e[7],
      g = e[11],
      v = e[15];
    return (
      p *
        (+s * l * h -
          r * c * h -
          s * o * d +
          i * c * d +
          r * o * f -
          i * l * f) +
      m *
        (+t * l * f -
          t * c * d +
          s * a * d -
          r * a * f +
          r * c * u -
          s * l * u) +
      g *
        (+t * c * h -
          t * o * f -
          s * a * h +
          i * a * f +
          s * o * u -
          i * c * u) +
      v *
        (-r * o * u - t * l * h + t * o * d + r * a * h - i * a * d + i * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = e[9],
      d = e[10],
      f = e[11],
      p = e[12],
      m = e[13],
      g = e[14],
      v = e[15],
      y = h * g * c - m * d * c + m * l * f - o * g * f - h * l * v + o * d * v,
      _ = p * d * c - u * g * c - p * l * f + a * g * f + u * l * v - a * d * v,
      x = u * m * c - p * h * c + p * o * f - a * m * f - u * o * v + a * h * v,
      S = p * h * l - u * m * l - p * o * d + a * m * d + u * o * g - a * h * g,
      b = t * y + i * _ + r * x + s * S;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / b;
    return (
      (e[0] = y * A),
      (e[1] =
        (m * d * s -
          h * g * s -
          m * r * f +
          i * g * f +
          h * r * v -
          i * d * v) *
        A),
      (e[2] =
        (o * g * s -
          m * l * s +
          m * r * c -
          i * g * c -
          o * r * v +
          i * l * v) *
        A),
      (e[3] =
        (h * l * s -
          o * d * s -
          h * r * c +
          i * d * c +
          o * r * f -
          i * l * f) *
        A),
      (e[4] = _ * A),
      (e[5] =
        (u * g * s -
          p * d * s +
          p * r * f -
          t * g * f -
          u * r * v +
          t * d * v) *
        A),
      (e[6] =
        (p * l * s -
          a * g * s -
          p * r * c +
          t * g * c +
          a * r * v -
          t * l * v) *
        A),
      (e[7] =
        (a * d * s -
          u * l * s +
          u * r * c -
          t * d * c -
          a * r * f +
          t * l * f) *
        A),
      (e[8] = x * A),
      (e[9] =
        (p * h * s -
          u * m * s -
          p * i * f +
          t * m * f +
          u * i * v -
          t * h * v) *
        A),
      (e[10] =
        (a * m * s -
          p * o * s +
          p * i * c -
          t * m * c -
          a * i * v +
          t * o * v) *
        A),
      (e[11] =
        (u * o * s -
          a * h * s -
          u * i * c +
          t * h * c +
          a * i * f -
          t * o * f) *
        A),
      (e[12] = S * A),
      (e[13] =
        (u * m * r -
          p * h * r +
          p * i * d -
          t * m * d -
          u * i * g +
          t * h * g) *
        A),
      (e[14] =
        (p * o * r -
          a * m * r -
          p * i * l +
          t * m * l +
          a * i * g -
          t * o * g) *
        A),
      (e[15] =
        (a * h * r -
          u * o * r +
          u * i * l -
          t * h * l -
          a * i * d +
          t * o * d) *
        A),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      u = s * o;
    return (
      this.set(
        c * a + i,
        c * o - r * l,
        c * l + r * o,
        0,
        c * o + r * l,
        u * o + i,
        u * l - r * a,
        0,
        c * l - r * o,
        u * l + r * a,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return (this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this);
  }
  makeShear(e, t, i, r, s, a) {
    return (this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this);
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      a = t._y,
      o = t._z,
      l = t._w,
      c = s + s,
      u = a + a,
      h = o + o,
      d = s * c,
      f = s * u,
      p = s * h,
      m = a * u,
      g = a * h,
      v = o * h,
      y = l * c,
      _ = l * u,
      x = l * h,
      S = i.x,
      b = i.y,
      A = i.z;
    return (
      (r[0] = (1 - (m + v)) * S),
      (r[1] = (f + x) * S),
      (r[2] = (p - _) * S),
      (r[3] = 0),
      (r[4] = (f - x) * b),
      (r[5] = (1 - (d + v)) * b),
      (r[6] = (g + y) * b),
      (r[7] = 0),
      (r[8] = (p + _) * A),
      (r[9] = (g - y) * A),
      (r[10] = (1 - (d + m)) * A),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = il.set(r[0], r[1], r[2]).length();
    const a = il.set(r[4], r[5], r[6]).length(),
      o = il.set(r[8], r[9], r[10]).length();
    (this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      fr.copy(this));
    const c = 1 / s,
      u = 1 / a,
      h = 1 / o;
    return (
      (fr.elements[0] *= c),
      (fr.elements[1] *= c),
      (fr.elements[2] *= c),
      (fr.elements[4] *= u),
      (fr.elements[5] *= u),
      (fr.elements[6] *= u),
      (fr.elements[8] *= h),
      (fr.elements[9] *= h),
      (fr.elements[10] *= h),
      t.setFromRotationMatrix(fr),
      (i.x = s),
      (i.y = a),
      (i.z = o),
      this
    );
  }
  makePerspective(e, t, i, r, s, a, o = Hi, l = !1) {
    const c = this.elements,
      u = (2 * s) / (t - e),
      h = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      f = (i + r) / (i - r);
    let p, m;
    if (l) ((p = s / (a - s)), (m = (a * s) / (a - s)));
    else if (o === Hi) ((p = -(a + s) / (a - s)), (m = (-2 * a * s) / (a - s)));
    else if (o === ic) ((p = -a / (a - s)), (m = (-a * s) / (a - s)));
    else
      throw new Error(
        'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + o
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = d),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = h),
      (c[9] = f),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = p),
      (c[14] = m),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, a, o = Hi, l = !1) {
    const c = this.elements,
      u = 2 / (t - e),
      h = 2 / (i - r),
      d = -(t + e) / (t - e),
      f = -(i + r) / (i - r);
    let p, m;
    if (l) ((p = 1 / (a - s)), (m = a / (a - s)));
    else if (o === Hi) ((p = -2 / (a - s)), (m = -(a + s) / (a - s)));
    else if (o === ic) ((p = -1 / (a - s)), (m = -s / (a - s)));
    else
      throw new Error(
        'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + o
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = d),
      (c[1] = 0),
      (c[5] = h),
      (c[9] = 0),
      (c[13] = f),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = p),
      (c[14] = m),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const il = new V(),
  fr = new pt(),
  mq = new V(0, 0, 0),
  gq = new V(1, 1, 1),
  Cs = new V(),
  Cd = new V(),
  Li = new V(),
  R1 = new pt(),
  I1 = new Ii();
class Yi {
  constructor(e = 0, t = 0, i = 0, r = Yi.DEFAULT_ORDER) {
    ((this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r));
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get order() {
    return this._order;
  }
  set order(e) {
    ((this._order = e), this._onChangeCallback());
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      a = r[4],
      o = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      h = r[2],
      d = r[6],
      f = r[10];
    switch (t) {
      case 'XYZ':
        ((this._y = Math.asin(ut(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0)));
        break;
      case 'YXZ':
        ((this._x = Math.asin(-ut(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(o, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0)));
        break;
      case 'ZXY':
        ((this._x = Math.asin(ut(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-h, f)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s))));
        break;
      case 'ZYX':
        ((this._y = Math.asin(-ut(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c))));
        break;
      case 'YZX':
        ((this._z = Math.asin(ut(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, f))));
        break;
      case 'XZY':
        ((this._z = Math.asin(-ut(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-u, f)), (this._y = 0)));
        break;
      default:
        Ge(
          'Euler: .setFromRotationMatrix() encountered an unknown order: ' + t
        );
    }
    return ((this._order = t), i === !0 && this._onChangeCallback(), this);
  }
  setFromQuaternion(e, t, i) {
    return (
      R1.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(R1, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return (I1.setFromEuler(this), this.setFromQuaternion(I1, e));
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._order);
  }
}
Yi.DEFAULT_ORDER = 'XYZ';
class Dm {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let vq = 0;
const P1 = new V(),
  rl = new Ii(),
  $r = new pt(),
  Rd = new V(),
  Kc = new V(),
  _q = new V(),
  yq = new Ii(),
  D1 = new V(1, 0, 0),
  O1 = new V(0, 1, 0),
  L1 = new V(0, 0, 1),
  U1 = { type: 'added' },
  xq = { type: 'removed' },
  sl = { type: 'childadded', child: null },
  P0 = { type: 'childremoved', child: null };
class Ft extends Ki {
  constructor() {
    (super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', { value: vq++ }),
      (this.uuid = Wi()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = Ft.DEFAULT_UP.clone()));
    const e = new V(),
      t = new Yi(),
      i = new Ii(),
      r = new V(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(i, void 0, !1);
    }
    (t._onChange(s),
      i._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new pt() },
        normalMatrix: { value: new xt() },
      }),
      (this.matrix = new pt()),
      (this.matrixWorld = new pt()),
      (this.matrixAutoUpdate = Ft.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Dm()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {}));
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale));
  }
  applyQuaternion(e) {
    return (this.quaternion.premultiply(e), this);
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return (rl.setFromAxisAngle(e, t), this.quaternion.multiply(rl), this);
  }
  rotateOnWorldAxis(e, t) {
    return (rl.setFromAxisAngle(e, t), this.quaternion.premultiply(rl), this);
  }
  rotateX(e) {
    return this.rotateOnAxis(D1, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(O1, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(L1, e);
  }
  translateOnAxis(e, t) {
    return (
      P1.copy(e).applyQuaternion(this.quaternion),
      this.position.add(P1.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(D1, e);
  }
  translateY(e) {
    return this.translateOnAxis(O1, e);
  }
  translateZ(e) {
    return this.translateOnAxis(L1, e);
  }
  localToWorld(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld));
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4($r.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? Rd.copy(e) : Rd.set(e, t, i);
    const r = this.parent;
    (this.updateWorldMatrix(!0, !1),
      Kc.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? $r.lookAt(Kc, Rd, this.up)
        : $r.lookAt(Rd, Kc, this.up),
      this.quaternion.setFromRotationMatrix($r),
      r &&
        ($r.extractRotation(r.matrixWorld),
        rl.setFromRotationMatrix($r),
        this.quaternion.premultiply(rl.invert())));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (gt("Object3D.add: object can't be added as a child of itself.", e),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(U1),
            (sl.child = e),
            this.dispatchEvent(sl),
            (sl.child = null))
          : gt('Object3D.add: object not an instance of THREE.Object3D.', e),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(xq),
        (P0.child = e),
        this.dispatchEvent(P0),
        (P0.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return (e !== null && e.remove(this), this);
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      $r.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), $r.multiply(e.parent.matrixWorld)),
      e.applyMatrix4($r),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(U1),
      (sl.child = e),
      this.dispatchEvent(sl),
      (sl.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty('id', e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty('name', e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(Kc, e, _q),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(Kc, yq, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    (this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0));
  }
  updateMatrixWorld(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0)));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string',
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.7,
        type: 'Object',
        generator: 'Object3D.toJSON',
      }));
    const r = {};
    ((r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== '' && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = 'InstancedMesh'),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = 'BatchedMesh'),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.geometryInfo = this._geometryInfo.map((o) => ({
          ...o,
          boundingBox: o.boundingBox ? o.boundingBox.toJSON() : void 0,
          boundingSphere: o.boundingSphere ? o.boundingSphere.toJSON() : void 0,
        }))),
        (r.instanceInfo = this._instanceInfo.map((o) => ({ ...o }))),
        (r.availableInstanceIds = this._availableInstanceIds.slice()),
        (r.availableGeometryIds = this._availableGeometryIds.slice()),
        (r.nextIndexStart = this._nextIndexStart),
        (r.nextVertexStart = this._nextVertexStart),
        (r.geometryCount = this._geometryCount),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        (r.indirectTexture = this._indirectTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null &&
          (r.boundingBox = this.boundingBox.toJSON())));
    function s(o, l) {
      return (o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid);
    }
    if (this.isScene)
      (this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid));
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        h = a(e.shapes),
        d = a(e.skeletons),
        f = a(e.animations),
        p = a(e.nodes);
      (o.length > 0 && (i.geometries = o),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        h.length > 0 && (i.shapes = h),
        d.length > 0 && (i.skeletons = d),
        f.length > 0 && (i.animations = f),
        p.length > 0 && (i.nodes = p));
    }
    return ((i.object = r), i);
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        (delete u.metadata, l.push(u));
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Ft.DEFAULT_UP = new V(0, 1, 0);
Ft.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const pr = new V(),
  es = new V(),
  D0 = new V(),
  ts = new V(),
  al = new V(),
  ol = new V(),
  k1 = new V(),
  O0 = new V(),
  L0 = new V(),
  U0 = new V(),
  k0 = new Lt(),
  B0 = new Lt(),
  N0 = new Lt();
class bi {
  constructor(e = new V(), t = new V(), i = new V()) {
    ((this.a = e), (this.b = t), (this.c = i));
  }
  static getNormal(e, t, i, r) {
    (r.subVectors(i, t), pr.subVectors(e, t), r.cross(pr));
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    (pr.subVectors(r, t), es.subVectors(i, t), D0.subVectors(e, t));
    const a = pr.dot(pr),
      o = pr.dot(es),
      l = pr.dot(D0),
      c = es.dot(es),
      u = es.dot(D0),
      h = a * c - o * o;
    if (h === 0) return (s.set(0, 0, 0), null);
    const d = 1 / h,
      f = (c * l - o * u) * d,
      p = (a * u - o * l) * d;
    return s.set(1 - f - p, p, f);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, ts) === null
      ? !1
      : ts.x >= 0 && ts.y >= 0 && ts.x + ts.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, a, o, l) {
    return this.getBarycoord(e, t, i, r, ts) === null
      ? ((l.x = 0),
        (l.y = 0),
        'z' in l && (l.z = 0),
        'w' in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, ts.x),
        l.addScaledVector(a, ts.y),
        l.addScaledVector(o, ts.z),
        l);
  }
  static getInterpolatedAttribute(e, t, i, r, s, a) {
    return (
      k0.setScalar(0),
      B0.setScalar(0),
      N0.setScalar(0),
      k0.fromBufferAttribute(e, t),
      B0.fromBufferAttribute(e, i),
      N0.fromBufferAttribute(e, r),
      a.setScalar(0),
      a.addScaledVector(k0, s.x),
      a.addScaledVector(B0, s.y),
      a.addScaledVector(N0, s.z),
      a
    );
  }
  static isFrontFacing(e, t, i, r) {
    return (pr.subVectors(i, t), es.subVectors(e, t), pr.cross(es).dot(r) < 0);
  }
  set(e, t, i) {
    return (this.a.copy(e), this.b.copy(t), this.c.copy(i), this);
  }
  setFromPointsAndIndices(e, t, i, r) {
    return (this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this);
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this);
  }
  getArea() {
    return (
      pr.subVectors(this.c, this.b),
      es.subVectors(this.a, this.b),
      pr.cross(es).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return bi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return bi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return bi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return bi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return bi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let a, o;
    (al.subVectors(r, i), ol.subVectors(s, i), O0.subVectors(e, i));
    const l = al.dot(O0),
      c = ol.dot(O0);
    if (l <= 0 && c <= 0) return t.copy(i);
    L0.subVectors(e, r);
    const u = al.dot(L0),
      h = ol.dot(L0);
    if (u >= 0 && h <= u) return t.copy(r);
    const d = l * h - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return ((a = l / (l - u)), t.copy(i).addScaledVector(al, a));
    U0.subVectors(e, s);
    const f = al.dot(U0),
      p = ol.dot(U0);
    if (p >= 0 && f <= p) return t.copy(s);
    const m = f * c - l * p;
    if (m <= 0 && c >= 0 && p <= 0)
      return ((o = c / (c - p)), t.copy(i).addScaledVector(ol, o));
    const g = u * p - f * h;
    if (g <= 0 && h - u >= 0 && f - p >= 0)
      return (
        k1.subVectors(s, r),
        (o = (h - u) / (h - u + (f - p))),
        t.copy(r).addScaledVector(k1, o)
      );
    const v = 1 / (g + m + d);
    return (
      (a = m * v),
      (o = d * v),
      t.copy(i).addScaledVector(al, a).addScaledVector(ol, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const M2 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Rs = { h: 0, s: 0, l: 0 },
  Id = { h: 0, s: 0, l: 0 };
function F0(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * 6 * (2 / 3 - t)
          : n
  );
}
class je {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == 'number'
          ? this.setHex(r)
          : typeof r == 'string' && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return ((this.r = e), (this.g = e), (this.b = e), this);
  }
  setHex(e, t = Wt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      kt.colorSpaceToWorking(this, t),
      this
    );
  }
  setRGB(e, t, i, r = kt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      kt.colorSpaceToWorking(this, r),
      this
    );
  }
  setHSL(e, t, i, r = kt.workingColorSpace) {
    if (((e = Jx(e, 1)), (t = ut(t, 0, 1)), (i = ut(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        a = 2 * i - s;
      ((this.r = F0(a, s, e + 1 / 3)),
        (this.g = F0(a, s, e)),
        (this.b = F0(a, s, e - 1 / 3)));
    }
    return (kt.colorSpaceToWorking(this, r), this);
  }
  setStyle(e, t = Wt) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        Ge('Color: Alpha component of ' + e + ' will be ignored.');
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = r[1],
        o = r[2];
      switch (a) {
        case 'rgb':
        case 'rgba':
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case 'hsl':
        case 'hsla':
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          Ge('Color: Unknown color model ' + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (a === 6) return this.setHex(parseInt(s, 16), t);
      Ge('Color: Invalid hex color ' + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Wt) {
    const i = M2[e.toLowerCase()];
    return (
      i !== void 0 ? this.setHex(i, t) : Ge('Color: Unknown color ' + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return ((this.r = e.r), (this.g = e.g), (this.b = e.b), this);
  }
  copySRGBToLinear(e) {
    return ((this.r = fs(e.r)), (this.g = fs(e.g)), (this.b = fs(e.b)), this);
  }
  copyLinearToSRGB(e) {
    return ((this.r = zl(e.r)), (this.g = zl(e.g)), (this.b = zl(e.b)), this);
  }
  convertSRGBToLinear() {
    return (this.copySRGBToLinear(this), this);
  }
  convertLinearToSRGB() {
    return (this.copyLinearToSRGB(this), this);
  }
  getHex(e = Wt) {
    return (
      kt.workingToColorSpace(Qn.copy(this), e),
      Math.round(ut(Qn.r * 255, 0, 255)) * 65536 +
        Math.round(ut(Qn.g * 255, 0, 255)) * 256 +
        Math.round(ut(Qn.b * 255, 0, 255))
    );
  }
  getHexString(e = Wt) {
    return ('000000' + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = kt.workingColorSpace) {
    kt.workingToColorSpace(Qn.copy(this), t);
    const i = Qn.r,
      r = Qn.g,
      s = Qn.b,
      a = Math.max(i, r, s),
      o = Math.min(i, r, s);
    let l, c;
    const u = (o + a) / 2;
    if (o === a) ((l = 0), (c = 0));
    else {
      const h = a - o;
      switch (((c = u <= 0.5 ? h / (a + o) : h / (2 - a - o)), a)) {
        case i:
          l = (r - s) / h + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - r) / h + 4;
          break;
      }
      l /= 6;
    }
    return ((e.h = l), (e.s = c), (e.l = u), e);
  }
  getRGB(e, t = kt.workingColorSpace) {
    return (
      kt.workingToColorSpace(Qn.copy(this), t),
      (e.r = Qn.r),
      (e.g = Qn.g),
      (e.b = Qn.b),
      e
    );
  }
  getStyle(e = Wt) {
    kt.workingToColorSpace(Qn.copy(this), e);
    const t = Qn.r,
      i = Qn.g,
      r = Qn.b;
    return e !== Wt
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return (this.getHSL(Rs), this.setHSL(Rs.h + e, Rs.s + t, Rs.l + i));
  }
  add(e) {
    return ((this.r += e.r), (this.g += e.g), (this.b += e.b), this);
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r),
      (this.g = e.g + t.g),
      (this.b = e.b + t.b),
      this
    );
  }
  addScalar(e) {
    return ((this.r += e), (this.g += e), (this.b += e), this);
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return ((this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this);
  }
  multiplyScalar(e) {
    return ((this.r *= e), (this.g *= e), (this.b *= e), this);
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    (this.getHSL(Rs), e.getHSL(Id));
    const i = Uu(Rs.h, Id.h, t),
      r = Uu(Rs.s, Id.s, t),
      s = Uu(Rs.l, Id.l, t);
    return (this.setHSL(i, r, s), this);
  }
  setFromVector3(e) {
    return ((this.r = e.x), (this.g = e.y), (this.b = e.z), this);
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return ((this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    (yield this.r, yield this.g, yield this.b);
  }
}
const Qn = new je();
je.NAMES = M2;
let bq = 0;
class jn extends Ki {
  constructor() {
    (super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', { value: bq++ }),
      (this.uuid = Wi()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = Eo),
      (this.side = Wr),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = op),
      (this.blendDst = lp),
      (this.blendEquation = Bs),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new je(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Do),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = K_),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = to),
      (this.stencilZFail = to),
      (this.stencilZPass = to),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0));
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    (this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e));
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          Ge(`Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          Ge(`Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
            ? r.copy(i)
            : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == 'string';
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.7,
        type: 'Material',
        generator: 'Material.toJSON',
      },
    };
    ((i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.sheenColorMap &&
        this.sheenColorMap.isTexture &&
        (i.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
      this.sheenRoughnessMap &&
        this.sheenRoughnessMap.isTexture &&
        (i.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Eo && (i.blending = this.blending),
      this.side !== Wr && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== op && (i.blendSrc = this.blendSrc),
      this.blendDst !== lp && (i.blendDst = this.blendDst),
      this.blendEquation !== Bs && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== Do && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== K_ && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== to && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== to && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== to && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData));
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        (delete l.metadata, a.push(l));
      }
      return a;
    }
    if (t) {
      const s = r(e.textures),
        a = r(e.images);
      (s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a));
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite));
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class xs extends jn {
  constructor(e) {
    (super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Yi()),
      (this.combine = kh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const ls = Sq();
function Sq() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : c < -14
        ? ((i[l] = 1024 >> (-c - 14)),
          (i[l | 256] = (1024 >> (-c - 14)) | 32768),
          (r[l] = -c - 1),
          (r[l | 256] = -c - 1))
        : c <= 15
          ? ((i[l] = (c + 15) << 10),
            (i[l | 256] = ((c + 15) << 10) | 32768),
            (r[l] = 13),
            (r[l | 256] = 13))
          : c < 128
            ? ((i[l] = 31744),
              (i[l | 256] = 64512),
              (r[l] = 24),
              (r[l | 256] = 24))
            : ((i[l] = 31744),
              (i[l | 256] = 64512),
              (r[l] = 13),
              (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    a = new Uint32Array(64),
    o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; (c & 8388608) === 0; ) ((c <<= 1), (u -= 8388608));
    ((c &= -8388609), (u += 947912704), (s[l] = c | u));
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) a[l] = l << 23;
  ((a[31] = 1199570944), (a[32] = 2147483648));
  for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (o[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: a,
    offsetTable: o,
  };
}
function xi(n) {
  (Math.abs(n) > 65504 && Ge('DataUtils.toHalfFloat(): Value out of range.'),
    (n = ut(n, -65504, 65504)),
    (ls.floatView[0] = n));
  const e = ls.uint32View[0],
    t = (e >> 23) & 511;
  return ls.baseTable[t] + ((e & 8388607) >> ls.shiftTable[t]);
}
function pu(n) {
  const e = n >> 10;
  return (
    (ls.uint32View[0] =
      ls.mantissaTable[ls.offsetTable[e] + (n & 1023)] + ls.exponentTable[e]),
    ls.floatView[0]
  );
}
class po {
  static toHalfFloat(e) {
    return xi(e);
  }
  static fromHalfFloat(e) {
    return pu(e);
  }
}
const wn = new V(),
  Pd = new pe();
let wq = 0;
class qt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.'
      );
    ((this.isBufferAttribute = !0),
      Object.defineProperty(this, 'id', { value: wq++ }),
      (this.name = ''),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = hh),
      (this.updateRanges = []),
      (this.gpuType = un),
      (this.version = 0));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.itemSize), (i *= t.itemSize));
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return (this.array.set(e), this);
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        (Pd.fromBufferAttribute(this, t),
          Pd.applyMatrix3(e),
          this.setXY(t, Pd.x, Pd.y));
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        (wn.fromBufferAttribute(this, t),
          wn.applyMatrix3(e),
          this.setXYZ(t, wn.x, wn.y, wn.z));
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (wn.fromBufferAttribute(this, t),
        wn.applyMatrix4(e),
        this.setXYZ(t, wn.x, wn.y, wn.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (wn.fromBufferAttribute(this, t),
        wn.applyNormalMatrix(e),
        this.setXYZ(t, wn.x, wn.y, wn.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (wn.fromBufferAttribute(this, t),
        wn.transformDirection(e),
        this.setXYZ(t, wn.x, wn.y, wn.z));
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return (this.normalized && (i = ui(i, this.array)), i);
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = bt(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = bt(t, this.array)), (i = bt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array)),
        (s = bt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== '' && (e.name = this.name),
      this.usage !== hh && (e.usage = this.usage),
      e
    );
  }
}
class Eq extends qt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class Aq extends qt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class Mq extends qt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class Tq extends qt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class Zx extends qt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Cq extends qt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class $x extends qt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class Rq extends qt {
  constructor(e, t, i) {
    (super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0));
  }
  getX(e) {
    let t = pu(this.array[e * this.itemSize]);
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize] = xi(t)),
      this
    );
  }
  getY(e) {
    let t = pu(this.array[e * this.itemSize + 1]);
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 1] = xi(t)),
      this
    );
  }
  getZ(e) {
    let t = pu(this.array[e * this.itemSize + 2]);
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 2] = xi(t)),
      this
    );
  }
  getW(e) {
    let t = pu(this.array[e * this.itemSize + 3]);
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.array[e * this.itemSize + 3] = xi(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = bt(t, this.array)), (i = bt(i, this.array))),
      (this.array[e + 0] = xi(t)),
      (this.array[e + 1] = xi(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array))),
      (this.array[e + 0] = xi(t)),
      (this.array[e + 1] = xi(i)),
      (this.array[e + 2] = xi(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array)),
        (s = bt(s, this.array))),
      (this.array[e + 0] = xi(t)),
      (this.array[e + 1] = xi(i)),
      (this.array[e + 2] = xi(r)),
      (this.array[e + 3] = xi(s)),
      this
    );
  }
}
class $e extends qt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let Iq = 0;
const Zi = new pt(),
  z0 = new Ft(),
  ll = new V(),
  Ui = new ii(),
  Jc = new ii(),
  Fn = new V();
class _t extends Ki {
  constructor() {
    (super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', { value: Iq++ }),
      (this.uuid = Wi()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {}));
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (w2(e) ? $x : Zx)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return ((this.indirect = e), this);
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return ((this.attributes[e] = t), this);
  }
  deleteAttribute(e) {
    return (delete this.attributes[e], this);
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    ((this.drawRange.start = e), (this.drawRange.count = t));
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new xt().getNormalMatrix(e);
      (i.applyNormalMatrix(s), (i.needsUpdate = !0));
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return (Zi.makeRotationFromQuaternion(e), this.applyMatrix4(Zi), this);
  }
  rotateX(e) {
    return (Zi.makeRotationX(e), this.applyMatrix4(Zi), this);
  }
  rotateY(e) {
    return (Zi.makeRotationY(e), this.applyMatrix4(Zi), this);
  }
  rotateZ(e) {
    return (Zi.makeRotationZ(e), this.applyMatrix4(Zi), this);
  }
  translate(e, t, i) {
    return (Zi.makeTranslation(e, t, i), this.applyMatrix4(Zi), this);
  }
  scale(e, t, i) {
    return (Zi.makeScale(e, t, i), this.applyMatrix4(Zi), this);
  }
  lookAt(e) {
    return (
      z0.lookAt(e),
      z0.updateMatrix(),
      this.applyMatrix4(z0.matrix),
      this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(ll).negate(),
      this.translate(ll.x, ll.y, ll.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute('position');
    if (t === void 0) {
      const i = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const a = e[r];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute('position', new $e(i, 3));
    } else {
      const i = Math.min(e.length, t.count);
      for (let r = 0; r < i; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      (e.length > t.count &&
        Ge(
          'BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.'
        ),
        (t.needsUpdate = !0));
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ii());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (gt(
        'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this
      ),
        this.boundingBox.set(
          new V(-1 / 0, -1 / 0, -1 / 0),
          new V(1 / 0, 1 / 0, 1 / 0)
        ));
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          (Ui.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Fn.addVectors(this.boundingBox.min, Ui.min),
                this.boundingBox.expandByPoint(Fn),
                Fn.addVectors(this.boundingBox.max, Ui.max),
                this.boundingBox.expandByPoint(Fn))
              : (this.boundingBox.expandByPoint(Ui.min),
                this.boundingBox.expandByPoint(Ui.max)));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      gt(
        'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Yn());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (gt(
        'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this
      ),
        this.boundingSphere.set(new V(), 1 / 0));
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Ui.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          (Jc.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Fn.addVectors(Ui.min, Jc.min),
                Ui.expandByPoint(Fn),
                Fn.addVectors(Ui.max, Jc.max),
                Ui.expandByPoint(Fn))
              : (Ui.expandByPoint(Jc.min), Ui.expandByPoint(Jc.max)));
        }
      Ui.getCenter(i);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        (Fn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Fn))));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            (Fn.fromBufferAttribute(o, c),
              l && (ll.fromBufferAttribute(e, c), Fn.add(ll)),
              (r = Math.max(r, i.distanceToSquared(Fn))));
        }
      ((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          gt(
            'BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ));
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      gt(
        'BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)'
      );
      return;
    }
    const i = t.position,
      r = t.normal,
      s = t.uv;
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new qt(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute('tangent'),
      o = [],
      l = [];
    for (let E = 0; E < i.count; E++) ((o[E] = new V()), (l[E] = new V()));
    const c = new V(),
      u = new V(),
      h = new V(),
      d = new pe(),
      f = new pe(),
      p = new pe(),
      m = new V(),
      g = new V();
    function v(E, w, M) {
      (c.fromBufferAttribute(i, E),
        u.fromBufferAttribute(i, w),
        h.fromBufferAttribute(i, M),
        d.fromBufferAttribute(s, E),
        f.fromBufferAttribute(s, w),
        p.fromBufferAttribute(s, M),
        u.sub(c),
        h.sub(c),
        f.sub(d),
        p.sub(d));
      const T = 1 / (f.x * p.y - p.x * f.y);
      isFinite(T) &&
        (m
          .copy(u)
          .multiplyScalar(p.y)
          .addScaledVector(h, -f.y)
          .multiplyScalar(T),
        g
          .copy(h)
          .multiplyScalar(f.x)
          .addScaledVector(u, -p.x)
          .multiplyScalar(T),
        o[E].add(m),
        o[w].add(m),
        o[M].add(m),
        l[E].add(g),
        l[w].add(g),
        l[M].add(g));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: e.count }]);
    for (let E = 0, w = y.length; E < w; ++E) {
      const M = y[E],
        T = M.start,
        D = M.count;
      for (let L = T, O = T + D; L < O; L += 3)
        v(e.getX(L + 0), e.getX(L + 1), e.getX(L + 2));
    }
    const _ = new V(),
      x = new V(),
      S = new V(),
      b = new V();
    function A(E) {
      (S.fromBufferAttribute(r, E), b.copy(S));
      const w = o[E];
      (_.copy(w),
        _.sub(S.multiplyScalar(S.dot(w))).normalize(),
        x.crossVectors(b, w));
      const T = x.dot(l[E]) < 0 ? -1 : 1;
      a.setXYZW(E, _.x, _.y, _.z, T);
    }
    for (let E = 0, w = y.length; E < w; ++E) {
      const M = y[E],
        T = M.start,
        D = M.count;
      for (let L = T, O = T + D; L < O; L += 3)
        (A(e.getX(L + 0)), A(e.getX(L + 1)), A(e.getX(L + 2)));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute('position');
    if (t !== void 0) {
      let i = this.getAttribute('normal');
      if (i === void 0)
        ((i = new qt(new Float32Array(t.count * 3), 3)),
          this.setAttribute('normal', i));
      else for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
      const r = new V(),
        s = new V(),
        a = new V(),
        o = new V(),
        l = new V(),
        c = new V(),
        u = new V(),
        h = new V();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const p = e.getX(d + 0),
            m = e.getX(d + 1),
            g = e.getX(d + 2);
          (r.fromBufferAttribute(t, p),
            s.fromBufferAttribute(t, m),
            a.fromBufferAttribute(t, g),
            u.subVectors(a, s),
            h.subVectors(r, s),
            u.cross(h),
            o.fromBufferAttribute(i, p),
            l.fromBufferAttribute(i, m),
            c.fromBufferAttribute(i, g),
            o.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(p, o.x, o.y, o.z),
            i.setXYZ(m, l.x, l.y, l.z),
            i.setXYZ(g, c.x, c.y, c.z));
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          (r.fromBufferAttribute(t, d + 0),
            s.fromBufferAttribute(t, d + 1),
            a.fromBufferAttribute(t, d + 2),
            u.subVectors(a, s),
            h.subVectors(r, s),
            u.cross(h),
            i.setXYZ(d + 0, u.x, u.y, u.z),
            i.setXYZ(d + 1, u.x, u.y, u.z),
            i.setXYZ(d + 2, u.x, u.y, u.z));
      (this.normalizeNormals(), (i.needsUpdate = !0));
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      (Fn.fromBufferAttribute(e, t),
        Fn.normalize(),
        e.setXYZ(t, Fn.x, Fn.y, Fn.z));
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        u = o.itemSize,
        h = o.normalized,
        d = new c.constructor(l.length * u);
      let f = 0,
        p = 0;
      for (let m = 0, g = l.length; m < g; m++) {
        o.isInterleavedBufferAttribute
          ? (f = l[m] * o.data.stride + o.offset)
          : (f = l[m] * u);
        for (let v = 0; v < u; v++) d[p++] = c[f++];
      }
      return new qt(d, u, h);
    }
    if (this.index === null)
      return (
        Ge(
          'BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'
        ),
        this
      );
    const t = new _t(),
      i = this.index.array,
      r = this.attributes;
    for (const o in r) {
      const l = r[o],
        c = e(l, i);
      t.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u],
          f = e(d, i);
        l.push(f);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON',
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== '' && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (o !== null && (e.data.boundingSphere = o.toJSON()), e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone());
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        h = s[c];
      for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const h = a[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
}
const B1 = new pt(),
  za = new Tc(),
  Dd = new Yn(),
  N1 = new V(),
  Od = new V(),
  Ld = new V(),
  Ud = new V(),
  V0 = new V(),
  kd = new V(),
  F1 = new V(),
  Bd = new V();
class hn extends Ft {
  constructor(e = new _t(), t = new xs()) {
    (super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      (this.count = 1),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s));
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      a = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      kd.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = o[l],
          h = s[l];
        u !== 0 &&
          (V0.fromBufferAttribute(h, e),
          a ? kd.addScaledVector(V0, u) : kd.addScaledVector(V0.sub(t), u));
      }
      t.add(kd);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Dd.copy(i.boundingSphere),
      Dd.applyMatrix4(s),
      za.copy(e.ray).recast(e.near),
      !(
        Dd.containsPoint(za.origin) === !1 &&
        (za.intersectSphere(Dd, N1) === null ||
          za.origin.distanceToSquared(N1) > (e.far - e.near) ** 2)
      ) &&
        (B1.copy(s).invert(),
        za.copy(e.ray).applyMatrix4(B1),
        !(i.boundingBox !== null && za.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, za)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      a = this.material,
      o = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      h = s.attributes.normal,
      d = s.groups,
      f = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let p = 0, m = d.length; p < m; p++) {
          const g = d[p],
            v = a[g.materialIndex],
            y = Math.max(g.start, f.start),
            _ = Math.min(
              o.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let x = y, S = _; x < S; x += 3) {
            const b = o.getX(x),
              A = o.getX(x + 1),
              E = o.getX(x + 2);
            ((r = Nd(this, v, e, i, c, u, h, b, A, E)),
              r &&
                ((r.faceIndex = Math.floor(x / 3)),
                (r.face.materialIndex = g.materialIndex),
                t.push(r)));
          }
        }
      else {
        const p = Math.max(0, f.start),
          m = Math.min(o.count, f.start + f.count);
        for (let g = p, v = m; g < v; g += 3) {
          const y = o.getX(g),
            _ = o.getX(g + 1),
            x = o.getX(g + 2);
          ((r = Nd(this, a, e, i, c, u, h, y, _, x)),
            r && ((r.faceIndex = Math.floor(g / 3)), t.push(r)));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let p = 0, m = d.length; p < m; p++) {
          const g = d[p],
            v = a[g.materialIndex],
            y = Math.max(g.start, f.start),
            _ = Math.min(
              l.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let x = y, S = _; x < S; x += 3) {
            const b = x,
              A = x + 1,
              E = x + 2;
            ((r = Nd(this, v, e, i, c, u, h, b, A, E)),
              r &&
                ((r.faceIndex = Math.floor(x / 3)),
                (r.face.materialIndex = g.materialIndex),
                t.push(r)));
          }
        }
      else {
        const p = Math.max(0, f.start),
          m = Math.min(l.count, f.start + f.count);
        for (let g = p, v = m; g < v; g += 3) {
          const y = g,
            _ = g + 1,
            x = g + 2;
          ((r = Nd(this, a, e, i, c, u, h, y, _, x)),
            r && ((r.faceIndex = Math.floor(g / 3)), t.push(r)));
        }
      }
  }
}
function Pq(n, e, t, i, r, s, a, o) {
  let l;
  if (
    (e.side === On
      ? (l = i.intersectTriangle(a, s, r, !0, o))
      : (l = i.intersectTriangle(r, s, a, e.side === Wr, o)),
    l === null)
  )
    return null;
  (Bd.copy(o), Bd.applyMatrix4(n.matrixWorld));
  const c = t.ray.origin.distanceTo(Bd);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Bd.clone(), object: n };
}
function Nd(n, e, t, i, r, s, a, o, l, c) {
  (n.getVertexPosition(o, Od),
    n.getVertexPosition(l, Ld),
    n.getVertexPosition(c, Ud));
  const u = Pq(n, e, t, i, Od, Ld, Ud, F1);
  if (u) {
    const h = new V();
    (bi.getBarycoord(F1, Od, Ld, Ud, h),
      r && (u.uv = bi.getInterpolatedAttribute(r, o, l, c, h, new pe())),
      s && (u.uv1 = bi.getInterpolatedAttribute(s, o, l, c, h, new pe())),
      a &&
        ((u.normal = bi.getInterpolatedAttribute(a, o, l, c, h, new V())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1)));
    const d = { a: o, b: l, c, normal: new V(), materialIndex: 0 };
    (bi.getNormal(Od, Ld, Ud, d.normal), (u.face = d), (u.barycoord = h));
  }
  return u;
}
class Vo extends _t {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
    (super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: a,
      }));
    const o = this;
    ((r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a)));
    const l = [],
      c = [],
      u = [],
      h = [];
    let d = 0,
      f = 0;
    (p('z', 'y', 'x', -1, -1, i, t, e, a, s, 0),
      p('z', 'y', 'x', 1, -1, i, t, -e, a, s, 1),
      p('x', 'z', 'y', 1, 1, e, i, t, r, a, 2),
      p('x', 'z', 'y', 1, -1, e, i, -t, r, a, 3),
      p('x', 'y', 'z', 1, -1, e, t, i, r, s, 4),
      p('x', 'y', 'z', -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute('position', new $e(c, 3)),
      this.setAttribute('normal', new $e(u, 3)),
      this.setAttribute('uv', new $e(h, 2)));
    function p(m, g, v, y, _, x, S, b, A, E, w) {
      const M = x / A,
        T = S / E,
        D = x / 2,
        L = S / 2,
        O = b / 2,
        z = A + 1,
        C = E + 1;
      let N = 0,
        U = 0;
      const W = new V();
      for (let G = 0; G < C; G++) {
        const ne = G * T - L;
        for (let ve = 0; ve < z; ve++) {
          const Se = ve * M - D;
          ((W[m] = Se * y),
            (W[g] = ne * _),
            (W[v] = O),
            c.push(W.x, W.y, W.z),
            (W[m] = 0),
            (W[g] = 0),
            (W[v] = b > 0 ? 1 : -1),
            u.push(W.x, W.y, W.z),
            h.push(ve / A),
            h.push(1 - G / E),
            (N += 1));
        }
      }
      for (let G = 0; G < E; G++)
        for (let ne = 0; ne < A; ne++) {
          const ve = d + ne + z * G,
            Se = d + ne + z * (G + 1),
            Ae = d + (ne + 1) + z * (G + 1),
            Oe = d + (ne + 1) + z * G;
          (l.push(ve, Se, Oe), l.push(Se, Ae, Oe), (U += 6));
        }
      (o.addGroup(f, U, w), (f += U), (d += N));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Vo(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function ac(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (Ge(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r);
    }
  }
  return e;
}
function oi(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = ac(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function Dq(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function T2(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : kt.workingColorSpace;
}
const C2 = { clone: ac, merge: oi };
var Oq = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Lq = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class rn extends jn {
  constructor(e) {
    (super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = Oq),
      (this.fragmentShader = Lq),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = ac(e.uniforms)),
      (this.uniformsGroups = Dq(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    ((t.glslVersion = this.glslVersion), (t.uniforms = {}));
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture
        ? (t.uniforms[r] = { type: 't', value: a.toJSON(e).uuid })
        : a && a.isColor
          ? (t.uniforms[r] = { type: 'c', value: a.getHex() })
          : a && a.isVector2
            ? (t.uniforms[r] = { type: 'v2', value: a.toArray() })
            : a && a.isVector3
              ? (t.uniforms[r] = { type: 'v3', value: a.toArray() })
              : a && a.isVector4
                ? (t.uniforms[r] = { type: 'v4', value: a.toArray() })
                : a && a.isMatrix3
                  ? (t.uniforms[r] = { type: 'm3', value: a.toArray() })
                  : a && a.isMatrix4
                    ? (t.uniforms[r] = { type: 'm4', value: a.toArray() })
                    : (t.uniforms[r] = { value: a });
    }
    (Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping));
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return (Object.keys(i).length > 0 && (t.extensions = i), t);
  }
}
class zh extends Ft {
  constructor() {
    (super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new pt()),
      (this.projectionMatrix = new pt()),
      (this.projectionMatrixInverse = new pt()),
      (this.coordinateSystem = Hi),
      (this._reversedDepth = !1));
  }
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  updateWorldMatrix(e, t) {
    (super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Is = new V(),
  z1 = new pe(),
  V1 = new pe();
class Vn extends zh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    (super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    ((this.fov = sc * 2 * Math.atan(t)), this.updateProjectionMatrix());
  }
  getFocalLength() {
    const e = Math.tan(Ao * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return sc * 2 * Math.atan(Math.tan(Ao * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    (Is.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Is.x, Is.y).multiplyScalar(-e / Is.z),
      Is.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(Is.x, Is.y).multiplyScalar(-e / Is.z));
  }
  getViewSize(e, t) {
    return (this.getViewBounds(e, z1, V1), t.subVectors(V1, z1));
  }
  setViewOffset(e, t, i, r, s, a) {
    ((this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Ao * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      ((s += (a.offsetX * r) / l),
        (t -= (a.offsetY * i) / c),
        (r *= a.width / l),
        (i *= a.height / c));
    }
    const o = this.filmOffset;
    (o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem,
        this.reversedDepth
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const cl = -90,
  ul = 1;
class R2 extends Ft {
  constructor(e, t, i) {
    (super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0));
    const r = new Vn(cl, ul, e, t);
    ((r.layers = this.layers), this.add(r));
    const s = new Vn(cl, ul, e, t);
    ((s.layers = this.layers), this.add(s));
    const a = new Vn(cl, ul, e, t);
    ((a.layers = this.layers), this.add(a));
    const o = new Vn(cl, ul, e, t);
    ((o.layers = this.layers), this.add(o));
    const l = new Vn(cl, ul, e, t);
    ((l.layers = this.layers), this.add(l));
    const c = new Vn(cl, ul, e, t);
    ((c.layers = this.layers), this.add(c));
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === Hi)
      (i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1));
    else if (e === ic)
      (i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1));
    else
      throw new Error(
        'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
          e
      );
    for (const c of t) (this.add(c), c.updateMatrixWorld());
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, a, o, l, c, u] = this.children,
      h = e.getRenderTarget(),
      d = e.getActiveCubeFace(),
      f = e.getActiveMipmapLevel(),
      p = e.xr.enabled;
    e.xr.enabled = !1;
    const m = i.texture.generateMipmaps;
    ((i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, a),
      e.setRenderTarget(i, 2, r),
      e.render(t, o),
      e.setRenderTarget(i, 3, r),
      e.render(t, l),
      e.setRenderTarget(i, 4, r),
      e.render(t, c),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5, r),
      e.render(t, u),
      e.setRenderTarget(h, d, f),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0));
  }
}
class Vh extends Vt {
  constructor(e = [], t = ys, i, r, s, a, o, l, c, u) {
    (super(e, t, i, r, s, a, o, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1));
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class I2 extends Sn {
  constructor(e = 1, t = {}) {
    (super(e, e, t), (this.isWebGLCubeRenderTarget = !0));
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    ((this.texture = new Vh(r)),
      this._setTextureOptions(t),
      (this.texture.isRenderTargetTexture = !0));
  }
  fromEquirectangularTexture(e, t) {
    ((this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter));
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Vo(5, 5, 5),
      s = new rn({
        name: 'CubemapFromEquirect',
        uniforms: ac(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: On,
        blending: Ln,
      });
    s.uniforms.tEquirect.value = t;
    const a = new hn(r, s),
      o = t.minFilter;
    return (
      t.minFilter === kr && (t.minFilter = Dt),
      new R2(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t = !0, i = !0, r = !0) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) (e.setRenderTarget(this, a), e.clear(t, i, r));
    e.setRenderTarget(s);
  }
}
class Ll extends Ft {
  constructor() {
    (super(), (this.isGroup = !0), (this.type = 'Group'));
  }
}
const Uq = { type: 'move' };
class Bf {
  constructor() {
    ((this._targetRay = null), (this._grip = null), (this._hand = null));
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Ll()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Ll()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new V()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new V())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Ll()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new V()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new V())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return (this.dispatchEvent({ type: 'connected', data: e }), this);
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: 'disconnected', data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== 'visible-blurred') {
      if (c && e.hand) {
        a = !0;
        for (const m of e.hand.values()) {
          const g = t.getJointPose(m, i),
            v = this._getHandJoint(c, m);
          (g !== null &&
            (v.matrix.fromArray(g.transform.matrix),
            v.matrix.decompose(v.position, v.rotation, v.scale),
            (v.matrixWorldNeedsUpdate = !0),
            (v.jointRadius = g.radius)),
            (v.visible = g !== null));
        }
        const u = c.joints['index-finger-tip'],
          h = c.joints['thumb-tip'],
          d = u.position.distanceTo(h.position),
          f = 0.02,
          p = 0.005;
        c.inputState.pinching && d > f + p
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: 'pinchend',
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= f - p &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (o.matrix.fromArray(r.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(r.linearVelocity))
            : (o.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(r.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(Uq)));
    }
    return (
      o !== null && (o.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Ll();
      ((i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i));
    }
    return e.joints[t.jointName];
  }
}
class Om {
  constructor(e, t = 25e-5) {
    ((this.isFogExp2 = !0),
      (this.name = ''),
      (this.color = new je(e)),
      (this.density = t));
  }
  clone() {
    return new Om(this.color, this.density);
  }
  toJSON() {
    return {
      type: 'FogExp2',
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Lm {
  constructor(e, t = 1, i = 1e3) {
    ((this.isFog = !0),
      (this.name = ''),
      (this.color = new je(e)),
      (this.near = t),
      (this.far = i));
  }
  clone() {
    return new Lm(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: 'Fog',
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class ph extends Ft {
  constructor() {
    (super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Yi()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Yi()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        ));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class Um {
  constructor(e, t) {
    ((this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = hh),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Wi()));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.stride), (i *= t.stride));
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  clone(e) {
    (e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Wi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer));
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return (i.setUsage(this.usage), i);
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Wi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const ai = new V();
class Uo {
  constructor(e, t, i, r = !1) {
    ((this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r));
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      (ai.fromBufferAttribute(this, t),
        ai.applyMatrix4(e),
        this.setXYZ(t, ai.x, ai.y, ai.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ai.fromBufferAttribute(this, t),
        ai.applyNormalMatrix(e),
        this.setXYZ(t, ai.x, ai.y, ai.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ai.fromBufferAttribute(this, t),
        ai.transformDirection(e),
        this.setXYZ(t, ai.x, ai.y, ai.z));
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return (this.normalized && (i = ui(i, this.array)), i);
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = bt(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = bt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return (this.normalized && (t = ui(t, this.array)), t);
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = bt(t, this.array)), (i = bt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = bt(t, this.array)),
        (i = bt(i, this.array)),
        (r = bt(r, this.array)),
        (s = bt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      fh(
        'InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new qt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Uo(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      fh(
        'InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class eb extends jn {
  constructor(e) {
    (super(),
      (this.isSpriteMaterial = !0),
      (this.type = 'SpriteMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let hl;
const Qc = new V(),
  dl = new V(),
  fl = new V(),
  pl = new pe(),
  Zc = new pe(),
  P2 = new pt(),
  Fd = new V(),
  $c = new V(),
  zd = new V(),
  H1 = new pe(),
  H0 = new pe(),
  G1 = new pe();
class D2 extends Ft {
  constructor(e = new eb()) {
    if (
      (super(), (this.isSprite = !0), (this.type = 'Sprite'), hl === void 0)
    ) {
      hl = new _t();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new Um(t, 5);
      (hl.setIndex([0, 1, 2, 0, 2, 3]),
        hl.setAttribute('position', new Uo(i, 3, 0, !1)),
        hl.setAttribute('uv', new Uo(i, 2, 3, !1)));
    }
    ((this.geometry = hl),
      (this.material = e),
      (this.center = new pe(0.5, 0.5)),
      (this.count = 1));
  }
  raycast(e, t) {
    (e.camera === null &&
      gt(
        'Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      dl.setFromMatrixScale(this.matrixWorld),
      P2.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      fl.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        dl.multiplyScalar(-fl.z));
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const a = this.center;
    (Vd(Fd.set(-0.5, -0.5, 0), fl, a, dl, r, s),
      Vd($c.set(0.5, -0.5, 0), fl, a, dl, r, s),
      Vd(zd.set(0.5, 0.5, 0), fl, a, dl, r, s),
      H1.set(0, 0),
      H0.set(1, 0),
      G1.set(1, 1));
    let o = e.ray.intersectTriangle(Fd, $c, zd, !1, Qc);
    if (
      o === null &&
      (Vd($c.set(-0.5, 0.5, 0), fl, a, dl, r, s),
      H0.set(0, 1),
      (o = e.ray.intersectTriangle(Fd, zd, $c, !1, Qc)),
      o === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Qc);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Qc.clone(),
        uv: bi.getInterpolation(Qc, Fd, $c, zd, H1, H0, G1, new pe()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Vd(n, e, t, i, r, s) {
  (pl.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Zc.x = s * pl.x - r * pl.y), (Zc.y = r * pl.x + s * pl.y))
      : Zc.copy(pl),
    n.copy(e),
    (n.x += Zc.x),
    (n.y += Zc.y),
    n.applyMatrix4(P2));
}
const Hd = new V(),
  W1 = new V();
class O2 extends Ft {
  constructor() {
    (super(),
      (this.isLOD = !0),
      (this._currentLevel = 0),
      (this.type = 'LOD'),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0));
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return ((this.autoUpdate = e.autoUpdate), this);
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let i = 0; i < t.length; i++)
      if (t[i].distance === e) {
        const r = t.splice(i, 1);
        return (this.remove(r[0].object), !0);
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Hd.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Hd);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      (Hd.setFromMatrixPosition(e.matrixWorld),
        W1.setFromMatrixPosition(this.matrixWorld));
      const i = Hd.distanceTo(W1) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let a = t[r].distance;
        if ((t[r].object.visible && (a -= a * t[r].hysteresis), i >= a))
          ((t[r - 1].object.visible = !1), (t[r].object.visible = !0));
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []));
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const a = i[r];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return t;
  }
}
const j1 = new V(),
  X1 = new Lt(),
  q1 = new Lt(),
  kq = new V(),
  Y1 = new pt(),
  Gd = new V(),
  G0 = new Yn(),
  K1 = new pt(),
  W0 = new Tc();
class L2 extends hn {
  constructor(e, t) {
    (super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = q_),
      (this.bindMatrix = new pt()),
      (this.bindMatrixInverse = new pt()),
      (this.boundingBox = null),
      (this.boundingSphere = null));
  }
  computeBoundingBox() {
    const e = this.geometry;
    (this.boundingBox === null && (this.boundingBox = new ii()),
      this.boundingBox.makeEmpty());
    const t = e.getAttribute('position');
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, Gd), this.boundingBox.expandByPoint(Gd));
  }
  computeBoundingSphere() {
    const e = this.geometry;
    (this.boundingSphere === null && (this.boundingSphere = new Yn()),
      this.boundingSphere.makeEmpty());
    const t = e.getAttribute('position');
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, Gd), this.boundingSphere.expandByPoint(Gd));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      G0.copy(this.boundingSphere),
      G0.applyMatrix4(r),
      e.ray.intersectsSphere(G0) !== !1 &&
        (K1.copy(r).invert(),
        W0.copy(e.ray).applyMatrix4(K1),
        !(
          this.boundingBox !== null && W0.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, W0)));
  }
  getVertexPosition(e, t) {
    return (super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t);
  }
  bind(e, t) {
    ((this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert());
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Lt(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      (s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w));
    }
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.bindMode === q_
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === u2
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : Ge('SkinnedMesh: Unrecognized bindMode: ' + this.bindMode));
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    (X1.fromBufferAttribute(r.attributes.skinIndex, e),
      q1.fromBufferAttribute(r.attributes.skinWeight, e),
      j1.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0));
    for (let s = 0; s < 4; s++) {
      const a = q1.getComponent(s);
      if (a !== 0) {
        const o = X1.getComponent(s);
        (Y1.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]),
          t.addScaledVector(kq.copy(j1).applyMatrix4(Y1), a));
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class tb extends Ft {
  constructor() {
    (super(), (this.isBone = !0), (this.type = 'Bone'));
  }
}
class or extends Vt {
  constructor(e = null, t = 1, i = 1, r, s, a, o, l, c = Un, u = Un, h, d) {
    (super(null, a, o, l, c, u, r, s, h, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
const J1 = new pt(),
  Bq = new pt();
class km {
  constructor(e = [], t = []) {
    ((this.uuid = Wi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init());
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      (Ge(
        'Skeleton: Number of inverse bone matrices does not match amount of bones.'
      ),
        (this.boneInverses = []));
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new pt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new pt();
      (this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i));
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : Bq;
      (J1.multiplyMatrices(o, t[s]), J1.toArray(i, s * 16));
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new km(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    ((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new or(t, e, e, Rn, un);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let a = t[s];
      (a === void 0 &&
        (Ge('Skeleton: No bone found with UUID:', s), (a = new tb())),
        this.bones.push(a),
        this.boneInverses.push(new pt().fromArray(e.boneInverses[i])));
    }
    return (this.init(), this);
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON',
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const a = t[r];
      e.bones.push(a.uuid);
      const o = i[r];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class oc extends qt {
  constructor(e, t, i, r = 1) {
    (super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ml = new pt(),
  Q1 = new pt(),
  Wd = [],
  Z1 = new ii(),
  Nq = new pt(),
  eu = new hn(),
  tu = new Yn();
class U2 extends hn {
  constructor(e, t, i) {
    (super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new oc(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    for (let r = 0; r < i; r++) this.setMatrixAt(r, Nq);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    (this.boundingBox === null && (this.boundingBox = new ii()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, ml),
        Z1.copy(e.boundingBox).applyMatrix4(ml),
        this.boundingBox.union(Z1));
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    (this.boundingSphere === null && (this.boundingSphere = new Yn()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, ml),
        tu.copy(e.boundingSphere).applyMatrix4(ml),
        this.boundingSphere.union(tu));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      a = e * s + 1;
    for (let o = 0; o < i.length; o++) i[o] = r[a + o];
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((eu.geometry = this.geometry),
      (eu.material = this.material),
      eu.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        tu.copy(this.boundingSphere),
        tu.applyMatrix4(i),
        e.ray.intersectsSphere(tu) !== !1))
    )
      for (let s = 0; s < r; s++) {
        (this.getMatrixAt(s, ml),
          Q1.multiplyMatrices(i, ml),
          (eu.matrixWorld = Q1),
          eu.raycast(e, Wd));
        for (let a = 0, o = Wd.length; a < o; a++) {
          const l = Wd[a];
          ((l.instanceId = s), (l.object = this), t.push(l));
        }
        Wd.length = 0;
      }
  }
  setColorAt(e, t) {
    (this.instanceColor === null &&
      (this.instanceColor = new oc(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3));
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = i.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new or(
        new Float32Array(r * this.count),
        r,
        this.count,
        Nh,
        un
      ));
    const s = this.morphTexture.source.data.data;
    let a = 0;
    for (let c = 0; c < i.length; c++) a += i[c];
    const o = this.geometry.morphTargetsRelative ? 1 : 1 - a,
      l = r * e;
    ((s[l] = o), s.set(i, l + 1));
  }
  updateMorphTargets() {}
  dispose() {
    (this.dispatchEvent({ type: 'dispose' }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)));
  }
}
const j0 = new V(),
  Fq = new V(),
  zq = new xt();
class Us {
  constructor(e = new V(1, 0, 0), t = 0) {
    ((this.isPlane = !0), (this.normal = e), (this.constant = t));
  }
  set(e, t) {
    return (this.normal.copy(e), (this.constant = t), this);
  }
  setComponents(e, t, i, r) {
    return (this.normal.set(e, t, i), (this.constant = r), this);
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return (this.normal.copy(e), (this.constant = -t.dot(this.normal)), this);
  }
  setFromCoplanarPoints(e, t, i) {
    const r = j0.subVectors(i, t).cross(Fq.subVectors(e, t)).normalize();
    return (this.setFromNormalAndCoplanarPoint(r, e), this);
  }
  copy(e) {
    return (this.normal.copy(e.normal), (this.constant = e.constant), this);
  }
  normalize() {
    const e = 1 / this.normal.length();
    return (this.normal.multiplyScalar(e), (this.constant *= e), this);
  }
  negate() {
    return ((this.constant *= -1), this.normal.negate(), this);
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(j0),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || zq.getNormalMatrix(e),
      r = this.coplanarPoint(j0).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return ((this.constant = -r.dot(s)), this);
  }
  translate(e) {
    return ((this.constant -= e.dot(this.normal)), this);
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Va = new Yn(),
  Vq = new pe(0.5, 0.5),
  jd = new V();
class Cc {
  constructor(
    e = new Us(),
    t = new Us(),
    i = new Us(),
    r = new Us(),
    s = new Us(),
    a = new Us()
  ) {
    this.planes = [e, t, i, r, s, a];
  }
  set(e, t, i, r, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(i),
      o[3].copy(r),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = Hi, i = !1) {
    const r = this.planes,
      s = e.elements,
      a = s[0],
      o = s[1],
      l = s[2],
      c = s[3],
      u = s[4],
      h = s[5],
      d = s[6],
      f = s[7],
      p = s[8],
      m = s[9],
      g = s[10],
      v = s[11],
      y = s[12],
      _ = s[13],
      x = s[14],
      S = s[15];
    if (
      (r[0].setComponents(c - a, f - u, v - p, S - y).normalize(),
      r[1].setComponents(c + a, f + u, v + p, S + y).normalize(),
      r[2].setComponents(c + o, f + h, v + m, S + _).normalize(),
      r[3].setComponents(c - o, f - h, v - m, S - _).normalize(),
      i)
    )
      (r[4].setComponents(l, d, g, x).normalize(),
        r[5].setComponents(c - l, f - d, v - g, S - x).normalize());
    else if (
      (r[4].setComponents(c - l, f - d, v - g, S - x).normalize(), t === Hi)
    )
      r[5].setComponents(c + l, f + d, v + g, S + x).normalize();
    else if (t === ic) r[5].setComponents(l, d, g, x).normalize();
    else
      throw new Error(
        'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      (e.boundingSphere === null && e.computeBoundingSphere(),
        Va.copy(e.boundingSphere).applyMatrix4(e.matrixWorld));
    else {
      const t = e.geometry;
      (t.boundingSphere === null && t.computeBoundingSphere(),
        Va.copy(t.boundingSphere).applyMatrix4(e.matrixWorld));
    }
    return this.intersectsSphere(Va);
  }
  intersectsSprite(e) {
    Va.center.set(0, 0, 0);
    const t = Vq.distanceTo(e.center);
    return (
      (Va.radius = 0.7071067811865476 + t),
      Va.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Va)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((jd.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (jd.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (jd.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(jd) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ir = new pt(),
  Pr = new Cc();
class Bm {
  constructor() {
    this.coordinateSystem = Hi;
  }
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0) return !1;
    for (let i = 0; i < t.cameras.length; i++) {
      const r = t.cameras[i];
      if (
        (Ir.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Pr.setFromProjectionMatrix(Ir, r.coordinateSystem, r.reversedDepth),
        Pr.intersectsObject(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let i = 0; i < t.cameras.length; i++) {
      const r = t.cameras[i];
      if (
        (Ir.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Pr.setFromProjectionMatrix(Ir, r.coordinateSystem, r.reversedDepth),
        Pr.intersectsSprite(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let i = 0; i < t.cameras.length; i++) {
      const r = t.cameras[i];
      if (
        (Ir.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Pr.setFromProjectionMatrix(Ir, r.coordinateSystem, r.reversedDepth),
        Pr.intersectsSphere(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let i = 0; i < t.cameras.length; i++) {
      const r = t.cameras[i];
      if (
        (Ir.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Pr.setFromProjectionMatrix(Ir, r.coordinateSystem, r.reversedDepth),
        Pr.intersectsBox(e))
      )
        return !0;
    }
    return !1;
  }
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let i = 0; i < t.cameras.length; i++) {
      const r = t.cameras[i];
      if (
        (Ir.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        Pr.setFromProjectionMatrix(Ir, r.coordinateSystem, r.reversedDepth),
        Pr.containsPoint(e))
      )
        return !0;
    }
    return !1;
  }
  clone() {
    return new Bm();
  }
}
function X0(n, e) {
  return n - e;
}
function Hq(n, e) {
  return n.z - e.z;
}
function Gq(n, e) {
  return e.z - n.z;
}
class Wq {
  constructor() {
    ((this.index = 0), (this.pool = []), (this.list = []));
  }
  push(e, t, i, r) {
    const s = this.pool,
      a = this.list;
    this.index >= s.length &&
      s.push({ start: -1, count: -1, z: -1, index: -1 });
    const o = s[this.index];
    (a.push(o),
      this.index++,
      (o.start = e),
      (o.count = t),
      (o.z = i),
      (o.index = r));
  }
  reset() {
    ((this.list.length = 0), (this.index = 0));
  }
}
const yi = new pt(),
  jq = new je(1, 1, 1),
  $1 = new Cc(),
  Xq = new Bm(),
  Xd = new ii(),
  Ha = new Yn(),
  nu = new V(),
  eM = new V(),
  qq = new V(),
  q0 = new Wq(),
  Zn = new hn(),
  qd = [];
function Yq(n, e, t = 0) {
  const i = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const r = n.count;
    for (let s = 0; s < r; s++)
      for (let a = 0; a < i; a++)
        e.setComponent(s + t, a, n.getComponent(s, a));
  } else e.array.set(n.array, t * i);
  e.needsUpdate = !0;
}
function Ga(n, e) {
  if (n.constructor !== e.constructor) {
    const t = Math.min(n.length, e.length);
    for (let i = 0; i < t; i++) e[i] = n[i];
  } else {
    const t = Math.min(n.length, e.length);
    e.set(new n.constructor(n.buffer, 0, t));
  }
}
class k2 extends hn {
  constructor(e, t, i = t * 2, r) {
    (super(new _t(), r),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = i),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture());
  }
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    ((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4),
      i = new or(t, e, e, Rn, un);
    this._matricesTexture = i;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      i = new or(t, e, e, Fh, Mr);
    this._indirectTexture = i;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      i = new or(t, e, e, Rn, un);
    ((i.colorSpace = kt.workingColorSpace), (this._colorsTexture = i));
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      i = this._maxVertexCount,
      r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const a = e.getAttribute(s),
          { array: o, itemSize: l, normalized: c } = a,
          u = new o.constructor(i * l),
          h = new qt(u, l, c);
        t.setAttribute(s, h);
      }
      if (e.getIndex() !== null) {
        const s = i > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new qt(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const i in t.attributes) {
      if (!e.hasAttribute(i))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`
        );
      const r = e.getAttribute(i),
        s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error(
          'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.'
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(e) {
    return ((this.customSort = e), this);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ii());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue;
      const s = t[i].geometryIndex;
      (this.getMatrixAt(i, yi),
        this.getBoundingBoxAt(s, Xd).applyMatrix4(yi),
        e.union(Xd));
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Yn());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let i = 0, r = t.length; i < r; i++) {
      if (t[i].active === !1) continue;
      const s = t[i].geometryIndex;
      (this.getMatrixAt(i, yi),
        this.getBoundingSphereAt(s, Ha).applyMatrix4(yi),
        e.union(Ha));
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error('THREE.BatchedMesh: Maximum item count reached.');
    const i = { visible: !0, active: !0, geometryIndex: e };
    let r = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(X0),
        (r = this._availableInstanceIds.shift()),
        (this._instanceInfo[r] = i))
      : ((r = this._instanceInfo.length), this._instanceInfo.push(i));
    const s = this._matricesTexture;
    (yi.identity().toArray(s.image.data, r * 16), (s.needsUpdate = !0));
    const a = this._colorsTexture;
    return (
      a && (jq.toArray(a.image.data, r * 4), (a.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      r
    );
  }
  addGeometry(e, t = -1, i = -1) {
    (this._initializeGeometry(e), this._validateGeometry(e));
    const r = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo;
    ((r.vertexStart = this._nextVertexStart),
      (r.reservedVertexCount =
        t === -1 ? e.getAttribute('position').count : t));
    const a = e.getIndex();
    if (
      (a !== null &&
        ((r.indexStart = this._nextIndexStart),
        (r.reservedIndexCount = i === -1 ? a.count : i)),
      (r.indexStart !== -1 &&
        r.indexStart + r.reservedIndexCount > this._maxIndexCount) ||
        r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.'
      );
    let l;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(X0),
          (l = this._availableGeometryIds.shift()),
          (s[l] = r))
        : ((l = this._geometryCount), this._geometryCount++, s.push(r)),
      this.setGeometryAt(l, e),
      (this._nextIndexStart = r.indexStart + r.reservedIndexCount),
      (this._nextVertexStart = r.vertexStart + r.reservedVertexCount),
      l
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error('THREE.BatchedMesh: Maximum geometry count reached.');
    this._validateGeometry(t);
    const i = this.geometry,
      r = i.getIndex() !== null,
      s = i.getIndex(),
      a = t.getIndex(),
      o = this._geometryInfo[e];
    if (
      (r && a.count > o.reservedIndexCount) ||
      t.attributes.position.count > o.reservedVertexCount
    )
      throw new Error(
        'THREE.BatchedMesh: Reserved space not large enough for provided geometry.'
      );
    const l = o.vertexStart,
      c = o.reservedVertexCount;
    o.vertexCount = t.getAttribute('position').count;
    for (const u in i.attributes) {
      const h = t.getAttribute(u),
        d = i.getAttribute(u);
      Yq(h, d, l);
      const f = h.itemSize;
      for (let p = h.count, m = c; p < m; p++) {
        const g = l + p;
        for (let v = 0; v < f; v++) d.setComponent(g, v, 0);
      }
      ((d.needsUpdate = !0), d.addUpdateRange(l * f, c * f));
    }
    if (r) {
      const u = o.indexStart,
        h = o.reservedIndexCount;
      o.indexCount = t.getIndex().count;
      for (let d = 0; d < a.count; d++) s.setX(u + d, l + a.getX(d));
      for (let d = a.count, f = h; d < f; d++) s.setX(u + d, l);
      ((s.needsUpdate = !0), s.addUpdateRange(u, o.reservedIndexCount));
    }
    return (
      (o.start = r ? o.indexStart : o.vertexStart),
      (o.count = r ? o.indexCount : o.vertexCount),
      (o.boundingBox = null),
      t.boundingBox !== null && (o.boundingBox = t.boundingBox.clone()),
      (o.boundingSphere = null),
      t.boundingSphere !== null &&
        (o.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const i = this._instanceInfo;
    for (let r = 0, s = i.length; r < s; r++)
      i[r].active && i[r].geometryIndex === e && this.deleteInstance(r);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const i = this._geometryInfo,
      r = i
        .map((a, o) => o)
        .sort((a, o) => i[a].vertexStart - i[o].vertexStart),
      s = this.geometry;
    for (let a = 0, o = i.length; a < o; a++) {
      const l = r[a],
        c = i[l];
      if (c.active !== !1) {
        if (s.index !== null) {
          if (c.indexStart !== t) {
            const { indexStart: u, vertexStart: h, reservedIndexCount: d } = c,
              f = s.index,
              p = f.array,
              m = e - h;
            for (let g = u; g < u + d; g++) p[g] = p[g] + m;
            (f.array.copyWithin(t, u, u + d),
              f.addUpdateRange(t, d),
              (c.indexStart = t));
          }
          t += c.reservedIndexCount;
        }
        if (c.vertexStart !== e) {
          const { vertexStart: u, reservedVertexCount: h } = c,
            d = s.attributes;
          for (const f in d) {
            const p = d[f],
              { array: m, itemSize: g } = p;
            (m.copyWithin(e * g, u * g, (u + h) * g),
              p.addUpdateRange(e * g, h * g));
          }
          c.vertexStart = e;
        }
        ((e += c.reservedVertexCount),
          (c.start = s.index ? c.indexStart : c.vertexStart),
          (this._nextIndexStart = s.index
            ? c.indexStart + c.reservedIndexCount
            : 0),
          (this._nextVertexStart = c.vertexStart + c.reservedVertexCount));
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const i = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingBox === null) {
      const s = new ii(),
        a = i.index,
        o = i.attributes.position;
      for (let l = r.start, c = r.start + r.count; l < c; l++) {
        let u = l;
        (a && (u = a.getX(u)), s.expandByPoint(nu.fromBufferAttribute(o, u)));
      }
      r.boundingBox = s;
    }
    return (t.copy(r.boundingBox), t);
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const i = this.geometry,
      r = this._geometryInfo[e];
    if (r.boundingSphere === null) {
      const s = new Yn();
      (this.getBoundingBoxAt(e, Xd), Xd.getCenter(s.center));
      const a = i.index,
        o = i.attributes.position;
      let l = 0;
      for (let c = r.start, u = r.start + r.count; c < u; c++) {
        let h = c;
        (a && (h = a.getX(h)),
          nu.fromBufferAttribute(o, h),
          (l = Math.max(l, s.center.distanceToSquared(nu))));
      }
      ((s.radius = Math.sqrt(l)), (r.boundingSphere = s));
    }
    return (t.copy(r.boundingSphere), t);
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const i = this._matricesTexture,
      r = this._matricesTexture.image.data;
    return (t.toArray(r, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return (this.validateInstanceId(e), this._instanceInfo[e].visible);
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return (this.validateInstanceId(e), this._instanceInfo[e].geometryIndex);
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const i = this._geometryInfo[e];
    return (
      (t.vertexStart = i.vertexStart),
      (t.vertexCount = i.vertexCount),
      (t.reservedVertexCount = i.reservedVertexCount),
      (t.indexStart = i.indexStart),
      (t.indexCount = i.indexCount),
      (t.reservedIndexCount = i.reservedIndexCount),
      (t.start = i.start),
      (t.count = i.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      i = this._instanceInfo;
    for (t.sort(X0); t[t.length - 1] === i.length - 1; ) (i.pop(), t.pop());
    if (e < i.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`
      );
    const r = new Int32Array(e),
      s = new Int32Array(e);
    (Ga(this._multiDrawCounts, r),
      Ga(this._multiDrawStarts, s),
      (this._multiDrawCounts = r),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e));
    const a = this._indirectTexture,
      o = this._matricesTexture,
      l = this._colorsTexture;
    (a.dispose(),
      this._initIndirectTexture(),
      Ga(a.image.data, this._indirectTexture.image.data),
      o.dispose(),
      this._initMatricesTexture(),
      Ga(o.image.data, this._matricesTexture.image.data),
      l &&
        (l.dispose(),
        this._initColorsTexture(),
        Ga(l.image.data, this._colorsTexture.image.data)));
  }
  setGeometrySize(e, t) {
    const i = [...this._geometryInfo].filter((o) => o.active);
    if (Math.max(...i.map((o) => o.vertexStart + o.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...i.map((l) => l.indexStart + l.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`
      );
    const s = this.geometry;
    (s.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new _t()),
        this._initializeGeometry(s)));
    const a = this.geometry;
    s.index && Ga(s.index.array, a.index.array);
    for (const o in s.attributes)
      Ga(s.attributes[o].array, a.attributes[o].array);
  }
  raycast(e, t) {
    const i = this._instanceInfo,
      r = this._geometryInfo,
      s = this.matrixWorld,
      a = this.geometry;
    ((Zn.material = this.material),
      (Zn.geometry.index = a.index),
      (Zn.geometry.attributes = a.attributes),
      Zn.geometry.boundingBox === null && (Zn.geometry.boundingBox = new ii()),
      Zn.geometry.boundingSphere === null &&
        (Zn.geometry.boundingSphere = new Yn()));
    for (let o = 0, l = i.length; o < l; o++) {
      if (!i[o].visible || !i[o].active) continue;
      const c = i[o].geometryIndex,
        u = r[c];
      (Zn.geometry.setDrawRange(u.start, u.count),
        this.getMatrixAt(o, Zn.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(c, Zn.geometry.boundingBox),
        this.getBoundingSphereAt(c, Zn.geometry.boundingSphere),
        Zn.raycast(e, qd));
      for (let h = 0, d = qd.length; h < d; h++) {
        const f = qd[h];
        ((f.object = this), (f.batchId = o), t.push(f));
      }
      qd.length = 0;
    }
    ((Zn.material = null),
      (Zn.geometry.index = null),
      (Zn.geometry.attributes = {}),
      Zn.geometry.setDrawRange(0, 1 / 0));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._availableInstanceIds = e._availableInstanceIds.slice()),
      (this._availableGeometryIds = e._availableGeometryIds.slice()),
      (this._nextIndexStart = e._nextIndexStart),
      (this._nextVertexStart = e._nextVertexStart),
      (this._geometryCount = e._geometryCount),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._indirectTexture = e._indirectTexture.clone()),
      (this._indirectTexture.image.data =
        this._indirectTexture.image.data.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    (this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null)));
  }
  onBeforeRender(e, t, i, r, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const a = r.getIndex(),
      o = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
      l = this._instanceInfo,
      c = this._multiDrawStarts,
      u = this._multiDrawCounts,
      h = this._geometryInfo,
      d = this.perObjectFrustumCulled,
      f = this._indirectTexture,
      p = f.image.data,
      m = i.isArrayCamera ? Xq : $1;
    d &&
      !i.isArrayCamera &&
      (yi
        .multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)
        .multiply(this.matrixWorld),
      $1.setFromProjectionMatrix(yi, i.coordinateSystem, i.reversedDepth));
    let g = 0;
    if (this.sortObjects) {
      (yi.copy(this.matrixWorld).invert(),
        nu.setFromMatrixPosition(i.matrixWorld).applyMatrix4(yi),
        eM
          .set(0, 0, -1)
          .transformDirection(i.matrixWorld)
          .transformDirection(yi));
      for (let _ = 0, x = l.length; _ < x; _++)
        if (l[_].visible && l[_].active) {
          const S = l[_].geometryIndex;
          (this.getMatrixAt(_, yi),
            this.getBoundingSphereAt(S, Ha).applyMatrix4(yi));
          let b = !1;
          if ((d && (b = !m.intersectsSphere(Ha, i)), !b)) {
            const A = h[S],
              E = qq.subVectors(Ha.center, nu).dot(eM);
            q0.push(A.start, A.count, E, _);
          }
        }
      const v = q0.list,
        y = this.customSort;
      y === null ? v.sort(s.transparent ? Gq : Hq) : y.call(this, v, i);
      for (let _ = 0, x = v.length; _ < x; _++) {
        const S = v[_];
        ((c[g] = S.start * o), (u[g] = S.count), (p[g] = S.index), g++);
      }
      q0.reset();
    } else
      for (let v = 0, y = l.length; v < y; v++)
        if (l[v].visible && l[v].active) {
          const _ = l[v].geometryIndex;
          let x = !1;
          if (
            (d &&
              (this.getMatrixAt(v, yi),
              this.getBoundingSphereAt(_, Ha).applyMatrix4(yi),
              (x = !m.intersectsSphere(Ha, i))),
            !x)
          ) {
            const S = h[_];
            ((c[g] = S.start * o), (u[g] = S.count), (p[g] = v), g++);
          }
        }
    ((f.needsUpdate = !0),
      (this._multiDrawCount = g),
      (this._visibilityChanged = !1));
  }
  onBeforeShadow(e, t, i, r, s, a) {
    this.onBeforeRender(e, null, r, s, a);
  }
}
class gi extends jn {
  constructor(e) {
    (super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const jp = new V(),
  Xp = new V(),
  tM = new pt(),
  iu = new Tc(),
  Yd = new Yn(),
  Y0 = new V(),
  nM = new V();
class ia extends Ft {
  constructor(e = new _t(), t = new gi()) {
    (super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        (jp.fromBufferAttribute(t, r - 1),
          Xp.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += jp.distanceTo(Xp)));
      e.setAttribute('lineDistance', new $e(i, 1));
    } else
      Ge(
        'Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      a = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Yd.copy(i.boundingSphere),
      Yd.applyMatrix4(r),
      (Yd.radius += s),
      e.ray.intersectsSphere(Yd) === !1)
    )
      return;
    (tM.copy(r).invert(), iu.copy(e.ray).applyMatrix4(tM));
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = this.isLineSegments ? 2 : 1,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const f = Math.max(0, a.start),
        p = Math.min(u.count, a.start + a.count);
      for (let m = f, g = p - 1; m < g; m += c) {
        const v = u.getX(m),
          y = u.getX(m + 1),
          _ = Kd(this, e, iu, l, v, y, m);
        _ && t.push(_);
      }
      if (this.isLineLoop) {
        const m = u.getX(p - 1),
          g = u.getX(f),
          v = Kd(this, e, iu, l, m, g, p - 1);
        v && t.push(v);
      }
    } else {
      const f = Math.max(0, a.start),
        p = Math.min(d.count, a.start + a.count);
      for (let m = f, g = p - 1; m < g; m += c) {
        const v = Kd(this, e, iu, l, m, m + 1, m);
        v && t.push(v);
      }
      if (this.isLineLoop) {
        const m = Kd(this, e, iu, l, p - 1, f, p - 1);
        m && t.push(m);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s));
        }
      }
    }
  }
}
function Kd(n, e, t, i, r, s, a) {
  const o = n.geometry.attributes.position;
  if (
    (jp.fromBufferAttribute(o, r),
    Xp.fromBufferAttribute(o, s),
    t.distanceSqToSegment(jp, Xp, Y0, nM) > i)
  )
    return;
  Y0.applyMatrix4(n.matrixWorld);
  const c = e.ray.origin.distanceTo(Y0);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      point: nM.clone().applyMatrix4(n.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    };
}
const iM = new V(),
  rM = new V();
class jr extends ia {
  constructor(e, t) {
    (super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments'));
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        (iM.fromBufferAttribute(t, r),
          rM.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + iM.distanceTo(rM)));
      e.setAttribute('lineDistance', new $e(i, 1));
    } else
      Ge(
        'LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
      );
    return this;
  }
}
class B2 extends ia {
  constructor(e, t) {
    (super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop'));
  }
}
class nb extends jn {
  constructor(e) {
    (super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const sM = new pt(),
  Q_ = new Tc(),
  Jd = new Yn(),
  Qd = new V();
class N2 extends Ft {
  constructor(e = new _t(), t = new nb()) {
    (super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      a = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Jd.copy(i.boundingSphere),
      Jd.applyMatrix4(r),
      (Jd.radius += s),
      e.ray.intersectsSphere(Jd) === !1)
    )
      return;
    (sM.copy(r).invert(), Q_.copy(e.ray).applyMatrix4(sM));
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = i.index,
      h = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start),
        f = Math.min(c.count, a.start + a.count);
      for (let p = d, m = f; p < m; p++) {
        const g = c.getX(p);
        (Qd.fromBufferAttribute(h, g), aM(Qd, g, l, r, e, t, this));
      }
    } else {
      const d = Math.max(0, a.start),
        f = Math.min(h.count, a.start + a.count);
      for (let p = d, m = f; p < m; p++)
        (Qd.fromBufferAttribute(h, p), aM(Qd, p, l, r, e, t, this));
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s));
        }
      }
    }
  }
}
function aM(n, e, t, i, r, s, a) {
  const o = Q_.distanceSqToPoint(n);
  if (o < t) {
    const l = new V();
    (Q_.closestPointToPoint(n, l), l.applyMatrix4(i));
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: a,
    });
  }
}
class F2 extends Vt {
  constructor(e, t, i, r, s = Dt, a = Dt, o, l, c) {
    (super(e, t, i, r, s, a, o, l, c),
      (this.isVideoTexture = !0),
      (this.generateMipmaps = !1),
      (this._requestVideoFrameCallbackId = 0));
    const u = this;
    function h() {
      ((u.needsUpdate = !0),
        (u._requestVideoFrameCallbackId = e.requestVideoFrameCallback(h)));
    }
    'requestVideoFrameCallback' in e &&
      (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(h));
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    'requestVideoFrameCallback' in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
  dispose() {
    (this._requestVideoFrameCallbackId !== 0 &&
      (this.source.data.cancelVideoFrameCallback(
        this._requestVideoFrameCallbackId
      ),
      (this._requestVideoFrameCallbackId = 0)),
      super.dispose());
  }
}
class Kq extends F2 {
  constructor(e, t, i, r, s, a, o, l) {
    (super({}, e, t, i, r, s, a, o, l), (this.isVideoFrameTexture = !0));
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    ((this.image = e), (this.needsUpdate = !0));
  }
}
class Jq extends Vt {
  constructor(e, t) {
    (super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Un),
      (this.minFilter = Un),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0));
  }
}
class Nm extends Vt {
  constructor(e, t, i, r, s, a, o, l, c, u, h, d) {
    (super(null, a, o, l, c, u, r, s, h, d),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
}
class Qq extends Nm {
  constructor(e, t, i, r, s, a) {
    (super(e, t, i, s, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = mn),
      (this.layerUpdates = new Set()));
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Zq extends Nm {
  constructor(e, t, i) {
    (super(void 0, e[0].width, e[0].height, t, i, ys),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e));
  }
}
class $q extends Vt {
  constructor(e, t, i, r, s, a, o, l, c) {
    (super(e, t, i, r, s, a, o, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0));
  }
}
class Fm extends Vt {
  constructor(e, t, i = Mr, r, s, a, o = Un, l = Un, c, u = nc, h = 1) {
    if (u !== nc && u !== Lo)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      );
    const d = { width: e, height: t, depth: h };
    (super(d, r, s, a, o, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.source = new Vs(Object.assign({}, e.image))),
      (this.compareFunction = e.compareFunction),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class ib extends Vt {
  constructor(e = null) {
    (super(), (this.sourceTexture = e), (this.isExternalTexture = !0));
  }
  copy(e) {
    return (super.copy(e), (this.sourceTexture = e.sourceTexture), this);
  }
}
class zm extends _t {
  constructor(e = 1, t = 1, i = 4, r = 8, s = 1) {
    (super(),
      (this.type = 'CapsuleGeometry'),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: i,
        radialSegments: r,
        heightSegments: s,
      }),
      (t = Math.max(0, t)),
      (i = Math.max(1, Math.floor(i))),
      (r = Math.max(3, Math.floor(r))),
      (s = Math.max(1, Math.floor(s))));
    const a = [],
      o = [],
      l = [],
      c = [],
      u = t / 2,
      h = (Math.PI / 2) * e,
      d = t,
      f = 2 * h + d,
      p = i * 2 + s,
      m = r + 1,
      g = new V(),
      v = new V();
    for (let y = 0; y <= p; y++) {
      let _ = 0,
        x = 0,
        S = 0,
        b = 0;
      if (y <= i) {
        const w = y / i,
          M = (w * Math.PI) / 2;
        ((x = -u - e * Math.cos(M)),
          (S = e * Math.sin(M)),
          (b = -e * Math.cos(M)),
          (_ = w * h));
      } else if (y <= i + s) {
        const w = (y - i) / s;
        ((x = -u + w * t), (S = e), (b = 0), (_ = h + w * d));
      } else {
        const w = (y - i - s) / i,
          M = (w * Math.PI) / 2;
        ((x = u + e * Math.sin(M)),
          (S = e * Math.cos(M)),
          (b = e * Math.sin(M)),
          (_ = h + d + w * h));
      }
      const A = Math.max(0, Math.min(1, _ / f));
      let E = 0;
      y === 0 ? (E = 0.5 / r) : y === p && (E = -0.5 / r);
      for (let w = 0; w <= r; w++) {
        const M = w / r,
          T = M * Math.PI * 2,
          D = Math.sin(T),
          L = Math.cos(T);
        ((v.x = -S * L),
          (v.y = x),
          (v.z = S * D),
          o.push(v.x, v.y, v.z),
          g.set(-S * L, b, S * D),
          g.normalize(),
          l.push(g.x, g.y, g.z),
          c.push(M + E, A));
      }
      if (y > 0) {
        const w = (y - 1) * m;
        for (let M = 0; M < r; M++) {
          const T = w + M,
            D = w + M + 1,
            L = y * m + M,
            O = y * m + M + 1;
          (a.push(T, D, L), a.push(D, O, L));
        }
      }
    }
    (this.setIndex(a),
      this.setAttribute('position', new $e(o, 3)),
      this.setAttribute('normal', new $e(l, 3)),
      this.setAttribute('uv', new $e(c, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new zm(
      e.radius,
      e.height,
      e.capSegments,
      e.radialSegments,
      e.heightSegments
    );
  }
}
class Vm extends _t {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    (super(),
      (this.type = 'CircleGeometry'),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t)));
    const s = [],
      a = [],
      o = [],
      l = [],
      c = new V(),
      u = new pe();
    (a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5));
    for (let h = 0, d = 3; h <= t; h++, d += 3) {
      const f = i + (h / t) * r;
      ((c.x = e * Math.cos(f)),
        (c.y = e * Math.sin(f)),
        a.push(c.x, c.y, c.z),
        o.push(0, 0, 1),
        (u.x = (a[d] / e + 1) / 2),
        (u.y = (a[d + 1] / e + 1) / 2),
        l.push(u.x, u.y));
    }
    for (let h = 1; h <= t; h++) s.push(h, h + 1, 0);
    (this.setIndex(s),
      this.setAttribute('position', new $e(a, 3)),
      this.setAttribute('normal', new $e(o, 3)),
      this.setAttribute('uv', new $e(l, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Vm(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Hh extends _t {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    a = !1,
    o = 0,
    l = Math.PI * 2
  ) {
    (super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: a,
        thetaStart: o,
        thetaLength: l,
      }));
    const c = this;
    ((r = Math.floor(r)), (s = Math.floor(s)));
    const u = [],
      h = [],
      d = [],
      f = [];
    let p = 0;
    const m = [],
      g = i / 2;
    let v = 0;
    (y(),
      a === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
      this.setIndex(u),
      this.setAttribute('position', new $e(h, 3)),
      this.setAttribute('normal', new $e(d, 3)),
      this.setAttribute('uv', new $e(f, 2)));
    function y() {
      const x = new V(),
        S = new V();
      let b = 0;
      const A = (t - e) / i;
      for (let E = 0; E <= s; E++) {
        const w = [],
          M = E / s,
          T = M * (t - e) + e;
        for (let D = 0; D <= r; D++) {
          const L = D / r,
            O = L * l + o,
            z = Math.sin(O),
            C = Math.cos(O);
          ((S.x = T * z),
            (S.y = -M * i + g),
            (S.z = T * C),
            h.push(S.x, S.y, S.z),
            x.set(z, A, C).normalize(),
            d.push(x.x, x.y, x.z),
            f.push(L, 1 - M),
            w.push(p++));
        }
        m.push(w);
      }
      for (let E = 0; E < r; E++)
        for (let w = 0; w < s; w++) {
          const M = m[w][E],
            T = m[w + 1][E],
            D = m[w + 1][E + 1],
            L = m[w][E + 1];
          ((e > 0 || w !== 0) && (u.push(M, T, L), (b += 3)),
            (t > 0 || w !== s - 1) && (u.push(T, D, L), (b += 3)));
        }
      (c.addGroup(v, b, 0), (v += b));
    }
    function _(x) {
      const S = p,
        b = new pe(),
        A = new V();
      let E = 0;
      const w = x === !0 ? e : t,
        M = x === !0 ? 1 : -1;
      for (let D = 1; D <= r; D++)
        (h.push(0, g * M, 0), d.push(0, M, 0), f.push(0.5, 0.5), p++);
      const T = p;
      for (let D = 0; D <= r; D++) {
        const O = (D / r) * l + o,
          z = Math.cos(O),
          C = Math.sin(O);
        ((A.x = w * C),
          (A.y = g * M),
          (A.z = w * z),
          h.push(A.x, A.y, A.z),
          d.push(0, M, 0),
          (b.x = z * 0.5 + 0.5),
          (b.y = C * 0.5 * M + 0.5),
          f.push(b.x, b.y),
          p++);
      }
      for (let D = 0; D < r; D++) {
        const L = S + D,
          O = T + D;
        (x === !0 ? u.push(O, O + 1, L) : u.push(O + 1, O, L), (E += 3));
      }
      (c.addGroup(v, E, x === !0 ? 1 : 2), (v += E));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Hh(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Gh extends Hh {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, a = 0, o = Math.PI * 2) {
    (super(0, e, t, i, r, s, a, o),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: a,
        thetaLength: o,
      }));
  }
  static fromJSON(e) {
    return new Gh(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ha extends _t {
  constructor(e = [], t = [], i = 1, r = 0) {
    (super(),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r }));
    const s = [],
      a = [];
    (o(r),
      c(i),
      u(),
      this.setAttribute('position', new $e(s, 3)),
      this.setAttribute('normal', new $e(s.slice(), 3)),
      this.setAttribute('uv', new $e(a, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals());
    function o(y) {
      const _ = new V(),
        x = new V(),
        S = new V();
      for (let b = 0; b < t.length; b += 3)
        (f(t[b + 0], _), f(t[b + 1], x), f(t[b + 2], S), l(_, x, S, y));
    }
    function l(y, _, x, S) {
      const b = S + 1,
        A = [];
      for (let E = 0; E <= b; E++) {
        A[E] = [];
        const w = y.clone().lerp(x, E / b),
          M = _.clone().lerp(x, E / b),
          T = b - E;
        for (let D = 0; D <= T; D++)
          D === 0 && E === b
            ? (A[E][D] = w)
            : (A[E][D] = w.clone().lerp(M, D / T));
      }
      for (let E = 0; E < b; E++)
        for (let w = 0; w < 2 * (b - E) - 1; w++) {
          const M = Math.floor(w / 2);
          w % 2 === 0
            ? (d(A[E][M + 1]), d(A[E + 1][M]), d(A[E][M]))
            : (d(A[E][M + 1]), d(A[E + 1][M + 1]), d(A[E + 1][M]));
        }
    }
    function c(y) {
      const _ = new V();
      for (let x = 0; x < s.length; x += 3)
        ((_.x = s[x + 0]),
          (_.y = s[x + 1]),
          (_.z = s[x + 2]),
          _.normalize().multiplyScalar(y),
          (s[x + 0] = _.x),
          (s[x + 1] = _.y),
          (s[x + 2] = _.z));
    }
    function u() {
      const y = new V();
      for (let _ = 0; _ < s.length; _ += 3) {
        ((y.x = s[_ + 0]), (y.y = s[_ + 1]), (y.z = s[_ + 2]));
        const x = g(y) / 2 / Math.PI + 0.5,
          S = v(y) / Math.PI + 0.5;
        a.push(x, 1 - S);
      }
      (p(), h());
    }
    function h() {
      for (let y = 0; y < a.length; y += 6) {
        const _ = a[y + 0],
          x = a[y + 2],
          S = a[y + 4],
          b = Math.max(_, x, S),
          A = Math.min(_, x, S);
        b > 0.9 &&
          A < 0.1 &&
          (_ < 0.2 && (a[y + 0] += 1),
          x < 0.2 && (a[y + 2] += 1),
          S < 0.2 && (a[y + 4] += 1));
      }
    }
    function d(y) {
      s.push(y.x, y.y, y.z);
    }
    function f(y, _) {
      const x = y * 3;
      ((_.x = e[x + 0]), (_.y = e[x + 1]), (_.z = e[x + 2]));
    }
    function p() {
      const y = new V(),
        _ = new V(),
        x = new V(),
        S = new V(),
        b = new pe(),
        A = new pe(),
        E = new pe();
      for (let w = 0, M = 0; w < s.length; w += 9, M += 6) {
        (y.set(s[w + 0], s[w + 1], s[w + 2]),
          _.set(s[w + 3], s[w + 4], s[w + 5]),
          x.set(s[w + 6], s[w + 7], s[w + 8]),
          b.set(a[M + 0], a[M + 1]),
          A.set(a[M + 2], a[M + 3]),
          E.set(a[M + 4], a[M + 5]),
          S.copy(y).add(_).add(x).divideScalar(3));
        const T = g(S);
        (m(b, M + 0, y, T), m(A, M + 2, _, T), m(E, M + 4, x, T));
      }
    }
    function m(y, _, x, S) {
      (S < 0 && y.x === 1 && (a[_] = y.x - 1),
        x.x === 0 && x.z === 0 && (a[_] = S / 2 / Math.PI + 0.5));
    }
    function g(y) {
      return Math.atan2(y.z, -y.x);
    }
    function v(y) {
      return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new ha(e.vertices, e.indices, e.radius, e.details);
  }
}
class Hm extends ha {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    (super(s, a, e, t),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Hm(e.radius, e.detail);
  }
}
const Zd = new V(),
  $d = new V(),
  K0 = new V(),
  ef = new bi();
class z2 extends _t {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Ao * t),
        a = e.getIndex(),
        o = e.getAttribute('position'),
        l = a ? a.count : o.count,
        c = [0, 0, 0],
        u = ['a', 'b', 'c'],
        h = new Array(3),
        d = {},
        f = [];
      for (let p = 0; p < l; p += 3) {
        a
          ? ((c[0] = a.getX(p)), (c[1] = a.getX(p + 1)), (c[2] = a.getX(p + 2)))
          : ((c[0] = p), (c[1] = p + 1), (c[2] = p + 2));
        const { a: m, b: g, c: v } = ef;
        if (
          (m.fromBufferAttribute(o, c[0]),
          g.fromBufferAttribute(o, c[1]),
          v.fromBufferAttribute(o, c[2]),
          ef.getNormal(K0),
          (h[0] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`),
          (h[1] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`),
          (h[2] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`),
          !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
        )
          for (let y = 0; y < 3; y++) {
            const _ = (y + 1) % 3,
              x = h[y],
              S = h[_],
              b = ef[u[y]],
              A = ef[u[_]],
              E = `${x}_${S}`,
              w = `${S}_${x}`;
            w in d && d[w]
              ? (K0.dot(d[w].normal) <= s &&
                  (f.push(b.x, b.y, b.z), f.push(A.x, A.y, A.z)),
                (d[w] = null))
              : E in d ||
                (d[E] = { index0: c[y], index1: c[_], normal: K0.clone() });
          }
      }
      for (const p in d)
        if (d[p]) {
          const { index0: m, index1: g } = d[p];
          (Zd.fromBufferAttribute(o, m),
            $d.fromBufferAttribute(o, g),
            f.push(Zd.x, Zd.y, Zd.z),
            f.push($d.x, $d.y, $d.z));
        }
      this.setAttribute('position', new $e(f, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
class Cr {
  constructor() {
    ((this.type = 'Curve'),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null));
  }
  getPoint() {
    Ge('Curve: .getPoint() not implemented.');
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      ((i = this.getPoint(a / e)), (s += i.distanceTo(r)), t.push(s), (r = i));
    return ((this.cacheArcLengths = t), t);
  }
  updateArcLengths() {
    ((this.needsUpdate = !0), this.getLengths());
  }
  getUtoTmapping(e, t = null) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let a;
    t ? (a = t) : (a = e * i[s - 1]);
    let o = 0,
      l = s - 1,
      c;
    for (; o <= l; )
      if (((r = Math.floor(o + (l - o) / 2)), (c = i[r] - a), c < 0)) o = r + 1;
      else if (c > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), i[r] === a)) return r / (s - 1);
    const u = i[r],
      d = i[r + 1] - u,
      f = (a - u) / d;
    return (r + f) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    (r < 0 && (r = 0), s > 1 && (s = 1));
    const a = this.getPoint(r),
      o = this.getPoint(s),
      l = t || (a.isVector2 ? new pe() : new V());
    return (l.copy(o).sub(a).normalize(), l);
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t = !1) {
    const i = new V(),
      r = [],
      s = [],
      a = [],
      o = new V(),
      l = new pt();
    for (let f = 0; f <= e; f++) {
      const p = f / e;
      r[f] = this.getTangentAt(p, new V());
    }
    ((s[0] = new V()), (a[0] = new V()));
    let c = Number.MAX_VALUE;
    const u = Math.abs(r[0].x),
      h = Math.abs(r[0].y),
      d = Math.abs(r[0].z);
    (u <= c && ((c = u), i.set(1, 0, 0)),
      h <= c && ((c = h), i.set(0, 1, 0)),
      d <= c && i.set(0, 0, 1),
      o.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], o),
      a[0].crossVectors(r[0], s[0]));
    for (let f = 1; f <= e; f++) {
      if (
        ((s[f] = s[f - 1].clone()),
        (a[f] = a[f - 1].clone()),
        o.crossVectors(r[f - 1], r[f]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const p = Math.acos(ut(r[f - 1].dot(r[f]), -1, 1));
        s[f].applyMatrix4(l.makeRotationAxis(o, p));
      }
      a[f].crossVectors(r[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(ut(s[0].dot(s[e]), -1, 1));
      ((f /= e), r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (f = -f));
      for (let p = 1; p <= e; p++)
        (s[p].applyMatrix4(l.makeRotationAxis(r[p], f * p)),
          a[p].crossVectors(r[p], s[p]));
    }
    return { tangents: r, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
  toJSON() {
    const e = {
      metadata: { version: 4.7, type: 'Curve', generator: 'Curve.toJSON' },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions),
      (e.type = this.type),
      e
    );
  }
  fromJSON(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
}
class Gm extends Cr {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    a = Math.PI * 2,
    o = !1,
    l = 0
  ) {
    (super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = a),
      (this.aClockwise = o),
      (this.aRotation = l));
  }
  getPoint(e, t = new pe()) {
    const i = t,
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    (s < Number.EPSILON && (a ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !a && (s === r ? (s = -r) : (s = s - r)));
    const o = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(o),
      c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation),
        h = Math.sin(this.aRotation),
        d = l - this.aX,
        f = c - this.aY;
      ((l = d * u - f * h + this.aX), (c = d * h + f * u + this.aY));
    }
    return i.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class V2 extends Gm {
  constructor(e, t, i, r, s, a) {
    (super(e, t, i, i, r, s, a),
      (this.isArcCurve = !0),
      (this.type = 'ArcCurve'));
  }
}
function rb() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, a, o, l) {
    ((n = s),
      (e = o),
      (t = -3 * s + 3 * a - 2 * o - l),
      (i = 2 * s - 2 * a + o + l));
  }
  return {
    initCatmullRom: function (s, a, o, l, c) {
      r(a, o, c * (o - s), c * (l - a));
    },
    initNonuniformCatmullRom: function (s, a, o, l, c, u, h) {
      let d = (a - s) / c - (o - s) / (c + u) + (o - a) / u,
        f = (o - a) / u - (l - a) / (u + h) + (l - o) / h;
      ((d *= u), (f *= u), r(a, o, d, f));
    },
    calc: function (s) {
      const a = s * s,
        o = a * s;
      return n + e * s + t * a + i * o;
    },
  };
}
const tf = new V(),
  J0 = new rb(),
  Q0 = new rb(),
  Z0 = new rb();
class H2 extends Cr {
  constructor(e = [], t = !1, i = 'centripetal', r = 0.5) {
    (super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r));
  }
  getPoint(e, t = new V()) {
    const i = t,
      r = this.points,
      s = r.length,
      a = (s - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a),
      l = a - o;
    this.closed
      ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s)
      : l === 0 && o === s - 1 && ((o = s - 2), (l = 1));
    let c, u;
    this.closed || o > 0
      ? (c = r[(o - 1) % s])
      : (tf.subVectors(r[0], r[1]).add(r[0]), (c = tf));
    const h = r[o % s],
      d = r[(o + 1) % s];
    if (
      (this.closed || o + 2 < s
        ? (u = r[(o + 2) % s])
        : (tf.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (u = tf)),
      this.curveType === 'centripetal' || this.curveType === 'chordal')
    ) {
      const f = this.curveType === 'chordal' ? 0.5 : 0.25;
      let p = Math.pow(c.distanceToSquared(h), f),
        m = Math.pow(h.distanceToSquared(d), f),
        g = Math.pow(d.distanceToSquared(u), f);
      (m < 1e-4 && (m = 1),
        p < 1e-4 && (p = m),
        g < 1e-4 && (g = m),
        J0.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, p, m, g),
        Q0.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, p, m, g),
        Z0.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, p, m, g));
    } else
      this.curveType === 'catmullrom' &&
        (J0.initCatmullRom(c.x, h.x, d.x, u.x, this.tension),
        Q0.initCatmullRom(c.y, h.y, d.y, u.y, this.tension),
        Z0.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
    return (i.set(J0.calc(l), Q0.calc(l), Z0.calc(l)), i);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new V().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function oM(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    a = (r - t) * 0.5,
    o = n * n,
    l = n * o;
  return (
    (2 * t - 2 * i + s + a) * l + (-3 * t + 3 * i - 2 * s - a) * o + s * n + t
  );
}
function e7(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function t7(n, e) {
  return 2 * (1 - n) * n * e;
}
function n7(n, e) {
  return n * n * e;
}
function ku(n, e, t, i) {
  return e7(n, e) + t7(n, t) + n7(n, i);
}
function i7(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function r7(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function s7(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function a7(n, e) {
  return n * n * n * e;
}
function Bu(n, e, t, i, r) {
  return i7(n, e) + r7(n, t) + s7(n, i) + a7(n, r);
}
class sb extends Cr {
  constructor(e = new pe(), t = new pe(), i = new pe(), r = new pe()) {
    (super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r));
  }
  getPoint(e, t = new pe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return (i.set(Bu(e, r.x, s.x, a.x, o.x), Bu(e, r.y, s.y, a.y, o.y)), i);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class G2 extends Cr {
  constructor(e = new V(), t = new V(), i = new V(), r = new V()) {
    (super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r));
  }
  getPoint(e, t = new V()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return (
      i.set(
        Bu(e, r.x, s.x, a.x, o.x),
        Bu(e, r.y, s.y, a.y, o.y),
        Bu(e, r.z, s.z, a.z, o.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class ab extends Cr {
  constructor(e = new pe(), t = new pe()) {
    (super(),
      (this.isLineCurve = !0),
      (this.type = 'LineCurve'),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new pe()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new pe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class W2 extends Cr {
  constructor(e = new V(), t = new V()) {
    (super(),
      (this.isLineCurve3 = !0),
      (this.type = 'LineCurve3'),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new V()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new V()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class ob extends Cr {
  constructor(e = new pe(), t = new pe(), i = new pe()) {
    (super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i));
  }
  getPoint(e, t = new pe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      a = this.v2;
    return (i.set(ku(e, r.x, s.x, a.x), ku(e, r.y, s.y, a.y)), i);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class lb extends Cr {
  constructor(e = new V(), t = new V(), i = new V()) {
    (super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i));
  }
  getPoint(e, t = new V()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      a = this.v2;
    return (
      i.set(ku(e, r.x, s.x, a.x), ku(e, r.y, s.y, a.y), ku(e, r.z, s.z, a.z)),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class cb extends Cr {
  constructor(e = []) {
    (super(),
      (this.isSplineCurve = !0),
      (this.type = 'SplineCurve'),
      (this.points = e));
  }
  getPoint(e, t = new pe()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      a = Math.floor(s),
      o = s - a,
      l = r[a === 0 ? a : a - 1],
      c = r[a],
      u = r[a > r.length - 2 ? r.length - 1 : a + 1],
      h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return (i.set(oM(o, l.x, c.x, u.x, h.x), oM(o, l.y, c.y, u.y, h.y)), i);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new pe().fromArray(r));
    }
    return this;
  }
}
var qp = Object.freeze({
  __proto__: null,
  ArcCurve: V2,
  CatmullRomCurve3: H2,
  CubicBezierCurve: sb,
  CubicBezierCurve3: G2,
  EllipseCurve: Gm,
  LineCurve: ab,
  LineCurve3: W2,
  QuadraticBezierCurve: ob,
  QuadraticBezierCurve3: lb,
  SplineCurve: cb,
});
class j2 extends Cr {
  constructor() {
    (super(),
      (this.type = 'CurvePath'),
      (this.curves = []),
      (this.autoClose = !1));
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
      this.curves.push(new qp[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const a = r[s] - i,
          o = this.curves[s],
          l = o.getLength(),
          c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    ((this.needsUpdate = !0),
      (this.cacheLengths = null),
      this.getCurveLengths());
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      ((t += this.curves[i].getLength()), e.push(t));
    return ((this.cacheLengths = e), e);
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return (this.autoClose && t.push(t[0]), t);
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r],
        o = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
            ? 1
            : a.isSplineCurve
              ? e * a.points.length
              : e,
        l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        (i && i.equals(u)) || (t.push(u), (i = u));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    (super.copy(e), (this.curves = []));
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return ((this.autoClose = e.autoClose), this);
  }
  toJSON() {
    const e = super.toJSON();
    ((e.autoClose = this.autoClose), (e.curves = []));
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []));
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new qp[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Yp extends j2 {
  constructor(e) {
    (super(),
      (this.type = 'Path'),
      (this.currentPoint = new pe()),
      e && this.setFromPoints(e));
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return (this.currentPoint.set(e, t), this);
  }
  lineTo(e, t) {
    const i = new ab(this.currentPoint.clone(), new pe(e, t));
    return (this.curves.push(i), this.currentPoint.set(e, t), this);
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new ob(this.currentPoint.clone(), new pe(e, t), new pe(i, r));
    return (this.curves.push(s), this.currentPoint.set(i, r), this);
  }
  bezierCurveTo(e, t, i, r, s, a) {
    const o = new sb(
      this.currentPoint.clone(),
      new pe(e, t),
      new pe(i, r),
      new pe(s, a)
    );
    return (this.curves.push(o), this.currentPoint.set(s, a), this);
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new cb(t);
    return (this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this);
  }
  arc(e, t, i, r, s, a) {
    const o = this.currentPoint.x,
      l = this.currentPoint.y;
    return (this.absarc(e + o, t + l, i, r, s, a), this);
  }
  absarc(e, t, i, r, s, a) {
    return (this.absellipse(e, t, i, i, r, s, a), this);
  }
  ellipse(e, t, i, r, s, a, o, l) {
    const c = this.currentPoint.x,
      u = this.currentPoint.y;
    return (this.absellipse(e + c, t + u, i, r, s, a, o, l), this);
  }
  absellipse(e, t, i, r, s, a, o, l) {
    const c = new Gm(e, t, i, r, s, a, o, l);
    if (this.curves.length > 0) {
      const h = c.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return (this.currentPoint.copy(u), this);
  }
  copy(e) {
    return (super.copy(e), this.currentPoint.copy(e.currentPoint), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.currentPoint = this.currentPoint.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.currentPoint.fromArray(e.currentPoint),
      this
    );
  }
}
class Mo extends Yp {
  constructor(e) {
    (super(e), (this.uuid = Wi()), (this.type = 'Shape'), (this.holes = []));
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    (super.copy(e), (this.holes = []));
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    ((e.uuid = this.uuid), (e.holes = []));
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []));
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new Yp().fromJSON(r));
    }
    return this;
  }
}
function o7(n, e, t = 2) {
  const i = e && e.length,
    r = i ? e[0] * t : n.length;
  let s = X2(n, 0, r, t, !0);
  const a = [];
  if (!s || s.next === s.prev) return a;
  let o, l, c;
  if ((i && (s = d7(n, e, s, t)), n.length > 80 * t)) {
    ((o = n[0]), (l = n[1]));
    let u = o,
      h = l;
    for (let d = t; d < r; d += t) {
      const f = n[d],
        p = n[d + 1];
      (f < o && (o = f), p < l && (l = p), f > u && (u = f), p > h && (h = p));
    }
    ((c = Math.max(u - o, h - l)), (c = c !== 0 ? 32767 / c : 0));
  }
  return (mh(s, a, t, o, l, c, 0), a);
}
function X2(n, e, t, i, r) {
  let s;
  if (r === w7(n, e, t, i) > 0)
    for (let a = e; a < t; a += i) s = lM((a / i) | 0, n[a], n[a + 1], s);
  else
    for (let a = t - i; a >= e; a -= i) s = lM((a / i) | 0, n[a], n[a + 1], s);
  return (s && lc(s, s.next) && (vh(s), (s = s.next)), s);
}
function ko(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (lc(t, t.next) || cn(t.prev, t, t.next) === 0))
    ) {
      if ((vh(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function mh(n, e, t, i, r, s, a) {
  if (!n) return;
  !a && s && v7(n, i, r, s);
  let o = n;
  for (; n.prev !== n.next; ) {
    const l = n.prev,
      c = n.next;
    if (s ? c7(n, i, r, s) : l7(n)) {
      (e.push(l.i, n.i, c.i), vh(n), (n = c.next), (o = c.next));
      continue;
    }
    if (((n = c), n === o)) {
      a
        ? a === 1
          ? ((n = u7(ko(n), e)), mh(n, e, t, i, r, s, 2))
          : a === 2 && h7(n, e, t, i, r, s)
        : mh(ko(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function l7(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (cn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    a = i.x,
    o = e.y,
    l = t.y,
    c = i.y,
    u = Math.min(r, s, a),
    h = Math.min(o, l, c),
    d = Math.max(r, s, a),
    f = Math.max(o, l, c);
  let p = i.next;
  for (; p !== e; ) {
    if (
      p.x >= u &&
      p.x <= d &&
      p.y >= h &&
      p.y <= f &&
      mu(r, o, s, l, a, c, p.x, p.y) &&
      cn(p.prev, p, p.next) >= 0
    )
      return !1;
    p = p.next;
  }
  return !0;
}
function c7(n, e, t, i) {
  const r = n.prev,
    s = n,
    a = n.next;
  if (cn(r, s, a) >= 0) return !1;
  const o = r.x,
    l = s.x,
    c = a.x,
    u = r.y,
    h = s.y,
    d = a.y,
    f = Math.min(o, l, c),
    p = Math.min(u, h, d),
    m = Math.max(o, l, c),
    g = Math.max(u, h, d),
    v = Z_(f, p, e, t, i),
    y = Z_(m, g, e, t, i);
  let _ = n.prevZ,
    x = n.nextZ;
  for (; _ && _.z >= v && x && x.z <= y; ) {
    if (
      (_.x >= f &&
        _.x <= m &&
        _.y >= p &&
        _.y <= g &&
        _ !== r &&
        _ !== a &&
        mu(o, u, l, h, c, d, _.x, _.y) &&
        cn(_.prev, _, _.next) >= 0) ||
      ((_ = _.prevZ),
      x.x >= f &&
        x.x <= m &&
        x.y >= p &&
        x.y <= g &&
        x !== r &&
        x !== a &&
        mu(o, u, l, h, c, d, x.x, x.y) &&
        cn(x.prev, x, x.next) >= 0)
    )
      return !1;
    x = x.nextZ;
  }
  for (; _ && _.z >= v; ) {
    if (
      _.x >= f &&
      _.x <= m &&
      _.y >= p &&
      _.y <= g &&
      _ !== r &&
      _ !== a &&
      mu(o, u, l, h, c, d, _.x, _.y) &&
      cn(_.prev, _, _.next) >= 0
    )
      return !1;
    _ = _.prevZ;
  }
  for (; x && x.z <= y; ) {
    if (
      x.x >= f &&
      x.x <= m &&
      x.y >= p &&
      x.y <= g &&
      x !== r &&
      x !== a &&
      mu(o, u, l, h, c, d, x.x, x.y) &&
      cn(x.prev, x, x.next) >= 0
    )
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function u7(n, e) {
  let t = n;
  do {
    const i = t.prev,
      r = t.next.next;
    (!lc(i, r) &&
      Y2(i, t, t.next, r) &&
      gh(i, r) &&
      gh(r, i) &&
      (e.push(i.i, t.i, r.i), vh(t), vh(t.next), (t = n = r)),
      (t = t.next));
  } while (t !== n);
  return ko(t);
}
function h7(n, e, t, i, r, s) {
  let a = n;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && x7(a, o)) {
        let l = K2(a, o);
        ((a = ko(a, a.next)),
          (l = ko(l, l.next)),
          mh(a, e, t, i, r, s, 0),
          mh(l, e, t, i, r, s, 0));
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== n);
}
function d7(n, e, t, i) {
  const r = [];
  for (let s = 0, a = e.length; s < a; s++) {
    const o = e[s] * i,
      l = s < a - 1 ? e[s + 1] * i : n.length,
      c = X2(n, o, l, i, !1);
    (c === c.next && (c.steiner = !0), r.push(y7(c)));
  }
  r.sort(f7);
  for (let s = 0; s < r.length; s++) t = p7(r[s], t);
  return t;
}
function f7(n, e) {
  let t = n.x - e.x;
  if (t === 0 && ((t = n.y - e.y), t === 0)) {
    const i = (n.next.y - n.y) / (n.next.x - n.x),
      r = (e.next.y - e.y) / (e.next.x - e.x);
    t = i - r;
  }
  return t;
}
function p7(n, e) {
  const t = m7(n, e);
  if (!t) return e;
  const i = K2(t, n);
  return (ko(i, i.next), ko(t, t.next));
}
function m7(n, e) {
  let t = e;
  const i = n.x,
    r = n.y;
  let s = -1 / 0,
    a;
  if (lc(n, t)) return t;
  do {
    if (lc(n, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const h = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        h <= i &&
        h > s &&
        ((s = h), (a = t.x < t.next.x ? t : t.next), h === i)
      )
        return a;
    }
    t = t.next;
  } while (t !== e);
  if (!a) return null;
  const o = a,
    l = a.x,
    c = a.y;
  let u = 1 / 0;
  t = a;
  do {
    if (
      i >= t.x &&
      t.x >= l &&
      i !== t.x &&
      q2(r < c ? i : s, r, l, c, r < c ? s : i, r, t.x, t.y)
    ) {
      const h = Math.abs(r - t.y) / (i - t.x);
      gh(t, n) &&
        (h < u || (h === u && (t.x > a.x || (t.x === a.x && g7(a, t))))) &&
        ((a = t), (u = h));
    }
    t = t.next;
  } while (t !== o);
  return a;
}
function g7(n, e) {
  return cn(n.prev, n, e.prev) < 0 && cn(e.next, n, n.next) < 0;
}
function v7(n, e, t, i) {
  let r = n;
  do
    (r.z === 0 && (r.z = Z_(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next));
  while (r !== n);
  ((r.prevZ.nextZ = null), (r.prevZ = null), _7(r));
}
function _7(n) {
  let e,
    t = 1;
  do {
    let i = n,
      r;
    n = null;
    let s = null;
    for (e = 0; i; ) {
      e++;
      let a = i,
        o = 0;
      for (let c = 0; c < t && (o++, (a = a.nextZ), !!a); c++);
      let l = t;
      for (; o > 0 || (l > 0 && a); )
        (o !== 0 && (l === 0 || !a || i.z <= a.z)
          ? ((r = i), (i = i.nextZ), o--)
          : ((r = a), (a = a.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r));
      i = a;
    }
    ((s.nextZ = null), (t *= 2));
  } while (e > 1);
  return n;
}
function Z_(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function y7(n) {
  let e = n,
    t = n;
  do ((e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next));
  while (e !== n);
  return t;
}
function q2(n, e, t, i, r, s, a, o) {
  return (
    (r - a) * (e - o) >= (n - a) * (s - o) &&
    (n - a) * (i - o) >= (t - a) * (e - o) &&
    (t - a) * (s - o) >= (r - a) * (i - o)
  );
}
function mu(n, e, t, i, r, s, a, o) {
  return !(n === a && e === o) && q2(n, e, t, i, r, s, a, o);
}
function x7(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !b7(n, e) &&
    ((gh(n, e) &&
      gh(e, n) &&
      S7(n, e) &&
      (cn(n.prev, n, e.prev) || cn(n, e.prev, e))) ||
      (lc(n, e) && cn(n.prev, n, n.next) > 0 && cn(e.prev, e, e.next) > 0))
  );
}
function cn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function lc(n, e) {
  return n.x === e.x && n.y === e.y;
}
function Y2(n, e, t, i) {
  const r = rf(cn(n, e, t)),
    s = rf(cn(n, e, i)),
    a = rf(cn(t, i, n)),
    o = rf(cn(t, i, e));
  return !!(
    (r !== s && a !== o) ||
    (r === 0 && nf(n, t, e)) ||
    (s === 0 && nf(n, i, e)) ||
    (a === 0 && nf(t, n, i)) ||
    (o === 0 && nf(t, e, i))
  );
}
function nf(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function rf(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function b7(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      Y2(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function gh(n, e) {
  return cn(n.prev, n, n.next) < 0
    ? cn(n, e, n.next) >= 0 && cn(n, n.prev, e) >= 0
    : cn(n, e, n.prev) < 0 || cn(n, n.next, e) < 0;
}
function S7(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    (t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next));
  while (t !== n);
  return i;
}
function K2(n, e) {
  const t = $_(n.i, n.x, n.y),
    i = $_(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function lM(n, e, t, i) {
  const r = $_(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function vh(n) {
  ((n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ));
}
function $_(n, e, t) {
  return {
    i: n,
    x: e,
    y: t,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: !1,
  };
}
function w7(n, e, t, i) {
  let r = 0;
  for (let s = e, a = t - i; s < t; s += i)
    ((r += (n[a] - n[s]) * (n[s + 1] + n[a + 1])), (a = s));
  return r;
}
class E7 {
  static triangulate(e, t, i = 2) {
    return o7(e, t, i);
  }
}
class Er {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Er.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    (cM(e), uM(i, e));
    let a = e.length;
    t.forEach(cM);
    for (let l = 0; l < t.length; l++)
      (r.push(a), (a += t[l].length), uM(i, t[l]));
    const o = E7.triangulate(i, r);
    for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
    return s;
  }
}
function cM(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function uM(n, e) {
  for (let t = 0; t < e.length; t++) (n.push(e[t].x), n.push(e[t].y));
}
class Wm extends _t {
  constructor(
    e = new Mo([
      new pe(0.5, 0.5),
      new pe(-0.5, 0.5),
      new pe(-0.5, -0.5),
      new pe(0.5, -0.5),
    ]),
    t = {}
  ) {
    (super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]));
    const i = this,
      r = [],
      s = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      a(c);
    }
    (this.setAttribute('position', new $e(r, 3)),
      this.setAttribute('uv', new $e(s, 2)),
      this.computeVertexNormals());
    function a(o) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        u = t.steps !== void 0 ? t.steps : 1,
        h = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        p = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
        m = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath,
        y = t.UVGenerator !== void 0 ? t.UVGenerator : A7;
      let _,
        x = !1,
        S,
        b,
        A,
        E;
      (v &&
        ((_ = v.getSpacedPoints(u)),
        (x = !0),
        (d = !1),
        (S = v.computeFrenetFrames(u, !1)),
        (b = new V()),
        (A = new V()),
        (E = new V())),
        d || ((g = 0), (f = 0), (p = 0), (m = 0)));
      const w = o.extractPoints(c);
      let M = w.shape;
      const T = w.holes;
      if (!Er.isClockWise(M)) {
        M = M.reverse();
        for (let ee = 0, B = T.length; ee < B; ee++) {
          const me = T[ee];
          Er.isClockWise(me) && (T[ee] = me.reverse());
        }
      }
      function L(ee) {
        const me = 10000000000000001e-36;
        let ye = ee[0];
        for (let Te = 1; Te <= ee.length; Te++) {
          const Ee = Te % ee.length,
            Xe = ee[Ee],
            Ne = Xe.x - ye.x,
            We = Xe.y - ye.y,
            F = Ne * Ne + We * We,
            P = Math.max(
              Math.abs(Xe.x),
              Math.abs(Xe.y),
              Math.abs(ye.x),
              Math.abs(ye.y)
            ),
            Q = me * P * P;
          if (F <= Q) {
            (ee.splice(Ee, 1), Te--);
            continue;
          }
          ye = Xe;
        }
      }
      (L(M), T.forEach(L));
      const O = T.length,
        z = M;
      for (let ee = 0; ee < O; ee++) {
        const B = T[ee];
        M = M.concat(B);
      }
      function C(ee, B, me) {
        return (
          B || gt('ExtrudeGeometry: vec does not exist'),
          ee.clone().addScaledVector(B, me)
        );
      }
      const N = M.length;
      function U(ee, B, me) {
        let ye, Te, Ee;
        const Xe = ee.x - B.x,
          Ne = ee.y - B.y,
          We = me.x - ee.x,
          F = me.y - ee.y,
          P = Xe * Xe + Ne * Ne,
          Q = Xe * F - Ne * We;
        if (Math.abs(Q) > Number.EPSILON) {
          const le = Math.sqrt(P),
            ge = Math.sqrt(We * We + F * F),
            se = B.x - Ne / le,
            Ke = B.y + Xe / le,
            Be = me.x - F / ge,
            at = me.y + We / ge,
            Je = ((Be - se) * F - (at - Ke) * We) / (Xe * F - Ne * We);
          ((ye = se + Xe * Je - ee.x), (Te = Ke + Ne * Je - ee.y));
          const we = ye * ye + Te * Te;
          if (we <= 2) return new pe(ye, Te);
          Ee = Math.sqrt(we / 2);
        } else {
          let le = !1;
          (Xe > Number.EPSILON
            ? We > Number.EPSILON && (le = !0)
            : Xe < -Number.EPSILON
              ? We < -Number.EPSILON && (le = !0)
              : Math.sign(Ne) === Math.sign(F) && (le = !0),
            le
              ? ((ye = -Ne), (Te = Xe), (Ee = Math.sqrt(P)))
              : ((ye = Xe), (Te = Ne), (Ee = Math.sqrt(P / 2))));
        }
        return new pe(ye / Ee, Te / Ee);
      }
      const W = [];
      for (
        let ee = 0, B = z.length, me = B - 1, ye = ee + 1;
        ee < B;
        ee++, me++, ye++
      )
        (me === B && (me = 0),
          ye === B && (ye = 0),
          (W[ee] = U(z[ee], z[me], z[ye])));
      const G = [];
      let ne,
        ve = W.concat();
      for (let ee = 0, B = O; ee < B; ee++) {
        const me = T[ee];
        ne = [];
        for (
          let ye = 0, Te = me.length, Ee = Te - 1, Xe = ye + 1;
          ye < Te;
          ye++, Ee++, Xe++
        )
          (Ee === Te && (Ee = 0),
            Xe === Te && (Xe = 0),
            (ne[ye] = U(me[ye], me[Ee], me[Xe])));
        (G.push(ne), (ve = ve.concat(ne)));
      }
      let Se;
      if (g === 0) Se = Er.triangulateShape(z, T);
      else {
        const ee = [],
          B = [];
        for (let me = 0; me < g; me++) {
          const ye = me / g,
            Te = f * Math.cos((ye * Math.PI) / 2),
            Ee = p * Math.sin((ye * Math.PI) / 2) + m;
          for (let Xe = 0, Ne = z.length; Xe < Ne; Xe++) {
            const We = C(z[Xe], W[Xe], Ee);
            (fe(We.x, We.y, -Te), ye === 0 && ee.push(We));
          }
          for (let Xe = 0, Ne = O; Xe < Ne; Xe++) {
            const We = T[Xe];
            ne = G[Xe];
            const F = [];
            for (let P = 0, Q = We.length; P < Q; P++) {
              const le = C(We[P], ne[P], Ee);
              (fe(le.x, le.y, -Te), ye === 0 && F.push(le));
            }
            ye === 0 && B.push(F);
          }
        }
        Se = Er.triangulateShape(ee, B);
      }
      const Ae = Se.length,
        Oe = p + m;
      for (let ee = 0; ee < N; ee++) {
        const B = d ? C(M[ee], ve[ee], Oe) : M[ee];
        x
          ? (A.copy(S.normals[0]).multiplyScalar(B.x),
            b.copy(S.binormals[0]).multiplyScalar(B.y),
            E.copy(_[0]).add(A).add(b),
            fe(E.x, E.y, E.z))
          : fe(B.x, B.y, 0);
      }
      for (let ee = 1; ee <= u; ee++)
        for (let B = 0; B < N; B++) {
          const me = d ? C(M[B], ve[B], Oe) : M[B];
          x
            ? (A.copy(S.normals[ee]).multiplyScalar(me.x),
              b.copy(S.binormals[ee]).multiplyScalar(me.y),
              E.copy(_[ee]).add(A).add(b),
              fe(E.x, E.y, E.z))
            : fe(me.x, me.y, (h / u) * ee);
        }
      for (let ee = g - 1; ee >= 0; ee--) {
        const B = ee / g,
          me = f * Math.cos((B * Math.PI) / 2),
          ye = p * Math.sin((B * Math.PI) / 2) + m;
        for (let Te = 0, Ee = z.length; Te < Ee; Te++) {
          const Xe = C(z[Te], W[Te], ye);
          fe(Xe.x, Xe.y, h + me);
        }
        for (let Te = 0, Ee = T.length; Te < Ee; Te++) {
          const Xe = T[Te];
          ne = G[Te];
          for (let Ne = 0, We = Xe.length; Ne < We; Ne++) {
            const F = C(Xe[Ne], ne[Ne], ye);
            x
              ? fe(F.x, F.y + _[u - 1].y, _[u - 1].x + me)
              : fe(F.x, F.y, h + me);
          }
        }
      }
      (Z(), J());
      function Z() {
        const ee = r.length / 3;
        if (d) {
          let B = 0,
            me = N * B;
          for (let ye = 0; ye < Ae; ye++) {
            const Te = Se[ye];
            K(Te[2] + me, Te[1] + me, Te[0] + me);
          }
          ((B = u + g * 2), (me = N * B));
          for (let ye = 0; ye < Ae; ye++) {
            const Te = Se[ye];
            K(Te[0] + me, Te[1] + me, Te[2] + me);
          }
        } else {
          for (let B = 0; B < Ae; B++) {
            const me = Se[B];
            K(me[2], me[1], me[0]);
          }
          for (let B = 0; B < Ae; B++) {
            const me = Se[B];
            K(me[0] + N * u, me[1] + N * u, me[2] + N * u);
          }
        }
        i.addGroup(ee, r.length / 3 - ee, 0);
      }
      function J() {
        const ee = r.length / 3;
        let B = 0;
        (de(z, B), (B += z.length));
        for (let me = 0, ye = T.length; me < ye; me++) {
          const Te = T[me];
          (de(Te, B), (B += Te.length));
        }
        i.addGroup(ee, r.length / 3 - ee, 1);
      }
      function de(ee, B) {
        let me = ee.length;
        for (; --me >= 0; ) {
          const ye = me;
          let Te = me - 1;
          Te < 0 && (Te = ee.length - 1);
          for (let Ee = 0, Xe = u + g * 2; Ee < Xe; Ee++) {
            const Ne = N * Ee,
              We = N * (Ee + 1),
              F = B + ye + Ne,
              P = B + Te + Ne,
              Q = B + Te + We,
              le = B + ye + We;
            oe(F, P, Q, le);
          }
        }
      }
      function fe(ee, B, me) {
        (l.push(ee), l.push(B), l.push(me));
      }
      function K(ee, B, me) {
        (he(ee), he(B), he(me));
        const ye = r.length / 3,
          Te = y.generateTopUV(i, r, ye - 3, ye - 2, ye - 1);
        (xe(Te[0]), xe(Te[1]), xe(Te[2]));
      }
      function oe(ee, B, me, ye) {
        (he(ee), he(B), he(ye), he(B), he(me), he(ye));
        const Te = r.length / 3,
          Ee = y.generateSideWallUV(i, r, Te - 6, Te - 3, Te - 2, Te - 1);
        (xe(Ee[0]), xe(Ee[1]), xe(Ee[3]), xe(Ee[1]), xe(Ee[2]), xe(Ee[3]));
      }
      function he(ee) {
        (r.push(l[ee * 3 + 0]), r.push(l[ee * 3 + 1]), r.push(l[ee * 3 + 2]));
      }
      function xe(ee) {
        (s.push(ee.x), s.push(ee.y));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return M7(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, a = e.shapes.length; s < a; s++) {
      const o = t[e.shapes[s]];
      i.push(o);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new qp[r.type]().fromJSON(r)),
      new Wm(i, e.options)
    );
  }
}
const A7 = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      a = e[t * 3 + 1],
      o = e[i * 3],
      l = e[i * 3 + 1],
      c = e[r * 3],
      u = e[r * 3 + 1];
    return [new pe(s, a), new pe(o, l), new pe(c, u)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const a = e[t * 3],
      o = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[i * 3],
      u = e[i * 3 + 1],
      h = e[i * 3 + 2],
      d = e[r * 3],
      f = e[r * 3 + 1],
      p = e[r * 3 + 2],
      m = e[s * 3],
      g = e[s * 3 + 1],
      v = e[s * 3 + 2];
    return Math.abs(o - u) < Math.abs(a - c)
      ? [new pe(a, 1 - l), new pe(c, 1 - h), new pe(d, 1 - p), new pe(m, 1 - v)]
      : [
          new pe(o, 1 - l),
          new pe(u, 1 - h),
          new pe(f, 1 - p),
          new pe(g, 1 - v),
        ];
  },
};
function M7(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Wh extends ha {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    (super(r, s, e, t),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Wh(e.radius, e.detail);
  }
}
class jm extends _t {
  constructor(
    e = [new pe(0, -0.5), new pe(0.5, 0), new pe(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    (super(),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = ut(r, 0, Math.PI * 2)));
    const s = [],
      a = [],
      o = [],
      l = [],
      c = [],
      u = 1 / t,
      h = new V(),
      d = new pe(),
      f = new V(),
      p = new V(),
      m = new V();
    let g = 0,
      v = 0;
    for (let y = 0; y <= e.length - 1; y++)
      switch (y) {
        case 0:
          ((g = e[y + 1].x - e[y].x),
            (v = e[y + 1].y - e[y].y),
            (f.x = v * 1),
            (f.y = -g),
            (f.z = v * 0),
            m.copy(f),
            f.normalize(),
            l.push(f.x, f.y, f.z));
          break;
        case e.length - 1:
          l.push(m.x, m.y, m.z);
          break;
        default:
          ((g = e[y + 1].x - e[y].x),
            (v = e[y + 1].y - e[y].y),
            (f.x = v * 1),
            (f.y = -g),
            (f.z = v * 0),
            p.copy(f),
            (f.x += m.x),
            (f.y += m.y),
            (f.z += m.z),
            f.normalize(),
            l.push(f.x, f.y, f.z),
            m.copy(p));
      }
    for (let y = 0; y <= t; y++) {
      const _ = i + y * u * r,
        x = Math.sin(_),
        S = Math.cos(_);
      for (let b = 0; b <= e.length - 1; b++) {
        ((h.x = e[b].x * x),
          (h.y = e[b].y),
          (h.z = e[b].x * S),
          a.push(h.x, h.y, h.z),
          (d.x = y / t),
          (d.y = b / (e.length - 1)),
          o.push(d.x, d.y));
        const A = l[3 * b + 0] * x,
          E = l[3 * b + 1],
          w = l[3 * b + 0] * S;
        c.push(A, E, w);
      }
    }
    for (let y = 0; y < t; y++)
      for (let _ = 0; _ < e.length - 1; _++) {
        const x = _ + y * e.length,
          S = x,
          b = x + e.length,
          A = x + e.length + 1,
          E = x + 1;
        (s.push(S, b, E), s.push(A, E, b));
      }
    (this.setIndex(s),
      this.setAttribute('position', new $e(a, 3)),
      this.setAttribute('uv', new $e(o, 2)),
      this.setAttribute('normal', new $e(c, 3)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new jm(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class jh extends ha {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    (super(i, r, e, t),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new jh(e.radius, e.detail);
  }
}
class da extends _t {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    (super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      }));
    const s = e / 2,
      a = t / 2,
      o = Math.floor(i),
      l = Math.floor(r),
      c = o + 1,
      u = l + 1,
      h = e / o,
      d = t / l,
      f = [],
      p = [],
      m = [],
      g = [];
    for (let v = 0; v < u; v++) {
      const y = v * d - a;
      for (let _ = 0; _ < c; _++) {
        const x = _ * h - s;
        (p.push(x, -y, 0), m.push(0, 0, 1), g.push(_ / o), g.push(1 - v / l));
      }
    }
    for (let v = 0; v < l; v++)
      for (let y = 0; y < o; y++) {
        const _ = y + c * v,
          x = y + c * (v + 1),
          S = y + 1 + c * (v + 1),
          b = y + 1 + c * v;
        (f.push(_, x, b), f.push(x, S, b));
      }
    (this.setIndex(f),
      this.setAttribute('position', new $e(p, 3)),
      this.setAttribute('normal', new $e(m, 3)),
      this.setAttribute('uv', new $e(g, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new da(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Xm extends _t {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, a = Math.PI * 2) {
    (super(),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: a,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r)));
    const o = [],
      l = [],
      c = [],
      u = [];
    let h = e;
    const d = (t - e) / r,
      f = new V(),
      p = new pe();
    for (let m = 0; m <= r; m++) {
      for (let g = 0; g <= i; g++) {
        const v = s + (g / i) * a;
        ((f.x = h * Math.cos(v)),
          (f.y = h * Math.sin(v)),
          l.push(f.x, f.y, f.z),
          c.push(0, 0, 1),
          (p.x = (f.x / t + 1) / 2),
          (p.y = (f.y / t + 1) / 2),
          u.push(p.x, p.y));
      }
      h += d;
    }
    for (let m = 0; m < r; m++) {
      const g = m * (i + 1);
      for (let v = 0; v < i; v++) {
        const y = v + g,
          _ = y,
          x = y + i + 1,
          S = y + i + 2,
          b = y + 1;
        (o.push(_, x, b), o.push(x, S, b));
      }
    }
    (this.setIndex(o),
      this.setAttribute('position', new $e(l, 3)),
      this.setAttribute('normal', new $e(c, 3)),
      this.setAttribute('uv', new $e(u, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Xm(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class qm extends _t {
  constructor(
    e = new Mo([new pe(0, 0.5), new pe(-0.5, -0.5), new pe(0.5, -0.5)]),
    t = 12
  ) {
    (super(),
      (this.type = 'ShapeGeometry'),
      (this.parameters = { shapes: e, curveSegments: t }));
    const i = [],
      r = [],
      s = [],
      a = [];
    let o = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let u = 0; u < e.length; u++)
        (c(e[u]), this.addGroup(o, l, u), (o += l), (l = 0));
    (this.setIndex(i),
      this.setAttribute('position', new $e(r, 3)),
      this.setAttribute('normal', new $e(s, 3)),
      this.setAttribute('uv', new $e(a, 2)));
    function c(u) {
      const h = r.length / 3,
        d = u.extractPoints(t);
      let f = d.shape;
      const p = d.holes;
      Er.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, v = p.length; g < v; g++) {
        const y = p[g];
        Er.isClockWise(y) === !0 && (p[g] = y.reverse());
      }
      const m = Er.triangulateShape(f, p);
      for (let g = 0, v = p.length; g < v; g++) {
        const y = p[g];
        f = f.concat(y);
      }
      for (let g = 0, v = f.length; g < v; g++) {
        const y = f[g];
        (r.push(y.x, y.y, 0), s.push(0, 0, 1), a.push(y.x, y.y));
      }
      for (let g = 0, v = m.length; g < v; g++) {
        const y = m[g],
          _ = y[0] + h,
          x = y[1] + h,
          S = y[2] + h;
        (i.push(_, x, S), (l += 3));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return T7(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const a = t[e.shapes[r]];
      i.push(a);
    }
    return new qm(i, e.curveSegments);
  }
}
function T7(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Xh extends _t {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    a = 0,
    o = Math.PI
  ) {
    (super(),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: a,
        thetaLength: o,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i))));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const u = [],
      h = new V(),
      d = new V(),
      f = [],
      p = [],
      m = [],
      g = [];
    for (let v = 0; v <= i; v++) {
      const y = [],
        _ = v / i;
      let x = 0;
      v === 0 && a === 0
        ? (x = 0.5 / t)
        : v === i && l === Math.PI && (x = -0.5 / t);
      for (let S = 0; S <= t; S++) {
        const b = S / t;
        ((h.x = -e * Math.cos(r + b * s) * Math.sin(a + _ * o)),
          (h.y = e * Math.cos(a + _ * o)),
          (h.z = e * Math.sin(r + b * s) * Math.sin(a + _ * o)),
          p.push(h.x, h.y, h.z),
          d.copy(h).normalize(),
          m.push(d.x, d.y, d.z),
          g.push(b + x, 1 - _),
          y.push(c++));
      }
      u.push(y);
    }
    for (let v = 0; v < i; v++)
      for (let y = 0; y < t; y++) {
        const _ = u[v][y + 1],
          x = u[v][y],
          S = u[v + 1][y],
          b = u[v + 1][y + 1];
        ((v !== 0 || a > 0) && f.push(_, x, b),
          (v !== i - 1 || l < Math.PI) && f.push(x, S, b));
      }
    (this.setIndex(f),
      this.setAttribute('position', new $e(p, 3)),
      this.setAttribute('normal', new $e(m, 3)),
      this.setAttribute('uv', new $e(g, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Xh(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Ym extends ha {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    (super(i, r, e, t),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Ym(e.radius, e.detail);
  }
}
class Km extends _t {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    (super(),
      (this.type = 'TorusGeometry'),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r)));
    const a = [],
      o = [],
      l = [],
      c = [],
      u = new V(),
      h = new V(),
      d = new V();
    for (let f = 0; f <= i; f++)
      for (let p = 0; p <= r; p++) {
        const m = (p / r) * s,
          g = (f / i) * Math.PI * 2;
        ((h.x = (e + t * Math.cos(g)) * Math.cos(m)),
          (h.y = (e + t * Math.cos(g)) * Math.sin(m)),
          (h.z = t * Math.sin(g)),
          o.push(h.x, h.y, h.z),
          (u.x = e * Math.cos(m)),
          (u.y = e * Math.sin(m)),
          d.subVectors(h, u).normalize(),
          l.push(d.x, d.y, d.z),
          c.push(p / r),
          c.push(f / i));
      }
    for (let f = 1; f <= i; f++)
      for (let p = 1; p <= r; p++) {
        const m = (r + 1) * f + p - 1,
          g = (r + 1) * (f - 1) + p - 1,
          v = (r + 1) * (f - 1) + p,
          y = (r + 1) * f + p;
        (a.push(m, g, y), a.push(g, v, y));
      }
    (this.setIndex(a),
      this.setAttribute('position', new $e(o, 3)),
      this.setAttribute('normal', new $e(l, 3)),
      this.setAttribute('uv', new $e(c, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Km(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Jm extends _t {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, a = 3) {
    (super(),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: a,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r)));
    const o = [],
      l = [],
      c = [],
      u = [],
      h = new V(),
      d = new V(),
      f = new V(),
      p = new V(),
      m = new V(),
      g = new V(),
      v = new V();
    for (let _ = 0; _ <= i; ++_) {
      const x = (_ / i) * s * Math.PI * 2;
      (y(x, s, a, e, f),
        y(x + 0.01, s, a, e, p),
        g.subVectors(p, f),
        v.addVectors(p, f),
        m.crossVectors(g, v),
        v.crossVectors(m, g),
        m.normalize(),
        v.normalize());
      for (let S = 0; S <= r; ++S) {
        const b = (S / r) * Math.PI * 2,
          A = -t * Math.cos(b),
          E = t * Math.sin(b);
        ((h.x = f.x + (A * v.x + E * m.x)),
          (h.y = f.y + (A * v.y + E * m.y)),
          (h.z = f.z + (A * v.z + E * m.z)),
          l.push(h.x, h.y, h.z),
          d.subVectors(h, f).normalize(),
          c.push(d.x, d.y, d.z),
          u.push(_ / i),
          u.push(S / r));
      }
    }
    for (let _ = 1; _ <= i; _++)
      for (let x = 1; x <= r; x++) {
        const S = (r + 1) * (_ - 1) + (x - 1),
          b = (r + 1) * _ + (x - 1),
          A = (r + 1) * _ + x,
          E = (r + 1) * (_ - 1) + x;
        (o.push(S, b, E), o.push(b, A, E));
      }
    (this.setIndex(o),
      this.setAttribute('position', new $e(l, 3)),
      this.setAttribute('normal', new $e(c, 3)),
      this.setAttribute('uv', new $e(u, 2)));
    function y(_, x, S, b, A) {
      const E = Math.cos(_),
        w = Math.sin(_),
        M = (S / x) * _,
        T = Math.cos(M);
      ((A.x = b * (2 + T) * 0.5 * E),
        (A.y = b * (2 + T) * w * 0.5),
        (A.z = b * Math.sin(M) * 0.5));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Jm(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class Qm extends _t {
  constructor(
    e = new lb(new V(-1, -1, 0), new V(-1, 1, 0), new V(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    (super(),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      }));
    const a = e.computeFrenetFrames(t, s);
    ((this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals));
    const o = new V(),
      l = new V(),
      c = new pe();
    let u = new V();
    const h = [],
      d = [],
      f = [],
      p = [];
    (m(),
      this.setIndex(p),
      this.setAttribute('position', new $e(h, 3)),
      this.setAttribute('normal', new $e(d, 3)),
      this.setAttribute('uv', new $e(f, 2)));
    function m() {
      for (let _ = 0; _ < t; _++) g(_);
      (g(s === !1 ? t : 0), y(), v());
    }
    function g(_) {
      u = e.getPointAt(_ / t, u);
      const x = a.normals[_],
        S = a.binormals[_];
      for (let b = 0; b <= r; b++) {
        const A = (b / r) * Math.PI * 2,
          E = Math.sin(A),
          w = -Math.cos(A);
        ((l.x = w * x.x + E * S.x),
          (l.y = w * x.y + E * S.y),
          (l.z = w * x.z + E * S.z),
          l.normalize(),
          d.push(l.x, l.y, l.z),
          (o.x = u.x + i * l.x),
          (o.y = u.y + i * l.y),
          (o.z = u.z + i * l.z),
          h.push(o.x, o.y, o.z));
      }
    }
    function v() {
      for (let _ = 1; _ <= t; _++)
        for (let x = 1; x <= r; x++) {
          const S = (r + 1) * (_ - 1) + (x - 1),
            b = (r + 1) * _ + (x - 1),
            A = (r + 1) * _ + x,
            E = (r + 1) * (_ - 1) + x;
          (p.push(S, b, E), p.push(b, A, E));
        }
    }
    function y() {
      for (let _ = 0; _ <= t; _++)
        for (let x = 0; x <= r; x++)
          ((c.x = _ / t), (c.y = x / r), f.push(c.x, c.y));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.path = this.parameters.path.toJSON()), e);
  }
  static fromJSON(e) {
    return new Qm(
      new qp[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class J2 extends _t {
  constructor(e = null) {
    if (
      (super(),
      (this.type = 'WireframeGeometry'),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new V(),
        s = new V();
      if (e.index !== null) {
        const a = e.attributes.position,
          o = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const h = l[c],
            d = h.start,
            f = h.count;
          for (let p = d, m = d + f; p < m; p += 3)
            for (let g = 0; g < 3; g++) {
              const v = o.getX(p + g),
                y = o.getX(p + ((g + 1) % 3));
              (r.fromBufferAttribute(a, v),
                s.fromBufferAttribute(a, y),
                hM(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * o + c,
              h = 3 * o + ((c + 1) % 3);
            (r.fromBufferAttribute(a, u),
              s.fromBufferAttribute(a, h),
              hM(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
          }
      }
      this.setAttribute('position', new $e(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
function hM(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var dM = Object.freeze({
  __proto__: null,
  BoxGeometry: Vo,
  CapsuleGeometry: zm,
  CircleGeometry: Vm,
  ConeGeometry: Gh,
  CylinderGeometry: Hh,
  DodecahedronGeometry: Hm,
  EdgesGeometry: z2,
  ExtrudeGeometry: Wm,
  IcosahedronGeometry: Wh,
  LatheGeometry: jm,
  OctahedronGeometry: jh,
  PlaneGeometry: da,
  PolyhedronGeometry: ha,
  RingGeometry: Xm,
  ShapeGeometry: qm,
  SphereGeometry: Xh,
  TetrahedronGeometry: Ym,
  TorusGeometry: Km,
  TorusKnotGeometry: Jm,
  TubeGeometry: Qm,
  WireframeGeometry: J2,
});
class Q2 extends jn {
  constructor(e) {
    (super(),
      (this.isShadowMaterial = !0),
      (this.type = 'ShadowMaterial'),
      (this.color = new je(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this);
  }
}
class Z2 extends rn {
  constructor(e) {
    (super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = 'RawShaderMaterial'));
  }
}
class ub extends jn {
  constructor(e) {
    (super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = 'MeshStandardMaterial'),
      (this.defines = { STANDARD: '' }),
      (this.color = new je(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Yi()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '' }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class $2 extends ub {
  constructor(e) {
    (super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new pe(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return ut((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new je(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new je(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new je(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e));
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    (this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e));
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    (this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e));
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    (this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e));
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    (this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e));
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    (this._sheen > 0 != e > 0 && this.version++, (this._sheen = e));
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    (this._transmission > 0 != e > 0 && this.version++,
      (this._transmission = e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class e3 extends jn {
  constructor(e) {
    (super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new je(16777215)),
      (this.specular = new je(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Yi()),
      (this.combine = kh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class t3 extends jn {
  constructor(e) {
    (super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class n3 extends jn {
  constructor(e) {
    (super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class i3 extends jn {
  constructor(e) {
    (super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Yi()),
      (this.combine = kh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class hb extends jn {
  constructor(e) {
    (super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = ca),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class db extends jn {
  constructor(e) {
    (super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class r3 extends jn {
  constructor(e) {
    (super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new je(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = ua),
      (this.normalScale = new pe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: '' }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class s3 extends gi {
  constructor(e) {
    (super(),
      (this.isLineDashedMaterial = !0),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function mo(n, e) {
  return !n || n.constructor === e
    ? n
    : typeof e.BYTES_PER_ELEMENT == 'number'
      ? new e(n)
      : Array.prototype.slice.call(n);
}
function a3(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function o3(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return (i.sort(e), i);
}
function ey(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, a = 0; a !== i; ++s) {
    const o = t[s] * e;
    for (let l = 0; l !== e; ++l) r[a++] = n[o + l];
  }
  return r;
}
function fb(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let a = s[i];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        ((a = s[i]),
          a !== void 0 && (e.push(s.time), t.push(...a)),
          (s = n[r++]));
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        ((a = s[i]),
          a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
          (s = n[r++]));
      while (s !== void 0);
    else
      do
        ((a = s[i]), a !== void 0 && (e.push(s.time), t.push(a)), (s = n[r++]));
      while (s !== void 0);
}
function C7(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const a = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l],
      u = c.getValueSize(),
      h = [],
      d = [];
    for (let f = 0; f < c.times.length; ++f) {
      const p = c.times[f] * r;
      if (!(p < t || p >= i)) {
        h.push(c.times[f]);
        for (let m = 0; m < u; ++m) d.push(c.values[f * u + m]);
      }
    }
    h.length !== 0 &&
      ((c.times = mo(h, c.times.constructor)),
      (c.values = mo(d, c.values.constructor)),
      a.push(c));
  }
  s.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
  return (s.resetDuration(), s);
}
function R7(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let a = 0; a < r; ++a) {
    const o = t.tracks[a],
      l = o.ValueTypeName;
    if (l === 'bool' || l === 'string') continue;
    const c = n.tracks.find(function (v) {
      return v.name === o.name && v.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const h = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (u = h / 3);
    let d = 0;
    const f = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (d = f / 3);
    const p = o.times.length - 1;
    let m;
    if (s <= o.times[0]) {
      const v = u,
        y = h - u;
      m = o.values.slice(v, y);
    } else if (s >= o.times[p]) {
      const v = p * h + u,
        y = v + h - u;
      m = o.values.slice(v, y);
    } else {
      const v = o.createInterpolant(),
        y = u,
        _ = h - u;
      (v.evaluate(s), (m = v.resultBuffer.slice(y, _)));
    }
    l === 'quaternion' &&
      new Ii().fromArray(m).normalize().conjugate().toArray(m);
    const g = c.times.length;
    for (let v = 0; v < g; ++v) {
      const y = v * f + d;
      if (l === 'quaternion')
        Ii.multiplyQuaternionsFlat(c.values, y, m, 0, c.values, y);
      else {
        const _ = f - d * 2;
        for (let x = 0; x < _; ++x) c.values[y + x] -= m[x];
      }
    }
  }
  return ((n.blendMode = Yx), n);
}
class I7 {
  static convertArray(e, t) {
    return mo(e, t);
  }
  static isTypedArray(e) {
    return a3(e);
  }
  static getKeyframeOrder(e) {
    return o3(e);
  }
  static sortedArray(e, t, i) {
    return ey(e, t, i);
  }
  static flattenJSON(e, t, i, r) {
    fb(e, t, i, r);
  }
  static subclip(e, t, i, r, s = 30) {
    return C7(e, t, i, r, s);
  }
  static makeClipAdditive(e, t = 0, i = e, r = 30) {
    return R7(e, t, i, r);
  }
}
class qh {
  constructor(e, t, i, r) {
    ((this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {}));
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let a;
        n: {
          i: if (!(e < r)) {
            for (let o = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === o) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= s)) {
            const o = t[1];
            e < o && ((i = 2), (s = o));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return ((this._cachedIndex = 0), this.copySampleValue_(0));
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            ((a = i), (i = 0));
            break n;
          }
          break e;
        }
        for (; i < a; ) {
          const o = (i + a) >>> 1;
          e < t[o] ? (a = o) : (i = o + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return ((this._cachedIndex = 0), this.copySampleValue_(0));
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      ((this._cachedIndex = i), this.intervalChanged_(i, s, r));
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let a = 0; a !== r; ++a) t[a] = i[s + a];
    return t;
  }
  interpolate_() {
    throw new Error('call to abstract method');
  }
  intervalChanged_() {}
}
class l3 extends qh {
  constructor(e, t, i, r) {
    (super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: ho, endingEnd: ho }));
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      a = e + 1,
      o = r[s],
      l = r[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case fo:
          ((s = e), (o = 2 * t - i));
          break;
        case ch:
          ((s = r.length - 2), (o = t + r[s] - r[s + 1]));
          break;
        default:
          ((s = e), (o = i));
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case fo:
          ((a = e), (l = 2 * i - t));
          break;
        case ch:
          ((a = 1), (l = i + r[1] - r[0]));
          break;
        default:
          ((a = e - 1), (l = t));
      }
    const c = (i - t) * 0.5,
      u = this.valueSize;
    ((this._weightPrev = c / (t - o)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * u),
      (this._offsetNext = a * u));
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = this._offsetPrev,
      h = this._offsetNext,
      d = this._weightPrev,
      f = this._weightNext,
      p = (i - t) / (r - t),
      m = p * p,
      g = m * p,
      v = -d * g + 2 * d * m - d * p,
      y = (1 + d) * g + (-1.5 - 2 * d) * m + (-0.5 + d) * p + 1,
      _ = (-1 - f) * g + (1.5 + f) * m + 0.5 * p,
      x = f * g - f * m;
    for (let S = 0; S !== o; ++S)
      s[S] = v * a[u + S] + y * a[c + S] + _ * a[l + S] + x * a[h + S];
    return s;
  }
}
class pb extends qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = (i - t) / (r - t),
      h = 1 - u;
    for (let d = 0; d !== o; ++d) s[d] = a[c + d] * h + a[l + d] * u;
    return s;
  }
}
class c3 extends qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ur {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (t === void 0 || t.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
    ((this.name = e),
      (this.times = mo(t, this.TimeBufferType)),
      (this.values = mo(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation));
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: mo(e.times, Array),
        values: mo(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return ((i.type = e.ValueTypeName), i);
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new c3(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new pb(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new l3(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case lh:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Wp:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case kf:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return (Ge('KeyframeTrack:', i), this);
    }
    return ((this.createInterpolant = t), this);
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return lh;
      case this.InterpolantFactoryMethodLinear:
        return Wp;
      case this.InterpolantFactoryMethodSmooth:
        return kf;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      a = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; a !== -1 && i[a] > t; ) --a;
    if ((++a, s !== 0 || a !== r)) {
      s >= a && ((a = Math.max(a, 1)), (s = a - 1));
      const o = this.getValueSize();
      ((this.times = i.slice(s, a)),
        (this.values = this.values.slice(s * o, a * o)));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (gt('KeyframeTrack: Invalid value size in track.', this), (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 && (gt('KeyframeTrack: Track is empty.', this), (e = !1));
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = i[o];
      if (typeof l == 'number' && isNaN(l)) {
        (gt('KeyframeTrack: Time is not a valid number.', this, o, l),
          (e = !1));
        break;
      }
      if (a !== null && a > l) {
        (gt('KeyframeTrack: Out of order keys.', this, o, l, a), (e = !1));
        break;
      }
      a = l;
    }
    if (r !== void 0 && a3(r))
      for (let o = 0, l = r.length; o !== l; ++o) {
        const c = r[o];
        if (isNaN(c)) {
          (gt('KeyframeTrack: Value is not a valid number.', this, o, c),
            (e = !1));
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === kf,
      s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const c = e[o],
        u = e[o + 1];
      if (c !== u && (o !== 1 || c !== e[0]))
        if (r) l = !0;
        else {
          const h = o * i,
            d = h - i,
            f = h + i;
          for (let p = 0; p !== i; ++p) {
            const m = t[h + p];
            if (m !== t[d + p] || m !== t[f + p]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const h = o * i,
            d = a * i;
          for (let f = 0; f !== i; ++f) t[d + f] = t[h + f];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * i, l = a * i, c = 0; c !== i; ++c) t[l + c] = t[o + c];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = e.slice(0, a)), (this.values = t.slice(0, a * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return ((r.createInterpolant = this.createInterpolant), r);
  }
}
ur.prototype.ValueTypeName = '';
ur.prototype.TimeBufferType = Float32Array;
ur.prototype.ValueBufferType = Float32Array;
ur.prototype.DefaultInterpolation = Wp;
class Ho extends ur {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Ho.prototype.ValueTypeName = 'bool';
Ho.prototype.ValueBufferType = Array;
Ho.prototype.DefaultInterpolation = lh;
Ho.prototype.InterpolantFactoryMethodLinear = void 0;
Ho.prototype.InterpolantFactoryMethodSmooth = void 0;
class mb extends ur {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
mb.prototype.ValueTypeName = 'color';
class _h extends ur {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
_h.prototype.ValueTypeName = 'number';
class u3 extends qh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = (i - t) / (r - t);
    let c = e * o;
    for (let u = c + o; c !== u; c += 4) Ii.slerpFlat(s, 0, a, c - o, a, c, l);
    return s;
  }
}
class Yh extends ur {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  InterpolantFactoryMethodLinear(e) {
    return new u3(this.times, this.values, this.getValueSize(), e);
  }
}
Yh.prototype.ValueTypeName = 'quaternion';
Yh.prototype.InterpolantFactoryMethodSmooth = void 0;
class Go extends ur {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Go.prototype.ValueTypeName = 'string';
Go.prototype.ValueBufferType = Array;
Go.prototype.DefaultInterpolation = lh;
Go.prototype.InterpolantFactoryMethodLinear = void 0;
Go.prototype.InterpolantFactoryMethodSmooth = void 0;
class yh extends ur {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
yh.prototype.ValueTypeName = 'vector';
class xh {
  constructor(e = '', t = -1, i = [], r = Rm) {
    ((this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Wi()),
      (this.userData = {}),
      this.duration < 0 && this.resetDuration());
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let a = 0, o = i.length; a !== o; ++a) t.push(D7(i[a]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (
      (s.uuid = e.uuid),
      (s.userData = JSON.parse(e.userData || '{}')),
      s
    );
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
        userData: JSON.stringify(e.userData),
      };
    for (let s = 0, a = i.length; s !== a; ++s) t.push(ur.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      a = [];
    for (let o = 0; o < s; o++) {
      let l = [],
        c = [];
      (l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0));
      const u = o3(l);
      ((l = ey(l, 1, u)),
        (c = ey(c, 1, u)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        a.push(
          new _h('.morphTargetInfluences[' + t[o].name + ']', l, c).scale(1 / i)
        ));
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const h = u[1];
        let d = r[h];
        (d || (r[h] = d = []), d.push(c));
      }
    }
    const a = [];
    for (const o in r)
      a.push(this.CreateFromMorphTargetSequence(o, r[o], t, i));
    return a;
  }
  static parseAnimation(e, t) {
    if (
      (Ge(
        'AnimationClip: parseAnimation() is deprecated and will be removed with r185'
      ),
      !e)
    )
      return (gt('AnimationClip: No animation in JSONLoader data.'), null);
    const i = function (h, d, f, p, m) {
        if (f.length !== 0) {
          const g = [],
            v = [];
          (fb(f, g, v, p), g.length !== 0 && m.push(new h(d, g, v)));
        }
      },
      r = [],
      s = e.name || 'default',
      a = e.fps || 30,
      o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let p;
          for (p = 0; p < d.length; p++)
            if (d[p].morphTargets)
              for (let m = 0; m < d[p].morphTargets.length; m++)
                f[d[p].morphTargets[m]] = -1;
          for (const m in f) {
            const g = [],
              v = [];
            for (let y = 0; y !== d[p].morphTargets.length; ++y) {
              const _ = d[p];
              (g.push(_.time), v.push(_.morphTarget === m ? 1 : 0));
            }
            r.push(new _h('.morphTargetInfluence[' + m + ']', g, v));
          }
          l = f.length * a;
        } else {
          const f = '.bones[' + t[h].name + ']';
          (i(yh, f + '.position', d, 'pos', r),
            i(Yh, f + '.quaternion', d, 'rot', r),
            i(yh, f + '.scale', d, 'scl', r));
        }
    }
    return r.length === 0 ? null : new this(s, l, r, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return ((this.duration = t), this);
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let i = 0; i < this.tracks.length; i++) e.push(this.tracks[i].clone());
    const t = new this.constructor(this.name, this.duration, e, this.blendMode);
    return ((t.userData = JSON.parse(JSON.stringify(this.userData))), t);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function P7(n) {
  switch (n.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return _h;
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return yh;
    case 'color':
      return mb;
    case 'quaternion':
      return Yh;
    case 'bool':
    case 'boolean':
      return Ho;
    case 'string':
      return Go;
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + n);
}
function D7(n) {
  if (n.type === void 0)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  const e = P7(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    (fb(n.keys, t, i, 'value'), (n.times = t), (n.values = i));
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Br = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class Kh {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    ((this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this._abortController = null),
      (this.itemStart = function (u) {
        (o++, s === !1 && r.onStart !== void 0 && r.onStart(u, a, o), (s = !0));
      }),
      (this.itemEnd = function (u) {
        (a++,
          r.onProgress !== void 0 && r.onProgress(u, a, o),
          a === o && ((s = !1), r.onLoad !== void 0 && r.onLoad()));
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return ((l = u), this);
      }),
      (this.addHandler = function (u, h) {
        return (c.push(u, h), this);
      }),
      (this.removeHandler = function (u) {
        const h = c.indexOf(u);
        return (h !== -1 && c.splice(h, 2), this);
      }),
      (this.getHandler = function (u) {
        for (let h = 0, d = c.length; h < d; h += 2) {
          const f = c[h],
            p = c[h + 1];
          if ((f.global && (f.lastIndex = 0), f.test(u))) return p;
        }
        return null;
      }),
      (this.abort = function () {
        return (
          this.abortController.abort(),
          (this._abortController = null),
          this
        );
      }));
  }
  get abortController() {
    return (
      this._abortController || (this._abortController = new AbortController()),
      this._abortController
    );
  }
}
const h3 = new Kh();
class vi {
  constructor(e) {
    ((this.manager = e !== void 0 ? e : h3),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {}));
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return ((this.crossOrigin = e), this);
  }
  setWithCredentials(e) {
    return ((this.withCredentials = e), this);
  }
  setPath(e) {
    return ((this.path = e), this);
  }
  setResourcePath(e) {
    return ((this.resourcePath = e), this);
  }
  setRequestHeader(e) {
    return ((this.requestHeader = e), this);
  }
  abort() {
    return this;
  }
}
vi.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const ns = {};
class O7 extends Error {
  constructor(e, t) {
    (super(e), (this.response = t));
  }
}
class ji extends vi {
  constructor(e) {
    (super(e),
      (this.mimeType = ''),
      (this.responseType = ''),
      (this._abortController = new AbortController()));
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = Br.get(`file:${e}`);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          (t && t(s), this.manager.itemEnd(e));
        }, 0),
        s
      );
    if (ns[e] !== void 0) {
      ns[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    ((ns[e] = []), ns[e].push({ onLoad: t, onProgress: i, onError: r }));
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin',
        signal:
          typeof AbortSignal.any == 'function'
            ? AbortSignal.any([
                this._abortController.signal,
                this.manager.abortController.signal,
              ])
            : this._abortController.signal,
      }),
      o = this.mimeType,
      l = this.responseType;
    (fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 && Ge('FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = ns[e],
            h = c.body.getReader(),
            d = c.headers.get('X-File-Size') || c.headers.get('Content-Length'),
            f = d ? parseInt(d) : 0,
            p = f !== 0;
          let m = 0;
          const g = new ReadableStream({
            start(v) {
              y();
              function y() {
                h.read().then(
                  ({ done: _, value: x }) => {
                    if (_) v.close();
                    else {
                      m += x.byteLength;
                      const S = new ProgressEvent('progress', {
                        lengthComputable: p,
                        loaded: m,
                        total: f,
                      });
                      for (let b = 0, A = u.length; b < A; b++) {
                        const E = u[b];
                        E.onProgress && E.onProgress(S);
                      }
                      (v.enqueue(x), y());
                    }
                  },
                  (_) => {
                    v.error(_);
                  }
                );
              }
            },
          });
          return new Response(g);
        } else
          throw new O7(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case 'arraybuffer':
            return c.arrayBuffer();
          case 'blob':
            return c.blob();
          case 'document':
            return c.text().then((u) => new DOMParser().parseFromString(u, o));
          case 'json':
            return c.json();
          default:
            if (o === '') return c.text();
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(o),
                d = h && h[1] ? h[1].toLowerCase() : void 0,
                f = new TextDecoder(d);
              return c.arrayBuffer().then((p) => f.decode(p));
            }
        }
      })
      .then((c) => {
        Br.add(`file:${e}`, c);
        const u = ns[e];
        delete ns[e];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onLoad && f.onLoad(c);
        }
      })
      .catch((c) => {
        const u = ns[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete ns[e];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e));
  }
  setResponseType(e) {
    return ((this.responseType = e), this);
  }
  setMimeType(e) {
    return ((this.mimeType = e), this);
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
class L7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = new ji(this.manager);
    (a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            (r ? r(l) : gt(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = xh.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class U7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = [],
      o = new Nm(),
      l = new ji(this.manager);
    (l.setPath(this.path),
      l.setResponseType('arraybuffer'),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials));
    let c = 0;
    function u(h) {
      l.load(
        e[h],
        function (d) {
          const f = s.parse(d, !0);
          ((a[h] = {
            width: f.width,
            height: f.height,
            format: f.format,
            mipmaps: f.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (f.mipmapCount === 1 && (o.minFilter = Dt),
              (o.image = a),
              (o.format = f.format),
              (o.needsUpdate = !0),
              t && t(o)));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let h = 0, d = e.length; h < d; ++h) u(h);
    else
      l.load(
        e,
        function (h) {
          const d = s.parse(h, !0);
          if (d.isCubemap) {
            const f = d.mipmaps.length / d.mipmapCount;
            for (let p = 0; p < f; p++) {
              a[p] = { mipmaps: [] };
              for (let m = 0; m < d.mipmapCount; m++)
                (a[p].mipmaps.push(d.mipmaps[p * d.mipmapCount + m]),
                  (a[p].format = d.format),
                  (a[p].width = d.width),
                  (a[p].height = d.height));
            }
            o.image = a;
          } else
            ((o.image.width = d.width),
              (o.image.height = d.height),
              (o.mipmaps = d.mipmaps));
          (d.mipmapCount === 1 && (o.minFilter = Dt),
            (o.format = d.format),
            (o.needsUpdate = !0),
            t && t(o));
        },
        i,
        r
      );
    return o;
  }
}
const gl = new WeakMap();
class bh extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    (this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      a = Br.get(`image:${e}`);
    if (a !== void 0) {
      if (a.complete === !0)
        (s.manager.itemStart(e),
          setTimeout(function () {
            (t && t(a), s.manager.itemEnd(e));
          }, 0));
      else {
        let h = gl.get(a);
        (h === void 0 && ((h = []), gl.set(a, h)),
          h.push({ onLoad: t, onError: r }));
      }
      return a;
    }
    const o = dh('img');
    function l() {
      (u(), t && t(this));
      const h = gl.get(this) || [];
      for (let d = 0; d < h.length; d++) {
        const f = h[d];
        f.onLoad && f.onLoad(this);
      }
      (gl.delete(this), s.manager.itemEnd(e));
    }
    function c(h) {
      (u(), r && r(h), Br.remove(`image:${e}`));
      const d = gl.get(this) || [];
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        p.onError && p.onError(h);
      }
      (gl.delete(this), s.manager.itemError(e), s.manager.itemEnd(e));
    }
    function u() {
      (o.removeEventListener('load', l, !1),
        o.removeEventListener('error', c, !1));
    }
    return (
      o.addEventListener('load', l, !1),
      o.addEventListener('error', c, !1),
      e.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      Br.add(`image:${e}`, o),
      s.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class k7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Vh();
    s.colorSpace = Wt;
    const a = new bh(this.manager);
    (a.setCrossOrigin(this.crossOrigin), a.setPath(this.path));
    let o = 0;
    function l(c) {
      a.load(
        e[c],
        function (u) {
          ((s.images[c] = u),
            o++,
            o === 6 && ((s.needsUpdate = !0), t && t(s)));
        },
        void 0,
        r
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return s;
  }
}
class gb extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = new or(),
      o = new ji(this.manager);
    return (
      o.setResponseType('arraybuffer'),
      o.setRequestHeader(this.requestHeader),
      o.setPath(this.path),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (l) {
          let c;
          try {
            c = s.parse(l);
          } catch (u) {
            if (r !== void 0) r(u);
            else {
              u(u);
              return;
            }
          }
          (c.image !== void 0
            ? (a.image = c.image)
            : c.data !== void 0 &&
              ((a.image.width = c.width),
              (a.image.height = c.height),
              (a.image.data = c.data)),
            (a.wrapS = c.wrapS !== void 0 ? c.wrapS : mn),
            (a.wrapT = c.wrapT !== void 0 ? c.wrapT : mn),
            (a.magFilter = c.magFilter !== void 0 ? c.magFilter : Dt),
            (a.minFilter = c.minFilter !== void 0 ? c.minFilter : Dt),
            (a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (a.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (a.flipY = c.flipY),
            c.format !== void 0 && (a.format = c.format),
            c.type !== void 0 && (a.type = c.type),
            c.mipmaps !== void 0 &&
              ((a.mipmaps = c.mipmaps), (a.minFilter = kr)),
            c.mipmapCount === 1 && (a.minFilter = Dt),
            c.generateMipmaps !== void 0 &&
              (a.generateMipmaps = c.generateMipmaps),
            (a.needsUpdate = !0),
            t && t(a, c));
        },
        i,
        r
      ),
      a
    );
  }
}
class B7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Vt(),
      a = new bh(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          ((s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s));
        },
        i,
        r
      ),
      s
    );
  }
}
class fa extends Ft {
  constructor(e, t = 1) {
    (super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new je(e)),
      (this.intensity = t));
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class d3 extends fa {
  constructor(e, t, i) {
    (super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = 'HemisphereLight'),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new je(t)));
  }
  copy(e, t) {
    return (super.copy(e, t), this.groundColor.copy(e.groundColor), this);
  }
}
const $0 = new pt(),
  fM = new V(),
  pM = new V();
class vb {
  constructor(e) {
    ((this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new pe(512, 512)),
      (this.mapType = gn),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new pt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Cc()),
      (this._frameExtents = new pe(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Lt(0, 0, 1, 1)]));
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    (fM.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(fM),
      pM.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(pM),
      t.updateMatrixWorld(),
      $0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(
        $0,
        t.coordinateSystem,
        t.reversedDepth
      ),
      t.reversedDepth
        ? i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1)
        : i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply($0));
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    (this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose());
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      (this.autoUpdate = e.autoUpdate),
      (this.needsUpdate = e.needsUpdate),
      (this.normalBias = e.normalBias),
      (this.blurSamples = e.blurSamples),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class N7 extends vb {
  constructor() {
    (super(new Vn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1),
      (this.aspect = 1));
  }
  updateMatrices(e) {
    const t = this.camera,
      i = sc * 2 * e.angle * this.focus,
      r = (this.mapSize.width / this.mapSize.height) * this.aspect,
      s = e.distance || t.far;
    ((i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e));
  }
  copy(e) {
    return (super.copy(e), (this.focus = e.focus), this);
  }
}
class f3 extends fa {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, a = 2) {
    (super(e, t),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new N7()));
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const mM = new pt(),
  ru = new V(),
  ev = new V();
class F7 extends vb {
  constructor() {
    (super(new Vn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new pe(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Lt(2, 1, 1, 1),
        new Lt(0, 1, 1, 1),
        new Lt(3, 1, 1, 1),
        new Lt(1, 1, 1, 1),
        new Lt(3, 0, 1, 1),
        new Lt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new V(1, 0, 0),
        new V(-1, 0, 0),
        new V(0, 0, 1),
        new V(0, 0, -1),
        new V(0, 1, 0),
        new V(0, -1, 0),
      ]),
      (this._cubeUps = [
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 1, 0),
        new V(0, 0, 1),
        new V(0, 0, -1),
      ]));
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    (s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      ru.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(ru),
      ev.copy(i.position),
      ev.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(ev),
      i.updateMatrixWorld(),
      r.makeTranslation(-ru.x, -ru.y, -ru.z),
      mM.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(
        mM,
        i.coordinateSystem,
        i.reversedDepth
      ));
  }
}
class p3 extends fa {
  constructor(e, t, i = 0, r = 2) {
    (super(e, t),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new F7()));
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Jh extends zh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
    (super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, a) {
    (this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      a = i + e,
      o = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      ((s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= u * this.view.offsetY),
        (l = o - u * this.view.height));
    }
    (this.projectionMatrix.makeOrthographic(
      s,
      a,
      o,
      l,
      this.near,
      this.far,
      this.coordinateSystem,
      this.reversedDepth
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class z7 extends vb {
  constructor() {
    (super(new Jh(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0));
  }
}
class m3 extends fa {
  constructor(e, t) {
    (super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(Ft.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ft()),
      (this.shadow = new z7()));
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class g3 extends fa {
  constructor(e, t) {
    (super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight'));
  }
}
class v3 extends fa {
  constructor(e, t, i = 10, r = 10) {
    (super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = 'RectAreaLight'),
      (this.width = i),
      (this.height = r));
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.width = e.width),
      (this.height = e.height),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.width = this.width), (t.object.height = this.height), t);
  }
}
class _3 {
  constructor() {
    ((this.isSphericalHarmonics3 = !0), (this.coefficients = []));
    for (let e = 0; e < 9; e++) this.coefficients.push(new V());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.282095),
      t.addScaledVector(a[1], 0.488603 * r),
      t.addScaledVector(a[2], 0.488603 * s),
      t.addScaledVector(a[3], 0.488603 * i),
      t.addScaledVector(a[4], 1.092548 * (i * r)),
      t.addScaledVector(a[5], 1.092548 * (r * s)),
      t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(a[7], 1.092548 * (i * s)),
      t.addScaledVector(a[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.886227),
      t.addScaledVector(a[1], 2 * 0.511664 * r),
      t.addScaledVector(a[2], 2 * 0.511664 * s),
      t.addScaledVector(a[3], 2 * 0.511664 * i),
      t.addScaledVector(a[4], 2 * 0.429043 * i * r),
      t.addScaledVector(a[5], 2 * 0.429043 * r * s),
      t.addScaledVector(a[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(a[7], 2 * 0.429043 * i * s),
      t.addScaledVector(a[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    ((t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r)));
  }
}
class y3 extends fa {
  constructor(e = new _3(), t = 1) {
    (super(void 0, t), (this.isLightProbe = !0), (this.sh = e));
  }
  copy(e) {
    return (super.copy(e), this.sh.copy(e.sh), this);
  }
  fromJSON(e) {
    return ((this.intensity = e.intensity), this.sh.fromArray(e.sh), this);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.sh = this.sh.toArray()), t);
  }
}
class Zm extends vi {
  constructor(e) {
    (super(e), (this.textures = {}));
  }
  load(e, t, i, r) {
    const s = this,
      a = new ji(s.manager);
    (a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            (r ? r(l) : gt(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 && Ge('MaterialLoader: Undefined texture', s),
        t[s]
      );
    }
    const r = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new je().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (r.dispersion = e.dispersion),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (r.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (r.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        r.blendColor !== void 0 &&
        r.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== void 0 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == 'number'
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const a = e.uniforms[s];
        switch (((r.uniforms[s] = {}), a.type)) {
          case 't':
            r.uniforms[s].value = i(a.value);
            break;
          case 'c':
            r.uniforms[s].value = new je().setHex(a.value);
            break;
          case 'v2':
            r.uniforms[s].value = new pe().fromArray(a.value);
            break;
          case 'v3':
            r.uniforms[s].value = new V().fromArray(a.value);
            break;
          case 'v4':
            r.uniforms[s].value = new Lt().fromArray(a.value);
            break;
          case 'm3':
            r.uniforms[s].value = new xt().fromArray(a.value);
            break;
          case 'm4':
            r.uniforms[s].value = new pt().fromArray(a.value);
            break;
          default:
            r.uniforms[s].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (r.lights = e.lights),
      e.clipping !== void 0 && (r.clipping = e.clipping),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      (Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new pe().fromArray(s)));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapRotation !== void 0 &&
        r.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new pe().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return ((this.textures = e), this);
  }
  createMaterialFromType(e) {
    return Zm.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: Q2,
      SpriteMaterial: eb,
      RawShaderMaterial: Z2,
      ShaderMaterial: rn,
      PointsMaterial: nb,
      MeshPhysicalMaterial: $2,
      MeshStandardMaterial: ub,
      MeshPhongMaterial: e3,
      MeshToonMaterial: t3,
      MeshNormalMaterial: n3,
      MeshLambertMaterial: i3,
      MeshDepthMaterial: hb,
      MeshDistanceMaterial: db,
      MeshBasicMaterial: xs,
      MeshMatcapMaterial: r3,
      LineDashedMaterial: s3,
      LineBasicMaterial: gi,
      Material: jn,
    };
    return new t[e]();
  }
}
class ty {
  static extractUrlBase(e) {
    const t = e.lastIndexOf('/');
    return t === -1 ? './' : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != 'string' || e === ''
      ? ''
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class x3 extends _t {
  constructor() {
    (super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0));
  }
  copy(e) {
    return (super.copy(e), (this.instanceCount = e.instanceCount), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class b3 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = new ji(s.manager);
    (a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            (r ? r(l) : gt(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = {},
      i = {};
    function r(f, p) {
      if (t[p] !== void 0) return t[p];
      const g = f.interleavedBuffers[p],
        v = s(f, g.buffer),
        y = Ol(g.type, v),
        _ = new Um(y, g.stride);
      return ((_.uuid = g.uuid), (t[p] = _), _);
    }
    function s(f, p) {
      if (i[p] !== void 0) return i[p];
      const g = f.arrayBuffers[p],
        v = new Uint32Array(g).buffer;
      return ((i[p] = v), v);
    }
    const a = e.isInstancedBufferGeometry ? new x3() : new _t(),
      o = e.data.index;
    if (o !== void 0) {
      const f = Ol(o.type, o.array);
      a.setIndex(new qt(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const p = l[f];
      let m;
      if (p.isInterleavedBufferAttribute) {
        const g = r(e.data, p.data);
        m = new Uo(g, p.itemSize, p.offset, p.normalized);
      } else {
        const g = Ol(p.type, p.array),
          v = p.isInstancedBufferAttribute ? oc : qt;
        m = new v(g, p.itemSize, p.normalized);
      }
      (p.name !== void 0 && (m.name = p.name),
        p.usage !== void 0 && m.setUsage(p.usage),
        a.setAttribute(f, m));
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const p = c[f],
          m = [];
        for (let g = 0, v = p.length; g < v; g++) {
          const y = p[g];
          let _;
          if (y.isInterleavedBufferAttribute) {
            const x = r(e.data, y.data);
            _ = new Uo(x, y.itemSize, y.offset, y.normalized);
          } else {
            const x = Ol(y.type, y.array);
            _ = new qt(x, y.itemSize, y.normalized);
          }
          (y.name !== void 0 && (_.name = y.name), m.push(_));
        }
        a.morphAttributes[f] = m;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const h = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (h !== void 0)
      for (let f = 0, p = h.length; f !== p; ++f) {
        const m = h[f];
        a.addGroup(m.start, m.count, m.materialIndex);
      }
    const d = e.data.boundingSphere;
    return (
      d !== void 0 && (a.boundingSphere = new Yn().fromJSON(d)),
      e.name && (a.name = e.name),
      e.userData && (a.userData = e.userData),
      a
    );
  }
}
class V7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = this.path === '' ? ty.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new ji(this.manager);
    (o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (h) {
            (r !== void 0 && r(h),
              h("ObjectLoader: Can't parse " + e + '.', h.message));
            return;
          }
          const u = c.metadata;
          if (
            u === void 0 ||
            u.type === void 0 ||
            u.type.toLowerCase() === 'geometry'
          ) {
            (r !== void 0 &&
              r(new Error("THREE.ObjectLoader: Can't load " + e)),
              gt("ObjectLoader: Can't load " + e));
            return;
          }
          s.parse(c, t);
        },
        i,
        r
      ));
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === '' ? ty.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new ji(this.manager);
    (s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials));
    const a = await s.loadAsync(e, t),
      o = JSON.parse(a),
      l = o.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === 'geometry'
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(o);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      a = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      o = this.parseTextures(e.textures, a),
      l = this.parseMaterials(e.materials, o),
      c = this.parseObject(e.object, s, l, o, i),
      u = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, u), this.bindLightTargets(c), t !== void 0)) {
      let h = !1;
      for (const d in a)
        if (a[d].data instanceof HTMLImageElement) {
          h = !0;
          break;
        }
      h === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, s),
      o = this.parseMaterials(e.materials, a),
      l = this.parseObject(e.object, r, o, a, t),
      c = this.parseSkeletons(e.skeletons, l);
    return (this.bindSkeletons(l, c), this.bindLightTargets(l), l);
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new Mo().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, a = e.length; s < a; s++) {
        const o = new km().fromJSON(e[s], r);
        i[o.uuid] = o;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new b3();
      for (let s = 0, a = e.length; s < a; s++) {
        let o;
        const l = e[s];
        switch (l.type) {
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            o = r.parse(l);
            break;
          default:
            l.type in dM
              ? (o = dM[l.type].fromJSON(l, t))
              : Ge(`ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        ((o.uuid = l.uuid),
          l.name !== void 0 && (o.name = l.name),
          l.userData !== void 0 && (o.userData = l.userData),
          (i[l.uuid] = o));
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new Zm();
      s.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a];
        (i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
          (r[l.uuid] = i[l.uuid]));
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = xh.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function a(l) {
      return (
        i.manager.itemStart(l),
        s.load(
          l,
          function () {
            i.manager.itemEnd(l);
          },
          void 0,
          function () {
            (i.manager.itemError(l), i.manager.itemEnd(l));
          }
        )
      );
    }
    function o(l) {
      if (typeof l == 'string') {
        const c = l,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return a(u);
      } else
        return l.data
          ? { data: Ol(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new Kh(t);
      ((s = new bh(l)), s.setCrossOrigin(this.crossOrigin));
      for (let c = 0, u = e.length; c < u; c++) {
        const h = e[c],
          d = h.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let p = 0, m = d.length; p < m; p++) {
            const g = d[p],
              v = o(g);
            v !== null &&
              (v instanceof HTMLImageElement
                ? f.push(v)
                : f.push(new or(v.data, v.width, v.height)));
          }
          r[h.uuid] = new Vs(f);
        } else {
          const f = o(h.url);
          r[h.uuid] = new Vs(f);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(a) {
      if (typeof a == 'string') {
        const o = a,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await r.loadAsync(l);
      } else
        return a.data
          ? { data: Ol(a.type, a.data), width: a.width, height: a.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      ((r = new bh(this.manager)), r.setCrossOrigin(this.crossOrigin));
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a],
          c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let h = 0, d = c.length; h < d; h++) {
            const f = c[h],
              p = await s(f);
            p !== null &&
              (p instanceof HTMLImageElement
                ? u.push(p)
                : u.push(new or(p.data, p.width, p.height)));
          }
          i[l.uuid] = new Vs(u);
        } else {
          const u = await s(l.url);
          i[l.uuid] = new Vs(u);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, a) {
      return typeof s == 'number'
        ? s
        : (Ge(
            'ObjectLoader.parseTexture: Constant should be in numeric form.',
            s
          ),
          a[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        (o.image === void 0 &&
          Ge('ObjectLoader: No "image" specified for', o.uuid),
          t[o.image] === void 0 &&
            Ge('ObjectLoader: Undefined image', o.image));
        const l = t[o.image],
          c = l.data;
        let u;
        (Array.isArray(c)
          ? ((u = new Vh()), c.length === 6 && (u.needsUpdate = !0))
          : (c && c.data ? (u = new or()) : (u = new Vt()),
            c && (u.needsUpdate = !0)),
          (u.source = l),
          (u.uuid = o.uuid),
          o.name !== void 0 && (u.name = o.name),
          o.mapping !== void 0 && (u.mapping = i(o.mapping, H7)),
          o.channel !== void 0 && (u.channel = o.channel),
          o.offset !== void 0 && u.offset.fromArray(o.offset),
          o.repeat !== void 0 && u.repeat.fromArray(o.repeat),
          o.center !== void 0 && u.center.fromArray(o.center),
          o.rotation !== void 0 && (u.rotation = o.rotation),
          o.wrap !== void 0 &&
            ((u.wrapS = i(o.wrap[0], gM)), (u.wrapT = i(o.wrap[1], gM))),
          o.format !== void 0 && (u.format = o.format),
          o.internalFormat !== void 0 && (u.internalFormat = o.internalFormat),
          o.type !== void 0 && (u.type = o.type),
          o.colorSpace !== void 0 && (u.colorSpace = o.colorSpace),
          o.minFilter !== void 0 && (u.minFilter = i(o.minFilter, vM)),
          o.magFilter !== void 0 && (u.magFilter = i(o.magFilter, vM)),
          o.anisotropy !== void 0 && (u.anisotropy = o.anisotropy),
          o.flipY !== void 0 && (u.flipY = o.flipY),
          o.generateMipmaps !== void 0 &&
            (u.generateMipmaps = o.generateMipmaps),
          o.premultiplyAlpha !== void 0 &&
            (u.premultiplyAlpha = o.premultiplyAlpha),
          o.unpackAlignment !== void 0 &&
            (u.unpackAlignment = o.unpackAlignment),
          o.compareFunction !== void 0 &&
            (u.compareFunction = o.compareFunction),
          o.userData !== void 0 && (u.userData = o.userData),
          (r[o.uuid] = u));
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let a;
    function o(d) {
      return (
        t[d] === void 0 && Ge('ObjectLoader: Undefined geometry', d),
        t[d]
      );
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let p = 0, m = d.length; p < m; p++) {
            const g = d[p];
            (i[g] === void 0 && Ge('ObjectLoader: Undefined material', g),
              f.push(i[g]));
          }
          return f;
        }
        return (
          i[d] === void 0 && Ge('ObjectLoader: Undefined material', d),
          i[d]
        );
      }
    }
    function c(d) {
      return (
        r[d] === void 0 && Ge('ObjectLoader: Undefined texture', d),
        r[d]
      );
    }
    let u, h;
    switch (e.type) {
      case 'Scene':
        ((a = new ph()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new je(e.background))
              : (a.background = c(e.background))),
          e.environment !== void 0 && (a.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === 'Fog'
              ? (a.fog = new Lm(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === 'FogExp2' &&
                (a.fog = new Om(e.fog.color, e.fog.density)),
            e.fog.name !== '' && (a.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (a.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            a.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (a.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            a.environmentRotation.fromArray(e.environmentRotation));
        break;
      case 'PerspectiveCamera':
        ((a = new Vn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view)));
        break;
      case 'OrthographicCamera':
        ((a = new Jh(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view)));
        break;
      case 'AmbientLight':
        a = new g3(e.color, e.intensity);
        break;
      case 'DirectionalLight':
        ((a = new m3(e.color, e.intensity)), (a.target = e.target || ''));
        break;
      case 'PointLight':
        a = new p3(e.color, e.intensity, e.distance, e.decay);
        break;
      case 'RectAreaLight':
        a = new v3(e.color, e.intensity, e.width, e.height);
        break;
      case 'SpotLight':
        ((a = new f3(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (a.target = e.target || ''));
        break;
      case 'HemisphereLight':
        a = new d3(e.color, e.groundColor, e.intensity);
        break;
      case 'LightProbe':
        a = new y3().fromJSON(e);
        break;
      case 'SkinnedMesh':
        ((u = o(e.geometry)),
          (h = l(e.material)),
          (a = new L2(u, h)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton));
        break;
      case 'Mesh':
        ((u = o(e.geometry)), (h = l(e.material)), (a = new hn(u, h)));
        break;
      case 'InstancedMesh':
        ((u = o(e.geometry)), (h = l(e.material)));
        const d = e.count,
          f = e.instanceMatrix,
          p = e.instanceColor;
        ((a = new U2(u, h, d)),
          (a.instanceMatrix = new oc(new Float32Array(f.array), 16)),
          p !== void 0 &&
            (a.instanceColor = new oc(new Float32Array(p.array), p.itemSize)));
        break;
      case 'BatchedMesh':
        ((u = o(e.geometry)),
          (h = l(e.material)),
          (a = new k2(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            h
          )),
          (a.geometry = u),
          (a.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (a.sortObjects = e.sortObjects),
          (a._drawRanges = e.drawRanges),
          (a._reservedRanges = e.reservedRanges),
          (a._geometryInfo = e.geometryInfo.map((m) => {
            let g = null,
              v = null;
            return (
              m.boundingBox !== void 0 &&
                (g = new ii().fromJSON(m.boundingBox)),
              m.boundingSphere !== void 0 &&
                (v = new Yn().fromJSON(m.boundingSphere)),
              { ...m, boundingBox: g, boundingSphere: v }
            );
          })),
          (a._instanceInfo = e.instanceInfo),
          (a._availableInstanceIds = e._availableInstanceIds),
          (a._availableGeometryIds = e._availableGeometryIds),
          (a._nextIndexStart = e.nextIndexStart),
          (a._nextVertexStart = e.nextVertexStart),
          (a._geometryCount = e.geometryCount),
          (a._maxInstanceCount = e.maxInstanceCount),
          (a._maxVertexCount = e.maxVertexCount),
          (a._maxIndexCount = e.maxIndexCount),
          (a._geometryInitialized = e.geometryInitialized),
          (a._matricesTexture = c(e.matricesTexture.uuid)),
          (a._indirectTexture = c(e.indirectTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (a._colorsTexture = c(e.colorsTexture.uuid)),
          e.boundingSphere !== void 0 &&
            (a.boundingSphere = new Yn().fromJSON(e.boundingSphere)),
          e.boundingBox !== void 0 &&
            (a.boundingBox = new ii().fromJSON(e.boundingBox)));
        break;
      case 'LOD':
        a = new O2();
        break;
      case 'Line':
        a = new ia(o(e.geometry), l(e.material));
        break;
      case 'LineLoop':
        a = new B2(o(e.geometry), l(e.material));
        break;
      case 'LineSegments':
        a = new jr(o(e.geometry), l(e.material));
        break;
      case 'PointCloud':
      case 'Points':
        a = new N2(o(e.geometry), l(e.material));
        break;
      case 'Sprite':
        a = new D2(l(e.material));
        break;
      case 'Group':
        a = new Ll();
        break;
      case 'Bone':
        a = new tb();
        break;
      default:
        a = new Ft();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (a.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        a.add(this.parseObject(d[f], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        a.animations.push(s[p]);
      }
    }
    if (e.type === 'LOD') {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const p = d[f],
          m = a.getObjectByProperty('uuid', p.object);
        m !== void 0 && a.addLevel(m, p.distance, p.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? Ge('ObjectLoader: No skeleton found with UUID:', i.skeleton)
            : i.bind(r, i.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const i = t.target,
          r = e.getObjectByProperty('uuid', i);
        r !== void 0 ? (t.target = r) : (t.target = new Ft());
      }
    });
  }
}
const H7 = {
    UVMapping: ea,
    CubeReflectionMapping: ys,
    CubeRefractionMapping: ta,
    EquirectangularReflectionMapping: rh,
    EquirectangularRefractionMapping: sh,
    CubeUVReflectionMapping: Mc,
  },
  gM = {
    RepeatWrapping: ah,
    ClampToEdgeWrapping: mn,
    MirroredRepeatWrapping: oh,
  },
  vM = {
    NearestFilter: Un,
    NearestMipmapNearestFilter: Gx,
    NearestMipmapLinearFilter: Dl,
    LinearFilter: Dt,
    LinearMipmapNearestFilter: Iu,
    LinearMipmapLinearFilter: kr,
  },
  tv = new WeakMap();
class G7 extends vi {
  constructor(e) {
    (super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        Ge('ImageBitmapLoader: createImageBitmap() not supported.'),
      typeof fetch > 'u' && Ge('ImageBitmapLoader: fetch() not supported.'),
      (this.options = { premultiplyAlpha: 'none' }),
      (this._abortController = new AbortController()));
  }
  setOptions(e) {
    return ((this.options = e), this);
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ''),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      a = Br.get(`image-bitmap:${e}`);
    if (a !== void 0) {
      if ((s.manager.itemStart(e), a.then)) {
        a.then((c) => {
          if (tv.has(a) === !0)
            (r && r(tv.get(a)), s.manager.itemError(e), s.manager.itemEnd(e));
          else return (t && t(c), s.manager.itemEnd(e), c);
        });
        return;
      }
      return (
        setTimeout(function () {
          (t && t(a), s.manager.itemEnd(e));
        }, 0),
        a
      );
    }
    const o = {};
    ((o.credentials =
      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (o.headers = this.requestHeader),
      (o.signal =
        typeof AbortSignal.any == 'function'
          ? AbortSignal.any([
              this._abortController.signal,
              this.manager.abortController.signal,
            ])
          : this._abortController.signal));
    const l = fetch(e, o)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(s.options, { colorSpaceConversion: 'none' })
        );
      })
      .then(function (c) {
        return (
          Br.add(`image-bitmap:${e}`, c),
          t && t(c),
          s.manager.itemEnd(e),
          c
        );
      })
      .catch(function (c) {
        (r && r(c),
          tv.set(l, c),
          Br.remove(`image-bitmap:${e}`),
          s.manager.itemError(e),
          s.manager.itemEnd(e));
      });
    (Br.add(`image-bitmap:${e}`, l), s.manager.itemStart(e));
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
let sf;
class _b {
  static getContext() {
    return (
      sf === void 0 &&
        (sf = new (window.AudioContext || window.webkitAudioContext)()),
      sf
    );
  }
  static setContext(e) {
    sf = e;
  }
}
class W7 extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      a = new ji(this.manager);
    (a.setResponseType('arraybuffer'),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            _b.getContext()
              .decodeAudioData(c, function (h) {
                t(h);
              })
              .catch(o);
          } catch (c) {
            o(c);
          }
        },
        i,
        r
      ));
    function o(l) {
      (r ? r(l) : gt(l), s.manager.itemError(e));
    }
  }
}
const _M = new pt(),
  yM = new pt(),
  Wa = new pt();
class j7 {
  constructor() {
    ((this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Vn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Vn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      }));
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      ((t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Wa.copy(e.projectionMatrix));
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        a = (t.near * Math.tan(Ao * t.fov * 0.5)) / t.zoom;
      let o, l;
      ((yM.elements[12] = -r),
        (_M.elements[12] = r),
        (o = -a * t.aspect + s),
        (l = a * t.aspect + s),
        (Wa.elements[0] = (2 * t.near) / (l - o)),
        (Wa.elements[8] = (l + o) / (l - o)),
        this.cameraL.projectionMatrix.copy(Wa),
        (o = -a * t.aspect - s),
        (l = a * t.aspect - s),
        (Wa.elements[0] = (2 * t.near) / (l - o)),
        (Wa.elements[8] = (l + o) / (l - o)),
        this.cameraR.projectionMatrix.copy(Wa));
    }
    (this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(yM),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_M));
  }
}
class S3 extends Vn {
  constructor(e = []) {
    (super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = e));
  }
}
class w3 {
  constructor(e = !0) {
    ((this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1));
  }
  start() {
    ((this.startTime = performance.now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0));
  }
  stop() {
    (this.getElapsedTime(), (this.running = !1), (this.autoStart = !1));
  }
  getElapsedTime() {
    return (this.getDelta(), this.elapsedTime);
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return (this.start(), 0);
    if (this.running) {
      const t = performance.now();
      ((e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e));
    }
    return e;
  }
}
const ja = new V(),
  nv = new Ii(),
  X7 = new V(),
  Xa = new V(),
  qa = new V();
class q7 extends Ft {
  constructor() {
    (super(),
      (this.type = 'AudioListener'),
      (this.context = _b.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new w3()));
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(ja, nv, X7),
      Xa.set(0, 0, -1).applyQuaternion(nv),
      qa.set(0, 1, 0).applyQuaternion(nv),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      (t.positionX.linearRampToValueAtTime(ja.x, i),
        t.positionY.linearRampToValueAtTime(ja.y, i),
        t.positionZ.linearRampToValueAtTime(ja.z, i),
        t.forwardX.linearRampToValueAtTime(Xa.x, i),
        t.forwardY.linearRampToValueAtTime(Xa.y, i),
        t.forwardZ.linearRampToValueAtTime(Xa.z, i),
        t.upX.linearRampToValueAtTime(qa.x, i),
        t.upY.linearRampToValueAtTime(qa.y, i),
        t.upZ.linearRampToValueAtTime(qa.z, i));
    } else
      (t.setPosition(ja.x, ja.y, ja.z),
        t.setOrientation(Xa.x, Xa.y, Xa.z, qa.x, qa.y, qa.z));
  }
}
class E3 extends Ft {
  constructor(e) {
    (super(),
      (this.type = 'Audio'),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = 'empty'),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []));
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'audioNode'),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaNode'),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = 'mediaStreamNode'),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = 'buffer'),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      Ge('Audio: Audio is already playing.');
      return;
    }
    if (this.hasPlaybackControl === !1) {
      Ge('Audio: this Audio has no playback control.');
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      Ge('Audio: this Audio has no playback control.');
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      Ge('Audio: this Audio has no playback control.');
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return ((this._connected = !0), this);
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return ((this._connected = !1), this);
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      Ge('Audio: this Audio has no playback control.');
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    ((this.isPlaying = !1), (this._progress = 0));
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (Ge('Audio: this Audio has no playback control.'), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      Ge('Audio: this Audio has no playback control.');
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return ((this.loopStart = e), this);
  }
  setLoopEnd(e) {
    return ((this.loopEnd = e), this);
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== 'buffer'
        ? (Ge('Audio: Audio source type cannot be copied.'), this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const Ya = new V(),
  xM = new Ii(),
  Y7 = new V(),
  Ka = new V();
class K7 extends E3 {
  constructor(e) {
    (super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = 'HRTF'),
      this.panner.connect(this.gain));
  }
  connect() {
    return (super.connect(), this.panner.connect(this.gain), this);
  }
  disconnect() {
    return (super.disconnect(), this.panner.disconnect(this.gain), this);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return ((this.panner.refDistance = e), this);
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return ((this.panner.rolloffFactor = e), this);
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return ((this.panner.distanceModel = e), this);
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return ((this.panner.maxDistance = e), this);
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    (this.matrixWorld.decompose(Ya, xM, Y7),
      Ka.set(0, 0, 1).applyQuaternion(xM));
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      (t.positionX.linearRampToValueAtTime(Ya.x, i),
        t.positionY.linearRampToValueAtTime(Ya.y, i),
        t.positionZ.linearRampToValueAtTime(Ya.z, i),
        t.orientationX.linearRampToValueAtTime(Ka.x, i),
        t.orientationY.linearRampToValueAtTime(Ka.y, i),
        t.orientationZ.linearRampToValueAtTime(Ka.z, i));
    } else
      (t.setPosition(Ya.x, Ya.y, Ya.z), t.setOrientation(Ka.x, Ka.y, Ka.z));
  }
}
class J7 {
  constructor(e, t = 2048) {
    ((this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser));
  }
  getFrequencyData() {
    return (this.analyser.getByteFrequencyData(this.data), this.data);
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class A3 {
  constructor(e, t, i) {
    ((this.binding = e), (this.valueSize = i));
    let r, s, a;
    switch (t) {
      case 'quaternion':
        ((r = this._slerp),
          (s = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5));
        break;
      case 'string':
      case 'bool':
        ((r = this._select),
          (s = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5)));
        break;
      default:
        ((r = this._lerp),
          (s = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5)));
    }
    ((this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0));
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== r; ++o) i[s + o] = i[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(i, s, 0, o, r);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    (this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e));
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      o = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    a > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        o.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, a = r; s !== a; ++s) t[s] = t[r + (s % i)];
    (this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0));
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    (this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1));
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[i + a];
  }
  _slerp(e, t, i, r) {
    Ii.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const a = this._workIndex * s;
    (Ii.multiplyQuaternionsFlat(e, a, e, t, e, i),
      Ii.slerpFlat(e, t, e, t, e, a, r));
  }
  _lerp(e, t, i, r, s) {
    const a = 1 - r;
    for (let o = 0; o !== s; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[i + o] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let a = 0; a !== s; ++a) {
      const o = t + a;
      e[o] = e[o] + e[i + a] * r;
    }
  }
}
const yb = '\\[\\]\\.:\\/',
  Q7 = new RegExp('[' + yb + ']', 'g'),
  xb = '[^' + yb + ']',
  Z7 = '[^' + yb.replace('\\.', '') + ']',
  $7 = /((?:WC+[\/:])*)/.source.replace('WC', xb),
  eY = /(WCOD+)?/.source.replace('WCOD', Z7),
  tY = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', xb),
  nY = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', xb),
  iY = new RegExp('^' + $7 + eY + tY + nY + '$'),
  rY = ['material', 'materials', 'bones', 'map'];
class sY {
  constructor(e, t, i) {
    const r = i || Bt.parseTrackName(t);
    ((this._targetGroup = e), (this._bindings = e.subscribe_(t, r)));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Bt {
  constructor(e, t, i) {
    ((this.path = t),
      (this.parsedPath = i || Bt.parseTrackName(t)),
      (this.node = Bt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Bt.Composite(e, t, i)
      : new Bt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, '_').replace(Q7, '');
  }
  static parseTrackName(e) {
    const t = iY.exec(e);
    if (t === null)
      throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf('.');
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      rY.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === '' ||
      t === '.' ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let a = 0; a < s.length; a++) {
            const o = s[a];
            if (o.name === t || o.uuid === t) return o;
            const l = i(o.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _getValue_unbound(e, t) {
    (this.bind(), this.getValue(e, t));
  }
  _setValue_unbound(e, t) {
    (this.bind(), this.setValue(e, t));
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Bt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      Ge('PropertyBinding: No target node found for track: ' + this.path + '.');
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case 'materials':
          if (!e.material) {
            gt(
              'PropertyBinding: Can not bind to material as node does not have a material.',
              this
            );
            return;
          }
          if (!e.material.materials) {
            gt(
              'PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case 'bones':
          if (!e.skeleton) {
            gt(
              'PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case 'map':
          if ('map' in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            gt(
              'PropertyBinding: Can not bind to material as node does not have a material.',
              this
            );
            return;
          }
          if (!e.material.map) {
            gt(
              'PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            gt(
              'PropertyBinding: Can not bind to objectName of node undefined.',
              this
            );
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          gt(
            'PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const a = e[r];
    if (a === void 0) {
      const c = t.nodeName;
      gt(
        'PropertyBinding: Trying to update property for track: ' +
          c +
          '.' +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let o = this.Versioning.None;
    ((this.targetObject = e),
      e.isMaterial === !0
        ? (o = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (o = this.Versioning.MatrixWorldNeedsUpdate));
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === 'morphTargetInfluences') {
        if (!e.geometry) {
          gt(
            'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          gt(
            'PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      ((l = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = s));
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
          ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
          : (this.propertyName = r);
    ((this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][o]));
  }
  unbind() {
    ((this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
}
Bt.Composite = sY;
Bt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Bt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Bt.prototype.GetterByBindingType = [
  Bt.prototype._getValue_direct,
  Bt.prototype._getValue_array,
  Bt.prototype._getValue_arrayElement,
  Bt.prototype._getValue_toArray,
];
Bt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Bt.prototype._setValue_direct,
    Bt.prototype._setValue_direct_setNeedsUpdate,
    Bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Bt.prototype._setValue_array,
    Bt.prototype._setValue_array_setNeedsUpdate,
    Bt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Bt.prototype._setValue_arrayElement,
    Bt.prototype._setValue_arrayElement_setNeedsUpdate,
    Bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Bt.prototype._setValue_fromArray,
    Bt.prototype._setValue_fromArray_setNeedsUpdate,
    Bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class aY {
  constructor() {
    ((this.isAnimationObjectGroup = !0),
      (this.uuid = Wi()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0));
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    ((this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {}));
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      a = s.length;
    let o,
      l = e.length,
      c = this.nCachedObjects_;
    for (let u = 0, h = arguments.length; u !== h; ++u) {
      const d = arguments[u],
        f = d.uuid;
      let p = t[f];
      if (p === void 0) {
        ((p = l++), (t[f] = p), e.push(d));
        for (let m = 0, g = a; m !== g; ++m) s[m].push(new Bt(d, i[m], r[m]));
      } else if (p < c) {
        o = e[p];
        const m = --c,
          g = e[m];
        ((t[g.uuid] = p), (e[p] = g), (t[f] = m), (e[m] = d));
        for (let v = 0, y = a; v !== y; ++v) {
          const _ = s[v],
            x = _[m];
          let S = _[p];
          ((_[p] = x), S === void 0 && (S = new Bt(d, i[v], r[v])), (_[m] = S));
        }
      } else
        e[p] !== o &&
          gt(
            'AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a],
        c = l.uuid,
        u = t[c];
      if (u !== void 0 && u >= s) {
        const h = s++,
          d = e[h];
        ((t[d.uuid] = u), (e[u] = d), (t[c] = h), (e[h] = l));
        for (let f = 0, p = r; f !== p; ++f) {
          const m = i[f],
            g = m[h],
            v = m[u];
          ((m[u] = g), (m[h] = v));
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      a = e.length;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o],
        u = c.uuid,
        h = t[u];
      if (h !== void 0)
        if ((delete t[u], h < s)) {
          const d = --s,
            f = e[d],
            p = --a,
            m = e[p];
          ((t[f.uuid] = h), (e[h] = f), (t[m.uuid] = d), (e[d] = m), e.pop());
          for (let g = 0, v = r; g !== v; ++g) {
            const y = i[g],
              _ = y[d],
              x = y[p];
            ((y[h] = _), (y[d] = x), y.pop());
          }
        } else {
          const d = --a,
            f = e[d];
          (d > 0 && (t[f.uuid] = h), (e[h] = f), e.pop());
          for (let p = 0, m = r; p !== m; ++p) {
            const g = i[p];
            ((g[h] = g[d]), g.pop());
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const a = this._paths,
      o = this._parsedPaths,
      l = this._objects,
      c = l.length,
      u = this.nCachedObjects_,
      h = new Array(c);
    ((r = s.length), (i[e] = r), a.push(e), o.push(t), s.push(h));
    for (let d = u, f = l.length; d !== f; ++d) {
      const p = l[d];
      h[d] = new Bt(p, e, t);
    }
    return h;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        a = this._bindings,
        o = a.length - 1,
        l = a[o],
        c = e[o];
      ((t[c] = i),
        (a[i] = l),
        a.pop(),
        (s[i] = s[o]),
        s.pop(),
        (r[i] = r[o]),
        r.pop());
    }
  }
}
class M3 {
  constructor(e, t, i = null, r = t.blendMode) {
    ((this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r));
    const s = t.tracks,
      a = s.length,
      o = new Array(a),
      l = { endingStart: ho, endingEnd: ho };
    for (let c = 0; c !== a; ++c) {
      const u = s[c].createInterpolant(null);
      ((o[c] = u), (u.settings = l));
    }
    ((this._interpolantSettings = l),
      (this._interpolants = o),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = d2),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0));
  }
  play() {
    return (this._mixer._activateAction(this), this);
  }
  stop() {
    return (this._mixer._deactivateAction(this), this.reset());
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return ((this._startTime = e), this);
  }
  setLoop(e, t) {
    return ((this.loop = e), (this.repetitions = t), this);
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i = !1) {
    if ((e.fadeOut(t), this.fadeIn(t), i === !0)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        a = s / r,
        o = r / s;
      (e.warp(1, a, t), this.warp(o, 1, t));
    }
    return this;
  }
  crossFadeTo(e, t, i = !1) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return ((this.timeScale = this._clip.duration / e), this.stopWarping());
  }
  syncWith(e) {
    return (
      (this.time = e.time),
      (this.timeScale = e.timeScale),
      this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._timeScaleInterpolant = o));
    const l = o.parameterPositions,
      c = o.sampleValues;
    return ((l[0] = s), (l[1] = s + i), (c[0] = e / a), (c[1] = t / a), this);
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t),
      o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Yx:
          for (let u = 0, h = l.length; u !== h; ++u)
            (l[u].evaluate(a), c[u].accumulateAdditive(o));
          break;
        case Rm:
        default:
          for (let u = 0, h = l.length; u !== h; ++u)
            (l[u].evaluate(a), c[u].accumulate(r, o));
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1)));
      }
    }
    return ((this._effectiveWeight = t), t);
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t)));
      }
    }
    return ((this._effectiveTimeScale = t), t);
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const a = i === f2;
    if (e === 0) return s === -1 ? r : a && (s & 1) === 1 ? t - r : r;
    if (i === h2) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: e < 0 ? -1 : 1,
          }));
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        r >= t || r < 0)
      ) {
        const o = Math.floor(r / t);
        ((r -= t * o), (s += Math.abs(o)));
        const l = this.repetitions - s;
        if (l <= 0)
          (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: e > 0 ? 1 : -1,
            }));
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else this._setEndings(!1, !1, a);
          ((this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: 'loop',
              action: this,
              loopDelta: o,
            }));
        }
      } else this.time = r;
      if (a && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = fo), (r.endingEnd = fo))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? fo : ho)
          : (r.endingStart = ch),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? fo : ho) : (r.endingEnd = ch));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let a = this._weightInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._weightInterpolant = a));
    const o = a.parameterPositions,
      l = a.sampleValues;
    return ((o[0] = s), (l[0] = t), (o[1] = s + e), (l[1] = i), this);
  }
}
const oY = new Float32Array(1);
class lY extends Ki {
  constructor(e) {
    (super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1));
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      a = e._propertyBindings,
      o = e._interpolants,
      l = i.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let h = 0; h !== s; ++h) {
      const d = r[h],
        f = d.name;
      let p = u[f];
      if (p !== void 0) (++p.referenceCount, (a[h] = p));
      else {
        if (((p = a[h]), p !== void 0)) {
          p._cacheIndex === null &&
            (++p.referenceCount, this._addInactiveBinding(p, l, f));
          continue;
        }
        const m = t && t._propertyBindings[h].binding.parsedPath;
        ((p = new A3(Bt.create(i, f, m), d.ValueTypeName, d.getValueSize())),
          ++p.referenceCount,
          this._addInactiveBinding(p, l, f),
          (a[h] = p));
      }
      o[h].resultBuffer = p.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        (this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i));
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    ((this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0));
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let a = s[t];
    if (a === void 0)
      ((a = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = a));
    else {
      const o = a.knownActions;
      ((e._byClipCacheIndex = o.length), o.push(e));
    }
    ((e._cacheIndex = r.length), r.push(e), (a.actionByRoot[i] = e));
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    ((i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null));
    const s = e._clip.uuid,
      a = this._actionsByClip,
      o = a[s],
      l = o.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    ((c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null));
    const h = o.actionByRoot,
      d = (e._localRoot || this._root).uuid;
    (delete h[d],
      l.length === 0 && delete a[s],
      this._removeInactiveBindingsForAction(e));
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let a = r[t];
    (a === void 0 && ((a = {}), (r[t] = a)),
      (a[i] = e),
      (e._cacheIndex = s.length),
      s.push(e));
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      a = this._bindingsByRootAndName,
      o = a[r],
      l = t[t.length - 1],
      c = e._cacheIndex;
    ((l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete o[s],
      Object.keys(o).length === 0 && delete a[r]);
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new pb(new Float32Array(2), new Float32Array(2), 1, oY)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    ((e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s));
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let a = typeof e == 'string' ? xh.findByName(r, e) : e;
    const o = a !== null ? a.uuid : e,
      l = this._actionsByClip[o];
    let c = null;
    if (
      (i === void 0 && (a !== null ? (i = a.blendMode) : (i = Rm)),
      l !== void 0)
    ) {
      const h = l.actionByRoot[s];
      if (h !== void 0 && h.blendMode === i) return h;
      ((c = l.knownActions[0]), a === null && (a = c._clip));
    }
    if (a === null) return null;
    const u = new M3(this, a, t, i);
    return (this._bindAction(u, c), this._addInactiveAction(u, o, s), u);
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == 'string' ? xh.findByName(i, e) : e,
      a = s ? s.uuid : e,
      o = this._actionsByClip[a];
    return (o !== void 0 && o.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, a);
    const o = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) o[c].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const a = s.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          h = t[t.length - 1];
        ((c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (h._cacheIndex = u),
          (t[u] = h),
          t.pop(),
          this._removeInactiveBindingsForAction(c));
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const a in i) {
      const o = i[a].actionByRoot,
        l = o[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const a in s) {
        const o = s[a];
        (o.restoreOriginalState(), this._removeInactiveBinding(o));
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class cY extends Qx {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    (super(e, t, r),
      (this.isRenderTarget3D = !0),
      (this.depth = i),
      (this.texture = new Pm(null, e, t, i)),
      this._setTextureOptions(r),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class Mt {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new Mt(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let uY = 0;
class hY extends Ki {
  constructor() {
    (super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, 'id', { value: uY++ }),
      (this.name = ''),
      (this.usage = hh),
      (this.uniforms = []));
  }
  add(e) {
    return (this.uniforms.push(e), this);
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return (t !== -1 && this.uniforms.splice(t, 1), this);
  }
  setName(e) {
    return ((this.name = e), this);
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' });
  }
  copy(e) {
    ((this.name = e.name), (this.usage = e.usage));
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let a = 0; a < s.length; a++) this.uniforms.push(s[a].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class dY extends Um {
  constructor(e, t, i = 1) {
    (super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  clone(e) {
    const t = super.clone(e);
    return ((t.meshPerAttribute = this.meshPerAttribute), t);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class fY {
  constructor(e, t, i, r, s, a = !1) {
    ((this.isGLBufferAttribute = !0),
      (this.name = ''),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.normalized = a),
      (this.version = 0));
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return ((this.buffer = e), this);
  }
  setType(e, t) {
    return ((this.type = e), (this.elementSize = t), this);
  }
  setItemSize(e) {
    return ((this.itemSize = e), this);
  }
  setCount(e) {
    return ((this.count = e), this);
  }
}
const bM = new pt();
class pY {
  constructor(e, t, i = 0, r = 1 / 0) {
    ((this.ray = new Tc(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Dm()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }));
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : gt('Raycaster: Unsupported camera type: ' + t.type);
  }
  setFromXRController(e) {
    return (
      bM.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(bM),
      this
    );
  }
  intersectObject(e, t = !0, i = []) {
    return (ny(e, this, i, t), i.sort(SM), i);
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) ny(e[r], this, i, t);
    return (i.sort(SM), i);
  }
}
function SM(n, e) {
  return n.distance - e.distance;
}
function ny(n, e, t, i) {
  let r = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0)
  ) {
    const s = n.children;
    for (let a = 0, o = s.length; a < o; a++) ny(s[a], e, t, !0);
  }
}
let mY = class {
  constructor() {
    ((this._previousTime = 0),
      (this._currentTime = 0),
      (this._startTime = performance.now()),
      (this._delta = 0),
      (this._elapsed = 0),
      (this._timescale = 1),
      (this._document = null),
      (this._pageVisibilityHandler = null));
  }
  connect(e) {
    ((this._document = e),
      e.hidden !== void 0 &&
        ((this._pageVisibilityHandler = gY.bind(this)),
        e.addEventListener(
          'visibilitychange',
          this._pageVisibilityHandler,
          !1
        )));
  }
  disconnect() {
    (this._pageVisibilityHandler !== null &&
      (this._document.removeEventListener(
        'visibilitychange',
        this._pageVisibilityHandler
      ),
      (this._pageVisibilityHandler = null)),
      (this._document = null));
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  setTimescale(e) {
    return ((this._timescale = e), this);
  }
  reset() {
    return ((this._currentTime = performance.now() - this._startTime), this);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    return (
      this._pageVisibilityHandler !== null && this._document.hidden === !0
        ? (this._delta = 0)
        : ((this._previousTime = this._currentTime),
          (this._currentTime =
            (e !== void 0 ? e : performance.now()) - this._startTime),
          (this._delta =
            (this._currentTime - this._previousTime) * this._timescale),
          (this._elapsed += this._delta)),
      this
    );
  }
};
function gY() {
  this._document.hidden === !1 && this.reset();
}
class vY {
  constructor(e = 1, t = 0, i = 0) {
    ((this.radius = e), (this.phi = t), (this.theta = i));
  }
  set(e, t, i) {
    return ((this.radius = e), (this.phi = t), (this.theta = i), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.phi = e.phi),
      (this.theta = e.theta),
      this
    );
  }
  makeSafe() {
    return ((this.phi = ut(this.phi, 1e-6, Math.PI - 1e-6)), this);
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(ut(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _Y {
  constructor(e = 1, t = 0, i = 0) {
    ((this.radius = e), (this.theta = t), (this.y = i));
  }
  set(e, t, i) {
    return ((this.radius = e), (this.theta = t), (this.y = i), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.theta = e.theta),
      (this.y = e.y),
      this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class bb {
  constructor(e, t, i, r) {
    ((bb.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r));
  }
  identity() {
    return (this.set(1, 0, 0, 1), this);
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 4; i++) this.elements[i] = e[i + t];
    return this;
  }
  set(e, t, i, r) {
    const s = this.elements;
    return ((s[0] = e), (s[2] = t), (s[1] = i), (s[3] = r), this);
  }
}
const wM = new pe();
class yY {
  constructor(e = new pe(1 / 0, 1 / 0), t = new pe(-1 / 0, -1 / 0)) {
    ((this.isBox2 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = wM.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, wM).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const EM = new V(),
  af = new V(),
  vl = new V(),
  _l = new V(),
  iv = new V(),
  xY = new V(),
  bY = new V();
class SY {
  constructor(e = new V(), t = new V()) {
    ((this.start = e), (this.end = t));
  }
  set(e, t) {
    return (this.start.copy(e), this.end.copy(t), this);
  }
  copy(e) {
    return (this.start.copy(e.start), this.end.copy(e.end), this);
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    (EM.subVectors(e, this.start), af.subVectors(this.end, this.start));
    const i = af.dot(af);
    let s = af.dot(EM) / i;
    return (t && (s = ut(s, 0, 1)), s);
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  distanceSqToLine3(e, t = xY, i = bY) {
    const r = 10000000000000001e-32;
    let s, a;
    const o = this.start,
      l = e.start,
      c = this.end,
      u = e.end;
    (vl.subVectors(c, o), _l.subVectors(u, l), iv.subVectors(o, l));
    const h = vl.dot(vl),
      d = _l.dot(_l),
      f = _l.dot(iv);
    if (h <= r && d <= r) return (t.copy(o), i.copy(l), t.sub(i), t.dot(t));
    if (h <= r) ((s = 0), (a = f / d), (a = ut(a, 0, 1)));
    else {
      const p = vl.dot(iv);
      if (d <= r) ((a = 0), (s = ut(-p / h, 0, 1)));
      else {
        const m = vl.dot(_l),
          g = h * d - m * m;
        (g !== 0 ? (s = ut((m * f - p * d) / g, 0, 1)) : (s = 0),
          (a = (m * s + f) / d),
          a < 0
            ? ((a = 0), (s = ut(-p / h, 0, 1)))
            : a > 1 && ((a = 1), (s = ut((m - p) / h, 0, 1))));
      }
    }
    return (
      t.copy(o).add(vl.multiplyScalar(s)),
      i.copy(l).add(_l.multiplyScalar(a)),
      t.sub(i),
      t.dot(t)
    );
  }
  applyMatrix4(e) {
    return (this.start.applyMatrix4(e), this.end.applyMatrix4(e), this);
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const AM = new V();
class wY extends Ft {
  constructor(e, t) {
    (super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = 'SpotLightHelper'));
    const i = new _t(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = (a / l) * Math.PI * 2,
        u = (o / l) * Math.PI * 2;
      r.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
    }
    i.setAttribute('position', new $e(r, 3));
    const s = new gi({ fog: !1, toneMapped: !1 });
    ((this.cone = new jr(i, s)), this.add(this.cone), this.update());
  }
  dispose() {
    (this.cone.geometry.dispose(), this.cone.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld));
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    (this.cone.scale.set(t, t, e),
      AM.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(AM),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color));
  }
}
const Ps = new V(),
  of = new pt(),
  rv = new pt();
class EY extends jr {
  constructor(e) {
    const t = T3(e),
      i = new _t(),
      r = [],
      s = [];
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent &&
        u.parent.isBone &&
        (r.push(0, 0, 0), r.push(0, 0, 0), s.push(0, 0, 0), s.push(0, 0, 0));
    }
    (i.setAttribute('position', new $e(r, 3)),
      i.setAttribute('color', new $e(s, 3)));
    const a = new gi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    (super(i, a),
      (this.isSkeletonHelper = !0),
      (this.type = 'SkeletonHelper'),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1));
    const o = new je(255),
      l = new je(65280);
    this.setColors(o, l);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute('position');
    rv.copy(this.root.matrixWorld).invert();
    for (let s = 0, a = 0; s < t.length; s++) {
      const o = t[s];
      o.parent &&
        o.parent.isBone &&
        (of.multiplyMatrices(rv, o.matrixWorld),
        Ps.setFromMatrixPosition(of),
        r.setXYZ(a, Ps.x, Ps.y, Ps.z),
        of.multiplyMatrices(rv, o.parent.matrixWorld),
        Ps.setFromMatrixPosition(of),
        r.setXYZ(a + 1, Ps.x, Ps.y, Ps.z),
        (a += 2));
    }
    ((i.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(e));
  }
  setColors(e, t) {
    const r = this.geometry.getAttribute('color');
    for (let s = 0; s < r.count; s += 2)
      (r.setXYZ(s, e.r, e.g, e.b), r.setXYZ(s + 1, t.r, t.g, t.b));
    return ((r.needsUpdate = !0), this);
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function T3(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++) e.push(...T3(n.children[t]));
  return e;
}
class AY extends hn {
  constructor(e, t, i) {
    const r = new Xh(t, 4, 2),
      s = new xs({ wireframe: !0, fog: !1, toneMapped: !1 });
    (super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = 'PointLightHelper'),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color));
  }
}
const MY = new V(),
  MM = new je(),
  TM = new je();
class TY extends Ft {
  constructor(e, t, i) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = 'HemisphereLightHelper'));
    const r = new jh(t);
    (r.rotateY(Math.PI * 0.5),
      (this.material = new xs({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0));
    const s = r.getAttribute('position'),
      a = new Float32Array(s.count * 3);
    (r.setAttribute('color', new qt(a, 3)),
      this.add(new hn(r, this.material)),
      this.update());
  }
  dispose() {
    (this.children[0].geometry.dispose(), this.children[0].material.dispose());
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute('color');
      (MM.copy(this.light.color), TM.copy(this.light.groundColor));
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? MM : TM;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    (this.light.updateWorldMatrix(!0, !1),
      e.lookAt(MY.setFromMatrixPosition(this.light.matrixWorld).negate()));
  }
}
class CY extends jr {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    ((i = new je(i)), (r = new je(r)));
    const s = t / 2,
      a = e / t,
      o = e / 2,
      l = [],
      c = [];
    for (let d = 0, f = 0, p = -o; d <= t; d++, p += a) {
      (l.push(-o, 0, p, o, 0, p), l.push(p, 0, -o, p, 0, o));
      const m = d === s ? i : r;
      (m.toArray(c, f),
        (f += 3),
        m.toArray(c, f),
        (f += 3),
        m.toArray(c, f),
        (f += 3),
        m.toArray(c, f),
        (f += 3));
    }
    const u = new _t();
    (u.setAttribute('position', new $e(l, 3)),
      u.setAttribute('color', new $e(c, 3)));
    const h = new gi({ vertexColors: !0, toneMapped: !1 });
    (super(u, h), (this.type = 'GridHelper'));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class RY extends jr {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, a = 8947848) {
    ((s = new je(s)), (a = new je(a)));
    const o = [],
      l = [];
    if (t > 1)
      for (let h = 0; h < t; h++) {
        const d = (h / t) * (Math.PI * 2),
          f = Math.sin(d) * e,
          p = Math.cos(d) * e;
        (o.push(0, 0, 0), o.push(f, 0, p));
        const m = h & 1 ? s : a;
        (l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b));
      }
    for (let h = 0; h < i; h++) {
      const d = h & 1 ? s : a,
        f = e - (e / i) * h;
      for (let p = 0; p < r; p++) {
        let m = (p / r) * (Math.PI * 2),
          g = Math.sin(m) * f,
          v = Math.cos(m) * f;
        (o.push(g, 0, v),
          l.push(d.r, d.g, d.b),
          (m = ((p + 1) / r) * (Math.PI * 2)),
          (g = Math.sin(m) * f),
          (v = Math.cos(m) * f),
          o.push(g, 0, v),
          l.push(d.r, d.g, d.b));
      }
    }
    const c = new _t();
    (c.setAttribute('position', new $e(o, 3)),
      c.setAttribute('color', new $e(l, 3)));
    const u = new gi({ vertexColors: !0, toneMapped: !1 });
    (super(c, u), (this.type = 'PolarGridHelper'));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
const CM = new V(),
  lf = new V(),
  RM = new V();
class IY extends Ft {
  constructor(e, t, i) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = 'DirectionalLightHelper'),
      t === void 0 && (t = 1));
    let r = new _t();
    r.setAttribute(
      'position',
      new $e([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new gi({ fog: !1, toneMapped: !1 });
    ((this.lightPlane = new ia(r, s)),
      this.add(this.lightPlane),
      (r = new _t()),
      r.setAttribute('position', new $e([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new ia(r, s)),
      this.add(this.targetLine),
      this.update());
  }
  dispose() {
    (this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      CM.setFromMatrixPosition(this.light.matrixWorld),
      lf.setFromMatrixPosition(this.light.target.matrixWorld),
      RM.subVectors(lf, CM),
      this.lightPlane.lookAt(lf),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(lf),
      (this.targetLine.scale.z = RM.length()));
  }
}
const cf = new V(),
  dn = new zh();
class PY extends jr {
  constructor(e) {
    const t = new _t(),
      i = new gi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      a = {};
    (o('n1', 'n2'),
      o('n2', 'n4'),
      o('n4', 'n3'),
      o('n3', 'n1'),
      o('f1', 'f2'),
      o('f2', 'f4'),
      o('f4', 'f3'),
      o('f3', 'f1'),
      o('n1', 'f1'),
      o('n2', 'f2'),
      o('n3', 'f3'),
      o('n4', 'f4'),
      o('p', 'n1'),
      o('p', 'n2'),
      o('p', 'n3'),
      o('p', 'n4'),
      o('u1', 'u2'),
      o('u2', 'u3'),
      o('u3', 'u1'),
      o('c', 't'),
      o('p', 'c'),
      o('cn1', 'cn2'),
      o('cn3', 'cn4'),
      o('cf1', 'cf2'),
      o('cf3', 'cf4'));
    function o(p, m) {
      (l(p), l(m));
    }
    function l(p) {
      (r.push(0, 0, 0),
        s.push(0, 0, 0),
        a[p] === void 0 && (a[p] = []),
        a[p].push(r.length / 3 - 1));
    }
    (t.setAttribute('position', new $e(r, 3)),
      t.setAttribute('color', new $e(s, 3)),
      super(t, i),
      (this.type = 'CameraHelper'),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update());
    const c = new je(16755200),
      u = new je(16711680),
      h = new je(43775),
      d = new je(16777215),
      f = new je(3355443);
    this.setColors(c, u, h, d, f);
  }
  setColors(e, t, i, r, s) {
    const o = this.geometry.getAttribute('color');
    return (
      o.setXYZ(0, e.r, e.g, e.b),
      o.setXYZ(1, e.r, e.g, e.b),
      o.setXYZ(2, e.r, e.g, e.b),
      o.setXYZ(3, e.r, e.g, e.b),
      o.setXYZ(4, e.r, e.g, e.b),
      o.setXYZ(5, e.r, e.g, e.b),
      o.setXYZ(6, e.r, e.g, e.b),
      o.setXYZ(7, e.r, e.g, e.b),
      o.setXYZ(8, e.r, e.g, e.b),
      o.setXYZ(9, e.r, e.g, e.b),
      o.setXYZ(10, e.r, e.g, e.b),
      o.setXYZ(11, e.r, e.g, e.b),
      o.setXYZ(12, e.r, e.g, e.b),
      o.setXYZ(13, e.r, e.g, e.b),
      o.setXYZ(14, e.r, e.g, e.b),
      o.setXYZ(15, e.r, e.g, e.b),
      o.setXYZ(16, e.r, e.g, e.b),
      o.setXYZ(17, e.r, e.g, e.b),
      o.setXYZ(18, e.r, e.g, e.b),
      o.setXYZ(19, e.r, e.g, e.b),
      o.setXYZ(20, e.r, e.g, e.b),
      o.setXYZ(21, e.r, e.g, e.b),
      o.setXYZ(22, e.r, e.g, e.b),
      o.setXYZ(23, e.r, e.g, e.b),
      o.setXYZ(24, t.r, t.g, t.b),
      o.setXYZ(25, t.r, t.g, t.b),
      o.setXYZ(26, t.r, t.g, t.b),
      o.setXYZ(27, t.r, t.g, t.b),
      o.setXYZ(28, t.r, t.g, t.b),
      o.setXYZ(29, t.r, t.g, t.b),
      o.setXYZ(30, t.r, t.g, t.b),
      o.setXYZ(31, t.r, t.g, t.b),
      o.setXYZ(32, i.r, i.g, i.b),
      o.setXYZ(33, i.r, i.g, i.b),
      o.setXYZ(34, i.r, i.g, i.b),
      o.setXYZ(35, i.r, i.g, i.b),
      o.setXYZ(36, i.r, i.g, i.b),
      o.setXYZ(37, i.r, i.g, i.b),
      o.setXYZ(38, r.r, r.g, r.b),
      o.setXYZ(39, r.r, r.g, r.b),
      o.setXYZ(40, s.r, s.g, s.b),
      o.setXYZ(41, s.r, s.g, s.b),
      o.setXYZ(42, s.r, s.g, s.b),
      o.setXYZ(43, s.r, s.g, s.b),
      o.setXYZ(44, s.r, s.g, s.b),
      o.setXYZ(45, s.r, s.g, s.b),
      o.setXYZ(46, s.r, s.g, s.b),
      o.setXYZ(47, s.r, s.g, s.b),
      o.setXYZ(48, s.r, s.g, s.b),
      o.setXYZ(49, s.r, s.g, s.b),
      (o.needsUpdate = !0),
      this
    );
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    let s, a;
    if (
      (dn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      this.camera.reversedDepth === !0)
    )
      ((s = 1), (a = 0));
    else if (this.camera.coordinateSystem === Hi) ((s = -1), (a = 1));
    else if (this.camera.coordinateSystem === ic) ((s = 0), (a = 1));
    else
      throw new Error(
        'THREE.CameraHelper.update(): Invalid coordinate system: ' +
          this.camera.coordinateSystem
      );
    (_n('c', t, e, dn, 0, 0, s),
      _n('t', t, e, dn, 0, 0, a),
      _n('n1', t, e, dn, -i, -r, s),
      _n('n2', t, e, dn, i, -r, s),
      _n('n3', t, e, dn, -i, r, s),
      _n('n4', t, e, dn, i, r, s),
      _n('f1', t, e, dn, -i, -r, a),
      _n('f2', t, e, dn, i, -r, a),
      _n('f3', t, e, dn, -i, r, a),
      _n('f4', t, e, dn, i, r, a),
      _n('u1', t, e, dn, i * 0.7, r * 1.1, s),
      _n('u2', t, e, dn, -i * 0.7, r * 1.1, s),
      _n('u3', t, e, dn, 0, r * 2, s),
      _n('cf1', t, e, dn, -i, 0, a),
      _n('cf2', t, e, dn, i, 0, a),
      _n('cf3', t, e, dn, 0, -r, a),
      _n('cf4', t, e, dn, 0, r, a),
      _n('cn1', t, e, dn, -i, 0, s),
      _n('cn2', t, e, dn, i, 0, s),
      _n('cn3', t, e, dn, 0, -r, s),
      _n('cn4', t, e, dn, 0, r, s),
      (e.getAttribute('position').needsUpdate = !0));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function _n(n, e, t, i, r, s, a) {
  cf.set(r, s, a).unproject(i);
  const o = e[n];
  if (o !== void 0) {
    const l = t.getAttribute('position');
    for (let c = 0, u = o.length; c < u; c++) l.setXYZ(o[c], cf.x, cf.y, cf.z);
  }
}
const uf = new ii();
class DY extends jr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(24),
      s = new _t();
    (s.setIndex(new qt(i, 1)),
      s.setAttribute('position', new qt(r, 3)),
      super(s, new gi({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = 'BoxHelper'),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  update() {
    if ((this.object !== void 0 && uf.setFromObject(this.object), uf.isEmpty()))
      return;
    const e = uf.min,
      t = uf.max,
      i = this.geometry.attributes.position,
      r = i.array;
    ((r[0] = t.x),
      (r[1] = t.y),
      (r[2] = t.z),
      (r[3] = e.x),
      (r[4] = t.y),
      (r[5] = t.z),
      (r[6] = e.x),
      (r[7] = e.y),
      (r[8] = t.z),
      (r[9] = t.x),
      (r[10] = e.y),
      (r[11] = t.z),
      (r[12] = t.x),
      (r[13] = t.y),
      (r[14] = e.z),
      (r[15] = e.x),
      (r[16] = t.y),
      (r[17] = e.z),
      (r[18] = e.x),
      (r[19] = e.y),
      (r[20] = e.z),
      (r[21] = t.x),
      (r[22] = e.y),
      (r[23] = e.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere());
  }
  setFromObject(e) {
    return ((this.object = e), this.update(), this);
  }
  copy(e, t) {
    return (super.copy(e, t), (this.object = e.object), this);
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class OY extends jr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new _t();
    (s.setIndex(new qt(i, 1)),
      s.setAttribute('position', new $e(r, 3)),
      super(s, new gi({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = 'Box3Helper'),
      this.geometry.computeBoundingSphere());
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class LY extends ia {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      a = new _t();
    (a.setAttribute('position', new $e(s, 3)),
      a.computeBoundingSphere(),
      super(a, new gi({ color: r, toneMapped: !1 })),
      (this.type = 'PlaneHelper'),
      (this.plane = e),
      (this.size = t));
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new _t();
    (l.setAttribute('position', new $e(o, 3)),
      l.computeBoundingSphere(),
      this.add(
        new hn(
          l,
          new xs({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      ));
  }
  updateMatrixWorld(e) {
    (this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose());
  }
}
const IM = new V();
let hf, sv;
class UY extends Ft {
  constructor(
    e = new V(0, 0, 1),
    t = new V(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    a = s * 0.2
  ) {
    (super(),
      (this.type = 'ArrowHelper'),
      hf === void 0 &&
        ((hf = new _t()),
        hf.setAttribute('position', new $e([0, 0, 0, 0, 1, 0], 3)),
        (sv = new Gh(0.5, 1, 5, 1)),
        sv.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new ia(hf, new gi({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new hn(sv, new xs({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, a));
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      IM.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(IM, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    (this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix());
  }
  setColor(e) {
    (this.line.material.color.set(e), this.cone.material.color.set(e));
  }
  copy(e) {
    return (
      super.copy(e, !1),
      this.line.copy(e.line),
      this.cone.copy(e.cone),
      this
    );
  }
  dispose() {
    (this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose());
  }
}
class kY extends jr {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new _t();
    (r.setAttribute('position', new $e(t, 3)),
      r.setAttribute('color', new $e(i, 3)));
    const s = new gi({ vertexColors: !0, toneMapped: !1 });
    (super(r, s), (this.type = 'AxesHelper'));
  }
  setColors(e, t, i) {
    const r = new je(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class BY {
  constructor() {
    ((this.type = 'ShapePath'),
      (this.color = new je()),
      (this.subPaths = []),
      (this.currentPath = null));
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Yp()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return (this.currentPath.lineTo(e, t), this);
  }
  quadraticCurveTo(e, t, i, r) {
    return (this.currentPath.quadraticCurveTo(e, t, i, r), this);
  }
  bezierCurveTo(e, t, i, r, s, a) {
    return (this.currentPath.bezierCurveTo(e, t, i, r, s, a), this);
  }
  splineThru(e) {
    return (this.currentPath.splineThru(e), this);
  }
  toShapes(e) {
    function t(v) {
      const y = [];
      for (let _ = 0, x = v.length; _ < x; _++) {
        const S = v[_],
          b = new Mo();
        ((b.curves = S.curves), y.push(b));
      }
      return y;
    }
    function i(v, y) {
      const _ = y.length;
      let x = !1;
      for (let S = _ - 1, b = 0; b < _; S = b++) {
        let A = y[S],
          E = y[b],
          w = E.x - A.x,
          M = E.y - A.y;
        if (Math.abs(M) > Number.EPSILON) {
          if (
            (M < 0 && ((A = y[b]), (w = -w), (E = y[S]), (M = -M)),
            v.y < A.y || v.y > E.y)
          )
            continue;
          if (v.y === A.y) {
            if (v.x === A.x) return !0;
          } else {
            const T = M * (v.x - A.x) - w * (v.y - A.y);
            if (T === 0) return !0;
            if (T < 0) continue;
            x = !x;
          }
        } else {
          if (v.y !== A.y) continue;
          if ((E.x <= v.x && v.x <= A.x) || (A.x <= v.x && v.x <= E.x))
            return !0;
        }
      }
      return x;
    }
    const r = Er.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let a, o, l;
    const c = [];
    if (s.length === 1)
      return ((o = s[0]), (l = new Mo()), (l.curves = o.curves), c.push(l), c);
    let u = !r(s[0].getPoints());
    u = e ? !u : u;
    const h = [],
      d = [];
    let f = [],
      p = 0,
      m;
    ((d[p] = void 0), (f[p] = []));
    for (let v = 0, y = s.length; v < y; v++)
      ((o = s[v]),
        (m = o.getPoints()),
        (a = r(m)),
        (a = e ? !a : a),
        a
          ? (!u && d[p] && p++,
            (d[p] = { s: new Mo(), p: m }),
            (d[p].s.curves = o.curves),
            u && p++,
            (f[p] = []))
          : f[p].push({ h: o, p: m[0] }));
    if (!d[0]) return t(s);
    if (d.length > 1) {
      let v = !1,
        y = 0;
      for (let _ = 0, x = d.length; _ < x; _++) h[_] = [];
      for (let _ = 0, x = d.length; _ < x; _++) {
        const S = f[_];
        for (let b = 0; b < S.length; b++) {
          const A = S[b];
          let E = !0;
          for (let w = 0; w < d.length; w++)
            i(A.p, d[w].p) &&
              (_ !== w && y++, E ? ((E = !1), h[w].push(A)) : (v = !0));
          E && h[_].push(A);
        }
      }
      y > 0 && v === !1 && (f = h);
    }
    let g;
    for (let v = 0, y = d.length; v < y; v++) {
      ((l = d[v].s), c.push(l), (g = f[v]));
      for (let _ = 0, x = g.length; _ < x; _++) l.holes.push(g[_].h);
    }
    return c;
  }
}
class NY extends Ki {
  constructor(e, t = null) {
    (super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null }));
  }
  connect(e) {
    if (e === void 0) {
      Ge('Controls: connect() now requires an element.');
      return;
    }
    (this.domElement !== null && this.disconnect(), (this.domElement = e));
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function FY(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function zY(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function VY(n) {
  return (
    (n.repeat.x = 1),
    (n.repeat.y = 1),
    (n.offset.x = 0),
    (n.offset.y = 0),
    n
  );
}
function iy(n, e, t, i) {
  const r = HY(i);
  switch (t) {
    case Xx:
      return n * e;
    case Nh:
      return ((n * e) / r.components) * r.byteLength;
    case Fh:
      return ((n * e) / r.components) * r.byteLength;
    case Mm:
      return ((n * e * 2) / r.components) * r.byteLength;
    case Tm:
      return ((n * e * 2) / r.components) * r.byteLength;
    case qx:
      return ((n * e * 3) / r.components) * r.byteLength;
    case Rn:
      return ((n * e * 4) / r.components) * r.byteLength;
    case Cm:
      return ((n * e * 4) / r.components) * r.byteLength;
    case Pu:
    case Du:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Ou:
    case Lu:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case vp:
    case yp:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case gp:
    case _p:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case xp:
    case bp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Sp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case wp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ep:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Ap:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Mp:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Tp:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Cp:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Rp:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Ip:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Pp:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Dp:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Op:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Lp:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Up:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case kp:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Bp:
    case Np:
    case Fp:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case zp:
    case Vp:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case Hp:
    case Gp:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function HY(n) {
  switch (n) {
    case gn:
    case Sm:
      return { byteLength: 1, components: 1 };
    case tc:
    case wm:
    case Gn:
      return { byteLength: 2, components: 1 };
    case Em:
    case Am:
      return { byteLength: 2, components: 4 };
    case Mr:
    case Bh:
    case un:
      return { byteLength: 4, components: 1 };
    case Wx:
    case jx:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
class GY {
  static contain(e, t) {
    return FY(e, t);
  }
  static cover(e, t) {
    return zY(e, t);
  }
  static fill(e) {
    return VY(e);
  }
  static getByteLength(e, t, i, r) {
    return iy(e, t, i, r);
  }
}
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', { detail: { revision: la } })
  );
typeof window < 'u' &&
  (window.__THREE__
    ? Ge('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = la));
function C3() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, a) {
    (t(s, a), (i = n.requestAnimationFrame(r)));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      (n.cancelAnimationFrame(i), (e = !1));
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function WY(n) {
  const e = new WeakMap();
  function t(o, l) {
    const c = o.array,
      u = o.usage,
      h = c.byteLength,
      d = n.createBuffer();
    (n.bindBuffer(l, d), n.bufferData(l, c, u), o.onUploadCallback());
    let f;
    if (c instanceof Float32Array) f = n.FLOAT;
    else if (typeof Float16Array < 'u' && c instanceof Float16Array)
      f = n.HALF_FLOAT;
    else if (c instanceof Uint16Array)
      o.isFloat16BufferAttribute ? (f = n.HALF_FLOAT) : (f = n.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) f = n.SHORT;
    else if (c instanceof Uint32Array) f = n.UNSIGNED_INT;
    else if (c instanceof Int32Array) f = n.INT;
    else if (c instanceof Int8Array) f = n.BYTE;
    else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE;
    else
      throw new Error(
        'THREE.WebGLAttributes: Unsupported buffer data format: ' + c
      );
    return {
      buffer: d,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: o.version,
      size: h,
    };
  }
  function i(o, l, c) {
    const u = l.array,
      h = l.updateRanges;
    if ((n.bindBuffer(c, o), h.length === 0)) n.bufferSubData(c, 0, u);
    else {
      h.sort((f, p) => f.start - p.start);
      let d = 0;
      for (let f = 1; f < h.length; f++) {
        const p = h[d],
          m = h[f];
        m.start <= p.start + p.count + 1
          ? (p.count = Math.max(p.count, m.start + m.count - p.start))
          : (++d, (h[d] = m));
      }
      h.length = d + 1;
      for (let f = 0, p = h.length; f < p; f++) {
        const m = h[f];
        n.bufferSubData(c, m.start * u.BYTES_PER_ELEMENT, u, m.start, m.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(o) {
    return (o.isInterleavedBufferAttribute && (o = o.data), e.get(o));
  }
  function s(o) {
    o.isInterleavedBufferAttribute && (o = o.data);
    const l = e.get(o);
    l && (n.deleteBuffer(l.buffer), e.delete(o));
  }
  function a(o, l) {
    if (
      (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute)
    ) {
      const u = e.get(o);
      (!u || u.version < o.version) &&
        e.set(o, {
          buffer: o.buffer,
          type: o.type,
          bytesPerElement: o.elementSize,
          version: o.version,
        });
      return;
    }
    const c = e.get(o);
    if (c === void 0) e.set(o, t(o, l));
    else if (c.version < o.version) {
      if (c.size !== o.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      (i(c.buffer, o, l), (c.version = o.version));
    }
  }
  return { get: r, remove: s, update: a };
}
var jY = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  XY = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  qY = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  YY = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  KY = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  JY = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  QY = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  ZY = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  $Y = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  eK = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  tK = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  nK = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  iK = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  rK = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  sK = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  aK = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  oK = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  lK = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  cK = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  uK = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  hK = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  dK = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  fK = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  pK = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  mK = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  gK = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  vK = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  _K = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  yK = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  xK = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  bK = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  SK = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  wK = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  EK = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
  AK = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  MK = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  TK = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  CK = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  RK = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  IK = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  PK = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  DK = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  OK = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  LK = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  UK = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  kK = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  BK = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  NK = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  FK = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  zK = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  VK = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  HK = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  GK = `uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 uv = vec2( roughness, dotNV );
	return texture2D( dfgLUT, uv ).rg;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );
	vec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );
	vec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  WK = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  jK = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  XK = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  qK = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  YK = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  KK = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  JK = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  QK = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  ZK = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  $K = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  eJ = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  tJ = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  nJ = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  iJ = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  rJ = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  sJ = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  aJ = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  oJ = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  lJ = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  cJ = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  uJ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  hJ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  dJ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  fJ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  pJ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  mJ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  gJ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  vJ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  _J = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  yJ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  xJ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  bJ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  SJ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  wJ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  EJ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  AJ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  MJ = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  TJ = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  CJ = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  RJ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  IJ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  PJ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  DJ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  OJ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  LJ = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  UJ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  kJ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  BJ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  NJ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  FJ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  zJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  VJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  HJ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  GJ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const WJ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  jJ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  XJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  qJ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  YJ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  KJ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  JJ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  QJ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  ZJ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  $J = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  eQ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  tQ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  nQ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  iQ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  rQ = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  sQ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  aQ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  oQ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  lQ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  cQ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  uQ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  hQ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  dQ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fQ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  pQ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  mQ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  gQ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  vQ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  _Q = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  yQ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  xQ = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  bQ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  SQ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  wQ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Et = {
    alphahash_fragment: jY,
    alphahash_pars_fragment: XY,
    alphamap_fragment: qY,
    alphamap_pars_fragment: YY,
    alphatest_fragment: KY,
    alphatest_pars_fragment: JY,
    aomap_fragment: QY,
    aomap_pars_fragment: ZY,
    batching_pars_vertex: $Y,
    batching_vertex: eK,
    begin_vertex: tK,
    beginnormal_vertex: nK,
    bsdfs: iK,
    iridescence_fragment: rK,
    bumpmap_pars_fragment: sK,
    clipping_planes_fragment: aK,
    clipping_planes_pars_fragment: oK,
    clipping_planes_pars_vertex: lK,
    clipping_planes_vertex: cK,
    color_fragment: uK,
    color_pars_fragment: hK,
    color_pars_vertex: dK,
    color_vertex: fK,
    common: pK,
    cube_uv_reflection_fragment: mK,
    defaultnormal_vertex: gK,
    displacementmap_pars_vertex: vK,
    displacementmap_vertex: _K,
    emissivemap_fragment: yK,
    emissivemap_pars_fragment: xK,
    colorspace_fragment: bK,
    colorspace_pars_fragment: SK,
    envmap_fragment: wK,
    envmap_common_pars_fragment: EK,
    envmap_pars_fragment: AK,
    envmap_pars_vertex: MK,
    envmap_physical_pars_fragment: BK,
    envmap_vertex: TK,
    fog_vertex: CK,
    fog_pars_vertex: RK,
    fog_fragment: IK,
    fog_pars_fragment: PK,
    gradientmap_pars_fragment: DK,
    lightmap_pars_fragment: OK,
    lights_lambert_fragment: LK,
    lights_lambert_pars_fragment: UK,
    lights_pars_begin: kK,
    lights_toon_fragment: NK,
    lights_toon_pars_fragment: FK,
    lights_phong_fragment: zK,
    lights_phong_pars_fragment: VK,
    lights_physical_fragment: HK,
    lights_physical_pars_fragment: GK,
    lights_fragment_begin: WK,
    lights_fragment_maps: jK,
    lights_fragment_end: XK,
    logdepthbuf_fragment: qK,
    logdepthbuf_pars_fragment: YK,
    logdepthbuf_pars_vertex: KK,
    logdepthbuf_vertex: JK,
    map_fragment: QK,
    map_pars_fragment: ZK,
    map_particle_fragment: $K,
    map_particle_pars_fragment: eJ,
    metalnessmap_fragment: tJ,
    metalnessmap_pars_fragment: nJ,
    morphinstance_vertex: iJ,
    morphcolor_vertex: rJ,
    morphnormal_vertex: sJ,
    morphtarget_pars_vertex: aJ,
    morphtarget_vertex: oJ,
    normal_fragment_begin: lJ,
    normal_fragment_maps: cJ,
    normal_pars_fragment: uJ,
    normal_pars_vertex: hJ,
    normal_vertex: dJ,
    normalmap_pars_fragment: fJ,
    clearcoat_normal_fragment_begin: pJ,
    clearcoat_normal_fragment_maps: mJ,
    clearcoat_pars_fragment: gJ,
    iridescence_pars_fragment: vJ,
    opaque_fragment: _J,
    packing: yJ,
    premultiplied_alpha_fragment: xJ,
    project_vertex: bJ,
    dithering_fragment: SJ,
    dithering_pars_fragment: wJ,
    roughnessmap_fragment: EJ,
    roughnessmap_pars_fragment: AJ,
    shadowmap_pars_fragment: MJ,
    shadowmap_pars_vertex: TJ,
    shadowmap_vertex: CJ,
    shadowmask_pars_fragment: RJ,
    skinbase_vertex: IJ,
    skinning_pars_vertex: PJ,
    skinning_vertex: DJ,
    skinnormal_vertex: OJ,
    specularmap_fragment: LJ,
    specularmap_pars_fragment: UJ,
    tonemapping_fragment: kJ,
    tonemapping_pars_fragment: BJ,
    transmission_fragment: NJ,
    transmission_pars_fragment: FJ,
    uv_pars_fragment: zJ,
    uv_pars_vertex: VJ,
    uv_vertex: HJ,
    worldpos_vertex: GJ,
    background_vert: WJ,
    background_frag: jJ,
    backgroundCube_vert: XJ,
    backgroundCube_frag: qJ,
    cube_vert: YJ,
    cube_frag: KJ,
    depth_vert: JJ,
    depth_frag: QJ,
    distanceRGBA_vert: ZJ,
    distanceRGBA_frag: $J,
    equirect_vert: eQ,
    equirect_frag: tQ,
    linedashed_vert: nQ,
    linedashed_frag: iQ,
    meshbasic_vert: rQ,
    meshbasic_frag: sQ,
    meshlambert_vert: aQ,
    meshlambert_frag: oQ,
    meshmatcap_vert: lQ,
    meshmatcap_frag: cQ,
    meshnormal_vert: uQ,
    meshnormal_frag: hQ,
    meshphong_vert: dQ,
    meshphong_frag: fQ,
    meshphysical_vert: pQ,
    meshphysical_frag: mQ,
    meshtoon_vert: gQ,
    meshtoon_frag: vQ,
    points_vert: _Q,
    points_frag: yQ,
    shadow_vert: xQ,
    shadow_frag: bQ,
    sprite_vert: SQ,
    sprite_frag: wQ,
  },
  He = {
    common: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new xt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new xt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new xt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new xt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
      dfgLUT: { value: null },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new xt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new xt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new xt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new xt() },
      normalScale: { value: new pe(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new xt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new xt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new xt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new xt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new je(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new xt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new xt() },
    },
    sprite: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      center: { value: new pe(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new xt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new xt() },
      alphaTest: { value: 0 },
    },
  },
  br = {
    basic: {
      uniforms: oi([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.fog,
      ]),
      vertexShader: Et.meshbasic_vert,
      fragmentShader: Et.meshbasic_frag,
    },
    lambert: {
      uniforms: oi([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        He.lights,
        { emissive: { value: new je(0) } },
      ]),
      vertexShader: Et.meshlambert_vert,
      fragmentShader: Et.meshlambert_frag,
    },
    phong: {
      uniforms: oi([
        He.common,
        He.specularmap,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        He.lights,
        {
          emissive: { value: new je(0) },
          specular: { value: new je(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Et.meshphong_vert,
      fragmentShader: Et.meshphong_frag,
    },
    standard: {
      uniforms: oi([
        He.common,
        He.envmap,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.roughnessmap,
        He.metalnessmap,
        He.fog,
        He.lights,
        {
          emissive: { value: new je(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Et.meshphysical_vert,
      fragmentShader: Et.meshphysical_frag,
    },
    toon: {
      uniforms: oi([
        He.common,
        He.aomap,
        He.lightmap,
        He.emissivemap,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.gradientmap,
        He.fog,
        He.lights,
        { emissive: { value: new je(0) } },
      ]),
      vertexShader: Et.meshtoon_vert,
      fragmentShader: Et.meshtoon_frag,
    },
    matcap: {
      uniforms: oi([
        He.common,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        He.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Et.meshmatcap_vert,
      fragmentShader: Et.meshmatcap_frag,
    },
    points: {
      uniforms: oi([He.points, He.fog]),
      vertexShader: Et.points_vert,
      fragmentShader: Et.points_frag,
    },
    dashed: {
      uniforms: oi([
        He.common,
        He.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Et.linedashed_vert,
      fragmentShader: Et.linedashed_frag,
    },
    depth: {
      uniforms: oi([He.common, He.displacementmap]),
      vertexShader: Et.depth_vert,
      fragmentShader: Et.depth_frag,
    },
    normal: {
      uniforms: oi([
        He.common,
        He.bumpmap,
        He.normalmap,
        He.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Et.meshnormal_vert,
      fragmentShader: Et.meshnormal_frag,
    },
    sprite: {
      uniforms: oi([He.sprite, He.fog]),
      vertexShader: Et.sprite_vert,
      fragmentShader: Et.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new xt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Et.background_vert,
      fragmentShader: Et.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new xt() },
      },
      vertexShader: Et.backgroundCube_vert,
      fragmentShader: Et.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Et.cube_vert,
      fragmentShader: Et.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Et.equirect_vert,
      fragmentShader: Et.equirect_frag,
    },
    distanceRGBA: {
      uniforms: oi([
        He.common,
        He.displacementmap,
        {
          referencePosition: { value: new V() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Et.distanceRGBA_vert,
      fragmentShader: Et.distanceRGBA_frag,
    },
    shadow: {
      uniforms: oi([
        He.lights,
        He.fog,
        { color: { value: new je(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Et.shadow_vert,
      fragmentShader: Et.shadow_frag,
    },
  };
br.physical = {
  uniforms: oi([
    br.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new xt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new xt() },
      clearcoatNormalScale: { value: new pe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new xt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new xt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new xt() },
      sheen: { value: 0 },
      sheenColor: { value: new je(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new xt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new xt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new xt() },
      transmissionSamplerSize: { value: new pe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new xt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new je(0) },
      specularColor: { value: new je(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new xt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new xt() },
      anisotropyVector: { value: new pe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new xt() },
    },
  ]),
  vertexShader: Et.meshphysical_vert,
  fragmentShader: Et.meshphysical_frag,
};
const df = { r: 0, b: 0, g: 0 },
  Ja = new Yi(),
  EQ = new pt();
function AQ(n, e, t, i, r, s, a) {
  const o = new je(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    h = null,
    d = 0,
    f = null;
  function p(_) {
    let x = _.isScene === !0 ? _.background : null;
    return (
      x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? t : e).get(x)),
      x
    );
  }
  function m(_) {
    let x = !1;
    const S = p(_);
    S === null ? v(o, l) : S && S.isColor && (v(S, 1), (x = !0));
    const b = n.xr.getEnvironmentBlendMode();
    (b === 'additive'
      ? i.buffers.color.setClear(0, 0, 0, 1, a)
      : b === 'alpha-blend' && i.buffers.color.setClear(0, 0, 0, 0, a),
      (n.autoClear || x) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil)));
  }
  function g(_, x) {
    const S = p(x);
    S && (S.isCubeTexture || S.mapping === Mc)
      ? (u === void 0 &&
          ((u = new hn(
            new Vo(1, 1, 1),
            new rn({
              name: 'BackgroundCubeMaterial',
              uniforms: ac(br.backgroundCube.uniforms),
              vertexShader: br.backgroundCube.vertexShader,
              fragmentShader: br.backgroundCube.fragmentShader,
              side: On,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          u.geometry.deleteAttribute('normal'),
          u.geometry.deleteAttribute('uv'),
          (u.onBeforeRender = function (b, A, E) {
            this.matrixWorld.copyPosition(E.matrixWorld);
          }),
          Object.defineProperty(u.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(u)),
        Ja.copy(x.backgroundRotation),
        (Ja.x *= -1),
        (Ja.y *= -1),
        (Ja.z *= -1),
        S.isCubeTexture &&
          S.isRenderTargetTexture === !1 &&
          ((Ja.y *= -1), (Ja.z *= -1)),
        (u.material.uniforms.envMap.value = S),
        (u.material.uniforms.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          x.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = x.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          EQ.makeRotationFromEuler(Ja)
        ),
        (u.material.toneMapped = kt.getTransfer(S.colorSpace) !== Yt),
        (h !== S || d !== S.version || f !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (h = S),
          (d = S.version),
          (f = n.toneMapping)),
        u.layers.enableAll(),
        _.unshift(u, u.geometry, u.material, 0, 0, null))
      : S &&
        S.isTexture &&
        (c === void 0 &&
          ((c = new hn(
            new da(2, 2),
            new rn({
              name: 'BackgroundMaterial',
              uniforms: ac(br.background.uniforms),
              vertexShader: br.background.vertexShader,
              fragmentShader: br.background.fragmentShader,
              side: Wr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          c.geometry.deleteAttribute('normal'),
          Object.defineProperty(c.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = S),
        (c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity),
        (c.material.toneMapped = kt.getTransfer(S.colorSpace) !== Yt),
        S.matrixAutoUpdate === !0 && S.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(S.matrix),
        (h !== S || d !== S.version || f !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (h = S),
          (d = S.version),
          (f = n.toneMapping)),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function v(_, x) {
    (_.getRGB(df, T2(n)), i.buffers.color.setClear(df.r, df.g, df.b, x, a));
  }
  function y() {
    (u !== void 0 && (u.geometry.dispose(), u.material.dispose(), (u = void 0)),
      c !== void 0 &&
        (c.geometry.dispose(), c.material.dispose(), (c = void 0)));
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (_, x = 1) {
      (o.set(_), (l = x), v(o, l));
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (_) {
      ((l = _), v(o, l));
    },
    render: m,
    addToRenderList: g,
    dispose: y,
  };
}
function MQ(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    i = {},
    r = d(null);
  let s = r,
    a = !1;
  function o(M, T, D, L, O) {
    let z = !1;
    const C = h(L, D, T);
    (s !== C && ((s = C), c(s.object)),
      (z = f(M, L, D, O)),
      z && p(M, L, D, O),
      O !== null && e.update(O, n.ELEMENT_ARRAY_BUFFER),
      (z || a) &&
        ((a = !1),
        x(M, T, D, L),
        O !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(O).buffer)));
  }
  function l() {
    return n.createVertexArray();
  }
  function c(M) {
    return n.bindVertexArray(M);
  }
  function u(M) {
    return n.deleteVertexArray(M);
  }
  function h(M, T, D) {
    const L = D.wireframe === !0;
    let O = i[M.id];
    O === void 0 && ((O = {}), (i[M.id] = O));
    let z = O[T.id];
    z === void 0 && ((z = {}), (O[T.id] = z));
    let C = z[L];
    return (C === void 0 && ((C = d(l())), (z[L] = C)), C);
  }
  function d(M) {
    const T = [],
      D = [],
      L = [];
    for (let O = 0; O < t; O++) ((T[O] = 0), (D[O] = 0), (L[O] = 0));
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: T,
      enabledAttributes: D,
      attributeDivisors: L,
      object: M,
      attributes: {},
      index: null,
    };
  }
  function f(M, T, D, L) {
    const O = s.attributes,
      z = T.attributes;
    let C = 0;
    const N = D.getAttributes();
    for (const U in N)
      if (N[U].location >= 0) {
        const G = O[U];
        let ne = z[U];
        if (
          (ne === void 0 &&
            (U === 'instanceMatrix' &&
              M.instanceMatrix &&
              (ne = M.instanceMatrix),
            U === 'instanceColor' && M.instanceColor && (ne = M.instanceColor)),
          G === void 0 || G.attribute !== ne || (ne && G.data !== ne.data))
        )
          return !0;
        C++;
      }
    return s.attributesNum !== C || s.index !== L;
  }
  function p(M, T, D, L) {
    const O = {},
      z = T.attributes;
    let C = 0;
    const N = D.getAttributes();
    for (const U in N)
      if (N[U].location >= 0) {
        let G = z[U];
        G === void 0 &&
          (U === 'instanceMatrix' && M.instanceMatrix && (G = M.instanceMatrix),
          U === 'instanceColor' && M.instanceColor && (G = M.instanceColor));
        const ne = {};
        ((ne.attribute = G),
          G && G.data && (ne.data = G.data),
          (O[U] = ne),
          C++);
      }
    ((s.attributes = O), (s.attributesNum = C), (s.index = L));
  }
  function m() {
    const M = s.newAttributes;
    for (let T = 0, D = M.length; T < D; T++) M[T] = 0;
  }
  function g(M) {
    v(M, 0);
  }
  function v(M, T) {
    const D = s.newAttributes,
      L = s.enabledAttributes,
      O = s.attributeDivisors;
    ((D[M] = 1),
      L[M] === 0 && (n.enableVertexAttribArray(M), (L[M] = 1)),
      O[M] !== T && (n.vertexAttribDivisor(M, T), (O[M] = T)));
  }
  function y() {
    const M = s.newAttributes,
      T = s.enabledAttributes;
    for (let D = 0, L = T.length; D < L; D++)
      T[D] !== M[D] && (n.disableVertexAttribArray(D), (T[D] = 0));
  }
  function _(M, T, D, L, O, z, C) {
    C === !0
      ? n.vertexAttribIPointer(M, T, D, O, z)
      : n.vertexAttribPointer(M, T, D, L, O, z);
  }
  function x(M, T, D, L) {
    m();
    const O = L.attributes,
      z = D.getAttributes(),
      C = T.defaultAttributeValues;
    for (const N in z) {
      const U = z[N];
      if (U.location >= 0) {
        let W = O[N];
        if (
          (W === void 0 &&
            (N === 'instanceMatrix' &&
              M.instanceMatrix &&
              (W = M.instanceMatrix),
            N === 'instanceColor' && M.instanceColor && (W = M.instanceColor)),
          W !== void 0)
        ) {
          const G = W.normalized,
            ne = W.itemSize,
            ve = e.get(W);
          if (ve === void 0) continue;
          const Se = ve.buffer,
            Ae = ve.type,
            Oe = ve.bytesPerElement,
            Z = Ae === n.INT || Ae === n.UNSIGNED_INT || W.gpuType === Bh;
          if (W.isInterleavedBufferAttribute) {
            const J = W.data,
              de = J.stride,
              fe = W.offset;
            if (J.isInstancedInterleavedBuffer) {
              for (let K = 0; K < U.locationSize; K++)
                v(U.location + K, J.meshPerAttribute);
              M.isInstancedMesh !== !0 &&
                L._maxInstanceCount === void 0 &&
                (L._maxInstanceCount = J.meshPerAttribute * J.count);
            } else for (let K = 0; K < U.locationSize; K++) g(U.location + K);
            n.bindBuffer(n.ARRAY_BUFFER, Se);
            for (let K = 0; K < U.locationSize; K++)
              _(
                U.location + K,
                ne / U.locationSize,
                Ae,
                G,
                de * Oe,
                (fe + (ne / U.locationSize) * K) * Oe,
                Z
              );
          } else {
            if (W.isInstancedBufferAttribute) {
              for (let J = 0; J < U.locationSize; J++)
                v(U.location + J, W.meshPerAttribute);
              M.isInstancedMesh !== !0 &&
                L._maxInstanceCount === void 0 &&
                (L._maxInstanceCount = W.meshPerAttribute * W.count);
            } else for (let J = 0; J < U.locationSize; J++) g(U.location + J);
            n.bindBuffer(n.ARRAY_BUFFER, Se);
            for (let J = 0; J < U.locationSize; J++)
              _(
                U.location + J,
                ne / U.locationSize,
                Ae,
                G,
                ne * Oe,
                (ne / U.locationSize) * J * Oe,
                Z
              );
          }
        } else if (C !== void 0) {
          const G = C[N];
          if (G !== void 0)
            switch (G.length) {
              case 2:
                n.vertexAttrib2fv(U.location, G);
                break;
              case 3:
                n.vertexAttrib3fv(U.location, G);
                break;
              case 4:
                n.vertexAttrib4fv(U.location, G);
                break;
              default:
                n.vertexAttrib1fv(U.location, G);
            }
        }
      }
    }
    y();
  }
  function S() {
    E();
    for (const M in i) {
      const T = i[M];
      for (const D in T) {
        const L = T[D];
        for (const O in L) (u(L[O].object), delete L[O]);
        delete T[D];
      }
      delete i[M];
    }
  }
  function b(M) {
    if (i[M.id] === void 0) return;
    const T = i[M.id];
    for (const D in T) {
      const L = T[D];
      for (const O in L) (u(L[O].object), delete L[O]);
      delete T[D];
    }
    delete i[M.id];
  }
  function A(M) {
    for (const T in i) {
      const D = i[T];
      if (D[M.id] === void 0) continue;
      const L = D[M.id];
      for (const O in L) (u(L[O].object), delete L[O]);
      delete D[M.id];
    }
  }
  function E() {
    (w(), (a = !0), s !== r && ((s = r), c(s.object)));
  }
  function w() {
    ((r.geometry = null), (r.program = null), (r.wireframe = !1));
  }
  return {
    setup: o,
    reset: E,
    resetDefaultState: w,
    dispose: S,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: A,
    initAttributes: m,
    enableAttribute: g,
    disableUnusedAttributes: y,
  };
}
function TQ(n, e, t) {
  let i;
  function r(c) {
    i = c;
  }
  function s(c, u) {
    (n.drawArrays(i, c, u), t.update(u, i, 1));
  }
  function a(c, u, h) {
    h !== 0 && (n.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
  }
  function o(c, u, h) {
    if (h === 0) return;
    e.get('WEBGL_multi_draw').multiDrawArraysWEBGL(i, c, 0, u, 0, h);
    let f = 0;
    for (let p = 0; p < h; p++) f += u[p];
    t.update(f, i, 1);
  }
  function l(c, u, h, d) {
    if (h === 0) return;
    const f = e.get('WEBGL_multi_draw');
    if (f === null) for (let p = 0; p < c.length; p++) a(c[p], u[p], d[p]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
      let p = 0;
      for (let m = 0; m < h; m++) p += u[m] * d[m];
      t.update(p, i, 1);
    }
  }
  ((this.setMode = r),
    (this.render = s),
    (this.renderInstances = a),
    (this.renderMultiDraw = o),
    (this.renderMultiDrawInstances = l));
}
function CQ(n, e, t, i) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has('EXT_texture_filter_anisotropic') === !0) {
      const A = e.get('EXT_texture_filter_anisotropic');
      r = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function a(A) {
    return !(
      A !== Rn &&
      i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function o(A) {
    const E =
      A === Gn &&
      (e.has('EXT_color_buffer_half_float') || e.has('EXT_color_buffer_float'));
    return !(
      A !== gn &&
      i.convert(A) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      A !== un &&
      !E
    );
  }
  function l(A) {
    if (A === 'highp') {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return 'highp';
      A = 'mediump';
    }
    return A === 'mediump' &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? 'mediump'
      : 'lowp';
  }
  let c = t.precision !== void 0 ? t.precision : 'highp';
  const u = l(c);
  u !== c &&
    (Ge('WebGLRenderer:', c, 'not supported, using', u, 'instead.'), (c = u));
  const h = t.logarithmicDepthBuffer === !0,
    d = t.reversedDepthBuffer === !0 && e.has('EXT_clip_control'),
    f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    m = n.getParameter(n.MAX_TEXTURE_SIZE),
    g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    v = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    y = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    _ = n.getParameter(n.MAX_VARYING_VECTORS),
    x = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    S = p > 0,
    b = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: a,
    textureTypeReadable: o,
    precision: c,
    logarithmicDepthBuffer: h,
    reversedDepthBuffer: d,
    maxTextures: f,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: g,
    maxAttributes: v,
    maxVertexUniforms: y,
    maxVaryings: _,
    maxFragmentUniforms: x,
    vertexTextures: S,
    maxSamples: b,
  };
}
function RQ(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const a = new Us(),
    o = new xt(),
    l = { value: null, needsUpdate: !1 };
  ((this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, d) {
      const f = h.length !== 0 || d || i !== 0 || r;
      return ((r = d), (i = h.length), f);
    }),
    (this.beginShadows = function () {
      ((s = !0), u(null));
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, d) {
      t = u(h, d, 0);
    }),
    (this.setState = function (h, d, f) {
      const p = h.clippingPlanes,
        m = h.clipIntersection,
        g = h.clipShadows,
        v = n.get(h);
      if (!r || p === null || p.length === 0 || (s && !g)) s ? u(null) : c();
      else {
        const y = s ? 0 : i,
          _ = y * 4;
        let x = v.clippingState || null;
        ((l.value = x), (x = u(p, d, _, f)));
        for (let S = 0; S !== _; ++S) x[S] = t[S];
        ((v.clippingState = x),
          (this.numIntersection = m ? this.numPlanes : 0),
          (this.numPlanes += y));
      }
    }));
  function c() {
    (l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0));
  }
  function u(h, d, f, p) {
    const m = h !== null ? h.length : 0;
    let g = null;
    if (m !== 0) {
      if (((g = l.value), p !== !0 || g === null)) {
        const v = f + m * 4,
          y = d.matrixWorldInverse;
        (o.getNormalMatrix(y),
          (g === null || g.length < v) && (g = new Float32Array(v)));
        for (let _ = 0, x = f; _ !== m; ++_, x += 4)
          (a.copy(h[_]).applyMatrix4(y, o),
            a.normal.toArray(g, x),
            (g[x + 3] = a.constant));
      }
      ((l.value = g), (l.needsUpdate = !0));
    }
    return ((e.numPlanes = m), (e.numIntersection = 0), g);
  }
}
function IQ(n) {
  let e = new WeakMap();
  function t(a, o) {
    return (o === rh ? (a.mapping = ys) : o === sh && (a.mapping = ta), a);
  }
  function i(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === rh || o === sh)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new I2(l.height);
            return (
              c.fromEquirectangularTexture(n, a),
              e.set(a, c),
              a.addEventListener('dispose', r),
              t(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function r(a) {
    const o = a.target;
    o.removeEventListener('dispose', r);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
const Hs = 4,
  PM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  so = 20,
  PQ = 512,
  su = new Jh(),
  DM = new je();
let av = null,
  ov = 0,
  lv = 0,
  cv = !1;
const DQ = new V();
class ry {
  constructor(e) {
    ((this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._lodMeshes = []),
      (this._backgroundBox = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      (this._blurMaterial = null),
      (this._ggxMaterial = null));
  }
  fromScene(e, t = 0, i = 0.1, r = 100, s = {}) {
    const { size: a = 256, position: o = DQ } = s;
    ((av = this._renderer.getRenderTarget()),
      (ov = this._renderer.getActiveCubeFace()),
      (lv = this._renderer.getActiveMipmapLevel()),
      (cv = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(a));
    const l = this._allocateTargets();
    return (
      (l.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, l, o),
      t > 0 && this._blur(l, 0, 0, t),
      this._applyPMREM(l),
      this._cleanup(l),
      l
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = UM()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = LM()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    (this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose(),
      this._backgroundBox !== null &&
        (this._backgroundBox.geometry.dispose(),
        this._backgroundBox.material.dispose()));
  }
  _setSize(e) {
    ((this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax)));
  }
  _dispose() {
    (this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._ggxMaterial !== null && this._ggxMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose());
    for (let e = 0; e < this._lodMeshes.length; e++)
      this._lodMeshes[e].geometry.dispose();
  }
  _cleanup(e) {
    (this._renderer.setRenderTarget(av, ov, lv),
      (this._renderer.xr.enabled = cv),
      (e.scissorTest = !1),
      yl(e, 0, 0, e.width, e.height));
  }
  _fromTexture(e, t) {
    (e.mapping === ys || e.mapping === ta
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (av = this._renderer.getRenderTarget()),
      (ov = this._renderer.getActiveCubeFace()),
      (lv = this._renderer.getActiveMipmapLevel()),
      (cv = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1));
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i),
      this._applyPMREM(i),
      this._cleanup(i),
      i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Dt,
        minFilter: Dt,
        generateMipmaps: !1,
        type: Gn,
        format: Rn,
        colorSpace: cr,
        depthBuffer: !1,
      },
      r = OM(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      (this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = OM(e, t, i)));
      const { _lodMax: s } = this;
      (({
        lodMeshes: this._lodMeshes,
        sizeLods: this._sizeLods,
        sigmas: this._sigmas,
      } = OQ(s)),
        (this._blurMaterial = UQ(s, e, t)));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new hn(new _t(), e);
    this._renderer.compile(t, su);
  }
  _sceneToCubeUV(e, t, i, r, s) {
    const l = new Vn(90, 1, t, i),
      c = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      f = h.toneMapping;
    (h.getClearColor(DM),
      (h.toneMapping = ds),
      (h.autoClear = !1),
      h.state.buffers.depth.getReversed() &&
        (h.setRenderTarget(r), h.clearDepth(), h.setRenderTarget(null)),
      this._backgroundBox === null &&
        (this._backgroundBox = new hn(
          new Vo(),
          new xs({
            name: 'PMREM.Background',
            side: On,
            depthWrite: !1,
            depthTest: !1,
          })
        )));
    const m = this._backgroundBox,
      g = m.material;
    let v = !1;
    const y = e.background;
    y
      ? y.isColor && (g.color.copy(y), (e.background = null), (v = !0))
      : (g.color.copy(DM), (v = !0));
    for (let _ = 0; _ < 6; _++) {
      const x = _ % 3;
      x === 0
        ? (l.up.set(0, c[_], 0),
          l.position.set(s.x, s.y, s.z),
          l.lookAt(s.x + u[_], s.y, s.z))
        : x === 1
          ? (l.up.set(0, 0, c[_]),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y + u[_], s.z))
          : (l.up.set(0, c[_], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y, s.z + u[_]));
      const S = this._cubeSize;
      (yl(r, x * S, _ > 2 ? S : 0, S, S),
        h.setRenderTarget(r),
        v && h.render(m, l),
        h.render(e, l));
    }
    ((h.toneMapping = f), (h.autoClear = d), (e.background = y));
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === ys || e.mapping === ta;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = UM()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = LM());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      a = this._lodMeshes[0];
    a.material = s;
    const o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    (yl(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, su));
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    const r = this._lodMeshes.length;
    for (let s = 1; s < r; s++) this._applyGGXFilter(e, s - 1, s);
    t.autoClear = i;
  }
  _applyGGXFilter(e, t, i) {
    const r = this._renderer,
      s = this._pingPongRenderTarget;
    if (this._ggxMaterial === null) {
      const y = 3 * Math.max(this._cubeSize, 16),
        _ = 4 * this._cubeSize;
      this._ggxMaterial = LQ(this._lodMax, y, _);
    }
    const a = this._ggxMaterial,
      o = this._lodMeshes[i];
    o.material = a;
    const l = a.uniforms,
      c = i / (this._lodMeshes.length - 1),
      u = t / (this._lodMeshes.length - 1),
      h = Math.sqrt(c * c - u * u),
      d = 0.05 + c * 0.95,
      f = h * d,
      { _lodMax: p } = this,
      m = this._sizeLods[i],
      g = 3 * m * (i > p - Hs ? i - p + Hs : 0),
      v = 4 * (this._cubeSize - m);
    ((l.envMap.value = e.texture),
      (l.roughness.value = f),
      (l.mipInt.value = p - t),
      yl(s, g, v, 3 * m, 2 * m),
      r.setRenderTarget(s),
      r.render(o, su),
      (l.envMap.value = s.texture),
      (l.roughness.value = 0),
      (l.mipInt.value = p - i),
      yl(e, g, v, 3 * m, 2 * m),
      r.setRenderTarget(e),
      r.render(o, su));
  }
  _blur(e, t, i, r, s) {
    const a = this._pingPongRenderTarget;
    (this._halfBlur(e, a, t, i, r, 'latitudinal', s),
      this._halfBlur(a, e, i, i, r, 'longitudinal', s));
  }
  _halfBlur(e, t, i, r, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== 'latitudinal' &&
      a !== 'longitudinal' &&
      gt('blur direction must be either latitudinal or longitudinal!');
    const u = 3,
      h = this._lodMeshes[r];
    h.material = c;
    const d = c.uniforms,
      f = this._sizeLods[i] - 1,
      p = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * so - 1),
      m = s / p,
      g = isFinite(s) ? 1 + Math.floor(u * m) : so;
    g > so &&
      Ge(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${so}`
      );
    const v = [];
    let y = 0;
    for (let A = 0; A < so; ++A) {
      const E = A / m,
        w = Math.exp((-E * E) / 2);
      (v.push(w), A === 0 ? (y += w) : A < g && (y += 2 * w));
    }
    for (let A = 0; A < v.length; A++) v[A] = v[A] / y;
    ((d.envMap.value = e.texture),
      (d.samples.value = g),
      (d.weights.value = v),
      (d.latitudinal.value = a === 'latitudinal'),
      o && (d.poleAxis.value = o));
    const { _lodMax: _ } = this;
    ((d.dTheta.value = p), (d.mipInt.value = _ - i));
    const x = this._sizeLods[r],
      S = 3 * x * (r > _ - Hs ? r - _ + Hs : 0),
      b = 4 * (this._cubeSize - x);
    (yl(t, S, b, 3 * x, 2 * x), l.setRenderTarget(t), l.render(h, su));
  }
}
function OQ(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - Hs + 1 + PM.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, r);
    e.push(o);
    let l = 1 / o;
    (a > n - Hs ? (l = PM[a - n + Hs - 1]) : a === 0 && (l = 0), t.push(l));
    const c = 1 / (o - 2),
      u = -c,
      h = 1 + c,
      d = [u, u, h, u, h, h, u, u, h, h, u, h],
      f = 6,
      p = 6,
      m = 3,
      g = 2,
      v = 1,
      y = new Float32Array(m * p * f),
      _ = new Float32Array(g * p * f),
      x = new Float32Array(v * p * f);
    for (let b = 0; b < f; b++) {
      const A = ((b % 3) * 2) / 3 - 1,
        E = b > 2 ? 0 : -1,
        w = [
          A,
          E,
          0,
          A + 2 / 3,
          E,
          0,
          A + 2 / 3,
          E + 1,
          0,
          A,
          E,
          0,
          A + 2 / 3,
          E + 1,
          0,
          A,
          E + 1,
          0,
        ];
      (y.set(w, m * p * b), _.set(d, g * p * b));
      const M = [b, b, b, b, b, b];
      x.set(M, v * p * b);
    }
    const S = new _t();
    (S.setAttribute('position', new qt(y, m)),
      S.setAttribute('uv', new qt(_, g)),
      S.setAttribute('faceIndex', new qt(x, v)),
      i.push(new hn(S, null)),
      r > Hs && r--);
  }
  return { lodMeshes: i, sizeLods: e, sigmas: t };
}
function OM(n, e, t) {
  const i = new Sn(n, e, t);
  return (
    (i.texture.mapping = Mc),
    (i.texture.name = 'PMREM.cubeUv'),
    (i.scissorTest = !0),
    i
  );
}
function yl(n, e, t, i, r) {
  (n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r));
}
function LQ(n, e, t) {
  return new rn({
    name: 'PMREMGGXConvolution',
    defines: {
      GGX_SAMPLES: PQ,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      roughness: { value: 0 },
      mipInt: { value: 0 },
    },
    vertexShader: $m(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,
    blending: Ln,
    depthTest: !1,
    depthWrite: !1,
  });
}
function UQ(n, e, t) {
  const i = new Float32Array(so),
    r = new V(0, 1, 0);
  return new rn({
    name: 'SphericalGaussianBlur',
    defines: {
      n: so,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: $m(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Ln,
    depthTest: !1,
    depthWrite: !1,
  });
}
function LM() {
  return new rn({
    name: 'EquirectangularToCubeUV',
    uniforms: { envMap: { value: null } },
    vertexShader: $m(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Ln,
    depthTest: !1,
    depthWrite: !1,
  });
}
function UM() {
  return new rn({
    name: 'CubemapToCubeUV',
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: $m(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Ln,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $m() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function kQ(n) {
  let e = new WeakMap(),
    t = null;
  function i(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === rh || l === sh,
        u = l === ys || l === ta;
      if (c || u) {
        let h = e.get(o);
        const d = h !== void 0 ? h.texture.pmremVersion : 0;
        if (o.isRenderTargetTexture && o.pmremVersion !== d)
          return (
            t === null && (t = new ry(n)),
            (h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h)),
            (h.texture.pmremVersion = o.pmremVersion),
            e.set(o, h),
            h.texture
          );
        if (h !== void 0) return h.texture;
        {
          const f = o.image;
          return (c && f && f.height > 0) || (u && f && r(f))
            ? (t === null && (t = new ry(n)),
              (h = c ? t.fromEquirectangular(o) : t.fromCubemap(o)),
              (h.texture.pmremVersion = o.pmremVersion),
              e.set(o, h),
              o.addEventListener('dispose', s),
              h.texture)
            : null;
        }
      }
    }
    return o;
  }
  function r(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener('dispose', s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    ((e = new WeakMap()), t !== null && (t.dispose(), (t = null)));
  }
  return { get: i, dispose: a };
}
function BQ(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    const r = n.getExtension(i);
    return ((e[i] = r), r);
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function () {
      (t('EXT_color_buffer_float'),
        t('WEBGL_clip_cull_distance'),
        t('OES_texture_float_linear'),
        t('EXT_color_buffer_half_float'),
        t('WEBGL_multisampled_render_to_texture'),
        t('WEBGL_render_shared_exponent'));
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null && rc('WebGLRenderer: ' + i + ' extension not supported.'),
        r
      );
    },
  };
}
function NQ(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function a(h) {
    const d = h.target;
    d.index !== null && e.remove(d.index);
    for (const p in d.attributes) e.remove(d.attributes[p]);
    (d.removeEventListener('dispose', a), delete r[d.id]);
    const f = s.get(d);
    (f && (e.remove(f), s.delete(d)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--);
  }
  function o(h, d) {
    return (
      r[d.id] === !0 ||
        (d.addEventListener('dispose', a),
        (r[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function l(h) {
    const d = h.attributes;
    for (const f in d) e.update(d[f], n.ARRAY_BUFFER);
  }
  function c(h) {
    const d = [],
      f = h.index,
      p = h.attributes.position;
    let m = 0;
    if (f !== null) {
      const y = f.array;
      m = f.version;
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const S = y[_ + 0],
          b = y[_ + 1],
          A = y[_ + 2];
        d.push(S, b, b, A, A, S);
      }
    } else if (p !== void 0) {
      const y = p.array;
      m = p.version;
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const S = _ + 0,
          b = _ + 1,
          A = _ + 2;
        d.push(S, b, b, A, A, S);
      }
    } else return;
    const g = new (w2(d) ? $x : Zx)(d, 1);
    g.version = m;
    const v = s.get(h);
    (v && e.remove(v), s.set(h, g));
  }
  function u(h) {
    const d = s.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && c(h);
    } else c(h);
    return s.get(h);
  }
  return { get: o, update: l, getWireframeAttribute: u };
}
function FQ(n, e, t) {
  let i;
  function r(d) {
    i = d;
  }
  let s, a;
  function o(d) {
    ((s = d.type), (a = d.bytesPerElement));
  }
  function l(d, f) {
    (n.drawElements(i, f, s, d * a), t.update(f, i, 1));
  }
  function c(d, f, p) {
    p !== 0 && (n.drawElementsInstanced(i, f, s, d * a, p), t.update(f, i, p));
  }
  function u(d, f, p) {
    if (p === 0) return;
    e.get('WEBGL_multi_draw').multiDrawElementsWEBGL(i, f, 0, s, d, 0, p);
    let g = 0;
    for (let v = 0; v < p; v++) g += f[v];
    t.update(g, i, 1);
  }
  function h(d, f, p, m) {
    if (p === 0) return;
    const g = e.get('WEBGL_multi_draw');
    if (g === null) for (let v = 0; v < d.length; v++) c(d[v] / a, f[v], m[v]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, f, 0, s, d, 0, m, 0, p);
      let v = 0;
      for (let y = 0; y < p; y++) v += f[y] * m[y];
      t.update(v, i, 1);
    }
  }
  ((this.setMode = r),
    (this.setIndex = o),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = h));
}
function zQ(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, a, o) {
    switch ((t.calls++, a)) {
      case n.TRIANGLES:
        t.triangles += o * (s / 3);
        break;
      case n.LINES:
        t.lines += o * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += o * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += o * s;
        break;
      case n.POINTS:
        t.points += o * s;
        break;
      default:
        gt('WebGLInfo: Unknown draw mode:', a);
        break;
    }
  }
  function r() {
    ((t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0));
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function VQ(n, e, t) {
  const i = new WeakMap(),
    r = new Lt();
  function s(a, o, l) {
    const c = a.morphTargetInfluences,
      u =
        o.morphAttributes.position ||
        o.morphAttributes.normal ||
        o.morphAttributes.color,
      h = u !== void 0 ? u.length : 0;
    let d = i.get(o);
    if (d === void 0 || d.count !== h) {
      let w = function () {
        (A.dispose(), i.delete(o), o.removeEventListener('dispose', w));
      };
      d !== void 0 && d.texture.dispose();
      const f = o.morphAttributes.position !== void 0,
        p = o.morphAttributes.normal !== void 0,
        m = o.morphAttributes.color !== void 0,
        g = o.morphAttributes.position || [],
        v = o.morphAttributes.normal || [],
        y = o.morphAttributes.color || [];
      let _ = 0;
      (f === !0 && (_ = 1), p === !0 && (_ = 2), m === !0 && (_ = 3));
      let x = o.attributes.position.count * _,
        S = 1;
      x > e.maxTextureSize &&
        ((S = Math.ceil(x / e.maxTextureSize)), (x = e.maxTextureSize));
      const b = new Float32Array(x * S * 4 * h),
        A = new Im(b, x, S, h);
      ((A.type = un), (A.needsUpdate = !0));
      const E = _ * 4;
      for (let M = 0; M < h; M++) {
        const T = g[M],
          D = v[M],
          L = y[M],
          O = x * S * 4 * M;
        for (let z = 0; z < T.count; z++) {
          const C = z * E;
          (f === !0 &&
            (r.fromBufferAttribute(T, z),
            (b[O + C + 0] = r.x),
            (b[O + C + 1] = r.y),
            (b[O + C + 2] = r.z),
            (b[O + C + 3] = 0)),
            p === !0 &&
              (r.fromBufferAttribute(D, z),
              (b[O + C + 4] = r.x),
              (b[O + C + 5] = r.y),
              (b[O + C + 6] = r.z),
              (b[O + C + 7] = 0)),
            m === !0 &&
              (r.fromBufferAttribute(L, z),
              (b[O + C + 8] = r.x),
              (b[O + C + 9] = r.y),
              (b[O + C + 10] = r.z),
              (b[O + C + 11] = L.itemSize === 4 ? r.w : 1)));
        }
      }
      ((d = { count: h, texture: A, size: new pe(x, S) }),
        i.set(o, d),
        o.addEventListener('dispose', w));
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      l.getUniforms().setValue(n, 'morphTexture', a.morphTexture, t);
    else {
      let f = 0;
      for (let m = 0; m < c.length; m++) f += c[m];
      const p = o.morphTargetsRelative ? 1 : 1 - f;
      (l.getUniforms().setValue(n, 'morphTargetBaseInfluence', p),
        l.getUniforms().setValue(n, 'morphTargetInfluences', c));
    }
    (l.getUniforms().setValue(n, 'morphTargetsTexture', d.texture, t),
      l.getUniforms().setValue(n, 'morphTargetsTextureSize', d.size));
  }
  return { update: s };
}
function HQ(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      h = e.get(l, u);
    if (
      (r.get(h) !== c && (e.update(h), r.set(h, c)),
      l.isInstancedMesh &&
        (l.hasEventListener('dispose', o) === !1 &&
          l.addEventListener('dispose', o),
        r.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const d = l.skeleton;
      r.get(d) !== c && (d.update(), r.set(d, c));
    }
    return h;
  }
  function a() {
    r = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    (c.removeEventListener('dispose', o),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor));
  }
  return { update: s, dispose: a };
}
const R3 = new Vt(),
  kM = new Fm(1, 1),
  I3 = new Im(),
  P3 = new Pm(),
  D3 = new Vh(),
  BM = [],
  NM = [],
  FM = new Float32Array(16),
  zM = new Float32Array(9),
  VM = new Float32Array(4);
function Rc(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = BM[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (BM[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) ((o += t), n[a].toArray(s, o));
  }
  return s;
}
function kn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Bn(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function eg(n, e) {
  let t = NM[e];
  t === void 0 && ((t = new Int32Array(e)), (NM[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function GQ(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function WQ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    (n.uniform2fv(this.addr, e), Bn(t, e));
  }
}
function jQ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (kn(t, e)) return;
    (n.uniform3fv(this.addr, e), Bn(t, e));
  }
}
function XQ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    (n.uniform4fv(this.addr, e), Bn(t, e));
  }
}
function qQ(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    (n.uniformMatrix2fv(this.addr, !1, e), Bn(t, e));
  } else {
    if (kn(t, i)) return;
    (VM.set(i), n.uniformMatrix2fv(this.addr, !1, VM), Bn(t, i));
  }
}
function YQ(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    (n.uniformMatrix3fv(this.addr, !1, e), Bn(t, e));
  } else {
    if (kn(t, i)) return;
    (zM.set(i), n.uniformMatrix3fv(this.addr, !1, zM), Bn(t, i));
  }
}
function KQ(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (kn(t, e)) return;
    (n.uniformMatrix4fv(this.addr, !1, e), Bn(t, e));
  } else {
    if (kn(t, i)) return;
    (FM.set(i), n.uniformMatrix4fv(this.addr, !1, FM), Bn(t, i));
  }
}
function JQ(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function QQ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    (n.uniform2iv(this.addr, e), Bn(t, e));
  }
}
function ZQ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (kn(t, e)) return;
    (n.uniform3iv(this.addr, e), Bn(t, e));
  }
}
function $Q(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    (n.uniform4iv(this.addr, e), Bn(t, e));
  }
}
function eZ(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function tZ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (kn(t, e)) return;
    (n.uniform2uiv(this.addr, e), Bn(t, e));
  }
}
function nZ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (kn(t, e)) return;
    (n.uniform3uiv(this.addr, e), Bn(t, e));
  }
}
function iZ(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (kn(t, e)) return;
    (n.uniform4uiv(this.addr, e), Bn(t, e));
  }
}
function rZ(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
  let s;
  (this.type === n.SAMPLER_2D_SHADOW
    ? ((kM.compareFunction = Kx), (s = kM))
    : (s = R3),
    t.setTexture2D(e || s, r));
}
function sZ(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || P3, r));
}
function aZ(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || D3, r));
}
function oZ(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || I3, r));
}
function lZ(n) {
  switch (n) {
    case 5126:
      return GQ;
    case 35664:
      return WQ;
    case 35665:
      return jQ;
    case 35666:
      return XQ;
    case 35674:
      return qQ;
    case 35675:
      return YQ;
    case 35676:
      return KQ;
    case 5124:
    case 35670:
      return JQ;
    case 35667:
    case 35671:
      return QQ;
    case 35668:
    case 35672:
      return ZQ;
    case 35669:
    case 35673:
      return $Q;
    case 5125:
      return eZ;
    case 36294:
      return tZ;
    case 36295:
      return nZ;
    case 36296:
      return iZ;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return rZ;
    case 35679:
    case 36299:
    case 36307:
      return sZ;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return aZ;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return oZ;
  }
}
function cZ(n, e) {
  n.uniform1fv(this.addr, e);
}
function uZ(n, e) {
  const t = Rc(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function hZ(n, e) {
  const t = Rc(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function dZ(n, e) {
  const t = Rc(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function fZ(n, e) {
  const t = Rc(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function pZ(n, e) {
  const t = Rc(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function mZ(n, e) {
  const t = Rc(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function gZ(n, e) {
  n.uniform1iv(this.addr, e);
}
function vZ(n, e) {
  n.uniform2iv(this.addr, e);
}
function _Z(n, e) {
  n.uniform3iv(this.addr, e);
}
function yZ(n, e) {
  n.uniform4iv(this.addr, e);
}
function xZ(n, e) {
  n.uniform1uiv(this.addr, e);
}
function bZ(n, e) {
  n.uniform2uiv(this.addr, e);
}
function SZ(n, e) {
  n.uniform3uiv(this.addr, e);
}
function wZ(n, e) {
  n.uniform4uiv(this.addr, e);
}
function EZ(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = eg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
  for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || R3, s[a]);
}
function AZ(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = eg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
  for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || P3, s[a]);
}
function MZ(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = eg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
  for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || D3, s[a]);
}
function TZ(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = eg(t, r);
  kn(i, s) || (n.uniform1iv(this.addr, s), Bn(i, s));
  for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || I3, s[a]);
}
function CZ(n) {
  switch (n) {
    case 5126:
      return cZ;
    case 35664:
      return uZ;
    case 35665:
      return hZ;
    case 35666:
      return dZ;
    case 35674:
      return fZ;
    case 35675:
      return pZ;
    case 35676:
      return mZ;
    case 5124:
    case 35670:
      return gZ;
    case 35667:
    case 35671:
      return vZ;
    case 35668:
    case 35672:
      return _Z;
    case 35669:
    case 35673:
      return yZ;
    case 5125:
      return xZ;
    case 36294:
      return bZ;
    case 36295:
      return SZ;
    case 36296:
      return wZ;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return EZ;
    case 35679:
    case 36299:
    case 36307:
      return AZ;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return MZ;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return TZ;
  }
}
class RZ {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = lZ(t.type)));
  }
}
class IZ {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = CZ(t.type)));
  }
}
class PZ {
  constructor(e) {
    ((this.id = e), (this.seq = []), (this.map = {}));
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, t[o.id], i);
    }
  }
}
const uv = /(\w+)(\])?(\[|\.)?/g;
function HM(n, e) {
  (n.seq.push(e), (n.map[e.id] = e));
}
function DZ(n, e, t) {
  const i = n.name,
    r = i.length;
  for (uv.lastIndex = 0; ; ) {
    const s = uv.exec(i),
      a = uv.lastIndex;
    let o = s[1];
    const l = s[2] === ']',
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === '[' && a + 2 === r))) {
      HM(t, c === void 0 ? new RZ(o, n, e) : new IZ(o, n, e));
      break;
    } else {
      let h = t.map[o];
      (h === void 0 && ((h = new PZ(o)), HM(t, h)), (t = h));
    }
  }
}
class Nf {
  constructor(e, t) {
    ((this.seq = []), (this.map = {}));
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        a = e.getUniformLocation(t, s.name);
      DZ(s, a, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s],
        l = i[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in t && i.push(a);
    }
    return i;
  }
}
function GM(n, e, t) {
  const i = n.createShader(e);
  return (n.shaderSource(i, t), n.compileShader(i), i);
}
const OZ = 37297;
let LZ = 0;
function UZ(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = r; a < s; a++) {
    const o = a + 1;
    i.push(`${o === e ? '>' : ' '} ${o}: ${t[a]}`);
  }
  return i.join(`
`);
}
const WM = new xt();
function kZ(n) {
  kt._getMatrix(WM, kt.workingColorSpace, n);
  const e = `mat3( ${WM.elements.map((t) => t.toFixed(4))} )`;
  switch (kt.getTransfer(n)) {
    case uh:
      return [e, 'LinearTransferOETF'];
    case Yt:
      return [e, 'sRGBTransferOETF'];
    default:
      return (
        Ge('WebGLProgram: Unsupported color space: ', n),
        [e, 'LinearTransferOETF']
      );
  }
}
function jM(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    s = (n.getShaderInfoLog(e) || '').trim();
  if (i && s === '') return '';
  const a = /ERROR: 0:(\d+)/.exec(s);
  if (a) {
    const o = parseInt(a[1]);
    return (
      t.toUpperCase() +
      `

` +
      s +
      `

` +
      UZ(n.getShaderSource(e), o)
    );
  } else return s;
}
function BZ(n, e) {
  const t = kZ(e);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    '}',
  ].join(`
`);
}
function NZ(n, e) {
  let t;
  switch (e) {
    case i2:
      t = 'Linear';
      break;
    case r2:
      t = 'Reinhard';
      break;
    case s2:
      t = 'Cineon';
      break;
    case a2:
      t = 'ACESFilmic';
      break;
    case l2:
      t = 'AgX';
      break;
    case c2:
      t = 'Neutral';
      break;
    case o2:
      t = 'Custom';
      break;
    default:
      (Ge('WebGLProgram: Unsupported toneMapping:', e), (t = 'Linear'));
  }
  return (
    'vec3 ' + n + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }'
  );
}
const ff = new V();
function FZ() {
  kt.getLuminanceCoefficients(ff);
  const n = ff.x.toFixed(4),
    e = ff.y.toFixed(4),
    t = ff.z.toFixed(4);
  return [
    'float luminance( const in vec3 rgb ) {',
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    '	return dot( weights, rgb );',
    '}',
  ].join(`
`);
}
function zZ(n) {
  return [
    n.extensionClipCullDistance
      ? '#extension GL_ANGLE_clip_cull_distance : require'
      : '',
    n.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ].filter(gu).join(`
`);
}
function VZ(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push('#define ' + t + ' ' + i);
  }
  return e.join(`
`);
}
function HZ(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      a = s.name;
    let o = 1;
    (s.type === n.FLOAT_MAT2 && (o = 2),
      s.type === n.FLOAT_MAT3 && (o = 3),
      s.type === n.FLOAT_MAT4 && (o = 4),
      (t[a] = {
        type: s.type,
        location: n.getAttribLocation(e, a),
        locationSize: o,
      }));
  }
  return t;
}
function gu(n) {
  return n !== '';
}
function XM(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function qM(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const GZ = /^[ \t]*#include +<([\w\d./]+)>/gm;
function sy(n) {
  return n.replace(GZ, jZ);
}
const WZ = new Map();
function jZ(n, e) {
  let t = Et[e];
  if (t === void 0) {
    const i = WZ.get(e);
    if (i !== void 0)
      ((t = Et[i]),
        Ge(
          'WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        ));
    else throw new Error('Can not resolve #include <' + e + '>');
  }
  return sy(t);
}
const XZ =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function YM(n) {
  return n.replace(XZ, qZ);
}
function qZ(n, e, t, i) {
  let r = '';
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, '[ ' + s + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function KM(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === 'highp'
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === 'mediump'
        ? (e += `
#define MEDIUM_PRECISION`)
        : n.precision === 'lowp' &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function YZ(n) {
  let e = 'SHADOWMAP_TYPE_BASIC';
  return (
    n.shadowMapType === Hx
      ? (e = 'SHADOWMAP_TYPE_PCF')
      : n.shadowMapType === kD
        ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
        : n.shadowMapType === Dr && (e = 'SHADOWMAP_TYPE_VSM'),
    e
  );
}
function KZ(n) {
  let e = 'ENVMAP_TYPE_CUBE';
  if (n.envMap)
    switch (n.envMapMode) {
      case ys:
      case ta:
        e = 'ENVMAP_TYPE_CUBE';
        break;
      case Mc:
        e = 'ENVMAP_TYPE_CUBE_UV';
        break;
    }
  return e;
}
function JZ(n) {
  let e = 'ENVMAP_MODE_REFLECTION';
  if (n.envMap)
    switch (n.envMapMode) {
      case ta:
        e = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  return e;
}
function QZ(n) {
  let e = 'ENVMAP_BLENDING_NONE';
  if (n.envMap)
    switch (n.combine) {
      case kh:
        e = 'ENVMAP_BLENDING_MULTIPLY';
        break;
      case t2:
        e = 'ENVMAP_BLENDING_MIX';
        break;
      case n2:
        e = 'ENVMAP_BLENDING_ADD';
        break;
    }
  return e;
}
function ZZ(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
    texelHeight: i,
    maxMip: t,
  };
}
function $Z(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const l = YZ(t),
    c = KZ(t),
    u = JZ(t),
    h = QZ(t),
    d = ZZ(t),
    f = zZ(t),
    p = VZ(s),
    m = r.createProgram();
  let g,
    v,
    y = t.glslVersion
      ? '#version ' +
        t.glslVersion +
        `
`
      : '';
  (t.isRawShaderMaterial
    ? ((g = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
      ].filter(gu).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (v = [
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
      ].filter(gu).join(`
`)),
      v.length > 0 &&
        (v += `
`))
    : ((g = [
        KM(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
        t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        t.batching ? '#define USE_BATCHING' : '',
        t.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        t.instancing ? '#define USE_INSTANCING' : '',
        t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.map ? '#define USE_MAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + u : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
        t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
        t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
        t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
        t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
        t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
        t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
        t.displacementMapUv
          ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv
          : '',
        t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
        t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
        t.anisotropyMapUv
          ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv
          : '',
        t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
        t.clearcoatNormalMapUv
          ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv
          : '',
        t.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv
          : '',
        t.iridescenceMapUv
          ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv
          : '',
        t.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv
          : '',
        t.sheenColorMapUv
          ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv
          : '',
        t.sheenRoughnessMapUv
          ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv
          : '',
        t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
        t.specularColorMapUv
          ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv
          : '',
        t.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv
          : '',
        t.transmissionMapUv
          ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv
          : '',
        t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors ? '#define USE_COLOR' : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.skinning ? '#define USE_SKINNING' : '',
        t.morphTargets ? '#define USE_MORPHTARGETS' : '',
        t.morphNormals && t.flatShading === !1
          ? '#define USE_MORPHNORMALS'
          : '',
        t.morphColors ? '#define USE_MORPHCOLORS' : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride
          : '',
        t.morphTargetsCount > 0
          ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount
          : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + l : '',
        t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
        t.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`,
      ].filter(gu).join(`
`)),
      (v = [
        KM(t),
        '#define SHADER_TYPE ' + t.shaderType,
        '#define SHADER_NAME ' + t.shaderName,
        p,
        t.useFog && t.fog ? '#define USE_FOG' : '',
        t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
        t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        t.map ? '#define USE_MAP' : '',
        t.matcap ? '#define USE_MATCAP' : '',
        t.envMap ? '#define USE_ENVMAP' : '',
        t.envMap ? '#define ' + c : '',
        t.envMap ? '#define ' + u : '',
        t.envMap ? '#define ' + h : '',
        d ? '#define CUBEUV_TEXEL_WIDTH ' + d.texelWidth : '',
        d ? '#define CUBEUV_TEXEL_HEIGHT ' + d.texelHeight : '',
        d ? '#define CUBEUV_MAX_MIP ' + d.maxMip + '.0' : '',
        t.lightMap ? '#define USE_LIGHTMAP' : '',
        t.aoMap ? '#define USE_AOMAP' : '',
        t.bumpMap ? '#define USE_BUMPMAP' : '',
        t.normalMap ? '#define USE_NORMALMAP' : '',
        t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        t.anisotropy ? '#define USE_ANISOTROPY' : '',
        t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        t.clearcoat ? '#define USE_CLEARCOAT' : '',
        t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        t.dispersion ? '#define USE_DISPERSION' : '',
        t.iridescence ? '#define USE_IRIDESCENCE' : '',
        t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        t.specularMap ? '#define USE_SPECULARMAP' : '',
        t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        t.metalnessMap ? '#define USE_METALNESSMAP' : '',
        t.alphaMap ? '#define USE_ALPHAMAP' : '',
        t.alphaTest ? '#define USE_ALPHATEST' : '',
        t.alphaHash ? '#define USE_ALPHAHASH' : '',
        t.sheen ? '#define USE_SHEEN' : '',
        t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        t.transmission ? '#define USE_TRANSMISSION' : '',
        t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
        t.vertexColors || t.instancingColor || t.batchingColor
          ? '#define USE_COLOR'
          : '',
        t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        t.vertexUv1s ? '#define USE_UV1' : '',
        t.vertexUv2s ? '#define USE_UV2' : '',
        t.vertexUv3s ? '#define USE_UV3' : '',
        t.pointsUvs ? '#define USE_POINTS_UV' : '',
        t.gradientMap ? '#define USE_GRADIENTMAP' : '',
        t.flatShading ? '#define FLAT_SHADED' : '',
        t.doubleSided ? '#define DOUBLE_SIDED' : '',
        t.flipSided ? '#define FLIP_SIDED' : '',
        t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        t.shadowMapEnabled ? '#define ' + l : '',
        t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        t.decodeVideoTextureEmissive
          ? '#define DECODE_VIDEO_TEXTURE_EMISSIVE'
          : '',
        t.logarithmicDepthBuffer ? '#define USE_LOGARITHMIC_DEPTH_BUFFER' : '',
        t.reversedDepthBuffer ? '#define USE_REVERSED_DEPTH_BUFFER' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        t.toneMapping !== ds ? '#define TONE_MAPPING' : '',
        t.toneMapping !== ds ? Et.tonemapping_pars_fragment : '',
        t.toneMapping !== ds ? NZ('toneMapping', t.toneMapping) : '',
        t.dithering ? '#define DITHERING' : '',
        t.opaque ? '#define OPAQUE' : '',
        Et.colorspace_pars_fragment,
        BZ('linearToOutputTexel', t.outputColorSpace),
        FZ(),
        t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
        `
`,
      ].filter(gu).join(`
`))),
    (a = sy(a)),
    (a = XM(a, t)),
    (a = qM(a, t)),
    (o = sy(o)),
    (o = XM(o, t)),
    (o = qM(o, t)),
    (a = YM(a)),
    (o = YM(o)),
    t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (g =
        [
          f,
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture',
        ].join(`
`) +
        `
` +
        g),
      (v =
        [
          '#define varying in',
          t.glslVersion === J_
            ? ''
            : 'layout(location = 0) out highp vec4 pc_fragColor;',
          t.glslVersion === J_ ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join(`
`) +
        `
` +
        v)));
  const _ = y + g + a,
    x = y + v + o,
    S = GM(r, r.VERTEX_SHADER, _),
    b = GM(r, r.FRAGMENT_SHADER, x);
  (r.attachShader(m, S),
    r.attachShader(m, b),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(m, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(m, 0, 'position'),
    r.linkProgram(m));
  function A(T) {
    if (n.debug.checkShaderErrors) {
      const D = r.getProgramInfoLog(m) || '',
        L = r.getShaderInfoLog(S) || '',
        O = r.getShaderInfoLog(b) || '',
        z = D.trim(),
        C = L.trim(),
        N = O.trim();
      let U = !0,
        W = !0;
      if (r.getProgramParameter(m, r.LINK_STATUS) === !1)
        if (((U = !1), typeof n.debug.onShaderError == 'function'))
          n.debug.onShaderError(r, m, S, b);
        else {
          const G = jM(r, S, 'vertex'),
            ne = jM(r, b, 'fragment');
          gt(
            'THREE.WebGLProgram: Shader Error ' +
              r.getError() +
              ' - VALIDATE_STATUS ' +
              r.getProgramParameter(m, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              T.name +
              `
Material Type: ` +
              T.type +
              `

Program Info Log: ` +
              z +
              `
` +
              G +
              `
` +
              ne
          );
        }
      else
        z !== ''
          ? Ge('WebGLProgram: Program Info Log:', z)
          : (C === '' || N === '') && (W = !1);
      W &&
        (T.diagnostics = {
          runnable: U,
          programLog: z,
          vertexShader: { log: C, prefix: g },
          fragmentShader: { log: N, prefix: v },
        });
    }
    (r.deleteShader(S), r.deleteShader(b), (E = new Nf(r, m)), (w = HZ(r, m)));
  }
  let E;
  this.getUniforms = function () {
    return (E === void 0 && A(this), E);
  };
  let w;
  this.getAttributes = function () {
    return (w === void 0 && A(this), w);
  };
  let M = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (M === !1 && (M = r.getProgramParameter(m, OZ)), M);
    }),
    (this.destroy = function () {
      (i.releaseStatesOfProgram(this),
        r.deleteProgram(m),
        (this.program = void 0));
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = LZ++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = S),
    (this.fragmentShader = b),
    this
  );
}
let e$ = 0;
class t$ {
  constructor() {
    ((this.shaderCache = new Map()), (this.materialCache = new Map()));
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(r) === !1 && (a.add(r), r.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      (i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code));
    return (this.materialCache.delete(e), this);
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    (this.shaderCache.clear(), this.materialCache.clear());
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new Set()), t.set(e, i)), i);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new n$(e)), t.set(e, i)), i);
  }
}
class n$ {
  constructor(e) {
    ((this.id = e$++), (this.code = e), (this.usedTimes = 0));
  }
}
function i$(n, e, t, i, r, s, a) {
  const o = new Dm(),
    l = new t$(),
    c = new Set(),
    u = [],
    h = r.logarithmicDepthBuffer,
    d = r.vertexTextures;
  let f = r.precision;
  const p = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  };
  function m(w) {
    return (c.add(w), w === 0 ? 'uv' : `uv${w}`);
  }
  function g(w, M, T, D, L) {
    const O = D.fog,
      z = L.geometry,
      C = w.isMeshStandardMaterial ? D.environment : null,
      N = (w.isMeshStandardMaterial ? t : e).get(w.envMap || C),
      U = N && N.mapping === Mc ? N.image.height : null,
      W = p[w.type];
    w.precision !== null &&
      ((f = r.getMaxPrecision(w.precision)),
      f !== w.precision &&
        Ge(
          'WebGLProgram.getParameters:',
          w.precision,
          'not supported, using',
          f,
          'instead.'
        ));
    const G =
        z.morphAttributes.position ||
        z.morphAttributes.normal ||
        z.morphAttributes.color,
      ne = G !== void 0 ? G.length : 0;
    let ve = 0;
    (z.morphAttributes.position !== void 0 && (ve = 1),
      z.morphAttributes.normal !== void 0 && (ve = 2),
      z.morphAttributes.color !== void 0 && (ve = 3));
    let Se, Ae, Oe, Z;
    if (W) {
      const jt = br[W];
      ((Se = jt.vertexShader), (Ae = jt.fragmentShader));
    } else
      ((Se = w.vertexShader),
        (Ae = w.fragmentShader),
        l.update(w),
        (Oe = l.getVertexShaderID(w)),
        (Z = l.getFragmentShaderID(w)));
    const J = n.getRenderTarget(),
      de = n.state.buffers.depth.getReversed(),
      fe = L.isInstancedMesh === !0,
      K = L.isBatchedMesh === !0,
      oe = !!w.map,
      he = !!w.matcap,
      xe = !!N,
      ee = !!w.aoMap,
      B = !!w.lightMap,
      me = !!w.bumpMap,
      ye = !!w.normalMap,
      Te = !!w.displacementMap,
      Ee = !!w.emissiveMap,
      Xe = !!w.metalnessMap,
      Ne = !!w.roughnessMap,
      We = w.anisotropy > 0,
      F = w.clearcoat > 0,
      P = w.dispersion > 0,
      Q = w.iridescence > 0,
      le = w.sheen > 0,
      ge = w.transmission > 0,
      se = We && !!w.anisotropyMap,
      Ke = F && !!w.clearcoatMap,
      Be = F && !!w.clearcoatNormalMap,
      at = F && !!w.clearcoatRoughnessMap,
      Je = Q && !!w.iridescenceMap,
      we = Q && !!w.iridescenceThicknessMap,
      Ce = le && !!w.sheenColorMap,
      ct = le && !!w.sheenRoughnessMap,
      it = !!w.specularMap,
      Le = !!w.specularColorMap,
      et = !!w.specularIntensityMap,
      Y = ge && !!w.transmissionMap,
      re = ge && !!w.thicknessMap,
      ke = !!w.gradientMap,
      ze = !!w.alphaMap,
      Ie = w.alphaTest > 0,
      be = !!w.alphaHash,
      tt = !!w.extensions;
    let vt = ds;
    w.toneMapped &&
      (J === null || J.isXRRenderTarget === !0) &&
      (vt = n.toneMapping);
    const Qt = {
      shaderID: W,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: Se,
      fragmentShader: Ae,
      defines: w.defines,
      customVertexShaderID: Oe,
      customFragmentShaderID: Z,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: f,
      batching: K,
      batchingColor: K && L._colorsTexture !== null,
      instancing: fe,
      instancingColor: fe && L.instanceColor !== null,
      instancingMorph: fe && L.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace:
        J === null
          ? n.outputColorSpace
          : J.isXRRenderTarget === !0
            ? J.texture.colorSpace
            : cr,
      alphaToCoverage: !!w.alphaToCoverage,
      map: oe,
      matcap: he,
      envMap: xe,
      envMapMode: xe && N.mapping,
      envMapCubeUVHeight: U,
      aoMap: ee,
      lightMap: B,
      bumpMap: me,
      normalMap: ye,
      displacementMap: d && Te,
      emissiveMap: Ee,
      normalMapObjectSpace: ye && w.normalMapType === m2,
      normalMapTangentSpace: ye && w.normalMapType === ua,
      metalnessMap: Xe,
      roughnessMap: Ne,
      anisotropy: We,
      anisotropyMap: se,
      clearcoat: F,
      clearcoatMap: Ke,
      clearcoatNormalMap: Be,
      clearcoatRoughnessMap: at,
      dispersion: P,
      iridescence: Q,
      iridescenceMap: Je,
      iridescenceThicknessMap: we,
      sheen: le,
      sheenColorMap: Ce,
      sheenRoughnessMap: ct,
      specularMap: it,
      specularColorMap: Le,
      specularIntensityMap: et,
      transmission: ge,
      transmissionMap: Y,
      thicknessMap: re,
      gradientMap: ke,
      opaque:
        w.transparent === !1 && w.blending === Eo && w.alphaToCoverage === !1,
      alphaMap: ze,
      alphaTest: Ie,
      alphaHash: be,
      combine: w.combine,
      mapUv: oe && m(w.map.channel),
      aoMapUv: ee && m(w.aoMap.channel),
      lightMapUv: B && m(w.lightMap.channel),
      bumpMapUv: me && m(w.bumpMap.channel),
      normalMapUv: ye && m(w.normalMap.channel),
      displacementMapUv: Te && m(w.displacementMap.channel),
      emissiveMapUv: Ee && m(w.emissiveMap.channel),
      metalnessMapUv: Xe && m(w.metalnessMap.channel),
      roughnessMapUv: Ne && m(w.roughnessMap.channel),
      anisotropyMapUv: se && m(w.anisotropyMap.channel),
      clearcoatMapUv: Ke && m(w.clearcoatMap.channel),
      clearcoatNormalMapUv: Be && m(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: at && m(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Je && m(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: we && m(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ce && m(w.sheenColorMap.channel),
      sheenRoughnessMapUv: ct && m(w.sheenRoughnessMap.channel),
      specularMapUv: it && m(w.specularMap.channel),
      specularColorMapUv: Le && m(w.specularColorMap.channel),
      specularIntensityMapUv: et && m(w.specularIntensityMap.channel),
      transmissionMapUv: Y && m(w.transmissionMap.channel),
      thicknessMapUv: re && m(w.thicknessMap.channel),
      alphaMapUv: ze && m(w.alphaMap.channel),
      vertexTangents: !!z.attributes.tangent && (ye || We),
      vertexColors: w.vertexColors,
      vertexAlphas:
        w.vertexColors === !0 &&
        !!z.attributes.color &&
        z.attributes.color.itemSize === 4,
      pointsUvs: L.isPoints === !0 && !!z.attributes.uv && (oe || ze),
      fog: !!O,
      useFog: w.fog === !0,
      fogExp2: !!O && O.isFogExp2,
      flatShading: w.flatShading === !0 && w.wireframe === !1,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reversedDepthBuffer: de,
      skinning: L.isSkinnedMesh === !0,
      morphTargets: z.morphAttributes.position !== void 0,
      morphNormals: z.morphAttributes.normal !== void 0,
      morphColors: z.morphAttributes.color !== void 0,
      morphTargetsCount: ne,
      morphTextureStride: ve,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: n.shadowMap.enabled && T.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: vt,
      decodeVideoTexture:
        oe &&
        w.map.isVideoTexture === !0 &&
        kt.getTransfer(w.map.colorSpace) === Yt,
      decodeVideoTextureEmissive:
        Ee &&
        w.emissiveMap.isVideoTexture === !0 &&
        kt.getTransfer(w.emissiveMap.colorSpace) === Yt,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === ci,
      flipSided: w.side === On,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionClipCullDistance:
        tt &&
        w.extensions.clipCullDistance === !0 &&
        i.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((tt && w.extensions.multiDraw === !0) || K) &&
        i.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: i.has(
        'KHR_parallel_shader_compile'
      ),
      customProgramCacheKey: w.customProgramCacheKey(),
    };
    return (
      (Qt.vertexUv1s = c.has(1)),
      (Qt.vertexUv2s = c.has(2)),
      (Qt.vertexUv3s = c.has(3)),
      c.clear(),
      Qt
    );
  }
  function v(w) {
    const M = [];
    if (
      (w.shaderID
        ? M.push(w.shaderID)
        : (M.push(w.customVertexShaderID), M.push(w.customFragmentShaderID)),
      w.defines !== void 0)
    )
      for (const T in w.defines) (M.push(T), M.push(w.defines[T]));
    return (
      w.isRawShaderMaterial === !1 &&
        (y(M, w), _(M, w), M.push(n.outputColorSpace)),
      M.push(w.customProgramCacheKey),
      M.join()
    );
  }
  function y(w, M) {
    (w.push(M.precision),
      w.push(M.outputColorSpace),
      w.push(M.envMapMode),
      w.push(M.envMapCubeUVHeight),
      w.push(M.mapUv),
      w.push(M.alphaMapUv),
      w.push(M.lightMapUv),
      w.push(M.aoMapUv),
      w.push(M.bumpMapUv),
      w.push(M.normalMapUv),
      w.push(M.displacementMapUv),
      w.push(M.emissiveMapUv),
      w.push(M.metalnessMapUv),
      w.push(M.roughnessMapUv),
      w.push(M.anisotropyMapUv),
      w.push(M.clearcoatMapUv),
      w.push(M.clearcoatNormalMapUv),
      w.push(M.clearcoatRoughnessMapUv),
      w.push(M.iridescenceMapUv),
      w.push(M.iridescenceThicknessMapUv),
      w.push(M.sheenColorMapUv),
      w.push(M.sheenRoughnessMapUv),
      w.push(M.specularMapUv),
      w.push(M.specularColorMapUv),
      w.push(M.specularIntensityMapUv),
      w.push(M.transmissionMapUv),
      w.push(M.thicknessMapUv),
      w.push(M.combine),
      w.push(M.fogExp2),
      w.push(M.sizeAttenuation),
      w.push(M.morphTargetsCount),
      w.push(M.morphAttributeCount),
      w.push(M.numDirLights),
      w.push(M.numPointLights),
      w.push(M.numSpotLights),
      w.push(M.numSpotLightMaps),
      w.push(M.numHemiLights),
      w.push(M.numRectAreaLights),
      w.push(M.numDirLightShadows),
      w.push(M.numPointLightShadows),
      w.push(M.numSpotLightShadows),
      w.push(M.numSpotLightShadowsWithMaps),
      w.push(M.numLightProbes),
      w.push(M.shadowMapType),
      w.push(M.toneMapping),
      w.push(M.numClippingPlanes),
      w.push(M.numClipIntersection),
      w.push(M.depthPacking));
  }
  function _(w, M) {
    (o.disableAll(),
      M.supportsVertexTextures && o.enable(0),
      M.instancing && o.enable(1),
      M.instancingColor && o.enable(2),
      M.instancingMorph && o.enable(3),
      M.matcap && o.enable(4),
      M.envMap && o.enable(5),
      M.normalMapObjectSpace && o.enable(6),
      M.normalMapTangentSpace && o.enable(7),
      M.clearcoat && o.enable(8),
      M.iridescence && o.enable(9),
      M.alphaTest && o.enable(10),
      M.vertexColors && o.enable(11),
      M.vertexAlphas && o.enable(12),
      M.vertexUv1s && o.enable(13),
      M.vertexUv2s && o.enable(14),
      M.vertexUv3s && o.enable(15),
      M.vertexTangents && o.enable(16),
      M.anisotropy && o.enable(17),
      M.alphaHash && o.enable(18),
      M.batching && o.enable(19),
      M.dispersion && o.enable(20),
      M.batchingColor && o.enable(21),
      M.gradientMap && o.enable(22),
      w.push(o.mask),
      o.disableAll(),
      M.fog && o.enable(0),
      M.useFog && o.enable(1),
      M.flatShading && o.enable(2),
      M.logarithmicDepthBuffer && o.enable(3),
      M.reversedDepthBuffer && o.enable(4),
      M.skinning && o.enable(5),
      M.morphTargets && o.enable(6),
      M.morphNormals && o.enable(7),
      M.morphColors && o.enable(8),
      M.premultipliedAlpha && o.enable(9),
      M.shadowMapEnabled && o.enable(10),
      M.doubleSided && o.enable(11),
      M.flipSided && o.enable(12),
      M.useDepthPacking && o.enable(13),
      M.dithering && o.enable(14),
      M.transmission && o.enable(15),
      M.sheen && o.enable(16),
      M.opaque && o.enable(17),
      M.pointsUvs && o.enable(18),
      M.decodeVideoTexture && o.enable(19),
      M.decodeVideoTextureEmissive && o.enable(20),
      M.alphaToCoverage && o.enable(21),
      w.push(o.mask));
  }
  function x(w) {
    const M = p[w.type];
    let T;
    if (M) {
      const D = br[M];
      T = C2.clone(D.uniforms);
    } else T = w.uniforms;
    return T;
  }
  function S(w, M) {
    let T;
    for (let D = 0, L = u.length; D < L; D++) {
      const O = u[D];
      if (O.cacheKey === M) {
        ((T = O), ++T.usedTimes);
        break;
      }
    }
    return (T === void 0 && ((T = new $Z(n, M, w, s)), u.push(T)), T);
  }
  function b(w) {
    if (--w.usedTimes === 0) {
      const M = u.indexOf(w);
      ((u[M] = u[u.length - 1]), u.pop(), w.destroy());
    }
  }
  function A(w) {
    l.remove(w);
  }
  function E() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: v,
    getUniforms: x,
    acquireProgram: S,
    releaseProgram: b,
    releaseShaderCache: A,
    programs: u,
    dispose: E,
  };
}
function r$() {
  let n = new WeakMap();
  function e(a) {
    return n.has(a);
  }
  function t(a) {
    let o = n.get(a);
    return (o === void 0 && ((o = {}), n.set(a, o)), o);
  }
  function i(a) {
    n.delete(a);
  }
  function r(a, o, l) {
    n.get(a)[o] = l;
  }
  function s() {
    n = new WeakMap();
  }
  return { has: e, get: t, remove: i, update: r, dispose: s };
}
function s$(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
}
function JM(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id;
}
function QM() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    ((e = 0), (t.length = 0), (i.length = 0), (r.length = 0));
  }
  function a(h, d, f, p, m, g) {
    let v = n[e];
    return (
      v === void 0
        ? ((v = {
            id: h.id,
            object: h,
            geometry: d,
            material: f,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: m,
            group: g,
          }),
          (n[e] = v))
        : ((v.id = h.id),
          (v.object = h),
          (v.geometry = d),
          (v.material = f),
          (v.groupOrder = p),
          (v.renderOrder = h.renderOrder),
          (v.z = m),
          (v.group = g)),
      e++,
      v
    );
  }
  function o(h, d, f, p, m, g) {
    const v = a(h, d, f, p, m, g);
    f.transmission > 0
      ? i.push(v)
      : f.transparent === !0
        ? r.push(v)
        : t.push(v);
  }
  function l(h, d, f, p, m, g) {
    const v = a(h, d, f, p, m, g);
    f.transmission > 0
      ? i.unshift(v)
      : f.transparent === !0
        ? r.unshift(v)
        : t.unshift(v);
  }
  function c(h, d) {
    (t.length > 1 && t.sort(h || s$),
      i.length > 1 && i.sort(d || JM),
      r.length > 1 && r.sort(d || JM));
  }
  function u() {
    for (let h = e, d = n.length; h < d; h++) {
      const f = n[h];
      if (f.id === null) break;
      ((f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null));
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: o,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function a$() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let a;
    return (
      s === void 0
        ? ((a = new QM()), n.set(i, [a]))
        : r >= s.length
          ? ((a = new QM()), s.push(a))
          : (a = s[r]),
      a
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function o$() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = { direction: new V(), color: new je() };
          break;
        case 'SpotLight':
          t = {
            position: new V(),
            direction: new V(),
            color: new je(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case 'PointLight':
          t = { position: new V(), color: new je(), distance: 0, decay: 0 };
          break;
        case 'HemisphereLight':
          t = { direction: new V(), skyColor: new je(), groundColor: new je() };
          break;
        case 'RectAreaLight':
          t = {
            color: new je(),
            position: new V(),
            halfWidth: new V(),
            halfHeight: new V(),
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
function l$() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case 'DirectionalLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pe(),
          };
          break;
        case 'SpotLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pe(),
          };
          break;
        case 'PointLight':
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
let c$ = 0;
function u$(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function h$(n) {
  const e = new o$(),
    t = l$(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) i.probe.push(new V());
  const r = new V(),
    s = new pt(),
    a = new pt();
  function o(c) {
    let u = 0,
      h = 0,
      d = 0;
    for (let w = 0; w < 9; w++) i.probe[w].set(0, 0, 0);
    let f = 0,
      p = 0,
      m = 0,
      g = 0,
      v = 0,
      y = 0,
      _ = 0,
      x = 0,
      S = 0,
      b = 0,
      A = 0;
    c.sort(u$);
    for (let w = 0, M = c.length; w < M; w++) {
      const T = c[w],
        D = T.color,
        L = T.intensity,
        O = T.distance,
        z = T.shadow && T.shadow.map ? T.shadow.map.texture : null;
      if (T.isAmbientLight) ((u += D.r * L), (h += D.g * L), (d += D.b * L));
      else if (T.isLightProbe) {
        for (let C = 0; C < 9; C++)
          i.probe[C].addScaledVector(T.sh.coefficients[C], L);
        A++;
      } else if (T.isDirectionalLight) {
        const C = e.get(T);
        if ((C.color.copy(T.color).multiplyScalar(T.intensity), T.castShadow)) {
          const N = T.shadow,
            U = t.get(T);
          ((U.shadowIntensity = N.intensity),
            (U.shadowBias = N.bias),
            (U.shadowNormalBias = N.normalBias),
            (U.shadowRadius = N.radius),
            (U.shadowMapSize = N.mapSize),
            (i.directionalShadow[f] = U),
            (i.directionalShadowMap[f] = z),
            (i.directionalShadowMatrix[f] = T.shadow.matrix),
            y++);
        }
        ((i.directional[f] = C), f++);
      } else if (T.isSpotLight) {
        const C = e.get(T);
        (C.position.setFromMatrixPosition(T.matrixWorld),
          C.color.copy(D).multiplyScalar(L),
          (C.distance = O),
          (C.coneCos = Math.cos(T.angle)),
          (C.penumbraCos = Math.cos(T.angle * (1 - T.penumbra))),
          (C.decay = T.decay),
          (i.spot[m] = C));
        const N = T.shadow;
        if (
          (T.map &&
            ((i.spotLightMap[S] = T.map),
            S++,
            N.updateMatrices(T),
            T.castShadow && b++),
          (i.spotLightMatrix[m] = N.matrix),
          T.castShadow)
        ) {
          const U = t.get(T);
          ((U.shadowIntensity = N.intensity),
            (U.shadowBias = N.bias),
            (U.shadowNormalBias = N.normalBias),
            (U.shadowRadius = N.radius),
            (U.shadowMapSize = N.mapSize),
            (i.spotShadow[m] = U),
            (i.spotShadowMap[m] = z),
            x++);
        }
        m++;
      } else if (T.isRectAreaLight) {
        const C = e.get(T);
        (C.color.copy(D).multiplyScalar(L),
          C.halfWidth.set(T.width * 0.5, 0, 0),
          C.halfHeight.set(0, T.height * 0.5, 0),
          (i.rectArea[g] = C),
          g++);
      } else if (T.isPointLight) {
        const C = e.get(T);
        if (
          (C.color.copy(T.color).multiplyScalar(T.intensity),
          (C.distance = T.distance),
          (C.decay = T.decay),
          T.castShadow)
        ) {
          const N = T.shadow,
            U = t.get(T);
          ((U.shadowIntensity = N.intensity),
            (U.shadowBias = N.bias),
            (U.shadowNormalBias = N.normalBias),
            (U.shadowRadius = N.radius),
            (U.shadowMapSize = N.mapSize),
            (U.shadowCameraNear = N.camera.near),
            (U.shadowCameraFar = N.camera.far),
            (i.pointShadow[p] = U),
            (i.pointShadowMap[p] = z),
            (i.pointShadowMatrix[p] = T.shadow.matrix),
            _++);
        }
        ((i.point[p] = C), p++);
      } else if (T.isHemisphereLight) {
        const C = e.get(T);
        (C.skyColor.copy(T.color).multiplyScalar(L),
          C.groundColor.copy(T.groundColor).multiplyScalar(L),
          (i.hemi[v] = C),
          v++);
      }
    }
    (g > 0 &&
      (n.has('OES_texture_float_linear') === !0
        ? ((i.rectAreaLTC1 = He.LTC_FLOAT_1), (i.rectAreaLTC2 = He.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = He.LTC_HALF_1), (i.rectAreaLTC2 = He.LTC_HALF_2))),
      (i.ambient[0] = u),
      (i.ambient[1] = h),
      (i.ambient[2] = d));
    const E = i.hash;
    (E.directionalLength !== f ||
      E.pointLength !== p ||
      E.spotLength !== m ||
      E.rectAreaLength !== g ||
      E.hemiLength !== v ||
      E.numDirectionalShadows !== y ||
      E.numPointShadows !== _ ||
      E.numSpotShadows !== x ||
      E.numSpotMaps !== S ||
      E.numLightProbes !== A) &&
      ((i.directional.length = f),
      (i.spot.length = m),
      (i.rectArea.length = g),
      (i.point.length = p),
      (i.hemi.length = v),
      (i.directionalShadow.length = y),
      (i.directionalShadowMap.length = y),
      (i.pointShadow.length = _),
      (i.pointShadowMap.length = _),
      (i.spotShadow.length = x),
      (i.spotShadowMap.length = x),
      (i.directionalShadowMatrix.length = y),
      (i.pointShadowMatrix.length = _),
      (i.spotLightMatrix.length = x + S - b),
      (i.spotLightMap.length = S),
      (i.numSpotLightShadowsWithMaps = b),
      (i.numLightProbes = A),
      (E.directionalLength = f),
      (E.pointLength = p),
      (E.spotLength = m),
      (E.rectAreaLength = g),
      (E.hemiLength = v),
      (E.numDirectionalShadows = y),
      (E.numPointShadows = _),
      (E.numSpotShadows = x),
      (E.numSpotMaps = S),
      (E.numLightProbes = A),
      (i.version = c$++));
  }
  function l(c, u) {
    let h = 0,
      d = 0,
      f = 0,
      p = 0,
      m = 0;
    const g = u.matrixWorldInverse;
    for (let v = 0, y = c.length; v < y; v++) {
      const _ = c[v];
      if (_.isDirectionalLight) {
        const x = i.directional[h];
        (x.direction.setFromMatrixPosition(_.matrixWorld),
          r.setFromMatrixPosition(_.target.matrixWorld),
          x.direction.sub(r),
          x.direction.transformDirection(g),
          h++);
      } else if (_.isSpotLight) {
        const x = i.spot[f];
        (x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(g),
          x.direction.setFromMatrixPosition(_.matrixWorld),
          r.setFromMatrixPosition(_.target.matrixWorld),
          x.direction.sub(r),
          x.direction.transformDirection(g),
          f++);
      } else if (_.isRectAreaLight) {
        const x = i.rectArea[p];
        (x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(g),
          a.identity(),
          s.copy(_.matrixWorld),
          s.premultiply(g),
          a.extractRotation(s),
          x.halfWidth.set(_.width * 0.5, 0, 0),
          x.halfHeight.set(0, _.height * 0.5, 0),
          x.halfWidth.applyMatrix4(a),
          x.halfHeight.applyMatrix4(a),
          p++);
      } else if (_.isPointLight) {
        const x = i.point[d];
        (x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(g),
          d++);
      } else if (_.isHemisphereLight) {
        const x = i.hemi[m];
        (x.direction.setFromMatrixPosition(_.matrixWorld),
          x.direction.transformDirection(g),
          m++);
      }
    }
  }
  return { setup: o, setupView: l, state: i };
}
function ZM(n) {
  const e = new h$(n),
    t = [],
    i = [];
  function r(u) {
    ((c.camera = u), (t.length = 0), (i.length = 0));
  }
  function s(u) {
    t.push(u);
  }
  function a(u) {
    i.push(u);
  }
  function o() {
    e.setup(t);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: c,
    setupLights: o,
    setupLightsView: l,
    pushLight: s,
    pushShadow: a,
  };
}
function d$(n) {
  let e = new WeakMap();
  function t(r, s = 0) {
    const a = e.get(r);
    let o;
    return (
      a === void 0
        ? ((o = new ZM(n)), e.set(r, [o]))
        : s >= a.length
          ? ((o = new ZM(n)), a.push(o))
          : (o = a[s]),
      o
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: t, dispose: i };
}
const f$ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  p$ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function m$(n, e, t) {
  let i = new Cc();
  const r = new pe(),
    s = new pe(),
    a = new Lt(),
    o = new hb({ depthPacking: p2 }),
    l = new db(),
    c = {},
    u = t.maxTextureSize,
    h = { [Wr]: On, [On]: Wr, [ci]: ci },
    d = new rn({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new pe() },
        radius: { value: 4 },
      },
      vertexShader: f$,
      fragmentShader: p$,
    }),
    f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const p = new _t();
  p.setAttribute(
    'position',
    new qt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const m = new hn(p, d),
    g = this;
  ((this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Hx));
  let v = this.type;
  this.render = function (b, A, E) {
    if (
      g.enabled === !1 ||
      (g.autoUpdate === !1 && g.needsUpdate === !1) ||
      b.length === 0
    )
      return;
    const w = n.getRenderTarget(),
      M = n.getActiveCubeFace(),
      T = n.getActiveMipmapLevel(),
      D = n.state;
    (D.setBlending(Ln),
      D.buffers.depth.getReversed() === !0
        ? D.buffers.color.setClear(0, 0, 0, 0)
        : D.buffers.color.setClear(1, 1, 1, 1),
      D.buffers.depth.setTest(!0),
      D.setScissorTest(!1));
    const L = v !== Dr && this.type === Dr,
      O = v === Dr && this.type !== Dr;
    for (let z = 0, C = b.length; z < C; z++) {
      const N = b[z],
        U = N.shadow;
      if (U === void 0) {
        Ge('WebGLShadowMap:', N, 'has no shadow.');
        continue;
      }
      if (U.autoUpdate === !1 && U.needsUpdate === !1) continue;
      r.copy(U.mapSize);
      const W = U.getFrameExtents();
      if (
        (r.multiply(W),
        s.copy(U.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / W.x)),
            (r.x = s.x * W.x),
            (U.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / W.y)),
            (r.y = s.y * W.y),
            (U.mapSize.y = s.y))),
        U.map === null || L === !0 || O === !0)
      ) {
        const ne = this.type !== Dr ? { minFilter: Un, magFilter: Un } : {};
        (U.map !== null && U.map.dispose(),
          (U.map = new Sn(r.x, r.y, ne)),
          (U.map.texture.name = N.name + '.shadowMap'),
          U.camera.updateProjectionMatrix());
      }
      (n.setRenderTarget(U.map), n.clear());
      const G = U.getViewportCount();
      for (let ne = 0; ne < G; ne++) {
        const ve = U.getViewport(ne);
        (a.set(s.x * ve.x, s.y * ve.y, s.x * ve.z, s.y * ve.w),
          D.viewport(a),
          U.updateMatrices(N, ne),
          (i = U.getFrustum()),
          x(A, E, U.camera, N, this.type));
      }
      (U.isPointLightShadow !== !0 && this.type === Dr && y(U, E),
        (U.needsUpdate = !1));
    }
    ((v = this.type), (g.needsUpdate = !1), n.setRenderTarget(w, M, T));
  };
  function y(b, A) {
    const E = e.update(m);
    (d.defines.VSM_SAMPLES !== b.blurSamples &&
      ((d.defines.VSM_SAMPLES = b.blurSamples),
      (f.defines.VSM_SAMPLES = b.blurSamples),
      (d.needsUpdate = !0),
      (f.needsUpdate = !0)),
      b.mapPass === null && (b.mapPass = new Sn(r.x, r.y)),
      (d.uniforms.shadow_pass.value = b.map.texture),
      (d.uniforms.resolution.value = b.mapSize),
      (d.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.mapPass),
      n.clear(),
      n.renderBufferDirect(A, null, E, d, m, null),
      (f.uniforms.shadow_pass.value = b.mapPass.texture),
      (f.uniforms.resolution.value = b.mapSize),
      (f.uniforms.radius.value = b.radius),
      n.setRenderTarget(b.map),
      n.clear(),
      n.renderBufferDirect(A, null, E, f, m, null));
  }
  function _(b, A, E, w) {
    let M = null;
    const T =
      E.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (T !== void 0) M = T;
    else if (
      ((M = E.isPointLight === !0 ? l : o),
      (n.localClippingEnabled &&
        A.clipShadows === !0 &&
        Array.isArray(A.clippingPlanes) &&
        A.clippingPlanes.length !== 0) ||
        (A.displacementMap && A.displacementScale !== 0) ||
        (A.alphaMap && A.alphaTest > 0) ||
        (A.map && A.alphaTest > 0) ||
        A.alphaToCoverage === !0)
    ) {
      const D = M.uuid,
        L = A.uuid;
      let O = c[D];
      O === void 0 && ((O = {}), (c[D] = O));
      let z = O[L];
      (z === void 0 &&
        ((z = M.clone()), (O[L] = z), A.addEventListener('dispose', S)),
        (M = z));
    }
    if (
      ((M.visible = A.visible),
      (M.wireframe = A.wireframe),
      w === Dr
        ? (M.side = A.shadowSide !== null ? A.shadowSide : A.side)
        : (M.side = A.shadowSide !== null ? A.shadowSide : h[A.side]),
      (M.alphaMap = A.alphaMap),
      (M.alphaTest = A.alphaToCoverage === !0 ? 0.5 : A.alphaTest),
      (M.map = A.map),
      (M.clipShadows = A.clipShadows),
      (M.clippingPlanes = A.clippingPlanes),
      (M.clipIntersection = A.clipIntersection),
      (M.displacementMap = A.displacementMap),
      (M.displacementScale = A.displacementScale),
      (M.displacementBias = A.displacementBias),
      (M.wireframeLinewidth = A.wireframeLinewidth),
      (M.linewidth = A.linewidth),
      E.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const D = n.properties.get(M);
      D.light = E;
    }
    return M;
  }
  function x(b, A, E, w, M) {
    if (b.visible === !1) return;
    if (
      b.layers.test(A.layers) &&
      (b.isMesh || b.isLine || b.isPoints) &&
      (b.castShadow || (b.receiveShadow && M === Dr)) &&
      (!b.frustumCulled || i.intersectsObject(b))
    ) {
      b.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, b.matrixWorld);
      const L = e.update(b),
        O = b.material;
      if (Array.isArray(O)) {
        const z = L.groups;
        for (let C = 0, N = z.length; C < N; C++) {
          const U = z[C],
            W = O[U.materialIndex];
          if (W && W.visible) {
            const G = _(b, W, w, M);
            (b.onBeforeShadow(n, b, A, E, L, G, U),
              n.renderBufferDirect(E, null, L, G, b, U),
              b.onAfterShadow(n, b, A, E, L, G, U));
          }
        }
      } else if (O.visible) {
        const z = _(b, O, w, M);
        (b.onBeforeShadow(n, b, A, E, L, z, null),
          n.renderBufferDirect(E, null, L, z, b, null),
          b.onAfterShadow(n, b, A, E, L, z, null));
      }
    }
    const D = b.children;
    for (let L = 0, O = D.length; L < O; L++) x(D[L], A, E, w, M);
  }
  function S(b) {
    b.target.removeEventListener('dispose', S);
    for (const E in c) {
      const w = c[E],
        M = b.target.uuid;
      M in w && (w[M].dispose(), delete w[M]);
    }
  }
}
const g$ = {
  [cp]: up,
  [hp]: pp,
  [dp]: mp,
  [Do]: fp,
  [up]: cp,
  [pp]: hp,
  [mp]: dp,
  [fp]: Do,
};
function v$(n, e) {
  function t() {
    let Y = !1;
    const re = new Lt();
    let ke = null;
    const ze = new Lt(0, 0, 0, 0);
    return {
      setMask: function (Ie) {
        ke !== Ie && !Y && (n.colorMask(Ie, Ie, Ie, Ie), (ke = Ie));
      },
      setLocked: function (Ie) {
        Y = Ie;
      },
      setClear: function (Ie, be, tt, vt, Qt) {
        (Qt === !0 && ((Ie *= vt), (be *= vt), (tt *= vt)),
          re.set(Ie, be, tt, vt),
          ze.equals(re) === !1 && (n.clearColor(Ie, be, tt, vt), ze.copy(re)));
      },
      reset: function () {
        ((Y = !1), (ke = null), ze.set(-1, 0, 0, 0));
      },
    };
  }
  function i() {
    let Y = !1,
      re = !1,
      ke = null,
      ze = null,
      Ie = null;
    return {
      setReversed: function (be) {
        if (re !== be) {
          const tt = e.get('EXT_clip_control');
          (be
            ? tt.clipControlEXT(tt.LOWER_LEFT_EXT, tt.ZERO_TO_ONE_EXT)
            : tt.clipControlEXT(tt.LOWER_LEFT_EXT, tt.NEGATIVE_ONE_TO_ONE_EXT),
            (re = be));
          const vt = Ie;
          ((Ie = null), this.setClear(vt));
        }
      },
      getReversed: function () {
        return re;
      },
      setTest: function (be) {
        be ? J(n.DEPTH_TEST) : de(n.DEPTH_TEST);
      },
      setMask: function (be) {
        ke !== be && !Y && (n.depthMask(be), (ke = be));
      },
      setFunc: function (be) {
        if ((re && (be = g$[be]), ze !== be)) {
          switch (be) {
            case cp:
              n.depthFunc(n.NEVER);
              break;
            case up:
              n.depthFunc(n.ALWAYS);
              break;
            case hp:
              n.depthFunc(n.LESS);
              break;
            case Do:
              n.depthFunc(n.LEQUAL);
              break;
            case dp:
              n.depthFunc(n.EQUAL);
              break;
            case fp:
              n.depthFunc(n.GEQUAL);
              break;
            case pp:
              n.depthFunc(n.GREATER);
              break;
            case mp:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          ze = be;
        }
      },
      setLocked: function (be) {
        Y = be;
      },
      setClear: function (be) {
        Ie !== be && (re && (be = 1 - be), n.clearDepth(be), (Ie = be));
      },
      reset: function () {
        ((Y = !1), (ke = null), (ze = null), (Ie = null), (re = !1));
      },
    };
  }
  function r() {
    let Y = !1,
      re = null,
      ke = null,
      ze = null,
      Ie = null,
      be = null,
      tt = null,
      vt = null,
      Qt = null;
    return {
      setTest: function (jt) {
        Y || (jt ? J(n.STENCIL_TEST) : de(n.STENCIL_TEST));
      },
      setMask: function (jt) {
        re !== jt && !Y && (n.stencilMask(jt), (re = jt));
      },
      setFunc: function (jt, Ji, Di) {
        (ke !== jt || ze !== Ji || Ie !== Di) &&
          (n.stencilFunc(jt, Ji, Di), (ke = jt), (ze = Ji), (Ie = Di));
      },
      setOp: function (jt, Ji, Di) {
        (be !== jt || tt !== Ji || vt !== Di) &&
          (n.stencilOp(jt, Ji, Di), (be = jt), (tt = Ji), (vt = Di));
      },
      setLocked: function (jt) {
        Y = jt;
      },
      setClear: function (jt) {
        Qt !== jt && (n.clearStencil(jt), (Qt = jt));
      },
      reset: function () {
        ((Y = !1),
          (re = null),
          (ke = null),
          (ze = null),
          (Ie = null),
          (be = null),
          (tt = null),
          (vt = null),
          (Qt = null));
      },
    };
  }
  const s = new t(),
    a = new i(),
    o = new r(),
    l = new WeakMap(),
    c = new WeakMap();
  let u = {},
    h = {},
    d = new WeakMap(),
    f = [],
    p = null,
    m = !1,
    g = null,
    v = null,
    y = null,
    _ = null,
    x = null,
    S = null,
    b = null,
    A = new je(0, 0, 0),
    E = 0,
    w = !1,
    M = null,
    T = null,
    D = null,
    L = null,
    O = null;
  const z = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let C = !1,
    N = 0;
  const U = n.getParameter(n.VERSION);
  U.indexOf('WebGL') !== -1
    ? ((N = parseFloat(/^WebGL (\d)/.exec(U)[1])), (C = N >= 1))
    : U.indexOf('OpenGL ES') !== -1 &&
      ((N = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])), (C = N >= 2));
  let W = null,
    G = {};
  const ne = n.getParameter(n.SCISSOR_BOX),
    ve = n.getParameter(n.VIEWPORT),
    Se = new Lt().fromArray(ne),
    Ae = new Lt().fromArray(ve);
  function Oe(Y, re, ke, ze) {
    const Ie = new Uint8Array(4),
      be = n.createTexture();
    (n.bindTexture(Y, be),
      n.texParameteri(Y, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(Y, n.TEXTURE_MAG_FILTER, n.NEAREST));
    for (let tt = 0; tt < ke; tt++)
      Y === n.TEXTURE_3D || Y === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(re, 0, n.RGBA, 1, 1, ze, 0, n.RGBA, n.UNSIGNED_BYTE, Ie)
        : n.texImage2D(
            re + tt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            Ie
          );
    return be;
  }
  const Z = {};
  ((Z[n.TEXTURE_2D] = Oe(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Z[n.TEXTURE_CUBE_MAP] = Oe(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (Z[n.TEXTURE_2D_ARRAY] = Oe(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (Z[n.TEXTURE_3D] = Oe(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    a.setClear(1),
    o.setClear(0),
    J(n.DEPTH_TEST),
    a.setFunc(Do),
    me(!1),
    ye(G_),
    J(n.CULL_FACE),
    ee(Ln));
  function J(Y) {
    u[Y] !== !0 && (n.enable(Y), (u[Y] = !0));
  }
  function de(Y) {
    u[Y] !== !1 && (n.disable(Y), (u[Y] = !1));
  }
  function fe(Y, re) {
    return h[Y] !== re
      ? (n.bindFramebuffer(Y, re),
        (h[Y] = re),
        Y === n.DRAW_FRAMEBUFFER && (h[n.FRAMEBUFFER] = re),
        Y === n.FRAMEBUFFER && (h[n.DRAW_FRAMEBUFFER] = re),
        !0)
      : !1;
  }
  function K(Y, re) {
    let ke = f,
      ze = !1;
    if (Y) {
      ((ke = d.get(re)), ke === void 0 && ((ke = []), d.set(re, ke)));
      const Ie = Y.textures;
      if (ke.length !== Ie.length || ke[0] !== n.COLOR_ATTACHMENT0) {
        for (let be = 0, tt = Ie.length; be < tt; be++)
          ke[be] = n.COLOR_ATTACHMENT0 + be;
        ((ke.length = Ie.length), (ze = !0));
      }
    } else ke[0] !== n.BACK && ((ke[0] = n.BACK), (ze = !0));
    ze && n.drawBuffers(ke);
  }
  function oe(Y) {
    return p !== Y ? (n.useProgram(Y), (p = Y), !0) : !1;
  }
  const he = {
    [Bs]: n.FUNC_ADD,
    [ND]: n.FUNC_SUBTRACT,
    [FD]: n.FUNC_REVERSE_SUBTRACT,
  };
  ((he[zD] = n.MIN), (he[VD] = n.MAX));
  const xe = {
    [HD]: n.ZERO,
    [GD]: n.ONE,
    [WD]: n.SRC_COLOR,
    [op]: n.SRC_ALPHA,
    [JD]: n.SRC_ALPHA_SATURATE,
    [YD]: n.DST_COLOR,
    [XD]: n.DST_ALPHA,
    [jD]: n.ONE_MINUS_SRC_COLOR,
    [lp]: n.ONE_MINUS_SRC_ALPHA,
    [KD]: n.ONE_MINUS_DST_COLOR,
    [qD]: n.ONE_MINUS_DST_ALPHA,
    [QD]: n.CONSTANT_COLOR,
    [ZD]: n.ONE_MINUS_CONSTANT_COLOR,
    [$D]: n.CONSTANT_ALPHA,
    [e2]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function ee(Y, re, ke, ze, Ie, be, tt, vt, Qt, jt) {
    if (Y === Ln) {
      m === !0 && (de(n.BLEND), (m = !1));
      return;
    }
    if ((m === !1 && (J(n.BLEND), (m = !0)), Y !== BD)) {
      if (Y !== g || jt !== w) {
        if (
          ((v !== Bs || x !== Bs) &&
            (n.blendEquation(n.FUNC_ADD), (v = Bs), (x = Bs)),
          jt)
        )
          switch (Y) {
            case Eo:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case W_:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case j_:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case X_:
              n.blendFuncSeparate(
                n.DST_COLOR,
                n.ONE_MINUS_SRC_ALPHA,
                n.ZERO,
                n.ONE
              );
              break;
            default:
              gt('WebGLState: Invalid blending: ', Y);
              break;
          }
        else
          switch (Y) {
            case Eo:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case W_:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE, n.ONE, n.ONE);
              break;
            case j_:
              gt(
                'WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true'
              );
              break;
            case X_:
              gt(
                'WebGLState: MultiplyBlending requires material.premultipliedAlpha = true'
              );
              break;
            default:
              gt('WebGLState: Invalid blending: ', Y);
              break;
          }
        ((y = null),
          (_ = null),
          (S = null),
          (b = null),
          A.set(0, 0, 0),
          (E = 0),
          (g = Y),
          (w = jt));
      }
      return;
    }
    ((Ie = Ie || re),
      (be = be || ke),
      (tt = tt || ze),
      (re !== v || Ie !== x) &&
        (n.blendEquationSeparate(he[re], he[Ie]), (v = re), (x = Ie)),
      (ke !== y || ze !== _ || be !== S || tt !== b) &&
        (n.blendFuncSeparate(xe[ke], xe[ze], xe[be], xe[tt]),
        (y = ke),
        (_ = ze),
        (S = be),
        (b = tt)),
      (vt.equals(A) === !1 || Qt !== E) &&
        (n.blendColor(vt.r, vt.g, vt.b, Qt), A.copy(vt), (E = Qt)),
      (g = Y),
      (w = !1));
  }
  function B(Y, re) {
    Y.side === ci ? de(n.CULL_FACE) : J(n.CULL_FACE);
    let ke = Y.side === On;
    (re && (ke = !ke),
      me(ke),
      Y.blending === Eo && Y.transparent === !1
        ? ee(Ln)
        : ee(
            Y.blending,
            Y.blendEquation,
            Y.blendSrc,
            Y.blendDst,
            Y.blendEquationAlpha,
            Y.blendSrcAlpha,
            Y.blendDstAlpha,
            Y.blendColor,
            Y.blendAlpha,
            Y.premultipliedAlpha
          ),
      a.setFunc(Y.depthFunc),
      a.setTest(Y.depthTest),
      a.setMask(Y.depthWrite),
      s.setMask(Y.colorWrite));
    const ze = Y.stencilWrite;
    (o.setTest(ze),
      ze &&
        (o.setMask(Y.stencilWriteMask),
        o.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
        o.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
      Ee(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
      Y.alphaToCoverage === !0
        ? J(n.SAMPLE_ALPHA_TO_COVERAGE)
        : de(n.SAMPLE_ALPHA_TO_COVERAGE));
  }
  function me(Y) {
    M !== Y && (Y ? n.frontFace(n.CW) : n.frontFace(n.CCW), (M = Y));
  }
  function ye(Y) {
    (Y !== LD
      ? (J(n.CULL_FACE),
        Y !== T &&
          (Y === G_
            ? n.cullFace(n.BACK)
            : Y === UD
              ? n.cullFace(n.FRONT)
              : n.cullFace(n.FRONT_AND_BACK)))
      : de(n.CULL_FACE),
      (T = Y));
  }
  function Te(Y) {
    Y !== D && (C && n.lineWidth(Y), (D = Y));
  }
  function Ee(Y, re, ke) {
    Y
      ? (J(n.POLYGON_OFFSET_FILL),
        (L !== re || O !== ke) && (n.polygonOffset(re, ke), (L = re), (O = ke)))
      : de(n.POLYGON_OFFSET_FILL);
  }
  function Xe(Y) {
    Y ? J(n.SCISSOR_TEST) : de(n.SCISSOR_TEST);
  }
  function Ne(Y) {
    (Y === void 0 && (Y = n.TEXTURE0 + z - 1),
      W !== Y && (n.activeTexture(Y), (W = Y)));
  }
  function We(Y, re, ke) {
    ke === void 0 && (W === null ? (ke = n.TEXTURE0 + z - 1) : (ke = W));
    let ze = G[ke];
    (ze === void 0 && ((ze = { type: void 0, texture: void 0 }), (G[ke] = ze)),
      (ze.type !== Y || ze.texture !== re) &&
        (W !== ke && (n.activeTexture(ke), (W = ke)),
        n.bindTexture(Y, re || Z[Y]),
        (ze.type = Y),
        (ze.texture = re)));
  }
  function F() {
    const Y = G[W];
    Y !== void 0 &&
      Y.type !== void 0 &&
      (n.bindTexture(Y.type, null), (Y.type = void 0), (Y.texture = void 0));
  }
  function P() {
    try {
      n.compressedTexImage2D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function Q() {
    try {
      n.compressedTexImage3D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function le() {
    try {
      n.texSubImage2D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function ge() {
    try {
      n.texSubImage3D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function se() {
    try {
      n.compressedTexSubImage2D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function Ke() {
    try {
      n.compressedTexSubImage3D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function Be() {
    try {
      n.texStorage2D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function at() {
    try {
      n.texStorage3D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function Je() {
    try {
      n.texImage2D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function we() {
    try {
      n.texImage3D(...arguments);
    } catch (Y) {
      Y('WebGLState:', Y);
    }
  }
  function Ce(Y) {
    Se.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w), Se.copy(Y));
  }
  function ct(Y) {
    Ae.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w), Ae.copy(Y));
  }
  function it(Y, re) {
    let ke = c.get(re);
    ke === void 0 && ((ke = new WeakMap()), c.set(re, ke));
    let ze = ke.get(Y);
    ze === void 0 && ((ze = n.getUniformBlockIndex(re, Y.name)), ke.set(Y, ze));
  }
  function Le(Y, re) {
    const ze = c.get(re).get(Y);
    l.get(re) !== ze &&
      (n.uniformBlockBinding(re, ze, Y.__bindingPointIndex), l.set(re, ze));
  }
  function et() {
    (n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      a.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (u = {}),
      (W = null),
      (G = {}),
      (h = {}),
      (d = new WeakMap()),
      (f = []),
      (p = null),
      (m = !1),
      (g = null),
      (v = null),
      (y = null),
      (_ = null),
      (x = null),
      (S = null),
      (b = null),
      (A = new je(0, 0, 0)),
      (E = 0),
      (w = !1),
      (M = null),
      (T = null),
      (D = null),
      (L = null),
      (O = null),
      Se.set(0, 0, n.canvas.width, n.canvas.height),
      Ae.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      a.reset(),
      o.reset());
  }
  return {
    buffers: { color: s, depth: a, stencil: o },
    enable: J,
    disable: de,
    bindFramebuffer: fe,
    drawBuffers: K,
    useProgram: oe,
    setBlending: ee,
    setMaterial: B,
    setFlipSided: me,
    setCullFace: ye,
    setLineWidth: Te,
    setPolygonOffset: Ee,
    setScissorTest: Xe,
    activeTexture: Ne,
    bindTexture: We,
    unbindTexture: F,
    compressedTexImage2D: P,
    compressedTexImage3D: Q,
    texImage2D: Je,
    texImage3D: we,
    updateUBOMapping: it,
    uniformBlockBinding: Le,
    texStorage2D: Be,
    texStorage3D: at,
    texSubImage2D: le,
    texSubImage3D: ge,
    compressedTexSubImage2D: se,
    compressedTexSubImage3D: Ke,
    scissor: Ce,
    viewport: ct,
    reset: et,
  };
}
function _$(n, e, t, i, r, s, a) {
  const o = e.has('WEBGL_multisampled_render_to_texture')
      ? e.get('WEBGL_multisampled_render_to_texture')
      : null,
    l =
      typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new pe(),
    u = new WeakMap();
  let h;
  const d = new WeakMap();
  let f = !1;
  try {
    f =
      typeof OffscreenCanvas < 'u' &&
      new OffscreenCanvas(1, 1).getContext('2d') !== null;
  } catch {}
  function p(F, P) {
    return f ? new OffscreenCanvas(F, P) : dh('canvas');
  }
  function m(F, P, Q) {
    let le = 1;
    const ge = We(F);
    if (
      ((ge.width > Q || ge.height > Q) &&
        (le = Q / Math.max(ge.width, ge.height)),
      le < 1)
    )
      if (
        (typeof HTMLImageElement < 'u' && F instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && F instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && F instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && F instanceof VideoFrame)
      ) {
        const se = Math.floor(le * ge.width),
          Ke = Math.floor(le * ge.height);
        h === void 0 && (h = p(se, Ke));
        const Be = P ? p(se, Ke) : h;
        return (
          (Be.width = se),
          (Be.height = Ke),
          Be.getContext('2d').drawImage(F, 0, 0, se, Ke),
          Ge(
            'WebGLRenderer: Texture has been resized from (' +
              ge.width +
              'x' +
              ge.height +
              ') to (' +
              se +
              'x' +
              Ke +
              ').'
          ),
          Be
        );
      } else
        return (
          'data' in F &&
            Ge(
              'WebGLRenderer: Image in DataTexture is too big (' +
                ge.width +
                'x' +
                ge.height +
                ').'
            ),
          F
        );
    return F;
  }
  function g(F) {
    return F.generateMipmaps;
  }
  function v(F) {
    n.generateMipmap(F);
  }
  function y(F) {
    return F.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : F.isWebGL3DRenderTarget
        ? n.TEXTURE_3D
        : F.isWebGLArrayRenderTarget || F.isCompressedArrayTexture
          ? n.TEXTURE_2D_ARRAY
          : n.TEXTURE_2D;
  }
  function _(F, P, Q, le, ge = !1) {
    if (F !== null) {
      if (n[F] !== void 0) return n[F];
      Ge(
        "WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          F +
          "'"
      );
    }
    let se = P;
    if (
      (P === n.RED &&
        (Q === n.FLOAT && (se = n.R32F),
        Q === n.HALF_FLOAT && (se = n.R16F),
        Q === n.UNSIGNED_BYTE && (se = n.R8)),
      P === n.RED_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (se = n.R8UI),
        Q === n.UNSIGNED_SHORT && (se = n.R16UI),
        Q === n.UNSIGNED_INT && (se = n.R32UI),
        Q === n.BYTE && (se = n.R8I),
        Q === n.SHORT && (se = n.R16I),
        Q === n.INT && (se = n.R32I)),
      P === n.RG &&
        (Q === n.FLOAT && (se = n.RG32F),
        Q === n.HALF_FLOAT && (se = n.RG16F),
        Q === n.UNSIGNED_BYTE && (se = n.RG8)),
      P === n.RG_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (se = n.RG8UI),
        Q === n.UNSIGNED_SHORT && (se = n.RG16UI),
        Q === n.UNSIGNED_INT && (se = n.RG32UI),
        Q === n.BYTE && (se = n.RG8I),
        Q === n.SHORT && (se = n.RG16I),
        Q === n.INT && (se = n.RG32I)),
      P === n.RGB_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (se = n.RGB8UI),
        Q === n.UNSIGNED_SHORT && (se = n.RGB16UI),
        Q === n.UNSIGNED_INT && (se = n.RGB32UI),
        Q === n.BYTE && (se = n.RGB8I),
        Q === n.SHORT && (se = n.RGB16I),
        Q === n.INT && (se = n.RGB32I)),
      P === n.RGBA_INTEGER &&
        (Q === n.UNSIGNED_BYTE && (se = n.RGBA8UI),
        Q === n.UNSIGNED_SHORT && (se = n.RGBA16UI),
        Q === n.UNSIGNED_INT && (se = n.RGBA32UI),
        Q === n.BYTE && (se = n.RGBA8I),
        Q === n.SHORT && (se = n.RGBA16I),
        Q === n.INT && (se = n.RGBA32I)),
      P === n.RGB &&
        (Q === n.UNSIGNED_INT_5_9_9_9_REV && (se = n.RGB9_E5),
        Q === n.UNSIGNED_INT_10F_11F_11F_REV && (se = n.R11F_G11F_B10F)),
      P === n.RGBA)
    ) {
      const Ke = ge ? uh : kt.getTransfer(le);
      (Q === n.FLOAT && (se = n.RGBA32F),
        Q === n.HALF_FLOAT && (se = n.RGBA16F),
        Q === n.UNSIGNED_BYTE && (se = Ke === Yt ? n.SRGB8_ALPHA8 : n.RGBA8),
        Q === n.UNSIGNED_SHORT_4_4_4_4 && (se = n.RGBA4),
        Q === n.UNSIGNED_SHORT_5_5_5_1 && (se = n.RGB5_A1));
    }
    return (
      (se === n.R16F ||
        se === n.R32F ||
        se === n.RG16F ||
        se === n.RG32F ||
        se === n.RGBA16F ||
        se === n.RGBA32F) &&
        e.get('EXT_color_buffer_float'),
      se
    );
  }
  function x(F, P) {
    let Q;
    return (
      F
        ? P === null || P === Mr || P === Oo
          ? (Q = n.DEPTH24_STENCIL8)
          : P === un
            ? (Q = n.DEPTH32F_STENCIL8)
            : P === tc &&
              ((Q = n.DEPTH24_STENCIL8),
              Ge(
                'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.'
              ))
        : P === null || P === Mr || P === Oo
          ? (Q = n.DEPTH_COMPONENT24)
          : P === un
            ? (Q = n.DEPTH_COMPONENT32F)
            : P === tc && (Q = n.DEPTH_COMPONENT16),
      Q
    );
  }
  function S(F, P) {
    return g(F) === !0 ||
      (F.isFramebufferTexture && F.minFilter !== Un && F.minFilter !== Dt)
      ? Math.log2(Math.max(P.width, P.height)) + 1
      : F.mipmaps !== void 0 && F.mipmaps.length > 0
        ? F.mipmaps.length
        : F.isCompressedTexture && Array.isArray(F.image)
          ? P.mipmaps.length
          : 1;
  }
  function b(F) {
    const P = F.target;
    (P.removeEventListener('dispose', b),
      E(P),
      P.isVideoTexture && u.delete(P));
  }
  function A(F) {
    const P = F.target;
    (P.removeEventListener('dispose', A), M(P));
  }
  function E(F) {
    const P = i.get(F);
    if (P.__webglInit === void 0) return;
    const Q = F.source,
      le = d.get(Q);
    if (le) {
      const ge = le[P.__cacheKey];
      (ge.usedTimes--,
        ge.usedTimes === 0 && w(F),
        Object.keys(le).length === 0 && d.delete(Q));
    }
    i.remove(F);
  }
  function w(F) {
    const P = i.get(F);
    n.deleteTexture(P.__webglTexture);
    const Q = F.source,
      le = d.get(Q);
    (delete le[P.__cacheKey], a.memory.textures--);
  }
  function M(F) {
    const P = i.get(F);
    if (
      (F.depthTexture && (F.depthTexture.dispose(), i.remove(F.depthTexture)),
      F.isWebGLCubeRenderTarget)
    )
      for (let le = 0; le < 6; le++) {
        if (Array.isArray(P.__webglFramebuffer[le]))
          for (let ge = 0; ge < P.__webglFramebuffer[le].length; ge++)
            n.deleteFramebuffer(P.__webglFramebuffer[le][ge]);
        else n.deleteFramebuffer(P.__webglFramebuffer[le]);
        P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer[le]);
      }
    else {
      if (Array.isArray(P.__webglFramebuffer))
        for (let le = 0; le < P.__webglFramebuffer.length; le++)
          n.deleteFramebuffer(P.__webglFramebuffer[le]);
      else n.deleteFramebuffer(P.__webglFramebuffer);
      if (
        (P.__webglDepthbuffer && n.deleteRenderbuffer(P.__webglDepthbuffer),
        P.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(P.__webglMultisampledFramebuffer),
        P.__webglColorRenderbuffer)
      )
        for (let le = 0; le < P.__webglColorRenderbuffer.length; le++)
          P.__webglColorRenderbuffer[le] &&
            n.deleteRenderbuffer(P.__webglColorRenderbuffer[le]);
      P.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(P.__webglDepthRenderbuffer);
    }
    const Q = F.textures;
    for (let le = 0, ge = Q.length; le < ge; le++) {
      const se = i.get(Q[le]);
      (se.__webglTexture &&
        (n.deleteTexture(se.__webglTexture), a.memory.textures--),
        i.remove(Q[le]));
    }
    i.remove(F);
  }
  let T = 0;
  function D() {
    T = 0;
  }
  function L() {
    const F = T;
    return (
      F >= r.maxTextures &&
        Ge(
          'WebGLTextures: Trying to use ' +
            F +
            ' texture units while this GPU supports only ' +
            r.maxTextures
        ),
      (T += 1),
      F
    );
  }
  function O(F) {
    const P = [];
    return (
      P.push(F.wrapS),
      P.push(F.wrapT),
      P.push(F.wrapR || 0),
      P.push(F.magFilter),
      P.push(F.minFilter),
      P.push(F.anisotropy),
      P.push(F.internalFormat),
      P.push(F.format),
      P.push(F.type),
      P.push(F.generateMipmaps),
      P.push(F.premultiplyAlpha),
      P.push(F.flipY),
      P.push(F.unpackAlignment),
      P.push(F.colorSpace),
      P.join()
    );
  }
  function z(F, P) {
    const Q = i.get(F);
    if (
      (F.isVideoTexture && Xe(F),
      F.isRenderTargetTexture === !1 &&
        F.isExternalTexture !== !0 &&
        F.version > 0 &&
        Q.__version !== F.version)
    ) {
      const le = F.image;
      if (le === null)
        Ge('WebGLRenderer: Texture marked for update but no image data found.');
      else if (le.complete === !1)
        Ge('WebGLRenderer: Texture marked for update but image is incomplete');
      else {
        Z(Q, F, P);
        return;
      }
    } else
      F.isExternalTexture &&
        (Q.__webglTexture = F.sourceTexture ? F.sourceTexture : null);
    t.bindTexture(n.TEXTURE_2D, Q.__webglTexture, n.TEXTURE0 + P);
  }
  function C(F, P) {
    const Q = i.get(F);
    if (
      F.isRenderTargetTexture === !1 &&
      F.version > 0 &&
      Q.__version !== F.version
    ) {
      Z(Q, F, P);
      return;
    } else
      F.isExternalTexture &&
        (Q.__webglTexture = F.sourceTexture ? F.sourceTexture : null);
    t.bindTexture(n.TEXTURE_2D_ARRAY, Q.__webglTexture, n.TEXTURE0 + P);
  }
  function N(F, P) {
    const Q = i.get(F);
    if (
      F.isRenderTargetTexture === !1 &&
      F.version > 0 &&
      Q.__version !== F.version
    ) {
      Z(Q, F, P);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, Q.__webglTexture, n.TEXTURE0 + P);
  }
  function U(F, P) {
    const Q = i.get(F);
    if (F.version > 0 && Q.__version !== F.version) {
      J(Q, F, P);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, Q.__webglTexture, n.TEXTURE0 + P);
  }
  const W = { [ah]: n.REPEAT, [mn]: n.CLAMP_TO_EDGE, [oh]: n.MIRRORED_REPEAT },
    G = {
      [Un]: n.NEAREST,
      [Gx]: n.NEAREST_MIPMAP_NEAREST,
      [Dl]: n.NEAREST_MIPMAP_LINEAR,
      [Dt]: n.LINEAR,
      [Iu]: n.LINEAR_MIPMAP_NEAREST,
      [kr]: n.LINEAR_MIPMAP_LINEAR,
    },
    ne = {
      [g2]: n.NEVER,
      [S2]: n.ALWAYS,
      [v2]: n.LESS,
      [Kx]: n.LEQUAL,
      [_2]: n.EQUAL,
      [b2]: n.GEQUAL,
      [y2]: n.GREATER,
      [x2]: n.NOTEQUAL,
    };
  function ve(F, P) {
    if (
      (P.type === un &&
        e.has('OES_texture_float_linear') === !1 &&
        (P.magFilter === Dt ||
          P.magFilter === Iu ||
          P.magFilter === Dl ||
          P.magFilter === kr ||
          P.minFilter === Dt ||
          P.minFilter === Iu ||
          P.minFilter === Dl ||
          P.minFilter === kr) &&
        Ge(
          'WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
        ),
      n.texParameteri(F, n.TEXTURE_WRAP_S, W[P.wrapS]),
      n.texParameteri(F, n.TEXTURE_WRAP_T, W[P.wrapT]),
      (F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(F, n.TEXTURE_WRAP_R, W[P.wrapR]),
      n.texParameteri(F, n.TEXTURE_MAG_FILTER, G[P.magFilter]),
      n.texParameteri(F, n.TEXTURE_MIN_FILTER, G[P.minFilter]),
      P.compareFunction &&
        (n.texParameteri(F, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(F, n.TEXTURE_COMPARE_FUNC, ne[P.compareFunction])),
      e.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        P.magFilter === Un ||
        (P.minFilter !== Dl && P.minFilter !== kr) ||
        (P.type === un && e.has('OES_texture_float_linear') === !1)
      )
        return;
      if (P.anisotropy > 1 || i.get(P).__currentAnisotropy) {
        const Q = e.get('EXT_texture_filter_anisotropic');
        (n.texParameterf(
          F,
          Q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(P.anisotropy, r.getMaxAnisotropy())
        ),
          (i.get(P).__currentAnisotropy = P.anisotropy));
      }
    }
  }
  function Se(F, P) {
    let Q = !1;
    F.__webglInit === void 0 &&
      ((F.__webglInit = !0), P.addEventListener('dispose', b));
    const le = P.source;
    let ge = d.get(le);
    ge === void 0 && ((ge = {}), d.set(le, ge));
    const se = O(P);
    if (se !== F.__cacheKey) {
      (ge[se] === void 0 &&
        ((ge[se] = { texture: n.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (Q = !0)),
        ge[se].usedTimes++);
      const Ke = ge[F.__cacheKey];
      (Ke !== void 0 &&
        (ge[F.__cacheKey].usedTimes--, Ke.usedTimes === 0 && w(P)),
        (F.__cacheKey = se),
        (F.__webglTexture = ge[se].texture));
    }
    return Q;
  }
  function Ae(F, P, Q) {
    return Math.floor(Math.floor(F / Q) / P);
  }
  function Oe(F, P, Q, le) {
    const se = F.updateRanges;
    if (se.length === 0)
      t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, P.width, P.height, Q, le, P.data);
    else {
      se.sort((we, Ce) => we.start - Ce.start);
      let Ke = 0;
      for (let we = 1; we < se.length; we++) {
        const Ce = se[Ke],
          ct = se[we],
          it = Ce.start + Ce.count,
          Le = Ae(ct.start, P.width, 4),
          et = Ae(Ce.start, P.width, 4);
        ct.start <= it + 1 &&
        Le === et &&
        Ae(ct.start + ct.count - 1, P.width, 4) === Le
          ? (Ce.count = Math.max(Ce.count, ct.start + ct.count - Ce.start))
          : (++Ke, (se[Ke] = ct));
      }
      se.length = Ke + 1;
      const Be = n.getParameter(n.UNPACK_ROW_LENGTH),
        at = n.getParameter(n.UNPACK_SKIP_PIXELS),
        Je = n.getParameter(n.UNPACK_SKIP_ROWS);
      n.pixelStorei(n.UNPACK_ROW_LENGTH, P.width);
      for (let we = 0, Ce = se.length; we < Ce; we++) {
        const ct = se[we],
          it = Math.floor(ct.start / 4),
          Le = Math.ceil(ct.count / 4),
          et = it % P.width,
          Y = Math.floor(it / P.width),
          re = Le,
          ke = 1;
        (n.pixelStorei(n.UNPACK_SKIP_PIXELS, et),
          n.pixelStorei(n.UNPACK_SKIP_ROWS, Y),
          t.texSubImage2D(n.TEXTURE_2D, 0, et, Y, re, ke, Q, le, P.data));
      }
      (F.clearUpdateRanges(),
        n.pixelStorei(n.UNPACK_ROW_LENGTH, Be),
        n.pixelStorei(n.UNPACK_SKIP_PIXELS, at),
        n.pixelStorei(n.UNPACK_SKIP_ROWS, Je));
    }
  }
  function Z(F, P, Q) {
    let le = n.TEXTURE_2D;
    ((P.isDataArrayTexture || P.isCompressedArrayTexture) &&
      (le = n.TEXTURE_2D_ARRAY),
      P.isData3DTexture && (le = n.TEXTURE_3D));
    const ge = Se(F, P),
      se = P.source;
    t.bindTexture(le, F.__webglTexture, n.TEXTURE0 + Q);
    const Ke = i.get(se);
    if (se.version !== Ke.__version || ge === !0) {
      t.activeTexture(n.TEXTURE0 + Q);
      const Be = kt.getPrimaries(kt.workingColorSpace),
        at = P.colorSpace === Sr ? null : kt.getPrimaries(P.colorSpace),
        Je =
          P.colorSpace === Sr || Be === at ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      (n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Je));
      let we = m(P.image, !1, r.maxTextureSize);
      we = Ne(P, we);
      const Ce = s.convert(P.format, P.colorSpace),
        ct = s.convert(P.type);
      let it = _(P.internalFormat, Ce, ct, P.colorSpace, P.isVideoTexture);
      ve(le, P);
      let Le;
      const et = P.mipmaps,
        Y = P.isVideoTexture !== !0,
        re = Ke.__version === void 0 || ge === !0,
        ke = se.dataReady,
        ze = S(P, we);
      if (P.isDepthTexture)
        ((it = x(P.format === Lo, P.type)),
          re &&
            (Y
              ? t.texStorage2D(n.TEXTURE_2D, 1, it, we.width, we.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  it,
                  we.width,
                  we.height,
                  0,
                  Ce,
                  ct,
                  null
                )));
      else if (P.isDataTexture)
        if (et.length > 0) {
          Y &&
            re &&
            t.texStorage2D(n.TEXTURE_2D, ze, it, et[0].width, et[0].height);
          for (let Ie = 0, be = et.length; Ie < be; Ie++)
            ((Le = et[Ie]),
              Y
                ? ke &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Ie,
                    0,
                    0,
                    Le.width,
                    Le.height,
                    Ce,
                    ct,
                    Le.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Ie,
                    it,
                    Le.width,
                    Le.height,
                    0,
                    Ce,
                    ct,
                    Le.data
                  ));
          P.generateMipmaps = !1;
        } else
          Y
            ? (re && t.texStorage2D(n.TEXTURE_2D, ze, it, we.width, we.height),
              ke && Oe(P, we, Ce, ct))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                it,
                we.width,
                we.height,
                0,
                Ce,
                ct,
                we.data
              );
      else if (P.isCompressedTexture)
        if (P.isCompressedArrayTexture) {
          Y &&
            re &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              ze,
              it,
              et[0].width,
              et[0].height,
              we.depth
            );
          for (let Ie = 0, be = et.length; Ie < be; Ie++)
            if (((Le = et[Ie]), P.format !== Rn))
              if (Ce !== null)
                if (Y) {
                  if (ke)
                    if (P.layerUpdates.size > 0) {
                      const tt = iy(Le.width, Le.height, P.format, P.type);
                      for (const vt of P.layerUpdates) {
                        const Qt = Le.data.subarray(
                          (vt * tt) / Le.data.BYTES_PER_ELEMENT,
                          ((vt + 1) * tt) / Le.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Ie,
                          0,
                          0,
                          vt,
                          Le.width,
                          Le.height,
                          1,
                          Ce,
                          Qt
                        );
                      }
                      P.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Ie,
                        0,
                        0,
                        0,
                        Le.width,
                        Le.height,
                        we.depth,
                        Ce,
                        Le.data
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ie,
                    it,
                    Le.width,
                    Le.height,
                    we.depth,
                    0,
                    Le.data,
                    0,
                    0
                  );
              else
                Ge(
                  'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                );
            else
              Y
                ? ke &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ie,
                    0,
                    0,
                    0,
                    Le.width,
                    Le.height,
                    we.depth,
                    Ce,
                    ct,
                    Le.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Ie,
                    it,
                    Le.width,
                    Le.height,
                    we.depth,
                    0,
                    Ce,
                    ct,
                    Le.data
                  );
        } else {
          Y &&
            re &&
            t.texStorage2D(n.TEXTURE_2D, ze, it, et[0].width, et[0].height);
          for (let Ie = 0, be = et.length; Ie < be; Ie++)
            ((Le = et[Ie]),
              P.format !== Rn
                ? Ce !== null
                  ? Y
                    ? ke &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Ie,
                        0,
                        0,
                        Le.width,
                        Le.height,
                        Ce,
                        Le.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Ie,
                        it,
                        Le.width,
                        Le.height,
                        0,
                        Le.data
                      )
                  : Ge(
                      'WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                    )
                : Y
                  ? ke &&
                    t.texSubImage2D(
                      n.TEXTURE_2D,
                      Ie,
                      0,
                      0,
                      Le.width,
                      Le.height,
                      Ce,
                      ct,
                      Le.data
                    )
                  : t.texImage2D(
                      n.TEXTURE_2D,
                      Ie,
                      it,
                      Le.width,
                      Le.height,
                      0,
                      Ce,
                      ct,
                      Le.data
                    ));
        }
      else if (P.isDataArrayTexture)
        if (Y) {
          if (
            (re &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                ze,
                it,
                we.width,
                we.height,
                we.depth
              ),
            ke)
          )
            if (P.layerUpdates.size > 0) {
              const Ie = iy(we.width, we.height, P.format, P.type);
              for (const be of P.layerUpdates) {
                const tt = we.data.subarray(
                  (be * Ie) / we.data.BYTES_PER_ELEMENT,
                  ((be + 1) * Ie) / we.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  be,
                  we.width,
                  we.height,
                  1,
                  Ce,
                  ct,
                  tt
                );
              }
              P.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                we.width,
                we.height,
                we.depth,
                Ce,
                ct,
                we.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            it,
            we.width,
            we.height,
            we.depth,
            0,
            Ce,
            ct,
            we.data
          );
      else if (P.isData3DTexture)
        Y
          ? (re &&
              t.texStorage3D(
                n.TEXTURE_3D,
                ze,
                it,
                we.width,
                we.height,
                we.depth
              ),
            ke &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                we.width,
                we.height,
                we.depth,
                Ce,
                ct,
                we.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              it,
              we.width,
              we.height,
              we.depth,
              0,
              Ce,
              ct,
              we.data
            );
      else if (P.isFramebufferTexture) {
        if (re)
          if (Y) t.texStorage2D(n.TEXTURE_2D, ze, it, we.width, we.height);
          else {
            let Ie = we.width,
              be = we.height;
            for (let tt = 0; tt < ze; tt++)
              (t.texImage2D(n.TEXTURE_2D, tt, it, Ie, be, 0, Ce, ct, null),
                (Ie >>= 1),
                (be >>= 1));
          }
      } else if (et.length > 0) {
        if (Y && re) {
          const Ie = We(et[0]);
          t.texStorage2D(n.TEXTURE_2D, ze, it, Ie.width, Ie.height);
        }
        for (let Ie = 0, be = et.length; Ie < be; Ie++)
          ((Le = et[Ie]),
            Y
              ? ke && t.texSubImage2D(n.TEXTURE_2D, Ie, 0, 0, Ce, ct, Le)
              : t.texImage2D(n.TEXTURE_2D, Ie, it, Ce, ct, Le));
        P.generateMipmaps = !1;
      } else if (Y) {
        if (re) {
          const Ie = We(we);
          t.texStorage2D(n.TEXTURE_2D, ze, it, Ie.width, Ie.height);
        }
        ke && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ce, ct, we);
      } else t.texImage2D(n.TEXTURE_2D, 0, it, Ce, ct, we);
      (g(P) && v(le), (Ke.__version = se.version), P.onUpdate && P.onUpdate(P));
    }
    F.__version = P.version;
  }
  function J(F, P, Q) {
    if (P.image.length !== 6) return;
    const le = Se(F, P),
      ge = P.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, F.__webglTexture, n.TEXTURE0 + Q);
    const se = i.get(ge);
    if (ge.version !== se.__version || le === !0) {
      t.activeTexture(n.TEXTURE0 + Q);
      const Ke = kt.getPrimaries(kt.workingColorSpace),
        Be = P.colorSpace === Sr ? null : kt.getPrimaries(P.colorSpace),
        at =
          P.colorSpace === Sr || Ke === Be ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      (n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, P.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, P.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, at));
      const Je = P.isCompressedTexture || P.image[0].isCompressedTexture,
        we = P.image[0] && P.image[0].isDataTexture,
        Ce = [];
      for (let be = 0; be < 6; be++)
        (!Je && !we
          ? (Ce[be] = m(P.image[be], !0, r.maxCubemapSize))
          : (Ce[be] = we ? P.image[be].image : P.image[be]),
          (Ce[be] = Ne(P, Ce[be])));
      const ct = Ce[0],
        it = s.convert(P.format, P.colorSpace),
        Le = s.convert(P.type),
        et = _(P.internalFormat, it, Le, P.colorSpace),
        Y = P.isVideoTexture !== !0,
        re = se.__version === void 0 || le === !0,
        ke = ge.dataReady;
      let ze = S(P, ct);
      ve(n.TEXTURE_CUBE_MAP, P);
      let Ie;
      if (Je) {
        Y &&
          re &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, ze, et, ct.width, ct.height);
        for (let be = 0; be < 6; be++) {
          Ie = Ce[be].mipmaps;
          for (let tt = 0; tt < Ie.length; tt++) {
            const vt = Ie[tt];
            P.format !== Rn
              ? it !== null
                ? Y
                  ? ke &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                      tt,
                      0,
                      0,
                      vt.width,
                      vt.height,
                      it,
                      vt.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                      tt,
                      et,
                      vt.width,
                      vt.height,
                      0,
                      vt.data
                    )
                : Ge(
                    'WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                  )
              : Y
                ? ke &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt,
                    0,
                    0,
                    vt.width,
                    vt.height,
                    it,
                    Le,
                    vt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt,
                    et,
                    vt.width,
                    vt.height,
                    0,
                    it,
                    Le,
                    vt.data
                  );
          }
        }
      } else {
        if (((Ie = P.mipmaps), Y && re)) {
          Ie.length > 0 && ze++;
          const be = We(Ce[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, ze, et, be.width, be.height);
        }
        for (let be = 0; be < 6; be++)
          if (we) {
            Y
              ? ke &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                  0,
                  0,
                  0,
                  Ce[be].width,
                  Ce[be].height,
                  it,
                  Le,
                  Ce[be].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                  0,
                  et,
                  Ce[be].width,
                  Ce[be].height,
                  0,
                  it,
                  Le,
                  Ce[be].data
                );
            for (let tt = 0; tt < Ie.length; tt++) {
              const Qt = Ie[tt].image[be].image;
              Y
                ? ke &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt + 1,
                    0,
                    0,
                    Qt.width,
                    Qt.height,
                    it,
                    Le,
                    Qt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt + 1,
                    et,
                    Qt.width,
                    Qt.height,
                    0,
                    it,
                    Le,
                    Qt.data
                  );
            }
          } else {
            Y
              ? ke &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                  0,
                  0,
                  0,
                  it,
                  Le,
                  Ce[be]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                  0,
                  et,
                  it,
                  Le,
                  Ce[be]
                );
            for (let tt = 0; tt < Ie.length; tt++) {
              const vt = Ie[tt];
              Y
                ? ke &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt + 1,
                    0,
                    0,
                    it,
                    Le,
                    vt.image[be]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + be,
                    tt + 1,
                    et,
                    it,
                    Le,
                    vt.image[be]
                  );
            }
          }
      }
      (g(P) && v(n.TEXTURE_CUBE_MAP),
        (se.__version = ge.version),
        P.onUpdate && P.onUpdate(P));
    }
    F.__version = P.version;
  }
  function de(F, P, Q, le, ge, se) {
    const Ke = s.convert(Q.format, Q.colorSpace),
      Be = s.convert(Q.type),
      at = _(Q.internalFormat, Ke, Be, Q.colorSpace),
      Je = i.get(P),
      we = i.get(Q);
    if (((we.__renderTarget = P), !Je.__hasExternalTextures)) {
      const Ce = Math.max(1, P.width >> se),
        ct = Math.max(1, P.height >> se);
      ge === n.TEXTURE_3D || ge === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(ge, se, at, Ce, ct, P.depth, 0, Ke, Be, null)
        : t.texImage2D(ge, se, at, Ce, ct, 0, Ke, Be, null);
    }
    (t.bindFramebuffer(n.FRAMEBUFFER, F),
      Ee(P)
        ? o.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            le,
            ge,
            we.__webglTexture,
            0,
            Te(P)
          )
        : (ge === n.TEXTURE_2D ||
            (ge >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              ge <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, le, ge, we.__webglTexture, se),
      t.bindFramebuffer(n.FRAMEBUFFER, null));
  }
  function fe(F, P, Q) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, F), P.depthBuffer)) {
      const le = P.depthTexture,
        ge = le && le.isDepthTexture ? le.type : null,
        se = x(P.stencilBuffer, ge),
        Ke = P.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Be = Te(P);
      (Ee(P)
        ? o.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Be,
            se,
            P.width,
            P.height
          )
        : Q
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Be,
              se,
              P.width,
              P.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, se, P.width, P.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Ke, n.RENDERBUFFER, F));
    } else {
      const le = P.textures;
      for (let ge = 0; ge < le.length; ge++) {
        const se = le[ge],
          Ke = s.convert(se.format, se.colorSpace),
          Be = s.convert(se.type),
          at = _(se.internalFormat, Ke, Be, se.colorSpace),
          Je = Te(P);
        Q && Ee(P) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Je,
              at,
              P.width,
              P.height
            )
          : Ee(P)
            ? o.renderbufferStorageMultisampleEXT(
                n.RENDERBUFFER,
                Je,
                at,
                P.width,
                P.height
              )
            : n.renderbufferStorage(n.RENDERBUFFER, at, P.width, P.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function K(F, P) {
    if (P && P.isWebGLCubeRenderTarget)
      throw new Error(
        'Depth Texture with cube render targets is not supported'
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, F),
      !(P.depthTexture && P.depthTexture.isDepthTexture))
    )
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
      );
    const le = i.get(P.depthTexture);
    ((le.__renderTarget = P),
      (!le.__webglTexture ||
        P.depthTexture.image.width !== P.width ||
        P.depthTexture.image.height !== P.height) &&
        ((P.depthTexture.image.width = P.width),
        (P.depthTexture.image.height = P.height),
        (P.depthTexture.needsUpdate = !0)),
      z(P.depthTexture, 0));
    const ge = le.__webglTexture,
      se = Te(P);
    if (P.depthTexture.format === nc)
      Ee(P)
        ? o.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ge,
            0,
            se
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ge,
            0
          );
    else if (P.depthTexture.format === Lo)
      Ee(P)
        ? o.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ge,
            0,
            se
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ge,
            0
          );
    else throw new Error('Unknown depthTexture format');
  }
  function oe(F) {
    const P = i.get(F),
      Q = F.isWebGLCubeRenderTarget === !0;
    if (P.__boundDepthTexture !== F.depthTexture) {
      const le = F.depthTexture;
      if ((P.__depthDisposeCallback && P.__depthDisposeCallback(), le)) {
        const ge = () => {
          (delete P.__boundDepthTexture,
            delete P.__depthDisposeCallback,
            le.removeEventListener('dispose', ge));
        };
        (le.addEventListener('dispose', ge), (P.__depthDisposeCallback = ge));
      }
      P.__boundDepthTexture = le;
    }
    if (F.depthTexture && !P.__autoAllocateDepthBuffer) {
      if (Q)
        throw new Error(
          'target.depthTexture not supported in Cube render targets'
        );
      const le = F.texture.mipmaps;
      le && le.length > 0
        ? K(P.__webglFramebuffer[0], F)
        : K(P.__webglFramebuffer, F);
    } else if (Q) {
      P.__webglDepthbuffer = [];
      for (let le = 0; le < 6; le++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[le]),
          P.__webglDepthbuffer[le] === void 0)
        )
          ((P.__webglDepthbuffer[le] = n.createRenderbuffer()),
            fe(P.__webglDepthbuffer[le], F, !1));
        else {
          const ge = F.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            se = P.__webglDepthbuffer[le];
          (n.bindRenderbuffer(n.RENDERBUFFER, se),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, ge, n.RENDERBUFFER, se));
        }
    } else {
      const le = F.texture.mipmaps;
      if (
        (le && le.length > 0
          ? t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer[0])
          : t.bindFramebuffer(n.FRAMEBUFFER, P.__webglFramebuffer),
        P.__webglDepthbuffer === void 0)
      )
        ((P.__webglDepthbuffer = n.createRenderbuffer()),
          fe(P.__webglDepthbuffer, F, !1));
      else {
        const ge = F.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          se = P.__webglDepthbuffer;
        (n.bindRenderbuffer(n.RENDERBUFFER, se),
          n.framebufferRenderbuffer(n.FRAMEBUFFER, ge, n.RENDERBUFFER, se));
      }
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function he(F, P, Q) {
    const le = i.get(F);
    (P !== void 0 &&
      de(
        le.__webglFramebuffer,
        F,
        F.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      Q !== void 0 && oe(F));
  }
  function xe(F) {
    const P = F.texture,
      Q = i.get(F),
      le = i.get(P);
    F.addEventListener('dispose', A);
    const ge = F.textures,
      se = F.isWebGLCubeRenderTarget === !0,
      Ke = ge.length > 1;
    if (
      (Ke ||
        (le.__webglTexture === void 0 &&
          (le.__webglTexture = n.createTexture()),
        (le.__version = P.version),
        a.memory.textures++),
      se)
    ) {
      Q.__webglFramebuffer = [];
      for (let Be = 0; Be < 6; Be++)
        if (P.mipmaps && P.mipmaps.length > 0) {
          Q.__webglFramebuffer[Be] = [];
          for (let at = 0; at < P.mipmaps.length; at++)
            Q.__webglFramebuffer[Be][at] = n.createFramebuffer();
        } else Q.__webglFramebuffer[Be] = n.createFramebuffer();
    } else {
      if (P.mipmaps && P.mipmaps.length > 0) {
        Q.__webglFramebuffer = [];
        for (let Be = 0; Be < P.mipmaps.length; Be++)
          Q.__webglFramebuffer[Be] = n.createFramebuffer();
      } else Q.__webglFramebuffer = n.createFramebuffer();
      if (Ke)
        for (let Be = 0, at = ge.length; Be < at; Be++) {
          const Je = i.get(ge[Be]);
          Je.__webglTexture === void 0 &&
            ((Je.__webglTexture = n.createTexture()), a.memory.textures++);
        }
      if (F.samples > 0 && Ee(F) === !1) {
        ((Q.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (Q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, Q.__webglMultisampledFramebuffer));
        for (let Be = 0; Be < ge.length; Be++) {
          const at = ge[Be];
          ((Q.__webglColorRenderbuffer[Be] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, Q.__webglColorRenderbuffer[Be]));
          const Je = s.convert(at.format, at.colorSpace),
            we = s.convert(at.type),
            Ce = _(
              at.internalFormat,
              Je,
              we,
              at.colorSpace,
              F.isXRRenderTarget === !0
            ),
            ct = Te(F);
          (n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            ct,
            Ce,
            F.width,
            F.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Be,
              n.RENDERBUFFER,
              Q.__webglColorRenderbuffer[Be]
            ));
        }
        (n.bindRenderbuffer(n.RENDERBUFFER, null),
          F.depthBuffer &&
            ((Q.__webglDepthRenderbuffer = n.createRenderbuffer()),
            fe(Q.__webglDepthRenderbuffer, F, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null));
      }
    }
    if (se) {
      (t.bindTexture(n.TEXTURE_CUBE_MAP, le.__webglTexture),
        ve(n.TEXTURE_CUBE_MAP, P));
      for (let Be = 0; Be < 6; Be++)
        if (P.mipmaps && P.mipmaps.length > 0)
          for (let at = 0; at < P.mipmaps.length; at++)
            de(
              Q.__webglFramebuffer[Be][at],
              F,
              P,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
              at
            );
        else
          de(
            Q.__webglFramebuffer[Be],
            F,
            P,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
            0
          );
      (g(P) && v(n.TEXTURE_CUBE_MAP), t.unbindTexture());
    } else if (Ke) {
      for (let Be = 0, at = ge.length; Be < at; Be++) {
        const Je = ge[Be],
          we = i.get(Je);
        let Ce = n.TEXTURE_2D;
        ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) &&
          (Ce = F.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
          t.bindTexture(Ce, we.__webglTexture),
          ve(Ce, Je),
          de(Q.__webglFramebuffer, F, Je, n.COLOR_ATTACHMENT0 + Be, Ce, 0),
          g(Je) && v(Ce));
      }
      t.unbindTexture();
    } else {
      let Be = n.TEXTURE_2D;
      if (
        ((F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) &&
          (Be = F.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Be, le.__webglTexture),
        ve(Be, P),
        P.mipmaps && P.mipmaps.length > 0)
      )
        for (let at = 0; at < P.mipmaps.length; at++)
          de(Q.__webglFramebuffer[at], F, P, n.COLOR_ATTACHMENT0, Be, at);
      else de(Q.__webglFramebuffer, F, P, n.COLOR_ATTACHMENT0, Be, 0);
      (g(P) && v(Be), t.unbindTexture());
    }
    F.depthBuffer && oe(F);
  }
  function ee(F) {
    const P = F.textures;
    for (let Q = 0, le = P.length; Q < le; Q++) {
      const ge = P[Q];
      if (g(ge)) {
        const se = y(F),
          Ke = i.get(ge).__webglTexture;
        (t.bindTexture(se, Ke), v(se), t.unbindTexture());
      }
    }
  }
  const B = [],
    me = [];
  function ye(F) {
    if (F.samples > 0) {
      if (Ee(F) === !1) {
        const P = F.textures,
          Q = F.width,
          le = F.height;
        let ge = n.COLOR_BUFFER_BIT;
        const se = F.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Ke = i.get(F),
          Be = P.length > 1;
        if (Be)
          for (let Je = 0; Je < P.length; Je++)
            (t.bindFramebuffer(
              n.FRAMEBUFFER,
              Ke.__webglMultisampledFramebuffer
            ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Je,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Je,
                n.TEXTURE_2D,
                null,
                0
              ));
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Ke.__webglMultisampledFramebuffer
        );
        const at = F.texture.mipmaps;
        at && at.length > 0
          ? t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer[0])
          : t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer);
        for (let Je = 0; Je < P.length; Je++) {
          if (
            (F.resolveDepthBuffer &&
              (F.depthBuffer && (ge |= n.DEPTH_BUFFER_BIT),
              F.stencilBuffer &&
                F.resolveStencilBuffer &&
                (ge |= n.STENCIL_BUFFER_BIT)),
            Be)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Ke.__webglColorRenderbuffer[Je]
            );
            const we = i.get(P[Je]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              we,
              0
            );
          }
          (n.blitFramebuffer(0, 0, Q, le, 0, 0, Q, le, ge, n.NEAREST),
            l === !0 &&
              ((B.length = 0),
              (me.length = 0),
              B.push(n.COLOR_ATTACHMENT0 + Je),
              F.depthBuffer &&
                F.resolveDepthBuffer === !1 &&
                (B.push(se),
                me.push(se),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, me)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, B)));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Be)
        )
          for (let Je = 0; Je < P.length; Je++) {
            (t.bindFramebuffer(
              n.FRAMEBUFFER,
              Ke.__webglMultisampledFramebuffer
            ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Je,
                n.RENDERBUFFER,
                Ke.__webglColorRenderbuffer[Je]
              ));
            const we = i.get(P[Je]).__webglTexture;
            (t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Je,
                n.TEXTURE_2D,
                we,
                0
              ));
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          Ke.__webglMultisampledFramebuffer
        );
      } else if (F.depthBuffer && F.resolveDepthBuffer === !1 && l) {
        const P = F.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [P]);
      }
    }
  }
  function Te(F) {
    return Math.min(r.maxSamples, F.samples);
  }
  function Ee(F) {
    const P = i.get(F);
    return (
      F.samples > 0 &&
      e.has('WEBGL_multisampled_render_to_texture') === !0 &&
      P.__useRenderToTexture !== !1
    );
  }
  function Xe(F) {
    const P = a.render.frame;
    u.get(F) !== P && (u.set(F, P), F.update());
  }
  function Ne(F, P) {
    const Q = F.colorSpace,
      le = F.format,
      ge = F.type;
    return (
      F.isCompressedTexture === !0 ||
        F.isVideoTexture === !0 ||
        (Q !== cr &&
          Q !== Sr &&
          (kt.getTransfer(Q) === Yt
            ? (le !== Rn || ge !== gn) &&
              Ge(
                'WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.'
              )
            : gt('WebGLTextures: Unsupported texture color space:', Q))),
      P
    );
  }
  function We(F) {
    return (
      typeof HTMLImageElement < 'u' && F instanceof HTMLImageElement
        ? ((c.width = F.naturalWidth || F.width),
          (c.height = F.naturalHeight || F.height))
        : typeof VideoFrame < 'u' && F instanceof VideoFrame
          ? ((c.width = F.displayWidth), (c.height = F.displayHeight))
          : ((c.width = F.width), (c.height = F.height)),
      c
    );
  }
  ((this.allocateTextureUnit = L),
    (this.resetTextureUnits = D),
    (this.setTexture2D = z),
    (this.setTexture2DArray = C),
    (this.setTexture3D = N),
    (this.setTextureCube = U),
    (this.rebindTextures = he),
    (this.setupRenderTarget = xe),
    (this.updateRenderTargetMipmap = ee),
    (this.updateMultisampleRenderTarget = ye),
    (this.setupDepthRenderbuffer = oe),
    (this.setupFrameBufferTexture = de),
    (this.useMultisampledRTT = Ee));
}
function O3(n, e) {
  function t(i, r = Sr) {
    let s;
    const a = kt.getTransfer(r);
    if (i === gn) return n.UNSIGNED_BYTE;
    if (i === Em) return n.UNSIGNED_SHORT_4_4_4_4;
    if (i === Am) return n.UNSIGNED_SHORT_5_5_5_1;
    if (i === Wx) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (i === jx) return n.UNSIGNED_INT_10F_11F_11F_REV;
    if (i === Sm) return n.BYTE;
    if (i === wm) return n.SHORT;
    if (i === tc) return n.UNSIGNED_SHORT;
    if (i === Bh) return n.INT;
    if (i === Mr) return n.UNSIGNED_INT;
    if (i === un) return n.FLOAT;
    if (i === Gn) return n.HALF_FLOAT;
    if (i === Xx) return n.ALPHA;
    if (i === qx) return n.RGB;
    if (i === Rn) return n.RGBA;
    if (i === nc) return n.DEPTH_COMPONENT;
    if (i === Lo) return n.DEPTH_STENCIL;
    if (i === Nh) return n.RED;
    if (i === Fh) return n.RED_INTEGER;
    if (i === Mm) return n.RG;
    if (i === Tm) return n.RG_INTEGER;
    if (i === Cm) return n.RGBA_INTEGER;
    if (i === Pu || i === Du || i === Ou || i === Lu)
      if (a === Yt)
        if (((s = e.get('WEBGL_compressed_texture_s3tc_srgb')), s !== null)) {
          if (i === Pu) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === Du) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === Ou) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Lu) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get('WEBGL_compressed_texture_s3tc')), s !== null)) {
        if (i === Pu) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === Du) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === Ou) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === Lu) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (i === gp || i === vp || i === _p || i === yp)
      if (((s = e.get('WEBGL_compressed_texture_pvrtc')), s !== null)) {
        if (i === gp) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === vp) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === _p) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === yp) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (i === xp || i === bp || i === Sp)
      if (((s = e.get('WEBGL_compressed_texture_etc')), s !== null)) {
        if (i === xp || i === bp)
          return a === Yt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (i === Sp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      i === wp ||
      i === Ep ||
      i === Ap ||
      i === Mp ||
      i === Tp ||
      i === Cp ||
      i === Rp ||
      i === Ip ||
      i === Pp ||
      i === Dp ||
      i === Op ||
      i === Lp ||
      i === Up ||
      i === kp
    )
      if (((s = e.get('WEBGL_compressed_texture_astc')), s !== null)) {
        if (i === wp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Ep)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Ap)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Mp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Tp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Cp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Rp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Ip)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Pp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Dp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Op)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Lp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Up)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === kp)
          return a === Yt
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (i === Bp || i === Np || i === Fp)
      if (((s = e.get('EXT_texture_compression_bptc')), s !== null)) {
        if (i === Bp)
          return a === Yt
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Np) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === Fp) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (i === zp || i === Vp || i === Hp || i === Gp)
      if (((s = e.get('EXT_texture_compression_rgtc')), s !== null)) {
        if (i === zp) return s.COMPRESSED_RED_RGTC1_EXT;
        if (i === Vp) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Hp) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Gp) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return i === Oo ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
  }
  return { convert: t };
}
const y$ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  x$ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class b$ {
  constructor() {
    ((this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0));
  }
  init(e, t) {
    if (this.texture === null) {
      const i = new ib(e.texture);
      ((e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) &&
        ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = i));
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        i = new rn({
          vertexShader: y$,
          fragmentShader: x$,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new hn(new da(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    ((this.texture = null), (this.mesh = null));
  }
  getDepthTexture() {
    return this.texture;
  }
}
class S$ extends Ki {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      a = null,
      o = 'local-floor',
      l = 1,
      c = null,
      u = null,
      h = null,
      d = null,
      f = null,
      p = null;
    const m = typeof XRWebGLBinding < 'u',
      g = new b$(),
      v = {},
      y = t.getContextAttributes();
    let _ = null,
      x = null;
    const S = [],
      b = [],
      A = new pe();
    let E = null;
    const w = new Vn();
    w.viewport = new Lt();
    const M = new Vn();
    M.viewport = new Lt();
    const T = [w, M],
      D = new S3();
    let L = null,
      O = null;
    ((this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Z) {
        let J = S[Z];
        return (
          J === void 0 && ((J = new Bf()), (S[Z] = J)),
          J.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Z) {
        let J = S[Z];
        return (J === void 0 && ((J = new Bf()), (S[Z] = J)), J.getGripSpace());
      }),
      (this.getHand = function (Z) {
        let J = S[Z];
        return (J === void 0 && ((J = new Bf()), (S[Z] = J)), J.getHandSpace());
      }));
    function z(Z) {
      const J = b.indexOf(Z.inputSource);
      if (J === -1) return;
      const de = S[J];
      de !== void 0 &&
        (de.update(Z.inputSource, Z.frame, c || a),
        de.dispatchEvent({ type: Z.type, data: Z.inputSource }));
    }
    function C() {
      (r.removeEventListener('select', z),
        r.removeEventListener('selectstart', z),
        r.removeEventListener('selectend', z),
        r.removeEventListener('squeeze', z),
        r.removeEventListener('squeezestart', z),
        r.removeEventListener('squeezeend', z),
        r.removeEventListener('end', C),
        r.removeEventListener('inputsourceschange', N));
      for (let Z = 0; Z < S.length; Z++) {
        const J = b[Z];
        J !== null && ((b[Z] = null), S[Z].disconnect(J));
      }
      ((L = null), (O = null), g.reset());
      for (const Z in v) delete v[Z];
      (e.setRenderTarget(_),
        (f = null),
        (d = null),
        (h = null),
        (r = null),
        (x = null),
        Oe.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(E),
        e.setSize(A.width, A.height, !1),
        i.dispatchEvent({ type: 'sessionend' }));
    }
    ((this.setFramebufferScaleFactor = function (Z) {
      ((s = Z),
        i.isPresenting === !0 &&
          Ge(
            'WebXRManager: Cannot change framebuffer scale while presenting.'
          ));
    }),
      (this.setReferenceSpaceType = function (Z) {
        ((o = Z),
          i.isPresenting === !0 &&
            Ge(
              'WebXRManager: Cannot change reference space type while presenting.'
            ));
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (Z) {
        c = Z;
      }),
      (this.getBaseLayer = function () {
        return d !== null ? d : f;
      }),
      (this.getBinding = function () {
        return (h === null && m && (h = new XRWebGLBinding(r, t)), h);
      }),
      (this.getFrame = function () {
        return p;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (Z) {
        if (((r = Z), r !== null)) {
          if (
            ((_ = e.getRenderTarget()),
            r.addEventListener('select', z),
            r.addEventListener('selectstart', z),
            r.addEventListener('selectend', z),
            r.addEventListener('squeeze', z),
            r.addEventListener('squeezestart', z),
            r.addEventListener('squeezeend', z),
            r.addEventListener('end', C),
            r.addEventListener('inputsourceschange', N),
            y.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (E = e.getPixelRatio()),
            e.getSize(A),
            m && 'createProjectionLayer' in XRWebGLBinding.prototype)
          ) {
            let de = null,
              fe = null,
              K = null;
            y.depth &&
              ((K = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (de = y.stencil ? Lo : nc),
              (fe = y.stencil ? Oo : Mr));
            const oe = { colorFormat: t.RGBA8, depthFormat: K, scaleFactor: s };
            ((h = this.getBinding()),
              (d = h.createProjectionLayer(oe)),
              r.updateRenderState({ layers: [d] }),
              e.setPixelRatio(1),
              e.setSize(d.textureWidth, d.textureHeight, !1),
              (x = new Sn(d.textureWidth, d.textureHeight, {
                format: Rn,
                type: gn,
                depthTexture: new Fm(
                  d.textureWidth,
                  d.textureHeight,
                  fe,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  de
                ),
                stencilBuffer: y.stencil,
                colorSpace: e.outputColorSpace,
                samples: y.antialias ? 4 : 0,
                resolveDepthBuffer: d.ignoreDepthValues === !1,
                resolveStencilBuffer: d.ignoreDepthValues === !1,
              })));
          } else {
            const de = {
              antialias: y.antialias,
              alpha: !0,
              depth: y.depth,
              stencil: y.stencil,
              framebufferScaleFactor: s,
            };
            ((f = new XRWebGLLayer(r, t, de)),
              r.updateRenderState({ baseLayer: f }),
              e.setPixelRatio(1),
              e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
              (x = new Sn(f.framebufferWidth, f.framebufferHeight, {
                format: Rn,
                type: gn,
                colorSpace: e.outputColorSpace,
                stencilBuffer: y.stencil,
                resolveDepthBuffer: f.ignoreDepthValues === !1,
                resolveStencilBuffer: f.ignoreDepthValues === !1,
              })));
          }
          ((x.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await r.requestReferenceSpace(o)),
            Oe.setContext(r),
            Oe.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: 'sessionstart' }));
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return g.getDepthTexture();
      }));
    function N(Z) {
      for (let J = 0; J < Z.removed.length; J++) {
        const de = Z.removed[J],
          fe = b.indexOf(de);
        fe >= 0 && ((b[fe] = null), S[fe].disconnect(de));
      }
      for (let J = 0; J < Z.added.length; J++) {
        const de = Z.added[J];
        let fe = b.indexOf(de);
        if (fe === -1) {
          for (let oe = 0; oe < S.length; oe++)
            if (oe >= b.length) {
              (b.push(de), (fe = oe));
              break;
            } else if (b[oe] === null) {
              ((b[oe] = de), (fe = oe));
              break;
            }
          if (fe === -1) break;
        }
        const K = S[fe];
        K && K.connect(de);
      }
    }
    const U = new V(),
      W = new V();
    function G(Z, J, de) {
      (U.setFromMatrixPosition(J.matrixWorld),
        W.setFromMatrixPosition(de.matrixWorld));
      const fe = U.distanceTo(W),
        K = J.projectionMatrix.elements,
        oe = de.projectionMatrix.elements,
        he = K[14] / (K[10] - 1),
        xe = K[14] / (K[10] + 1),
        ee = (K[9] + 1) / K[5],
        B = (K[9] - 1) / K[5],
        me = (K[8] - 1) / K[0],
        ye = (oe[8] + 1) / oe[0],
        Te = he * me,
        Ee = he * ye,
        Xe = fe / (-me + ye),
        Ne = Xe * -me;
      if (
        (J.matrixWorld.decompose(Z.position, Z.quaternion, Z.scale),
        Z.translateX(Ne),
        Z.translateZ(Xe),
        Z.matrixWorld.compose(Z.position, Z.quaternion, Z.scale),
        Z.matrixWorldInverse.copy(Z.matrixWorld).invert(),
        K[10] === -1)
      )
        (Z.projectionMatrix.copy(J.projectionMatrix),
          Z.projectionMatrixInverse.copy(J.projectionMatrixInverse));
      else {
        const We = he + Xe,
          F = xe + Xe,
          P = Te - Ne,
          Q = Ee + (fe - Ne),
          le = ((ee * xe) / F) * We,
          ge = ((B * xe) / F) * We;
        (Z.projectionMatrix.makePerspective(P, Q, le, ge, We, F),
          Z.projectionMatrixInverse.copy(Z.projectionMatrix).invert());
      }
    }
    function ne(Z, J) {
      (J === null
        ? Z.matrixWorld.copy(Z.matrix)
        : Z.matrixWorld.multiplyMatrices(J.matrixWorld, Z.matrix),
        Z.matrixWorldInverse.copy(Z.matrixWorld).invert());
    }
    this.updateCamera = function (Z) {
      if (r === null) return;
      let J = Z.near,
        de = Z.far;
      (g.texture !== null &&
        (g.depthNear > 0 && (J = g.depthNear),
        g.depthFar > 0 && (de = g.depthFar)),
        (D.near = M.near = w.near = J),
        (D.far = M.far = w.far = de),
        (L !== D.near || O !== D.far) &&
          (r.updateRenderState({ depthNear: D.near, depthFar: D.far }),
          (L = D.near),
          (O = D.far)),
        (D.layers.mask = Z.layers.mask | 6),
        (w.layers.mask = D.layers.mask & 3),
        (M.layers.mask = D.layers.mask & 5));
      const fe = Z.parent,
        K = D.cameras;
      ne(D, fe);
      for (let oe = 0; oe < K.length; oe++) ne(K[oe], fe);
      (K.length === 2
        ? G(D, w, M)
        : D.projectionMatrix.copy(w.projectionMatrix),
        ve(Z, D, fe));
    };
    function ve(Z, J, de) {
      (de === null
        ? Z.matrix.copy(J.matrixWorld)
        : (Z.matrix.copy(de.matrixWorld),
          Z.matrix.invert(),
          Z.matrix.multiply(J.matrixWorld)),
        Z.matrix.decompose(Z.position, Z.quaternion, Z.scale),
        Z.updateMatrixWorld(!0),
        Z.projectionMatrix.copy(J.projectionMatrix),
        Z.projectionMatrixInverse.copy(J.projectionMatrixInverse),
        Z.isPerspectiveCamera &&
          ((Z.fov = sc * 2 * Math.atan(1 / Z.projectionMatrix.elements[5])),
          (Z.zoom = 1)));
    }
    ((this.getCamera = function () {
      return D;
    }),
      (this.getFoveation = function () {
        if (!(d === null && f === null)) return l;
      }),
      (this.setFoveation = function (Z) {
        ((l = Z),
          d !== null && (d.fixedFoveation = Z),
          f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = Z));
      }),
      (this.hasDepthSensing = function () {
        return g.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return g.getMesh(D);
      }),
      (this.getCameraTexture = function (Z) {
        return v[Z];
      }));
    let Se = null;
    function Ae(Z, J) {
      if (((u = J.getViewerPose(c || a)), (p = J), u !== null)) {
        const de = u.views;
        f !== null &&
          (e.setRenderTargetFramebuffer(x, f.framebuffer),
          e.setRenderTarget(x));
        let fe = !1;
        de.length !== D.cameras.length && ((D.cameras.length = 0), (fe = !0));
        for (let xe = 0; xe < de.length; xe++) {
          const ee = de[xe];
          let B = null;
          if (f !== null) B = f.getViewport(ee);
          else {
            const ye = h.getViewSubImage(d, ee);
            ((B = ye.viewport),
              xe === 0 &&
                (e.setRenderTargetTextures(
                  x,
                  ye.colorTexture,
                  ye.depthStencilTexture
                ),
                e.setRenderTarget(x)));
          }
          let me = T[xe];
          (me === void 0 &&
            ((me = new Vn()),
            me.layers.enable(xe),
            (me.viewport = new Lt()),
            (T[xe] = me)),
            me.matrix.fromArray(ee.transform.matrix),
            me.matrix.decompose(me.position, me.quaternion, me.scale),
            me.projectionMatrix.fromArray(ee.projectionMatrix),
            me.projectionMatrixInverse.copy(me.projectionMatrix).invert(),
            me.viewport.set(B.x, B.y, B.width, B.height),
            xe === 0 &&
              (D.matrix.copy(me.matrix),
              D.matrix.decompose(D.position, D.quaternion, D.scale)),
            fe === !0 && D.cameras.push(me));
        }
        const K = r.enabledFeatures;
        if (
          K &&
          K.includes('depth-sensing') &&
          r.depthUsage == 'gpu-optimized' &&
          m
        ) {
          h = i.getBinding();
          const xe = h.getDepthInformation(de[0]);
          xe && xe.isValid && xe.texture && g.init(xe, r.renderState);
        }
        if (K && K.includes('camera-access') && m) {
          (e.state.unbindTexture(), (h = i.getBinding()));
          for (let xe = 0; xe < de.length; xe++) {
            const ee = de[xe].camera;
            if (ee) {
              let B = v[ee];
              B || ((B = new ib()), (v[ee] = B));
              const me = h.getCameraImage(ee);
              B.sourceTexture = me;
            }
          }
        }
      }
      for (let de = 0; de < S.length; de++) {
        const fe = b[de],
          K = S[de];
        fe !== null && K !== void 0 && K.update(fe, J, c || a);
      }
      (Se && Se(Z, J),
        J.detectedPlanes &&
          i.dispatchEvent({ type: 'planesdetected', data: J }),
        (p = null));
    }
    const Oe = new C3();
    (Oe.setAnimationLoop(Ae),
      (this.setAnimationLoop = function (Z) {
        Se = Z;
      }),
      (this.dispose = function () {}));
  }
}
const Qa = new Yi(),
  w$ = new pt();
function E$(n, e) {
  function t(g, v) {
    (g.matrixAutoUpdate === !0 && g.updateMatrix(), v.value.copy(g.matrix));
  }
  function i(g, v) {
    (v.color.getRGB(g.fogColor.value, T2(n)),
      v.isFog
        ? ((g.fogNear.value = v.near), (g.fogFar.value = v.far))
        : v.isFogExp2 && (g.fogDensity.value = v.density));
  }
  function r(g, v, y, _, x) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial
      ? s(g, v)
      : v.isMeshToonMaterial
        ? (s(g, v), h(g, v))
        : v.isMeshPhongMaterial
          ? (s(g, v), u(g, v))
          : v.isMeshStandardMaterial
            ? (s(g, v), d(g, v), v.isMeshPhysicalMaterial && f(g, v, x))
            : v.isMeshMatcapMaterial
              ? (s(g, v), p(g, v))
              : v.isMeshDepthMaterial
                ? s(g, v)
                : v.isMeshDistanceMaterial
                  ? (s(g, v), m(g, v))
                  : v.isMeshNormalMaterial
                    ? s(g, v)
                    : v.isLineBasicMaterial
                      ? (a(g, v), v.isLineDashedMaterial && o(g, v))
                      : v.isPointsMaterial
                        ? l(g, v, y, _)
                        : v.isSpriteMaterial
                          ? c(g, v)
                          : v.isShadowMaterial
                            ? (g.color.value.copy(v.color),
                              (g.opacity.value = v.opacity))
                            : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function s(g, v) {
    ((g.opacity.value = v.opacity),
      v.color && g.diffuse.value.copy(v.color),
      v.emissive &&
        g.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),
      v.map && ((g.map.value = v.map), t(v.map, g.mapTransform)),
      v.alphaMap &&
        ((g.alphaMap.value = v.alphaMap), t(v.alphaMap, g.alphaMapTransform)),
      v.bumpMap &&
        ((g.bumpMap.value = v.bumpMap),
        t(v.bumpMap, g.bumpMapTransform),
        (g.bumpScale.value = v.bumpScale),
        v.side === On && (g.bumpScale.value *= -1)),
      v.normalMap &&
        ((g.normalMap.value = v.normalMap),
        t(v.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(v.normalScale),
        v.side === On && g.normalScale.value.negate()),
      v.displacementMap &&
        ((g.displacementMap.value = v.displacementMap),
        t(v.displacementMap, g.displacementMapTransform),
        (g.displacementScale.value = v.displacementScale),
        (g.displacementBias.value = v.displacementBias)),
      v.emissiveMap &&
        ((g.emissiveMap.value = v.emissiveMap),
        t(v.emissiveMap, g.emissiveMapTransform)),
      v.specularMap &&
        ((g.specularMap.value = v.specularMap),
        t(v.specularMap, g.specularMapTransform)),
      v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest));
    const y = e.get(v),
      _ = y.envMap,
      x = y.envMapRotation;
    (_ &&
      ((g.envMap.value = _),
      Qa.copy(x),
      (Qa.x *= -1),
      (Qa.y *= -1),
      (Qa.z *= -1),
      _.isCubeTexture &&
        _.isRenderTargetTexture === !1 &&
        ((Qa.y *= -1), (Qa.z *= -1)),
      g.envMapRotation.value.setFromMatrix4(w$.makeRotationFromEuler(Qa)),
      (g.flipEnvMap.value =
        _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
      (g.reflectivity.value = v.reflectivity),
      (g.ior.value = v.ior),
      (g.refractionRatio.value = v.refractionRatio)),
      v.lightMap &&
        ((g.lightMap.value = v.lightMap),
        (g.lightMapIntensity.value = v.lightMapIntensity),
        t(v.lightMap, g.lightMapTransform)),
      v.aoMap &&
        ((g.aoMap.value = v.aoMap),
        (g.aoMapIntensity.value = v.aoMapIntensity),
        t(v.aoMap, g.aoMapTransform)));
  }
  function a(g, v) {
    (g.diffuse.value.copy(v.color),
      (g.opacity.value = v.opacity),
      v.map && ((g.map.value = v.map), t(v.map, g.mapTransform)));
  }
  function o(g, v) {
    ((g.dashSize.value = v.dashSize),
      (g.totalSize.value = v.dashSize + v.gapSize),
      (g.scale.value = v.scale));
  }
  function l(g, v, y, _) {
    (g.diffuse.value.copy(v.color),
      (g.opacity.value = v.opacity),
      (g.size.value = v.size * y),
      (g.scale.value = _ * 0.5),
      v.map && ((g.map.value = v.map), t(v.map, g.uvTransform)),
      v.alphaMap &&
        ((g.alphaMap.value = v.alphaMap), t(v.alphaMap, g.alphaMapTransform)),
      v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest));
  }
  function c(g, v) {
    (g.diffuse.value.copy(v.color),
      (g.opacity.value = v.opacity),
      (g.rotation.value = v.rotation),
      v.map && ((g.map.value = v.map), t(v.map, g.mapTransform)),
      v.alphaMap &&
        ((g.alphaMap.value = v.alphaMap), t(v.alphaMap, g.alphaMapTransform)),
      v.alphaTest > 0 && (g.alphaTest.value = v.alphaTest));
  }
  function u(g, v) {
    (g.specular.value.copy(v.specular),
      (g.shininess.value = Math.max(v.shininess, 1e-4)));
  }
  function h(g, v) {
    v.gradientMap && (g.gradientMap.value = v.gradientMap);
  }
  function d(g, v) {
    ((g.metalness.value = v.metalness),
      v.metalnessMap &&
        ((g.metalnessMap.value = v.metalnessMap),
        t(v.metalnessMap, g.metalnessMapTransform)),
      (g.roughness.value = v.roughness),
      v.roughnessMap &&
        ((g.roughnessMap.value = v.roughnessMap),
        t(v.roughnessMap, g.roughnessMapTransform)),
      v.envMap && (g.envMapIntensity.value = v.envMapIntensity));
  }
  function f(g, v, y) {
    ((g.ior.value = v.ior),
      v.sheen > 0 &&
        (g.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),
        (g.sheenRoughness.value = v.sheenRoughness),
        v.sheenColorMap &&
          ((g.sheenColorMap.value = v.sheenColorMap),
          t(v.sheenColorMap, g.sheenColorMapTransform)),
        v.sheenRoughnessMap &&
          ((g.sheenRoughnessMap.value = v.sheenRoughnessMap),
          t(v.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
      v.clearcoat > 0 &&
        ((g.clearcoat.value = v.clearcoat),
        (g.clearcoatRoughness.value = v.clearcoatRoughness),
        v.clearcoatMap &&
          ((g.clearcoatMap.value = v.clearcoatMap),
          t(v.clearcoatMap, g.clearcoatMapTransform)),
        v.clearcoatRoughnessMap &&
          ((g.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap),
          t(v.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        v.clearcoatNormalMap &&
          ((g.clearcoatNormalMap.value = v.clearcoatNormalMap),
          t(v.clearcoatNormalMap, g.clearcoatNormalMapTransform),
          g.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),
          v.side === On && g.clearcoatNormalScale.value.negate())),
      v.dispersion > 0 && (g.dispersion.value = v.dispersion),
      v.iridescence > 0 &&
        ((g.iridescence.value = v.iridescence),
        (g.iridescenceIOR.value = v.iridescenceIOR),
        (g.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0]),
        (g.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1]),
        v.iridescenceMap &&
          ((g.iridescenceMap.value = v.iridescenceMap),
          t(v.iridescenceMap, g.iridescenceMapTransform)),
        v.iridescenceThicknessMap &&
          ((g.iridescenceThicknessMap.value = v.iridescenceThicknessMap),
          t(v.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
      v.transmission > 0 &&
        ((g.transmission.value = v.transmission),
        (g.transmissionSamplerMap.value = y.texture),
        g.transmissionSamplerSize.value.set(y.width, y.height),
        v.transmissionMap &&
          ((g.transmissionMap.value = v.transmissionMap),
          t(v.transmissionMap, g.transmissionMapTransform)),
        (g.thickness.value = v.thickness),
        v.thicknessMap &&
          ((g.thicknessMap.value = v.thicknessMap),
          t(v.thicknessMap, g.thicknessMapTransform)),
        (g.attenuationDistance.value = v.attenuationDistance),
        g.attenuationColor.value.copy(v.attenuationColor)),
      v.anisotropy > 0 &&
        (g.anisotropyVector.value.set(
          v.anisotropy * Math.cos(v.anisotropyRotation),
          v.anisotropy * Math.sin(v.anisotropyRotation)
        ),
        v.anisotropyMap &&
          ((g.anisotropyMap.value = v.anisotropyMap),
          t(v.anisotropyMap, g.anisotropyMapTransform))),
      (g.specularIntensity.value = v.specularIntensity),
      g.specularColor.value.copy(v.specularColor),
      v.specularColorMap &&
        ((g.specularColorMap.value = v.specularColorMap),
        t(v.specularColorMap, g.specularColorMapTransform)),
      v.specularIntensityMap &&
        ((g.specularIntensityMap.value = v.specularIntensityMap),
        t(v.specularIntensityMap, g.specularIntensityMapTransform)));
  }
  function p(g, v) {
    v.matcap && (g.matcap.value = v.matcap);
  }
  function m(g, v) {
    const y = e.get(v).light;
    (g.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (g.nearDistance.value = y.shadow.camera.near),
      (g.farDistance.value = y.shadow.camera.far));
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function A$(n, e, t, i) {
  let r = {},
    s = {},
    a = [];
  const o = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, _) {
    const x = _.program;
    i.uniformBlockBinding(y, x);
  }
  function c(y, _) {
    let x = r[y.id];
    x === void 0 &&
      (p(y), (x = u(y)), (r[y.id] = x), y.addEventListener('dispose', g));
    const S = _.program;
    i.updateUBOMapping(y, S);
    const b = e.render.frame;
    s[y.id] !== b && (d(y), (s[y.id] = b));
  }
  function u(y) {
    const _ = h();
    y.__bindingPointIndex = _;
    const x = n.createBuffer(),
      S = y.__size,
      b = y.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, x),
      n.bufferData(n.UNIFORM_BUFFER, S, b),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, _, x),
      x
    );
  }
  function h() {
    for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return (a.push(y), y);
    return (
      gt(
        'WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'
      ),
      0
    );
  }
  function d(y) {
    const _ = r[y.id],
      x = y.uniforms,
      S = y.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, _);
    for (let b = 0, A = x.length; b < A; b++) {
      const E = Array.isArray(x[b]) ? x[b] : [x[b]];
      for (let w = 0, M = E.length; w < M; w++) {
        const T = E[w];
        if (f(T, b, w, S) === !0) {
          const D = T.__offset,
            L = Array.isArray(T.value) ? T.value : [T.value];
          let O = 0;
          for (let z = 0; z < L.length; z++) {
            const C = L[z],
              N = m(C);
            typeof C == 'number' || typeof C == 'boolean'
              ? ((T.__data[0] = C),
                n.bufferSubData(n.UNIFORM_BUFFER, D + O, T.__data))
              : C.isMatrix3
                ? ((T.__data[0] = C.elements[0]),
                  (T.__data[1] = C.elements[1]),
                  (T.__data[2] = C.elements[2]),
                  (T.__data[3] = 0),
                  (T.__data[4] = C.elements[3]),
                  (T.__data[5] = C.elements[4]),
                  (T.__data[6] = C.elements[5]),
                  (T.__data[7] = 0),
                  (T.__data[8] = C.elements[6]),
                  (T.__data[9] = C.elements[7]),
                  (T.__data[10] = C.elements[8]),
                  (T.__data[11] = 0))
                : (C.toArray(T.__data, O),
                  (O += N.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, D, T.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function f(y, _, x, S) {
    const b = y.value,
      A = _ + '_' + x;
    if (S[A] === void 0)
      return (
        typeof b == 'number' || typeof b == 'boolean'
          ? (S[A] = b)
          : (S[A] = b.clone()),
        !0
      );
    {
      const E = S[A];
      if (typeof b == 'number' || typeof b == 'boolean') {
        if (E !== b) return ((S[A] = b), !0);
      } else if (E.equals(b) === !1) return (E.copy(b), !0);
    }
    return !1;
  }
  function p(y) {
    const _ = y.uniforms;
    let x = 0;
    const S = 16;
    for (let A = 0, E = _.length; A < E; A++) {
      const w = Array.isArray(_[A]) ? _[A] : [_[A]];
      for (let M = 0, T = w.length; M < T; M++) {
        const D = w[M],
          L = Array.isArray(D.value) ? D.value : [D.value];
        for (let O = 0, z = L.length; O < z; O++) {
          const C = L[O],
            N = m(C),
            U = x % S,
            W = U % N.boundary,
            G = U + W;
          ((x += W),
            G !== 0 && S - G < N.storage && (x += S - G),
            (D.__data = new Float32Array(
              N.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (D.__offset = x),
            (x += N.storage));
        }
      }
    }
    const b = x % S;
    return (b > 0 && (x += S - b), (y.__size = x), (y.__cache = {}), this);
  }
  function m(y) {
    const _ = { boundary: 0, storage: 0 };
    return (
      typeof y == 'number' || typeof y == 'boolean'
        ? ((_.boundary = 4), (_.storage = 4))
        : y.isVector2
          ? ((_.boundary = 8), (_.storage = 8))
          : y.isVector3 || y.isColor
            ? ((_.boundary = 16), (_.storage = 12))
            : y.isVector4
              ? ((_.boundary = 16), (_.storage = 16))
              : y.isMatrix3
                ? ((_.boundary = 48), (_.storage = 48))
                : y.isMatrix4
                  ? ((_.boundary = 64), (_.storage = 64))
                  : y.isTexture
                    ? Ge(
                        'WebGLRenderer: Texture samplers can not be part of an uniforms group.'
                      )
                    : Ge('WebGLRenderer: Unsupported uniform value type.', y),
      _
    );
  }
  function g(y) {
    const _ = y.target;
    _.removeEventListener('dispose', g);
    const x = a.indexOf(_.__bindingPointIndex);
    (a.splice(x, 1), n.deleteBuffer(r[_.id]), delete r[_.id], delete s[_.id]);
  }
  function v() {
    for (const y in r) n.deleteBuffer(r[y]);
    ((a = []), (r = {}), (s = {}));
  }
  return { bind: l, update: c, dispose: v };
}
const M$ = new Uint16Array([
  11481, 15204, 11534, 15171, 11808, 15015, 12385, 14843, 12894, 14716, 13396,
  14600, 13693, 14483, 13976, 14366, 14237, 14171, 14405, 13961, 14511, 13770,
  14605, 13598, 14687, 13444, 14760, 13305, 14822, 13066, 14876, 12857, 14923,
  12675, 14963, 12517, 14997, 12379, 15025, 12230, 15049, 12023, 15070, 11843,
  15086, 11687, 15100, 11551, 15111, 11433, 15120, 11330, 15127, 11217, 15132,
  11060, 15135, 10922, 15138, 10801, 15139, 10695, 15139, 10600, 13012, 14923,
  13020, 14917, 13064, 14886, 13176, 14800, 13349, 14666, 13513, 14526, 13724,
  14398, 13960, 14230, 14200, 14020, 14383, 13827, 14488, 13651, 14583, 13491,
  14667, 13348, 14740, 13132, 14803, 12908, 14856, 12713, 14901, 12542, 14938,
  12394, 14968, 12241, 14992, 12017, 15010, 11822, 15024, 11654, 15034, 11507,
  15041, 11380, 15044, 11269, 15044, 11081, 15042, 10913, 15037, 10764, 15031,
  10635, 15023, 10520, 15014, 10419, 15003, 10330, 13657, 14676, 13658, 14673,
  13670, 14660, 13698, 14622, 13750, 14547, 13834, 14442, 13956, 14317, 14112,
  14093, 14291, 13889, 14407, 13704, 14499, 13538, 14586, 13389, 14664, 13201,
  14733, 12966, 14792, 12758, 14842, 12577, 14882, 12418, 14915, 12272, 14940,
  12033, 14959, 11826, 14972, 11646, 14980, 11490, 14983, 11355, 14983, 11212,
  14979, 11008, 14971, 10830, 14961, 10675, 14950, 10540, 14936, 10420, 14923,
  10315, 14909, 10204, 14894, 10041, 14089, 14460, 14090, 14459, 14096, 14452,
  14112, 14431, 14141, 14388, 14186, 14305, 14252, 14130, 14341, 13941, 14399,
  13756, 14467, 13585, 14539, 13430, 14610, 13272, 14677, 13026, 14737, 12808,
  14790, 12617, 14833, 12449, 14869, 12303, 14896, 12065, 14916, 11845, 14929,
  11655, 14937, 11490, 14939, 11347, 14936, 11184, 14930, 10970, 14921, 10783,
  14912, 10621, 14900, 10480, 14885, 10356, 14867, 10247, 14848, 10062, 14827,
  9894, 14805, 9745, 14400, 14208, 14400, 14206, 14402, 14198, 14406, 14174,
  14415, 14122, 14427, 14035, 14444, 13913, 14469, 13767, 14504, 13613, 14548,
  13463, 14598, 13324, 14651, 13082, 14704, 12858, 14752, 12658, 14795, 12483,
  14831, 12330, 14860, 12106, 14881, 11875, 14895, 11675, 14903, 11501, 14905,
  11351, 14903, 11178, 14900, 10953, 14892, 10757, 14880, 10589, 14865, 10442,
  14847, 10313, 14827, 10162, 14805, 9965, 14782, 9792, 14757, 9642, 14731,
  9507, 14562, 13883, 14562, 13883, 14563, 13877, 14566, 13862, 14570, 13830,
  14576, 13773, 14584, 13689, 14595, 13582, 14613, 13461, 14637, 13336, 14668,
  13120, 14704, 12897, 14741, 12695, 14776, 12516, 14808, 12358, 14835, 12150,
  14856, 11910, 14870, 11701, 14878, 11519, 14882, 11361, 14884, 11187, 14880,
  10951, 14871, 10748, 14858, 10572, 14842, 10418, 14823, 10286, 14801, 10099,
  14777, 9897, 14751, 9722, 14725, 9567, 14696, 9430, 14666, 9309, 14702, 13604,
  14702, 13604, 14702, 13600, 14703, 13591, 14705, 13570, 14707, 13533, 14709,
  13477, 14712, 13400, 14718, 13305, 14727, 13106, 14743, 12907, 14762, 12716,
  14784, 12539, 14807, 12380, 14827, 12190, 14844, 11943, 14855, 11727, 14863,
  11539, 14870, 11376, 14871, 11204, 14868, 10960, 14858, 10748, 14845, 10565,
  14829, 10406, 14809, 10269, 14786, 10058, 14761, 9852, 14734, 9671, 14705,
  9512, 14674, 9374, 14641, 9253, 14608, 9076, 14821, 13366, 14821, 13365,
  14821, 13364, 14821, 13358, 14821, 13344, 14821, 13320, 14819, 13252, 14817,
  13145, 14815, 13011, 14814, 12858, 14817, 12698, 14823, 12539, 14832, 12389,
  14841, 12214, 14850, 11968, 14856, 11750, 14861, 11558, 14866, 11390, 14867,
  11226, 14862, 10972, 14853, 10754, 14840, 10565, 14823, 10401, 14803, 10259,
  14780, 10032, 14754, 9820, 14725, 9635, 14694, 9473, 14661, 9333, 14627, 9203,
  14593, 8988, 14557, 8798, 14923, 13014, 14922, 13014, 14922, 13012, 14922,
  13004, 14920, 12987, 14919, 12957, 14915, 12907, 14909, 12834, 14902, 12738,
  14894, 12623, 14888, 12498, 14883, 12370, 14880, 12203, 14878, 11970, 14875,
  11759, 14873, 11569, 14874, 11401, 14872, 11243, 14865, 10986, 14855, 10762,
  14842, 10568, 14825, 10401, 14804, 10255, 14781, 10017, 14754, 9799, 14725,
  9611, 14692, 9445, 14658, 9301, 14623, 9139, 14587, 8920, 14548, 8729, 14509,
  8562, 15008, 12672, 15008, 12672, 15008, 12671, 15007, 12667, 15005, 12656,
  15001, 12637, 14997, 12605, 14989, 12556, 14978, 12490, 14966, 12407, 14953,
  12313, 14940, 12136, 14927, 11934, 14914, 11742, 14903, 11563, 14896, 11401,
  14889, 11247, 14879, 10992, 14866, 10767, 14851, 10570, 14833, 10400, 14812,
  10252, 14789, 10007, 14761, 9784, 14731, 9592, 14698, 9424, 14663, 9279,
  14627, 9088, 14588, 8868, 14548, 8676, 14508, 8508, 14467, 8360, 15080, 12386,
  15080, 12386, 15079, 12385, 15078, 12383, 15076, 12378, 15072, 12367, 15066,
  12347, 15057, 12315, 15045, 12253, 15030, 12138, 15012, 11998, 14993, 11845,
  14972, 11685, 14951, 11530, 14935, 11383, 14920, 11228, 14904, 10981, 14887,
  10762, 14870, 10567, 14850, 10397, 14827, 10248, 14803, 9997, 14774, 9771,
  14743, 9578, 14710, 9407, 14674, 9259, 14637, 9048, 14596, 8826, 14555, 8632,
  14514, 8464, 14471, 8317, 14427, 8182, 15139, 12008, 15139, 12008, 15138,
  12008, 15137, 12007, 15135, 12003, 15130, 11990, 15124, 11969, 15115, 11929,
  15102, 11872, 15086, 11794, 15064, 11693, 15041, 11581, 15013, 11459, 14987,
  11336, 14966, 11170, 14944, 10944, 14921, 10738, 14898, 10552, 14875, 10387,
  14850, 10239, 14824, 9983, 14794, 9758, 14762, 9563, 14728, 9392, 14692, 9244,
  14653, 9014, 14611, 8791, 14569, 8597, 14526, 8427, 14481, 8281, 14436, 8110,
  14391, 7885, 15188, 11617, 15188, 11617, 15187, 11617, 15186, 11618, 15183,
  11617, 15179, 11612, 15173, 11601, 15163, 11581, 15150, 11546, 15133, 11495,
  15110, 11427, 15083, 11346, 15051, 11246, 15024, 11057, 14996, 10868, 14967,
  10687, 14938, 10517, 14911, 10362, 14882, 10206, 14853, 9956, 14821, 9737,
  14787, 9543, 14752, 9375, 14715, 9228, 14675, 8980, 14632, 8760, 14589, 8565,
  14544, 8395, 14498, 8248, 14451, 8049, 14404, 7824, 14357, 7630, 15228, 11298,
  15228, 11298, 15227, 11299, 15226, 11301, 15223, 11303, 15219, 11302, 15213,
  11299, 15204, 11290, 15191, 11271, 15174, 11217, 15150, 11129, 15119, 11015,
  15087, 10886, 15057, 10744, 15024, 10599, 14990, 10455, 14957, 10318, 14924,
  10143, 14891, 9911, 14856, 9701, 14820, 9516, 14782, 9352, 14744, 9200, 14703,
  8946, 14659, 8725, 14615, 8533, 14568, 8366, 14521, 8220, 14472, 7992, 14423,
  7770, 14374, 7578, 14315, 7408, 15260, 10819, 15260, 10819, 15259, 10822,
  15258, 10826, 15256, 10832, 15251, 10836, 15246, 10841, 15237, 10838, 15225,
  10821, 15207, 10788, 15183, 10734, 15151, 10660, 15120, 10571, 15087, 10469,
  15049, 10359, 15012, 10249, 14974, 10041, 14937, 9837, 14900, 9647, 14860,
  9475, 14820, 9320, 14779, 9147, 14736, 8902, 14691, 8688, 14646, 8499, 14598,
  8335, 14549, 8189, 14499, 7940, 14448, 7720, 14397, 7529, 14347, 7363, 14256,
  7218, 15285, 10410, 15285, 10411, 15285, 10413, 15284, 10418, 15282, 10425,
  15278, 10434, 15272, 10442, 15264, 10449, 15252, 10445, 15235, 10433, 15210,
  10403, 15179, 10358, 15149, 10301, 15113, 10218, 15073, 10059, 15033, 9894,
  14991, 9726, 14951, 9565, 14909, 9413, 14865, 9273, 14822, 9073, 14777, 8845,
  14730, 8641, 14682, 8459, 14633, 8300, 14583, 8129, 14531, 7883, 14479, 7670,
  14426, 7482, 14373, 7321, 14305, 7176, 14201, 6939, 15305, 9939, 15305, 9940,
  15305, 9945, 15304, 9955, 15302, 9967, 15298, 9989, 15293, 10010, 15286,
  10033, 15274, 10044, 15258, 10045, 15233, 10022, 15205, 9975, 15174, 9903,
  15136, 9808, 15095, 9697, 15053, 9578, 15009, 9451, 14965, 9327, 14918, 9198,
  14871, 8973, 14825, 8766, 14775, 8579, 14725, 8408, 14675, 8259, 14622, 8058,
  14569, 7821, 14515, 7615, 14460, 7435, 14405, 7276, 14350, 7108, 14256, 6866,
  14149, 6653, 15321, 9444, 15321, 9445, 15321, 9448, 15320, 9458, 15317, 9470,
  15314, 9490, 15310, 9515, 15302, 9540, 15292, 9562, 15276, 9579, 15251, 9577,
  15226, 9559, 15195, 9519, 15156, 9463, 15116, 9389, 15071, 9304, 15025, 9208,
  14978, 9023, 14927, 8838, 14878, 8661, 14827, 8496, 14774, 8344, 14722, 8206,
  14667, 7973, 14612, 7749, 14556, 7555, 14499, 7382, 14443, 7229, 14385, 7025,
  14322, 6791, 14210, 6588, 14100, 6409, 15333, 8920, 15333, 8921, 15332, 8927,
  15332, 8943, 15329, 8965, 15326, 9002, 15322, 9048, 15316, 9106, 15307, 9162,
  15291, 9204, 15267, 9221, 15244, 9221, 15212, 9196, 15175, 9134, 15133, 9043,
  15088, 8930, 15040, 8801, 14990, 8665, 14938, 8526, 14886, 8391, 14830, 8261,
  14775, 8087, 14719, 7866, 14661, 7664, 14603, 7482, 14544, 7322, 14485, 7178,
  14426, 6936, 14367, 6713, 14281, 6517, 14166, 6348, 14054, 6198, 15341, 8360,
  15341, 8361, 15341, 8366, 15341, 8379, 15339, 8399, 15336, 8431, 15332, 8473,
  15326, 8527, 15318, 8585, 15302, 8632, 15281, 8670, 15258, 8690, 15227, 8690,
  15191, 8664, 15149, 8612, 15104, 8543, 15055, 8456, 15001, 8360, 14948, 8259,
  14892, 8122, 14834, 7923, 14776, 7734, 14716, 7558, 14656, 7397, 14595, 7250,
  14534, 7070, 14472, 6835, 14410, 6628, 14350, 6443, 14243, 6283, 14125, 6135,
  14010, 5889, 15348, 7715, 15348, 7717, 15348, 7725, 15347, 7745, 15345, 7780,
  15343, 7836, 15339, 7905, 15334, 8e3, 15326, 8103, 15310, 8193, 15293, 8239,
  15270, 8270, 15240, 8287, 15204, 8283, 15163, 8260, 15118, 8223, 15067, 8143,
  15014, 8014, 14958, 7873, 14899, 7723, 14839, 7573, 14778, 7430, 14715, 7293,
  14652, 7164, 14588, 6931, 14524, 6720, 14460, 6531, 14396, 6362, 14330, 6210,
  14207, 6015, 14086, 5781, 13969, 5576, 15352, 7114, 15352, 7116, 15352, 7128,
  15352, 7159, 15350, 7195, 15348, 7237, 15345, 7299, 15340, 7374, 15332, 7457,
  15317, 7544, 15301, 7633, 15280, 7703, 15251, 7754, 15216, 7775, 15176, 7767,
  15131, 7733, 15079, 7670, 15026, 7588, 14967, 7492, 14906, 7387, 14844, 7278,
  14779, 7171, 14714, 6965, 14648, 6770, 14581, 6587, 14515, 6420, 14448, 6269,
  14382, 6123, 14299, 5881, 14172, 5665, 14049, 5477, 13929, 5310, 15355, 6329,
  15355, 6330, 15355, 6339, 15355, 6362, 15353, 6410, 15351, 6472, 15349, 6572,
  15344, 6688, 15337, 6835, 15323, 6985, 15309, 7142, 15287, 7220, 15260, 7277,
  15226, 7310, 15188, 7326, 15142, 7318, 15090, 7285, 15036, 7239, 14976, 7177,
  14914, 7045, 14849, 6892, 14782, 6736, 14714, 6581, 14645, 6433, 14576, 6293,
  14506, 6164, 14438, 5946, 14369, 5733, 14270, 5540, 14140, 5369, 14014, 5216,
  13892, 5043, 15357, 5483, 15357, 5484, 15357, 5496, 15357, 5528, 15356, 5597,
  15354, 5692, 15351, 5835, 15347, 6011, 15339, 6195, 15328, 6317, 15314, 6446,
  15293, 6566, 15268, 6668, 15235, 6746, 15197, 6796, 15152, 6811, 15101, 6790,
  15046, 6748, 14985, 6673, 14921, 6583, 14854, 6479, 14785, 6371, 14714, 6259,
  14643, 6149, 14571, 5946, 14499, 5750, 14428, 5567, 14358, 5401, 14242, 5250,
  14109, 5111, 13980, 4870, 13856, 4657, 15359, 4555, 15359, 4557, 15358, 4573,
  15358, 4633, 15357, 4715, 15355, 4841, 15353, 5061, 15349, 5216, 15342, 5391,
  15331, 5577, 15318, 5770, 15299, 5967, 15274, 6150, 15243, 6223, 15206, 6280,
  15161, 6310, 15111, 6317, 15055, 6300, 14994, 6262, 14928, 6208, 14860, 6141,
  14788, 5994, 14715, 5838, 14641, 5684, 14566, 5529, 14492, 5384, 14418, 5247,
  14346, 5121, 14216, 4892, 14079, 4682, 13948, 4496, 13822, 4330, 15359, 3498,
  15359, 3501, 15359, 3520, 15359, 3598, 15358, 3719, 15356, 3860, 15355, 4137,
  15351, 4305, 15344, 4563, 15334, 4809, 15321, 5116, 15303, 5273, 15280, 5418,
  15250, 5547, 15214, 5653, 15170, 5722, 15120, 5761, 15064, 5763, 15002, 5733,
  14935, 5673, 14865, 5597, 14792, 5504, 14716, 5400, 14640, 5294, 14563, 5185,
  14486, 5041, 14410, 4841, 14335, 4655, 14191, 4482, 14051, 4325, 13918, 4183,
  13790, 4012, 15360, 2282, 15360, 2285, 15360, 2306, 15360, 2401, 15359, 2547,
  15357, 2748, 15355, 3103, 15352, 3349, 15345, 3675, 15336, 4020, 15324, 4272,
  15307, 4496, 15285, 4716, 15255, 4908, 15220, 5086, 15178, 5170, 15128, 5214,
  15072, 5234, 15010, 5231, 14943, 5206, 14871, 5166, 14796, 5102, 14718, 4971,
  14639, 4833, 14559, 4687, 14480, 4541, 14402, 4401, 14315, 4268, 14167, 4142,
  14025, 3958, 13888, 3747, 13759, 3556, 15360, 923, 15360, 925, 15360, 946,
  15360, 1052, 15359, 1214, 15357, 1494, 15356, 1892, 15352, 2274, 15346, 2663,
  15338, 3099, 15326, 3393, 15309, 3679, 15288, 3980, 15260, 4183, 15226, 4325,
  15185, 4437, 15136, 4517, 15080, 4570, 15018, 4591, 14950, 4581, 14877, 4545,
  14800, 4485, 14720, 4411, 14638, 4325, 14556, 4231, 14475, 4136, 14395, 3988,
  14297, 3803, 14145, 3628, 13999, 3465, 13861, 3314, 13729, 3177, 15360, 263,
  15360, 264, 15360, 272, 15360, 325, 15359, 407, 15358, 548, 15356, 780, 15352,
  1144, 15347, 1580, 15339, 2099, 15328, 2425, 15312, 2795, 15292, 3133, 15264,
  3329, 15232, 3517, 15191, 3689, 15143, 3819, 15088, 3923, 15025, 3978, 14956,
  3999, 14882, 3979, 14804, 3931, 14722, 3855, 14639, 3756, 14554, 3645, 14470,
  3529, 14388, 3409, 14279, 3289, 14124, 3173, 13975, 3055, 13834, 2848, 13701,
  2658, 15360, 49, 15360, 49, 15360, 52, 15360, 75, 15359, 111, 15358, 201,
  15356, 283, 15353, 519, 15348, 726, 15340, 1045, 15329, 1415, 15314, 1795,
  15295, 2173, 15269, 2410, 15237, 2649, 15197, 2866, 15150, 3054, 15095, 3140,
  15032, 3196, 14963, 3228, 14888, 3236, 14808, 3224, 14725, 3191, 14639, 3146,
  14553, 3088, 14466, 2976, 14382, 2836, 14262, 2692, 14103, 2549, 13952, 2409,
  13808, 2278, 13674, 2154, 15360, 4, 15360, 4, 15360, 4, 15360, 13, 15359, 33,
  15358, 59, 15357, 112, 15353, 199, 15348, 302, 15341, 456, 15331, 628, 15316,
  827, 15297, 1082, 15272, 1332, 15241, 1601, 15202, 1851, 15156, 2069, 15101,
  2172, 15039, 2256, 14970, 2314, 14894, 2348, 14813, 2358, 14728, 2344, 14640,
  2311, 14551, 2263, 14463, 2203, 14376, 2133, 14247, 2059, 14084, 1915, 13930,
  1761, 13784, 1609, 13648, 1464, 15360, 0, 15360, 0, 15360, 0, 15360, 3, 15359,
  18, 15358, 26, 15357, 53, 15354, 80, 15348, 97, 15341, 165, 15332, 238, 15318,
  326, 15299, 427, 15275, 529, 15245, 654, 15207, 771, 15161, 885, 15108, 994,
  15046, 1089, 14976, 1170, 14900, 1229, 14817, 1266, 14731, 1284, 14641, 1282,
  14550, 1260, 14460, 1223, 14370, 1174, 14232, 1116, 14066, 1050, 13909, 981,
  13761, 910, 13623, 839,
]);
let is = null;
function T$() {
  return (
    is === null &&
      ((is = new or(M$, 32, 32, Mm, Gn)),
      (is.minFilter = Dt),
      (is.magFilter = Dt),
      (is.wrapS = mn),
      (is.wrapT = mn),
      (is.generateMipmaps = !1),
      (is.needsUpdate = !0)),
    is
  );
}
class L3 {
  constructor(e = {}) {
    const {
      canvas: t = E2(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = 'default',
      failIfMajorPerformanceCaveat: h = !1,
      reversedDepthBuffer: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (i !== null) {
      if (
        typeof WebGLRenderingContext < 'u' &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          'THREE.WebGLRenderer: WebGL 1 is not supported since r163.'
        );
      f = i.getContextAttributes().alpha;
    } else f = a;
    const p = new Set([Cm, Tm, Fh]),
      m = new Set([gn, Mr, tc, Oo, Em, Am]),
      g = new Uint32Array(4),
      v = new Int32Array(4);
    let y = null,
      _ = null;
    const x = [],
      S = [];
    ((this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = ds),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1));
    const b = this;
    let A = !1;
    this._outputColorSpace = Wt;
    let E = 0,
      w = 0,
      M = null,
      T = -1,
      D = null;
    const L = new Lt(),
      O = new Lt();
    let z = null;
    const C = new je(0);
    let N = 0,
      U = t.width,
      W = t.height,
      G = 1,
      ne = null,
      ve = null;
    const Se = new Lt(0, 0, U, W),
      Ae = new Lt(0, 0, U, W);
    let Oe = !1;
    const Z = new Cc();
    let J = !1,
      de = !1;
    const fe = new pt(),
      K = new V(),
      oe = new Lt(),
      he = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let xe = !1;
    function ee() {
      return M === null ? G : 1;
    }
    let B = i;
    function me(I, H) {
      return t.getContext(I, H);
    }
    try {
      const I = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ('setAttribute' in t &&
          t.setAttribute('data-engine', `three.js r${la}`),
        t.addEventListener('webglcontextlost', Ie, !1),
        t.addEventListener('webglcontextrestored', be, !1),
        t.addEventListener('webglcontextcreationerror', tt, !1),
        B === null)
      ) {
        const H = 'webgl2';
        if (((B = me(H, I)), B === null))
          throw me(H)
            ? new Error(
                'Error creating WebGL context with your selected attributes.'
              )
            : new Error('Error creating WebGL context.');
      }
    } catch (I) {
      throw (I('WebGLRenderer: ' + I.message), I);
    }
    let ye,
      Te,
      Ee,
      Xe,
      Ne,
      We,
      F,
      P,
      Q,
      le,
      ge,
      se,
      Ke,
      Be,
      at,
      Je,
      we,
      Ce,
      ct,
      it,
      Le,
      et,
      Y,
      re;
    function ke() {
      ((ye = new BQ(B)),
        ye.init(),
        (et = new O3(B, ye)),
        (Te = new CQ(B, ye, e, et)),
        (Ee = new v$(B, ye)),
        Te.reversedDepthBuffer && d && Ee.buffers.depth.setReversed(!0),
        (Xe = new zQ(B)),
        (Ne = new r$()),
        (We = new _$(B, ye, Ee, Ne, Te, et, Xe)),
        (F = new IQ(b)),
        (P = new kQ(b)),
        (Q = new WY(B)),
        (Y = new MQ(B, Q)),
        (le = new NQ(B, Q, Xe, Y)),
        (ge = new HQ(B, le, Q, Xe)),
        (ct = new VQ(B, Te, We)),
        (Je = new RQ(Ne)),
        (se = new i$(b, F, P, ye, Te, Y, Je)),
        (Ke = new E$(b, Ne)),
        (Be = new a$()),
        (at = new d$(ye)),
        (Ce = new AQ(b, F, P, Ee, ge, f, l)),
        (we = new m$(b, ge, Te)),
        (re = new A$(B, Xe, Te, Ee)),
        (it = new TQ(B, ye, Xe)),
        (Le = new FQ(B, ye, Xe)),
        (Xe.programs = se.programs),
        (b.capabilities = Te),
        (b.extensions = ye),
        (b.properties = Ne),
        (b.renderLists = Be),
        (b.shadowMap = we),
        (b.state = Ee),
        (b.info = Xe));
    }
    ke();
    const ze = new S$(b, B);
    ((this.xr = ze),
      (this.getContext = function () {
        return B;
      }),
      (this.getContextAttributes = function () {
        return B.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const I = ye.get('WEBGL_lose_context');
        I && I.loseContext();
      }),
      (this.forceContextRestore = function () {
        const I = ye.get('WEBGL_lose_context');
        I && I.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return G;
      }),
      (this.setPixelRatio = function (I) {
        I !== void 0 && ((G = I), this.setSize(U, W, !1));
      }),
      (this.getSize = function (I) {
        return I.set(U, W);
      }),
      (this.setSize = function (I, H, X = !0) {
        if (ze.isPresenting) {
          Ge("WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        ((U = I),
          (W = H),
          (t.width = Math.floor(I * G)),
          (t.height = Math.floor(H * G)),
          X === !0 && ((t.style.width = I + 'px'), (t.style.height = H + 'px')),
          this.setViewport(0, 0, I, H));
      }),
      (this.getDrawingBufferSize = function (I) {
        return I.set(U * G, W * G).floor();
      }),
      (this.setDrawingBufferSize = function (I, H, X) {
        ((U = I),
          (W = H),
          (G = X),
          (t.width = Math.floor(I * X)),
          (t.height = Math.floor(H * X)),
          this.setViewport(0, 0, I, H));
      }),
      (this.getCurrentViewport = function (I) {
        return I.copy(L);
      }),
      (this.getViewport = function (I) {
        return I.copy(Se);
      }),
      (this.setViewport = function (I, H, X, $) {
        (I.isVector4 ? Se.set(I.x, I.y, I.z, I.w) : Se.set(I, H, X, $),
          Ee.viewport(L.copy(Se).multiplyScalar(G).round()));
      }),
      (this.getScissor = function (I) {
        return I.copy(Ae);
      }),
      (this.setScissor = function (I, H, X, $) {
        (I.isVector4 ? Ae.set(I.x, I.y, I.z, I.w) : Ae.set(I, H, X, $),
          Ee.scissor(O.copy(Ae).multiplyScalar(G).round()));
      }),
      (this.getScissorTest = function () {
        return Oe;
      }),
      (this.setScissorTest = function (I) {
        Ee.setScissorTest((Oe = I));
      }),
      (this.setOpaqueSort = function (I) {
        ne = I;
      }),
      (this.setTransparentSort = function (I) {
        ve = I;
      }),
      (this.getClearColor = function (I) {
        return I.copy(Ce.getClearColor());
      }),
      (this.setClearColor = function () {
        Ce.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return Ce.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ce.setClearAlpha(...arguments);
      }),
      (this.clear = function (I = !0, H = !0, X = !0) {
        let $ = 0;
        if (I) {
          let j = !1;
          if (M !== null) {
            const ae = M.texture.format;
            j = p.has(ae);
          }
          if (j) {
            const ae = M.texture.type,
              _e = m.has(ae),
              Me = Ce.getClearColor(),
              Pe = Ce.getClearAlpha(),
              Ve = Me.r,
              Ye = Me.g,
              qe = Me.b;
            _e
              ? ((g[0] = Ve),
                (g[1] = Ye),
                (g[2] = qe),
                (g[3] = Pe),
                B.clearBufferuiv(B.COLOR, 0, g))
              : ((v[0] = Ve),
                (v[1] = Ye),
                (v[2] = qe),
                (v[3] = Pe),
                B.clearBufferiv(B.COLOR, 0, v));
          } else $ |= B.COLOR_BUFFER_BIT;
        }
        (H && ($ |= B.DEPTH_BUFFER_BIT),
          X &&
            (($ |= B.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          B.clear($));
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        (t.removeEventListener('webglcontextlost', Ie, !1),
          t.removeEventListener('webglcontextrestored', be, !1),
          t.removeEventListener('webglcontextcreationerror', tt, !1),
          Ce.dispose(),
          Be.dispose(),
          at.dispose(),
          Ne.dispose(),
          F.dispose(),
          P.dispose(),
          ge.dispose(),
          Y.dispose(),
          re.dispose(),
          se.dispose(),
          ze.dispose(),
          ze.removeEventListener('sessionstart', Zh),
          ze.removeEventListener('sessionend', pa),
          Xr.stop());
      }));
    function Ie(I) {
      (I.preventDefault(), fh('WebGLRenderer: Context Lost.'), (A = !0));
    }
    function be() {
      (fh('WebGLRenderer: Context Restored.'), (A = !1));
      const I = Xe.autoReset,
        H = we.enabled,
        X = we.autoUpdate,
        $ = we.needsUpdate,
        j = we.type;
      (ke(),
        (Xe.autoReset = I),
        (we.enabled = H),
        (we.autoUpdate = X),
        (we.needsUpdate = $),
        (we.type = j));
    }
    function tt(I) {
      gt(
        'WebGLRenderer: A WebGL context could not be created. Reason: ',
        I.statusMessage
      );
    }
    function vt(I) {
      const H = I.target;
      (H.removeEventListener('dispose', vt), Qt(H));
    }
    function Qt(I) {
      (jt(I), Ne.remove(I));
    }
    function jt(I) {
      const H = Ne.get(I).programs;
      H !== void 0 &&
        (H.forEach(function (X) {
          se.releaseProgram(X);
        }),
        I.isShaderMaterial && se.releaseShaderCache(I));
    }
    this.renderBufferDirect = function (I, H, X, $, j, ae) {
      H === null && (H = he);
      const _e = j.isMesh && j.matrixWorld.determinant() < 0,
        Me = te(I, H, X, $, j);
      Ee.setMaterial($, _e);
      let Pe = X.index,
        Ve = 1;
      if ($.wireframe === !0) {
        if (((Pe = le.getWireframeAttribute(X)), Pe === void 0)) return;
        Ve = 2;
      }
      const Ye = X.drawRange,
        qe = X.attributes.position;
      let nt = Ye.start * Ve,
        Tt = (Ye.start + Ye.count) * Ve;
      (ae !== null &&
        ((nt = Math.max(nt, ae.start * Ve)),
        (Tt = Math.min(Tt, (ae.start + ae.count) * Ve))),
        Pe !== null
          ? ((nt = Math.max(nt, 0)), (Tt = Math.min(Tt, Pe.count)))
          : qe != null &&
            ((nt = Math.max(nt, 0)), (Tt = Math.min(Tt, qe.count))));
      const ht = Tt - nt;
      if (ht < 0 || ht === 1 / 0) return;
      Y.setup(j, $, Me, X, Pe);
      let wt,
        It = it;
      if (
        (Pe !== null && ((wt = Q.get(Pe)), (It = Le), It.setIndex(wt)),
        j.isMesh)
      )
        $.wireframe === !0
          ? (Ee.setLineWidth($.wireframeLinewidth * ee()), It.setMode(B.LINES))
          : It.setMode(B.TRIANGLES);
      else if (j.isLine) {
        let ot = $.linewidth;
        (ot === void 0 && (ot = 1),
          Ee.setLineWidth(ot * ee()),
          j.isLineSegments
            ? It.setMode(B.LINES)
            : j.isLineLoop
              ? It.setMode(B.LINE_LOOP)
              : It.setMode(B.LINE_STRIP));
      } else
        j.isPoints
          ? It.setMode(B.POINTS)
          : j.isSprite && It.setMode(B.TRIANGLES);
      if (j.isBatchedMesh)
        if (j._multiDrawInstances !== null)
          (rc(
            'WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.'
          ),
            It.renderMultiDrawInstances(
              j._multiDrawStarts,
              j._multiDrawCounts,
              j._multiDrawCount,
              j._multiDrawInstances
            ));
        else if (ye.get('WEBGL_multi_draw'))
          It.renderMultiDraw(
            j._multiDrawStarts,
            j._multiDrawCounts,
            j._multiDrawCount
          );
        else {
          const ot = j._multiDrawStarts,
            Ot = j._multiDrawCounts,
            rt = j._multiDrawCount,
            Xt = Pe ? Q.get(Pe).bytesPerElement : 1,
            Ht = Ne.get($).currentProgram.getUniforms();
          for (let yt = 0; yt < rt; yt++)
            (Ht.setValue(B, '_gl_DrawID', yt), It.render(ot[yt] / Xt, Ot[yt]));
        }
      else if (j.isInstancedMesh) It.renderInstances(nt, ht, j.count);
      else if (X.isInstancedBufferGeometry) {
        const ot = X._maxInstanceCount !== void 0 ? X._maxInstanceCount : 1 / 0,
          Ot = Math.min(X.instanceCount, ot);
        It.renderInstances(nt, ht, Ot);
      } else It.render(nt, ht);
    };
    function Ji(I, H, X) {
      I.transparent === !0 && I.side === ci && I.forceSinglePass === !1
        ? ((I.side = On),
          (I.needsUpdate = !0),
          R(I, H, X),
          (I.side = Wr),
          (I.needsUpdate = !0),
          R(I, H, X),
          (I.side = ci))
        : R(I, H, X);
    }
    ((this.compile = function (I, H, X = null) {
      (X === null && (X = I),
        (_ = at.get(X)),
        _.init(H),
        S.push(_),
        X.traverseVisible(function (j) {
          j.isLight &&
            j.layers.test(H.layers) &&
            (_.pushLight(j), j.castShadow && _.pushShadow(j));
        }),
        I !== X &&
          I.traverseVisible(function (j) {
            j.isLight &&
              j.layers.test(H.layers) &&
              (_.pushLight(j), j.castShadow && _.pushShadow(j));
          }),
        _.setupLights());
      const $ = new Set();
      return (
        I.traverse(function (j) {
          if (!(j.isMesh || j.isPoints || j.isLine || j.isSprite)) return;
          const ae = j.material;
          if (ae)
            if (Array.isArray(ae))
              for (let _e = 0; _e < ae.length; _e++) {
                const Me = ae[_e];
                (Ji(Me, X, j), $.add(Me));
              }
            else (Ji(ae, X, j), $.add(ae));
        }),
        (_ = S.pop()),
        $
      );
    }),
      (this.compileAsync = function (I, H, X = null) {
        const $ = this.compile(I, H, X);
        return new Promise((j) => {
          function ae() {
            if (
              ($.forEach(function (_e) {
                Ne.get(_e).currentProgram.isReady() && $.delete(_e);
              }),
              $.size === 0)
            ) {
              j(I);
              return;
            }
            setTimeout(ae, 10);
          }
          ye.get('KHR_parallel_shader_compile') !== null
            ? ae()
            : setTimeout(ae, 10);
        });
      }));
    let Di = null;
    function tg(I) {
      Di && Di(I);
    }
    function Zh() {
      Xr.stop();
    }
    function pa() {
      Xr.start();
    }
    const Xr = new C3();
    (Xr.setAnimationLoop(tg),
      typeof self < 'u' && Xr.setContext(self),
      (this.setAnimationLoop = function (I) {
        ((Di = I), ze.setAnimationLoop(I), I === null ? Xr.stop() : Xr.start());
      }),
      ze.addEventListener('sessionstart', Zh),
      ze.addEventListener('sessionend', pa),
      (this.render = function (I, H) {
        if (H !== void 0 && H.isCamera !== !0) {
          gt(
            'WebGLRenderer.render: camera is not an instance of THREE.Camera.'
          );
          return;
        }
        if (A === !0) return;
        if (
          (I.matrixWorldAutoUpdate === !0 && I.updateMatrixWorld(),
          H.parent === null &&
            H.matrixWorldAutoUpdate === !0 &&
            H.updateMatrixWorld(),
          ze.enabled === !0 &&
            ze.isPresenting === !0 &&
            (ze.cameraAutoUpdate === !0 && ze.updateCamera(H),
            (H = ze.getCamera())),
          I.isScene === !0 && I.onBeforeRender(b, I, H, M),
          (_ = at.get(I, S.length)),
          _.init(H),
          S.push(_),
          fe.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse),
          Z.setFromProjectionMatrix(fe, Hi, H.reversedDepth),
          (de = this.localClippingEnabled),
          (J = Je.init(this.clippingPlanes, de)),
          (y = Be.get(I, x.length)),
          y.init(),
          x.push(y),
          ze.enabled === !0 && ze.isPresenting === !0)
        ) {
          const ae = b.xr.getDepthSensingMesh();
          ae !== null && qr(ae, H, -1 / 0, b.sortObjects);
        }
        (qr(I, H, 0, b.sortObjects),
          y.finish(),
          b.sortObjects === !0 && y.sort(ne, ve),
          (xe =
            ze.enabled === !1 ||
            ze.isPresenting === !1 ||
            ze.hasDepthSensing() === !1),
          xe && Ce.addToRenderList(y, I),
          this.info.render.frame++,
          J === !0 && Je.beginShadows());
        const X = _.state.shadowsArray;
        (we.render(X, I, H),
          J === !0 && Je.endShadows(),
          this.info.autoReset === !0 && this.info.reset());
        const $ = y.opaque,
          j = y.transmissive;
        if ((_.setupLights(), H.isArrayCamera)) {
          const ae = H.cameras;
          if (j.length > 0)
            for (let _e = 0, Me = ae.length; _e < Me; _e++) {
              const Pe = ae[_e];
              Rt($, j, I, Pe);
            }
          xe && Ce.render(I);
          for (let _e = 0, Me = ae.length; _e < Me; _e++) {
            const Pe = ae[_e];
            bs(y, I, Pe, Pe.viewport);
          }
        } else
          (j.length > 0 && Rt($, j, I, H), xe && Ce.render(I), bs(y, I, H));
        (M !== null &&
          w === 0 &&
          (We.updateMultisampleRenderTarget(M), We.updateRenderTargetMipmap(M)),
          I.isScene === !0 && I.onAfterRender(b, I, H),
          Y.resetDefaultState(),
          (T = -1),
          (D = null),
          S.pop(),
          S.length > 0
            ? ((_ = S[S.length - 1]),
              J === !0 && Je.setGlobalState(b.clippingPlanes, _.state.camera))
            : (_ = null),
          x.pop(),
          x.length > 0 ? (y = x[x.length - 1]) : (y = null));
      }));
    function qr(I, H, X, $) {
      if (I.visible === !1) return;
      if (I.layers.test(H.layers)) {
        if (I.isGroup) X = I.renderOrder;
        else if (I.isLOD) I.autoUpdate === !0 && I.update(H);
        else if (I.isLight) (_.pushLight(I), I.castShadow && _.pushShadow(I));
        else if (I.isSprite) {
          if (!I.frustumCulled || Z.intersectsSprite(I)) {
            $ && oe.setFromMatrixPosition(I.matrixWorld).applyMatrix4(fe);
            const _e = ge.update(I),
              Me = I.material;
            Me.visible && y.push(I, _e, Me, X, oe.z, null);
          }
        } else if (
          (I.isMesh || I.isLine || I.isPoints) &&
          (!I.frustumCulled || Z.intersectsObject(I))
        ) {
          const _e = ge.update(I),
            Me = I.material;
          if (
            ($ &&
              (I.boundingSphere !== void 0
                ? (I.boundingSphere === null && I.computeBoundingSphere(),
                  oe.copy(I.boundingSphere.center))
                : (_e.boundingSphere === null && _e.computeBoundingSphere(),
                  oe.copy(_e.boundingSphere.center)),
              oe.applyMatrix4(I.matrixWorld).applyMatrix4(fe)),
            Array.isArray(Me))
          ) {
            const Pe = _e.groups;
            for (let Ve = 0, Ye = Pe.length; Ve < Ye; Ve++) {
              const qe = Pe[Ve],
                nt = Me[qe.materialIndex];
              nt && nt.visible && y.push(I, _e, nt, X, oe.z, qe);
            }
          } else Me.visible && y.push(I, _e, Me, X, oe.z, null);
        }
      }
      const ae = I.children;
      for (let _e = 0, Me = ae.length; _e < Me; _e++) qr(ae[_e], H, X, $);
    }
    function bs(I, H, X, $) {
      const { opaque: j, transmissive: ae, transparent: _e } = I;
      (_.setupLightsView(X),
        J === !0 && Je.setGlobalState(b.clippingPlanes, X),
        $ && Ee.viewport(L.copy($)),
        j.length > 0 && ma(j, H, X),
        ae.length > 0 && ma(ae, H, X),
        _e.length > 0 && ma(_e, H, X),
        Ee.buffers.depth.setTest(!0),
        Ee.buffers.depth.setMask(!0),
        Ee.buffers.color.setMask(!0),
        Ee.setPolygonOffset(!1));
    }
    function Rt(I, H, X, $) {
      if ((X.isScene === !0 ? X.overrideMaterial : null) !== null) return;
      _.state.transmissionRenderTarget[$.id] === void 0 &&
        (_.state.transmissionRenderTarget[$.id] = new Sn(1, 1, {
          generateMipmaps: !0,
          type:
            ye.has('EXT_color_buffer_half_float') ||
            ye.has('EXT_color_buffer_float')
              ? Gn
              : gn,
          minFilter: kr,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: kt.workingColorSpace,
        }));
      const ae = _.state.transmissionRenderTarget[$.id],
        _e = $.viewport || L;
      ae.setSize(
        _e.z * b.transmissionResolutionScale,
        _e.w * b.transmissionResolutionScale
      );
      const Me = b.getRenderTarget(),
        Pe = b.getActiveCubeFace(),
        Ve = b.getActiveMipmapLevel();
      (b.setRenderTarget(ae),
        b.getClearColor(C),
        (N = b.getClearAlpha()),
        N < 1 && b.setClearColor(16777215, 0.5),
        b.clear(),
        xe && Ce.render(X));
      const Ye = b.toneMapping;
      b.toneMapping = ds;
      const qe = $.viewport;
      if (
        ($.viewport !== void 0 && ($.viewport = void 0),
        _.setupLightsView($),
        J === !0 && Je.setGlobalState(b.clippingPlanes, $),
        ma(I, X, $),
        We.updateMultisampleRenderTarget(ae),
        We.updateRenderTargetMipmap(ae),
        ye.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let nt = !1;
        for (let Tt = 0, ht = H.length; Tt < ht; Tt++) {
          const wt = H[Tt],
            { object: It, geometry: ot, material: Ot, group: rt } = wt;
          if (Ot.side === ci && It.layers.test($.layers)) {
            const Xt = Ot.side;
            ((Ot.side = On),
              (Ot.needsUpdate = !0),
              $h(It, X, $, ot, Ot, rt),
              (Ot.side = Xt),
              (Ot.needsUpdate = !0),
              (nt = !0));
          }
        }
        nt === !0 &&
          (We.updateMultisampleRenderTarget(ae),
          We.updateRenderTargetMipmap(ae));
      }
      (b.setRenderTarget(Me, Pe, Ve),
        b.setClearColor(C, N),
        qe !== void 0 && ($.viewport = qe),
        (b.toneMapping = Ye));
    }
    function ma(I, H, X) {
      const $ = H.isScene === !0 ? H.overrideMaterial : null;
      for (let j = 0, ae = I.length; j < ae; j++) {
        const _e = I[j],
          { object: Me, geometry: Pe, group: Ve } = _e;
        let Ye = _e.material;
        (Ye.allowOverride === !0 && $ !== null && (Ye = $),
          Me.layers.test(X.layers) && $h(Me, H, X, Pe, Ye, Ve));
      }
    }
    function $h(I, H, X, $, j, ae) {
      (I.onBeforeRender(b, H, X, $, j, ae),
        I.modelViewMatrix.multiplyMatrices(X.matrixWorldInverse, I.matrixWorld),
        I.normalMatrix.getNormalMatrix(I.modelViewMatrix),
        j.onBeforeRender(b, H, X, $, I, ae),
        j.transparent === !0 && j.side === ci && j.forceSinglePass === !1
          ? ((j.side = On),
            (j.needsUpdate = !0),
            b.renderBufferDirect(X, H, $, j, I, ae),
            (j.side = Wr),
            (j.needsUpdate = !0),
            b.renderBufferDirect(X, H, $, j, I, ae),
            (j.side = ci))
          : b.renderBufferDirect(X, H, $, j, I, ae),
        I.onAfterRender(b, H, X, $, j, ae));
    }
    function R(I, H, X) {
      H.isScene !== !0 && (H = he);
      const $ = Ne.get(I),
        j = _.state.lights,
        ae = _.state.shadowsArray,
        _e = j.state.version,
        Me = se.getParameters(I, j.state, ae, H, X),
        Pe = se.getProgramCacheKey(Me);
      let Ve = $.programs;
      (($.environment = I.isMeshStandardMaterial ? H.environment : null),
        ($.fog = H.fog),
        ($.envMap = (I.isMeshStandardMaterial ? P : F).get(
          I.envMap || $.environment
        )),
        ($.envMapRotation =
          $.environment !== null && I.envMap === null
            ? H.environmentRotation
            : I.envMapRotation),
        Ve === void 0 &&
          (I.addEventListener('dispose', vt),
          (Ve = new Map()),
          ($.programs = Ve)));
      let Ye = Ve.get(Pe);
      if (Ye !== void 0) {
        if ($.currentProgram === Ye && $.lightsStateVersion === _e)
          return (q(I, Me), Ye);
      } else
        ((Me.uniforms = se.getUniforms(I)),
          I.onBeforeCompile(Me, b),
          (Ye = se.acquireProgram(Me, Pe)),
          Ve.set(Pe, Ye),
          ($.uniforms = Me.uniforms));
      const qe = $.uniforms;
      return (
        ((!I.isShaderMaterial && !I.isRawShaderMaterial) ||
          I.clipping === !0) &&
          (qe.clippingPlanes = Je.uniform),
        q(I, Me),
        ($.needsLights = ue(I)),
        ($.lightsStateVersion = _e),
        $.needsLights &&
          ((qe.ambientLightColor.value = j.state.ambient),
          (qe.lightProbe.value = j.state.probe),
          (qe.directionalLights.value = j.state.directional),
          (qe.directionalLightShadows.value = j.state.directionalShadow),
          (qe.spotLights.value = j.state.spot),
          (qe.spotLightShadows.value = j.state.spotShadow),
          (qe.rectAreaLights.value = j.state.rectArea),
          (qe.ltc_1.value = j.state.rectAreaLTC1),
          (qe.ltc_2.value = j.state.rectAreaLTC2),
          (qe.pointLights.value = j.state.point),
          (qe.pointLightShadows.value = j.state.pointShadow),
          (qe.hemisphereLights.value = j.state.hemi),
          (qe.directionalShadowMap.value = j.state.directionalShadowMap),
          (qe.directionalShadowMatrix.value = j.state.directionalShadowMatrix),
          (qe.spotShadowMap.value = j.state.spotShadowMap),
          (qe.spotLightMatrix.value = j.state.spotLightMatrix),
          (qe.spotLightMap.value = j.state.spotLightMap),
          (qe.pointShadowMap.value = j.state.pointShadowMap),
          (qe.pointShadowMatrix.value = j.state.pointShadowMatrix)),
        ($.currentProgram = Ye),
        ($.uniformsList = null),
        Ye
      );
    }
    function k(I) {
      if (I.uniformsList === null) {
        const H = I.currentProgram.getUniforms();
        I.uniformsList = Nf.seqWithValue(H.seq, I.uniforms);
      }
      return I.uniformsList;
    }
    function q(I, H) {
      const X = Ne.get(I);
      ((X.outputColorSpace = H.outputColorSpace),
        (X.batching = H.batching),
        (X.batchingColor = H.batchingColor),
        (X.instancing = H.instancing),
        (X.instancingColor = H.instancingColor),
        (X.instancingMorph = H.instancingMorph),
        (X.skinning = H.skinning),
        (X.morphTargets = H.morphTargets),
        (X.morphNormals = H.morphNormals),
        (X.morphColors = H.morphColors),
        (X.morphTargetsCount = H.morphTargetsCount),
        (X.numClippingPlanes = H.numClippingPlanes),
        (X.numIntersection = H.numClipIntersection),
        (X.vertexAlphas = H.vertexAlphas),
        (X.vertexTangents = H.vertexTangents),
        (X.toneMapping = H.toneMapping));
    }
    function te(I, H, X, $, j) {
      (H.isScene !== !0 && (H = he), We.resetTextureUnits());
      const ae = H.fog,
        _e = $.isMeshStandardMaterial ? H.environment : null,
        Me =
          M === null
            ? b.outputColorSpace
            : M.isXRRenderTarget === !0
              ? M.texture.colorSpace
              : cr,
        Pe = ($.isMeshStandardMaterial ? P : F).get($.envMap || _e),
        Ve =
          $.vertexColors === !0 &&
          !!X.attributes.color &&
          X.attributes.color.itemSize === 4,
        Ye = !!X.attributes.tangent && (!!$.normalMap || $.anisotropy > 0),
        qe = !!X.morphAttributes.position,
        nt = !!X.morphAttributes.normal,
        Tt = !!X.morphAttributes.color;
      let ht = ds;
      $.toneMapped &&
        (M === null || M.isXRRenderTarget === !0) &&
        (ht = b.toneMapping);
      const wt =
          X.morphAttributes.position ||
          X.morphAttributes.normal ||
          X.morphAttributes.color,
        It = wt !== void 0 ? wt.length : 0,
        ot = Ne.get($),
        Ot = _.state.lights;
      if (J === !0 && (de === !0 || I !== D)) {
        const ri = I === D && $.id === T;
        Je.setState($, I, ri);
      }
      let rt = !1;
      $.version === ot.__version
        ? ((ot.needsLights && ot.lightsStateVersion !== Ot.state.version) ||
            ot.outputColorSpace !== Me ||
            (j.isBatchedMesh && ot.batching === !1) ||
            (!j.isBatchedMesh && ot.batching === !0) ||
            (j.isBatchedMesh &&
              ot.batchingColor === !0 &&
              j.colorTexture === null) ||
            (j.isBatchedMesh &&
              ot.batchingColor === !1 &&
              j.colorTexture !== null) ||
            (j.isInstancedMesh && ot.instancing === !1) ||
            (!j.isInstancedMesh && ot.instancing === !0) ||
            (j.isSkinnedMesh && ot.skinning === !1) ||
            (!j.isSkinnedMesh && ot.skinning === !0) ||
            (j.isInstancedMesh &&
              ot.instancingColor === !0 &&
              j.instanceColor === null) ||
            (j.isInstancedMesh &&
              ot.instancingColor === !1 &&
              j.instanceColor !== null) ||
            (j.isInstancedMesh &&
              ot.instancingMorph === !0 &&
              j.morphTexture === null) ||
            (j.isInstancedMesh &&
              ot.instancingMorph === !1 &&
              j.morphTexture !== null) ||
            ot.envMap !== Pe ||
            ($.fog === !0 && ot.fog !== ae) ||
            (ot.numClippingPlanes !== void 0 &&
              (ot.numClippingPlanes !== Je.numPlanes ||
                ot.numIntersection !== Je.numIntersection)) ||
            ot.vertexAlphas !== Ve ||
            ot.vertexTangents !== Ye ||
            ot.morphTargets !== qe ||
            ot.morphNormals !== nt ||
            ot.morphColors !== Tt ||
            ot.toneMapping !== ht ||
            ot.morphTargetsCount !== It) &&
          (rt = !0)
        : ((rt = !0), (ot.__version = $.version));
      let Xt = ot.currentProgram;
      rt === !0 && (Xt = R($, H, j));
      let Ht = !1,
        yt = !1,
        Nn = !1;
      const Gt = Xt.getUniforms(),
        Kt = ot.uniforms;
      if (
        (Ee.useProgram(Xt.program) && ((Ht = !0), (yt = !0), (Nn = !0)),
        $.id !== T && ((T = $.id), (yt = !0)),
        Ht || D !== I)
      ) {
        (Ee.buffers.depth.getReversed() &&
          I.reversedDepth !== !0 &&
          ((I._reversedDepth = !0), I.updateProjectionMatrix()),
          Gt.setValue(B, 'projectionMatrix', I.projectionMatrix),
          Gt.setValue(B, 'viewMatrix', I.matrixWorldInverse));
        const _i = Gt.map.cameraPosition;
        (_i !== void 0 &&
          _i.setValue(B, K.setFromMatrixPosition(I.matrixWorld)),
          Te.logarithmicDepthBuffer &&
            Gt.setValue(
              B,
              'logDepthBufFC',
              2 / (Math.log(I.far + 1) / Math.LN2)
            ),
          ($.isMeshPhongMaterial ||
            $.isMeshToonMaterial ||
            $.isMeshLambertMaterial ||
            $.isMeshBasicMaterial ||
            $.isMeshStandardMaterial ||
            $.isShaderMaterial) &&
            Gt.setValue(B, 'isOrthographic', I.isOrthographicCamera === !0),
          D !== I && ((D = I), (yt = !0), (Nn = !0)));
      }
      if (j.isSkinnedMesh) {
        (Gt.setOptional(B, j, 'bindMatrix'),
          Gt.setOptional(B, j, 'bindMatrixInverse'));
        const ri = j.skeleton;
        ri &&
          (ri.boneTexture === null && ri.computeBoneTexture(),
          Gt.setValue(B, 'boneTexture', ri.boneTexture, We));
      }
      j.isBatchedMesh &&
        (Gt.setOptional(B, j, 'batchingTexture'),
        Gt.setValue(B, 'batchingTexture', j._matricesTexture, We),
        Gt.setOptional(B, j, 'batchingIdTexture'),
        Gt.setValue(B, 'batchingIdTexture', j._indirectTexture, We),
        Gt.setOptional(B, j, 'batchingColorTexture'),
        j._colorsTexture !== null &&
          Gt.setValue(B, 'batchingColorTexture', j._colorsTexture, We));
      const vn = X.morphAttributes;
      if (
        ((vn.position !== void 0 ||
          vn.normal !== void 0 ||
          vn.color !== void 0) &&
          ct.update(j, X, Xt),
        (yt || ot.receiveShadow !== j.receiveShadow) &&
          ((ot.receiveShadow = j.receiveShadow),
          Gt.setValue(B, 'receiveShadow', j.receiveShadow)),
        $.isMeshGouraudMaterial &&
          $.envMap !== null &&
          ((Kt.envMap.value = Pe),
          (Kt.flipEnvMap.value =
            Pe.isCubeTexture && Pe.isRenderTargetTexture === !1 ? -1 : 1)),
        $.isMeshStandardMaterial &&
          $.envMap === null &&
          H.environment !== null &&
          (Kt.envMapIntensity.value = H.environmentIntensity),
        Kt.dfgLUT !== void 0 && (Kt.dfgLUT.value = T$()),
        yt &&
          (Gt.setValue(B, 'toneMappingExposure', b.toneMappingExposure),
          ot.needsLights && ce(Kt, Nn),
          ae && $.fog === !0 && Ke.refreshFogUniforms(Kt, ae),
          Ke.refreshMaterialUniforms(
            Kt,
            $,
            G,
            W,
            _.state.transmissionRenderTarget[I.id]
          ),
          Nf.upload(B, k(ot), Kt, We)),
        $.isShaderMaterial &&
          $.uniformsNeedUpdate === !0 &&
          (Nf.upload(B, k(ot), Kt, We), ($.uniformsNeedUpdate = !1)),
        $.isSpriteMaterial && Gt.setValue(B, 'center', j.center),
        Gt.setValue(B, 'modelViewMatrix', j.modelViewMatrix),
        Gt.setValue(B, 'normalMatrix', j.normalMatrix),
        Gt.setValue(B, 'modelMatrix', j.matrixWorld),
        $.isShaderMaterial || $.isRawShaderMaterial)
      ) {
        const ri = $.uniformsGroups;
        for (let _i = 0, ng = ri.length; _i < ng; _i++) {
          const ga = ri[_i];
          (re.update(ga, Xt), re.bind(ga, Xt));
        }
      }
      return Xt;
    }
    function ce(I, H) {
      ((I.ambientLightColor.needsUpdate = H),
        (I.lightProbe.needsUpdate = H),
        (I.directionalLights.needsUpdate = H),
        (I.directionalLightShadows.needsUpdate = H),
        (I.pointLights.needsUpdate = H),
        (I.pointLightShadows.needsUpdate = H),
        (I.spotLights.needsUpdate = H),
        (I.spotLightShadows.needsUpdate = H),
        (I.rectAreaLights.needsUpdate = H),
        (I.hemisphereLights.needsUpdate = H));
    }
    function ue(I) {
      return (
        I.isMeshLambertMaterial ||
        I.isMeshToonMaterial ||
        I.isMeshPhongMaterial ||
        I.isMeshStandardMaterial ||
        I.isShadowMaterial ||
        (I.isShaderMaterial && I.lights === !0)
      );
    }
    ((this.getActiveCubeFace = function () {
      return E;
    }),
      (this.getActiveMipmapLevel = function () {
        return w;
      }),
      (this.getRenderTarget = function () {
        return M;
      }),
      (this.setRenderTargetTextures = function (I, H, X) {
        const $ = Ne.get(I);
        (($.__autoAllocateDepthBuffer = I.resolveDepthBuffer === !1),
          $.__autoAllocateDepthBuffer === !1 && ($.__useRenderToTexture = !1),
          (Ne.get(I.texture).__webglTexture = H),
          (Ne.get(I.depthTexture).__webglTexture = $.__autoAllocateDepthBuffer
            ? void 0
            : X),
          ($.__hasExternalTextures = !0));
      }),
      (this.setRenderTargetFramebuffer = function (I, H) {
        const X = Ne.get(I);
        ((X.__webglFramebuffer = H),
          (X.__useDefaultFramebuffer = H === void 0));
      }));
    const De = B.createFramebuffer();
    ((this.setRenderTarget = function (I, H = 0, X = 0) {
      ((M = I), (E = H), (w = X));
      let $ = !0,
        j = null,
        ae = !1,
        _e = !1;
      if (I) {
        const Pe = Ne.get(I);
        if (Pe.__useDefaultFramebuffer !== void 0)
          (Ee.bindFramebuffer(B.FRAMEBUFFER, null), ($ = !1));
        else if (Pe.__webglFramebuffer === void 0) We.setupRenderTarget(I);
        else if (Pe.__hasExternalTextures)
          We.rebindTextures(
            I,
            Ne.get(I.texture).__webglTexture,
            Ne.get(I.depthTexture).__webglTexture
          );
        else if (I.depthBuffer) {
          const qe = I.depthTexture;
          if (Pe.__boundDepthTexture !== qe) {
            if (
              qe !== null &&
              Ne.has(qe) &&
              (I.width !== qe.image.width || I.height !== qe.image.height)
            )
              throw new Error(
                'WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.'
              );
            We.setupDepthRenderbuffer(I);
          }
        }
        const Ve = I.texture;
        (Ve.isData3DTexture ||
          Ve.isDataArrayTexture ||
          Ve.isCompressedArrayTexture) &&
          (_e = !0);
        const Ye = Ne.get(I).__webglFramebuffer;
        (I.isWebGLCubeRenderTarget
          ? (Array.isArray(Ye[H]) ? (j = Ye[H][X]) : (j = Ye[H]), (ae = !0))
          : I.samples > 0 && We.useMultisampledRTT(I) === !1
            ? (j = Ne.get(I).__webglMultisampledFramebuffer)
            : Array.isArray(Ye)
              ? (j = Ye[X])
              : (j = Ye),
          L.copy(I.viewport),
          O.copy(I.scissor),
          (z = I.scissorTest));
      } else
        (L.copy(Se).multiplyScalar(G).floor(),
          O.copy(Ae).multiplyScalar(G).floor(),
          (z = Oe));
      if (
        (X !== 0 && (j = De),
        Ee.bindFramebuffer(B.FRAMEBUFFER, j) && $ && Ee.drawBuffers(I, j),
        Ee.viewport(L),
        Ee.scissor(O),
        Ee.setScissorTest(z),
        ae)
      ) {
        const Pe = Ne.get(I.texture);
        B.framebufferTexture2D(
          B.FRAMEBUFFER,
          B.COLOR_ATTACHMENT0,
          B.TEXTURE_CUBE_MAP_POSITIVE_X + H,
          Pe.__webglTexture,
          X
        );
      } else if (_e) {
        const Pe = H;
        for (let Ve = 0; Ve < I.textures.length; Ve++) {
          const Ye = Ne.get(I.textures[Ve]);
          B.framebufferTextureLayer(
            B.FRAMEBUFFER,
            B.COLOR_ATTACHMENT0 + Ve,
            Ye.__webglTexture,
            X,
            Pe
          );
        }
      } else if (I !== null && X !== 0) {
        const Pe = Ne.get(I.texture);
        B.framebufferTexture2D(
          B.FRAMEBUFFER,
          B.COLOR_ATTACHMENT0,
          B.TEXTURE_2D,
          Pe.__webglTexture,
          X
        );
      }
      T = -1;
    }),
      (this.readRenderTargetPixels = function (I, H, X, $, j, ae, _e, Me = 0) {
        if (!(I && I.isWebGLRenderTarget)) {
          gt(
            'WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          );
          return;
        }
        let Pe = Ne.get(I).__webglFramebuffer;
        if ((I.isWebGLCubeRenderTarget && _e !== void 0 && (Pe = Pe[_e]), Pe)) {
          Ee.bindFramebuffer(B.FRAMEBUFFER, Pe);
          try {
            const Ve = I.textures[Me],
              Ye = Ve.format,
              qe = Ve.type;
            if (!Te.textureFormatReadable(Ye)) {
              gt(
                'WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
              );
              return;
            }
            if (!Te.textureTypeReadable(qe)) {
              gt(
                'WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
              );
              return;
            }
            H >= 0 &&
              H <= I.width - $ &&
              X >= 0 &&
              X <= I.height - j &&
              (I.textures.length > 1 && B.readBuffer(B.COLOR_ATTACHMENT0 + Me),
              B.readPixels(H, X, $, j, et.convert(Ye), et.convert(qe), ae));
          } finally {
            const Ve = M !== null ? Ne.get(M).__webglFramebuffer : null;
            Ee.bindFramebuffer(B.FRAMEBUFFER, Ve);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        I,
        H,
        X,
        $,
        j,
        ae,
        _e,
        Me = 0
      ) {
        if (!(I && I.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          );
        let Pe = Ne.get(I).__webglFramebuffer;
        if ((I.isWebGLCubeRenderTarget && _e !== void 0 && (Pe = Pe[_e]), Pe))
          if (H >= 0 && H <= I.width - $ && X >= 0 && X <= I.height - j) {
            Ee.bindFramebuffer(B.FRAMEBUFFER, Pe);
            const Ve = I.textures[Me],
              Ye = Ve.format,
              qe = Ve.type;
            if (!Te.textureFormatReadable(Ye))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.'
              );
            if (!Te.textureTypeReadable(qe))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.'
              );
            const nt = B.createBuffer();
            (B.bindBuffer(B.PIXEL_PACK_BUFFER, nt),
              B.bufferData(B.PIXEL_PACK_BUFFER, ae.byteLength, B.STREAM_READ),
              I.textures.length > 1 && B.readBuffer(B.COLOR_ATTACHMENT0 + Me),
              B.readPixels(H, X, $, j, et.convert(Ye), et.convert(qe), 0));
            const Tt = M !== null ? Ne.get(M).__webglFramebuffer : null;
            Ee.bindFramebuffer(B.FRAMEBUFFER, Tt);
            const ht = B.fenceSync(B.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              B.flush(),
              await jX(B, ht, 4),
              B.bindBuffer(B.PIXEL_PACK_BUFFER, nt),
              B.getBufferSubData(B.PIXEL_PACK_BUFFER, 0, ae),
              B.deleteBuffer(nt),
              B.deleteSync(ht),
              ae
            );
          } else
            throw new Error(
              'THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.'
            );
      }),
      (this.copyFramebufferToTexture = function (I, H = null, X = 0) {
        const $ = Math.pow(2, -X),
          j = Math.floor(I.image.width * $),
          ae = Math.floor(I.image.height * $),
          _e = H !== null ? H.x : 0,
          Me = H !== null ? H.y : 0;
        (We.setTexture2D(I, 0),
          B.copyTexSubImage2D(B.TEXTURE_2D, X, 0, 0, _e, Me, j, ae),
          Ee.unbindTexture());
      }));
    const Re = B.createFramebuffer(),
      Fe = B.createFramebuffer();
    ((this.copyTextureToTexture = function (
      I,
      H,
      X = null,
      $ = null,
      j = 0,
      ae = null
    ) {
      ae === null &&
        (j !== 0
          ? (rc(
              'WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.'
            ),
            (ae = j),
            (j = 0))
          : (ae = 0));
      let _e, Me, Pe, Ve, Ye, qe, nt, Tt, ht;
      const wt = I.isCompressedTexture ? I.mipmaps[ae] : I.image;
      if (X !== null)
        ((_e = X.max.x - X.min.x),
          (Me = X.max.y - X.min.y),
          (Pe = X.isBox3 ? X.max.z - X.min.z : 1),
          (Ve = X.min.x),
          (Ye = X.min.y),
          (qe = X.isBox3 ? X.min.z : 0));
      else {
        const vn = Math.pow(2, -j);
        ((_e = Math.floor(wt.width * vn)),
          (Me = Math.floor(wt.height * vn)),
          I.isDataArrayTexture
            ? (Pe = wt.depth)
            : I.isData3DTexture
              ? (Pe = Math.floor(wt.depth * vn))
              : (Pe = 1),
          (Ve = 0),
          (Ye = 0),
          (qe = 0));
      }
      $ !== null
        ? ((nt = $.x), (Tt = $.y), (ht = $.z))
        : ((nt = 0), (Tt = 0), (ht = 0));
      const It = et.convert(H.format),
        ot = et.convert(H.type);
      let Ot;
      (H.isData3DTexture
        ? (We.setTexture3D(H, 0), (Ot = B.TEXTURE_3D))
        : H.isDataArrayTexture || H.isCompressedArrayTexture
          ? (We.setTexture2DArray(H, 0), (Ot = B.TEXTURE_2D_ARRAY))
          : (We.setTexture2D(H, 0), (Ot = B.TEXTURE_2D)),
        B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL, H.flipY),
        B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
        B.pixelStorei(B.UNPACK_ALIGNMENT, H.unpackAlignment));
      const rt = B.getParameter(B.UNPACK_ROW_LENGTH),
        Xt = B.getParameter(B.UNPACK_IMAGE_HEIGHT),
        Ht = B.getParameter(B.UNPACK_SKIP_PIXELS),
        yt = B.getParameter(B.UNPACK_SKIP_ROWS),
        Nn = B.getParameter(B.UNPACK_SKIP_IMAGES);
      (B.pixelStorei(B.UNPACK_ROW_LENGTH, wt.width),
        B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, wt.height),
        B.pixelStorei(B.UNPACK_SKIP_PIXELS, Ve),
        B.pixelStorei(B.UNPACK_SKIP_ROWS, Ye),
        B.pixelStorei(B.UNPACK_SKIP_IMAGES, qe));
      const Gt = I.isDataArrayTexture || I.isData3DTexture,
        Kt = H.isDataArrayTexture || H.isData3DTexture;
      if (I.isDepthTexture) {
        const vn = Ne.get(I),
          ri = Ne.get(H),
          _i = Ne.get(vn.__renderTarget),
          ng = Ne.get(ri.__renderTarget);
        (Ee.bindFramebuffer(B.READ_FRAMEBUFFER, _i.__webglFramebuffer),
          Ee.bindFramebuffer(B.DRAW_FRAMEBUFFER, ng.__webglFramebuffer));
        for (let ga = 0; ga < Pe; ga++)
          (Gt &&
            (B.framebufferTextureLayer(
              B.READ_FRAMEBUFFER,
              B.COLOR_ATTACHMENT0,
              Ne.get(I).__webglTexture,
              j,
              qe + ga
            ),
            B.framebufferTextureLayer(
              B.DRAW_FRAMEBUFFER,
              B.COLOR_ATTACHMENT0,
              Ne.get(H).__webglTexture,
              ae,
              ht + ga
            )),
            B.blitFramebuffer(
              Ve,
              Ye,
              _e,
              Me,
              nt,
              Tt,
              _e,
              Me,
              B.DEPTH_BUFFER_BIT,
              B.NEAREST
            ));
        (Ee.bindFramebuffer(B.READ_FRAMEBUFFER, null),
          Ee.bindFramebuffer(B.DRAW_FRAMEBUFFER, null));
      } else if (j !== 0 || I.isRenderTargetTexture || Ne.has(I)) {
        const vn = Ne.get(I),
          ri = Ne.get(H);
        (Ee.bindFramebuffer(B.READ_FRAMEBUFFER, Re),
          Ee.bindFramebuffer(B.DRAW_FRAMEBUFFER, Fe));
        for (let _i = 0; _i < Pe; _i++)
          (Gt
            ? B.framebufferTextureLayer(
                B.READ_FRAMEBUFFER,
                B.COLOR_ATTACHMENT0,
                vn.__webglTexture,
                j,
                qe + _i
              )
            : B.framebufferTexture2D(
                B.READ_FRAMEBUFFER,
                B.COLOR_ATTACHMENT0,
                B.TEXTURE_2D,
                vn.__webglTexture,
                j
              ),
            Kt
              ? B.framebufferTextureLayer(
                  B.DRAW_FRAMEBUFFER,
                  B.COLOR_ATTACHMENT0,
                  ri.__webglTexture,
                  ae,
                  ht + _i
                )
              : B.framebufferTexture2D(
                  B.DRAW_FRAMEBUFFER,
                  B.COLOR_ATTACHMENT0,
                  B.TEXTURE_2D,
                  ri.__webglTexture,
                  ae
                ),
            j !== 0
              ? B.blitFramebuffer(
                  Ve,
                  Ye,
                  _e,
                  Me,
                  nt,
                  Tt,
                  _e,
                  Me,
                  B.COLOR_BUFFER_BIT,
                  B.NEAREST
                )
              : Kt
                ? B.copyTexSubImage3D(Ot, ae, nt, Tt, ht + _i, Ve, Ye, _e, Me)
                : B.copyTexSubImage2D(Ot, ae, nt, Tt, Ve, Ye, _e, Me));
        (Ee.bindFramebuffer(B.READ_FRAMEBUFFER, null),
          Ee.bindFramebuffer(B.DRAW_FRAMEBUFFER, null));
      } else
        Kt
          ? I.isDataTexture || I.isData3DTexture
            ? B.texSubImage3D(Ot, ae, nt, Tt, ht, _e, Me, Pe, It, ot, wt.data)
            : H.isCompressedArrayTexture
              ? B.compressedTexSubImage3D(
                  Ot,
                  ae,
                  nt,
                  Tt,
                  ht,
                  _e,
                  Me,
                  Pe,
                  It,
                  wt.data
                )
              : B.texSubImage3D(Ot, ae, nt, Tt, ht, _e, Me, Pe, It, ot, wt)
          : I.isDataTexture
            ? B.texSubImage2D(B.TEXTURE_2D, ae, nt, Tt, _e, Me, It, ot, wt.data)
            : I.isCompressedTexture
              ? B.compressedTexSubImage2D(
                  B.TEXTURE_2D,
                  ae,
                  nt,
                  Tt,
                  wt.width,
                  wt.height,
                  It,
                  wt.data
                )
              : B.texSubImage2D(B.TEXTURE_2D, ae, nt, Tt, _e, Me, It, ot, wt);
      (B.pixelStorei(B.UNPACK_ROW_LENGTH, rt),
        B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, Xt),
        B.pixelStorei(B.UNPACK_SKIP_PIXELS, Ht),
        B.pixelStorei(B.UNPACK_SKIP_ROWS, yt),
        B.pixelStorei(B.UNPACK_SKIP_IMAGES, Nn),
        ae === 0 && H.generateMipmaps && B.generateMipmap(Ot),
        Ee.unbindTexture());
    }),
      (this.initRenderTarget = function (I) {
        Ne.get(I).__webglFramebuffer === void 0 && We.setupRenderTarget(I);
      }),
      (this.initTexture = function (I) {
        (I.isCubeTexture
          ? We.setTextureCube(I, 0)
          : I.isData3DTexture
            ? We.setTexture3D(I, 0)
            : I.isDataArrayTexture || I.isCompressedArrayTexture
              ? We.setTexture2DArray(I, 0)
              : We.setTexture2D(I, 0),
          Ee.unbindTexture());
      }),
      (this.resetState = function () {
        ((E = 0), (w = 0), (M = null), Ee.reset(), Y.reset());
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this })
        ));
  }
  get coordinateSystem() {
    return Hi;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    ((t.drawingBufferColorSpace = kt._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = kt._getUnpackColorSpace()));
  }
}
const lie = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: a2,
      AddEquation: Bs,
      AddOperation: n2,
      AdditiveAnimationBlendMode: Yx,
      AdditiveBlending: W_,
      AgXToneMapping: l2,
      AlphaFormat: Xx,
      AlwaysCompare: S2,
      AlwaysDepth: up,
      AlwaysStencilFunc: K_,
      AmbientLight: g3,
      AnimationAction: M3,
      AnimationClip: xh,
      AnimationLoader: L7,
      AnimationMixer: lY,
      AnimationObjectGroup: aY,
      AnimationUtils: I7,
      ArcCurve: V2,
      ArrayCamera: S3,
      ArrowHelper: UY,
      AttachedBindMode: q_,
      Audio: E3,
      AudioAnalyser: J7,
      AudioContext: _b,
      AudioListener: q7,
      AudioLoader: W7,
      AxesHelper: kY,
      BackSide: On,
      BasicDepthPacking: ca,
      BasicShadowMap: aX,
      BatchedMesh: k2,
      Bone: tb,
      BooleanKeyframeTrack: Ho,
      Box2: yY,
      Box3: ii,
      Box3Helper: OY,
      BoxGeometry: Vo,
      BoxHelper: DY,
      BufferAttribute: qt,
      BufferGeometry: _t,
      BufferGeometryLoader: b3,
      ByteType: Sm,
      Cache: Br,
      Camera: zh,
      CameraHelper: PY,
      CanvasTexture: $q,
      CapsuleGeometry: zm,
      CatmullRomCurve3: H2,
      CineonToneMapping: s2,
      CircleGeometry: Vm,
      ClampToEdgeWrapping: mn,
      Clock: w3,
      Color: je,
      ColorKeyframeTrack: mb,
      ColorManagement: kt,
      CompressedArrayTexture: Qq,
      CompressedCubeTexture: Zq,
      CompressedTexture: Nm,
      CompressedTextureLoader: U7,
      ConeGeometry: Gh,
      ConstantAlphaFactor: $D,
      ConstantColorFactor: QD,
      Controls: NY,
      CubeCamera: R2,
      CubeReflectionMapping: ys,
      CubeRefractionMapping: ta,
      CubeTexture: Vh,
      CubeTextureLoader: k7,
      CubeUVReflectionMapping: Mc,
      CubicBezierCurve: sb,
      CubicBezierCurve3: G2,
      CubicInterpolant: l3,
      CullFaceBack: G_,
      CullFaceFront: UD,
      CullFaceFrontBack: sX,
      CullFaceNone: LD,
      Curve: Cr,
      CurvePath: j2,
      CustomBlending: BD,
      CustomToneMapping: o2,
      CylinderGeometry: Hh,
      Cylindrical: _Y,
      Data3DTexture: Pm,
      DataArrayTexture: Im,
      DataTexture: or,
      DataTextureLoader: gb,
      DataUtils: po,
      DecrementStencilOp: yX,
      DecrementWrapStencilOp: bX,
      DefaultLoadingManager: h3,
      DepthFormat: nc,
      DepthStencilFormat: Lo,
      DepthTexture: Fm,
      DetachedBindMode: u2,
      DirectionalLight: m3,
      DirectionalLightHelper: IY,
      DiscreteInterpolant: c3,
      DodecahedronGeometry: Hm,
      DoubleSide: ci,
      DstAlphaFactor: XD,
      DstColorFactor: YD,
      DynamicCopyUsage: kX,
      DynamicDrawUsage: IX,
      DynamicReadUsage: OX,
      EdgesGeometry: z2,
      EllipseCurve: Gm,
      EqualCompare: _2,
      EqualDepth: dp,
      EqualStencilFunc: AX,
      EquirectangularReflectionMapping: rh,
      EquirectangularRefractionMapping: sh,
      Euler: Yi,
      EventDispatcher: Ki,
      ExternalTexture: ib,
      ExtrudeGeometry: Wm,
      FileLoader: ji,
      Float16BufferAttribute: Rq,
      Float32BufferAttribute: $e,
      FloatType: un,
      Fog: Lm,
      FogExp2: Om,
      FramebufferTexture: Jq,
      FrontSide: Wr,
      Frustum: Cc,
      FrustumArray: Bm,
      GLBufferAttribute: fY,
      GLSL1: NX,
      GLSL3: J_,
      GreaterCompare: y2,
      GreaterDepth: pp,
      GreaterEqualCompare: b2,
      GreaterEqualDepth: fp,
      GreaterEqualStencilFunc: RX,
      GreaterStencilFunc: TX,
      GridHelper: CY,
      Group: Ll,
      HalfFloatType: Gn,
      HemisphereLight: d3,
      HemisphereLightHelper: TY,
      IcosahedronGeometry: Wh,
      ImageBitmapLoader: G7,
      ImageLoader: bh,
      ImageUtils: A2,
      IncrementStencilOp: _X,
      IncrementWrapStencilOp: xX,
      InstancedBufferAttribute: oc,
      InstancedBufferGeometry: x3,
      InstancedInterleavedBuffer: dY,
      InstancedMesh: U2,
      Int16BufferAttribute: Tq,
      Int32BufferAttribute: Cq,
      Int8BufferAttribute: Eq,
      IntType: Bh,
      InterleavedBuffer: Um,
      InterleavedBufferAttribute: Uo,
      Interpolant: qh,
      InterpolateDiscrete: lh,
      InterpolateLinear: Wp,
      InterpolateSmooth: kf,
      InterpolationSamplingMode: VX,
      InterpolationSamplingType: zX,
      InvertStencilOp: SX,
      KeepStencilOp: to,
      KeyframeTrack: ur,
      LOD: O2,
      LatheGeometry: jm,
      Layers: Dm,
      LessCompare: v2,
      LessDepth: hp,
      LessEqualCompare: Kx,
      LessEqualDepth: Do,
      LessEqualStencilFunc: MX,
      LessStencilFunc: EX,
      Light: fa,
      LightProbe: y3,
      Line: ia,
      Line3: SY,
      LineBasicMaterial: gi,
      LineCurve: ab,
      LineCurve3: W2,
      LineDashedMaterial: s3,
      LineLoop: B2,
      LineSegments: jr,
      LinearFilter: Dt,
      LinearInterpolant: pb,
      LinearMipMapLinearFilter: Y_,
      LinearMipMapNearestFilter: cX,
      LinearMipmapLinearFilter: kr,
      LinearMipmapNearestFilter: Iu,
      LinearSRGBColorSpace: cr,
      LinearToneMapping: i2,
      LinearTransfer: uh,
      Loader: vi,
      LoaderUtils: ty,
      LoadingManager: Kh,
      LoopOnce: h2,
      LoopPingPong: f2,
      LoopRepeat: d2,
      MOUSE: iX,
      Material: jn,
      MaterialLoader: Zm,
      MathUtils: lq,
      Matrix2: bb,
      Matrix3: xt,
      Matrix4: pt,
      MaxEquation: VD,
      Mesh: hn,
      MeshBasicMaterial: xs,
      MeshDepthMaterial: hb,
      MeshDistanceMaterial: db,
      MeshLambertMaterial: i3,
      MeshMatcapMaterial: r3,
      MeshNormalMaterial: n3,
      MeshPhongMaterial: e3,
      MeshPhysicalMaterial: $2,
      MeshStandardMaterial: ub,
      MeshToonMaterial: t3,
      MinEquation: zD,
      MirroredRepeatWrapping: oh,
      MixOperation: t2,
      MultiplyBlending: X_,
      MultiplyOperation: kh,
      NearestFilter: Un,
      NearestMipMapLinearFilter: lX,
      NearestMipMapNearestFilter: oX,
      NearestMipmapLinearFilter: Dl,
      NearestMipmapNearestFilter: Gx,
      NeutralToneMapping: c2,
      NeverCompare: g2,
      NeverDepth: cp,
      NeverStencilFunc: wX,
      NoBlending: Ln,
      NoColorSpace: Sr,
      NoToneMapping: ds,
      NormalAnimationBlendMode: Rm,
      NormalBlending: Eo,
      NotEqualCompare: x2,
      NotEqualDepth: mp,
      NotEqualStencilFunc: CX,
      NumberKeyframeTrack: _h,
      Object3D: Ft,
      ObjectLoader: V7,
      ObjectSpaceNormalMap: m2,
      OctahedronGeometry: jh,
      OneFactor: GD,
      OneMinusConstantAlphaFactor: e2,
      OneMinusConstantColorFactor: ZD,
      OneMinusDstAlphaFactor: qD,
      OneMinusDstColorFactor: KD,
      OneMinusSrcAlphaFactor: lp,
      OneMinusSrcColorFactor: jD,
      OrthographicCamera: Jh,
      PCFShadowMap: Hx,
      PCFSoftShadowMap: kD,
      PMREMGenerator: ry,
      Path: Yp,
      PerspectiveCamera: Vn,
      Plane: Us,
      PlaneGeometry: da,
      PlaneHelper: LY,
      PointLight: p3,
      PointLightHelper: AY,
      Points: N2,
      PointsMaterial: nb,
      PolarGridHelper: RY,
      PolyhedronGeometry: ha,
      PositionalAudio: K7,
      PropertyBinding: Bt,
      PropertyMixer: A3,
      QuadraticBezierCurve: ob,
      QuadraticBezierCurve3: lb,
      Quaternion: Ii,
      QuaternionKeyframeTrack: Yh,
      QuaternionLinearInterpolant: u3,
      RED_GREEN_RGTC2_Format: Hp,
      RED_RGTC1_Format: zp,
      REVISION: la,
      RGBADepthPacking: p2,
      RGBAFormat: Rn,
      RGBAIntegerFormat: Cm,
      RGBA_ASTC_10x10_Format: Lp,
      RGBA_ASTC_10x5_Format: Pp,
      RGBA_ASTC_10x6_Format: Dp,
      RGBA_ASTC_10x8_Format: Op,
      RGBA_ASTC_12x10_Format: Up,
      RGBA_ASTC_12x12_Format: kp,
      RGBA_ASTC_4x4_Format: wp,
      RGBA_ASTC_5x4_Format: Ep,
      RGBA_ASTC_5x5_Format: Ap,
      RGBA_ASTC_6x5_Format: Mp,
      RGBA_ASTC_6x6_Format: Tp,
      RGBA_ASTC_8x5_Format: Cp,
      RGBA_ASTC_8x6_Format: Rp,
      RGBA_ASTC_8x8_Format: Ip,
      RGBA_BPTC_Format: Bp,
      RGBA_ETC2_EAC_Format: Sp,
      RGBA_PVRTC_2BPPV1_Format: yp,
      RGBA_PVRTC_4BPPV1_Format: _p,
      RGBA_S3TC_DXT1_Format: Du,
      RGBA_S3TC_DXT3_Format: Ou,
      RGBA_S3TC_DXT5_Format: Lu,
      RGBDepthPacking: pX,
      RGBFormat: qx,
      RGBIntegerFormat: uX,
      RGB_BPTC_SIGNED_Format: Np,
      RGB_BPTC_UNSIGNED_Format: Fp,
      RGB_ETC1_Format: xp,
      RGB_ETC2_Format: bp,
      RGB_PVRTC_2BPPV1_Format: vp,
      RGB_PVRTC_4BPPV1_Format: gp,
      RGB_S3TC_DXT1_Format: Pu,
      RGDepthPacking: mX,
      RGFormat: Mm,
      RGIntegerFormat: Tm,
      RawShaderMaterial: Z2,
      Ray: Tc,
      Raycaster: pY,
      RectAreaLight: v3,
      RedFormat: Nh,
      RedIntegerFormat: Fh,
      ReinhardToneMapping: r2,
      RenderTarget: Qx,
      RenderTarget3D: cY,
      RepeatWrapping: ah,
      ReplaceStencilOp: vX,
      ReverseSubtractEquation: FD,
      RingGeometry: Xm,
      SIGNED_RED_GREEN_RGTC2_Format: Gp,
      SIGNED_RED_RGTC1_Format: Vp,
      SRGBColorSpace: Wt,
      SRGBTransfer: Yt,
      Scene: ph,
      ShaderChunk: Et,
      ShaderLib: br,
      ShaderMaterial: rn,
      ShadowMaterial: Q2,
      Shape: Mo,
      ShapeGeometry: qm,
      ShapePath: BY,
      ShapeUtils: Er,
      ShortType: wm,
      Skeleton: km,
      SkeletonHelper: EY,
      SkinnedMesh: L2,
      Source: Vs,
      Sphere: Yn,
      SphereGeometry: Xh,
      Spherical: vY,
      SphericalHarmonics3: _3,
      SplineCurve: cb,
      SpotLight: f3,
      SpotLightHelper: wY,
      Sprite: D2,
      SpriteMaterial: eb,
      SrcAlphaFactor: op,
      SrcAlphaSaturateFactor: JD,
      SrcColorFactor: WD,
      StaticCopyUsage: UX,
      StaticDrawUsage: hh,
      StaticReadUsage: DX,
      StereoCamera: j7,
      StreamCopyUsage: BX,
      StreamDrawUsage: PX,
      StreamReadUsage: LX,
      StringKeyframeTrack: Go,
      SubtractEquation: ND,
      SubtractiveBlending: j_,
      TOUCH: rX,
      TangentSpaceNormalMap: ua,
      TetrahedronGeometry: Ym,
      Texture: Vt,
      TextureLoader: B7,
      TextureUtils: GY,
      Timer: mY,
      TimestampQuery: FX,
      TorusGeometry: Km,
      TorusKnotGeometry: Jm,
      Triangle: bi,
      TriangleFanDrawMode: fX,
      TriangleStripDrawMode: dX,
      TrianglesDrawMode: hX,
      TubeGeometry: Qm,
      UVMapping: ea,
      Uint16BufferAttribute: Zx,
      Uint32BufferAttribute: $x,
      Uint8BufferAttribute: Aq,
      Uint8ClampedBufferAttribute: Mq,
      Uniform: Mt,
      UniformsGroup: hY,
      UniformsLib: He,
      UniformsUtils: C2,
      UnsignedByteType: gn,
      UnsignedInt101111Type: jx,
      UnsignedInt248Type: Oo,
      UnsignedInt5999Type: Wx,
      UnsignedIntType: Mr,
      UnsignedShort4444Type: Em,
      UnsignedShort5551Type: Am,
      UnsignedShortType: tc,
      VSMShadowMap: Dr,
      Vector2: pe,
      Vector3: V,
      Vector4: Lt,
      VectorKeyframeTrack: yh,
      VideoFrameTexture: Kq,
      VideoTexture: F2,
      WebGL3DRenderTarget: fq,
      WebGLArrayRenderTarget: dq,
      WebGLCoordinateSystem: Hi,
      WebGLCubeRenderTarget: I2,
      WebGLRenderTarget: Sn,
      WebGLRenderer: L3,
      WebGLUtils: O3,
      WebGPUCoordinateSystem: ic,
      WebXRController: Bf,
      WireframeGeometry: J2,
      WrapAroundEnding: ch,
      ZeroCurvatureEnding: ho,
      ZeroFactor: HD,
      ZeroSlopeEnding: fo,
      ZeroStencilOp: gX,
      createCanvasElement: E2,
      error: gt,
      getConsoleFunction: WX,
      log: fh,
      setConsoleFunction: GX,
      warn: Ge,
      warnOnce: rc,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
var hv = { exports: {} },
  dv = {},
  fv = { exports: {} },
  pv = {};
var $M;
function C$() {
  if ($M) return pv;
  $M = 1;
  var n = mT();
  function e(h, d) {
    return (h === d && (h !== 0 || 1 / h === 1 / d)) || (h !== h && d !== d);
  }
  var t = typeof Object.is == 'function' ? Object.is : e,
    i = n.useState,
    r = n.useEffect,
    s = n.useLayoutEffect,
    a = n.useDebugValue;
  function o(h, d) {
    var f = d(),
      p = i({ inst: { value: f, getSnapshot: d } }),
      m = p[0].inst,
      g = p[1];
    return (
      s(
        function () {
          ((m.value = f), (m.getSnapshot = d), l(m) && g({ inst: m }));
        },
        [h, f, d]
      ),
      r(
        function () {
          return (
            l(m) && g({ inst: m }),
            h(function () {
              l(m) && g({ inst: m });
            })
          );
        },
        [h]
      ),
      a(f),
      f
    );
  }
  function l(h) {
    var d = h.getSnapshot;
    h = h.value;
    try {
      var f = d();
      return !t(h, f);
    } catch {
      return !0;
    }
  }
  function c(h, d) {
    return d();
  }
  var u =
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
      ? c
      : o;
  return (
    (pv.useSyncExternalStore =
      n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : u),
    pv
  );
}
var eT;
function R$() {
  return (eT || ((eT = 1), (fv.exports = C$())), fv.exports);
}
var tT;
function I$() {
  if (tT) return dv;
  tT = 1;
  var n = mT(),
    e = R$();
  function t(c, u) {
    return (c === u && (c !== 0 || 1 / c === 1 / u)) || (c !== c && u !== u);
  }
  var i = typeof Object.is == 'function' ? Object.is : t,
    r = e.useSyncExternalStore,
    s = n.useRef,
    a = n.useEffect,
    o = n.useMemo,
    l = n.useDebugValue;
  return (
    (dv.useSyncExternalStoreWithSelector = function (c, u, h, d, f) {
      var p = s(null);
      if (p.current === null) {
        var m = { hasValue: !1, value: null };
        p.current = m;
      } else m = p.current;
      p = o(
        function () {
          function v(b) {
            if (!y) {
              if (((y = !0), (_ = b), (b = d(b)), f !== void 0 && m.hasValue)) {
                var A = m.value;
                if (f(A, b)) return (x = A);
              }
              return (x = b);
            }
            if (((A = x), i(_, b))) return A;
            var E = d(b);
            return f !== void 0 && f(A, E) ? ((_ = b), A) : ((_ = b), (x = E));
          }
          var y = !1,
            _,
            x,
            S = h === void 0 ? null : h;
          return [
            function () {
              return v(u());
            },
            S === null
              ? void 0
              : function () {
                  return v(S());
                },
          ];
        },
        [u, h, d, f]
      );
      var g = r(c, p[0], p[1]);
      return (
        a(
          function () {
            ((m.hasValue = !0), (m.value = g));
          },
          [g]
        ),
        l(g),
        g
      );
    }),
    dv
  );
}
var nT;
function P$() {
  return (nT || ((nT = 1), (hv.exports = I$())), hv.exports);
}
var D$ = P$();
const O$ = cy(D$),
  iT = (n) => {
    let e;
    const t = new Set(),
      i = (c, u) => {
        const h = typeof c == 'function' ? c(e) : c;
        if (!Object.is(h, e)) {
          const d = e;
          ((e =
            (u ?? (typeof h != 'object' || h === null))
              ? h
              : Object.assign({}, e, h)),
            t.forEach((f) => f(e, d)));
        }
      },
      r = () => e,
      o = {
        setState: i,
        getState: r,
        getInitialState: () => l,
        subscribe: (c) => (t.add(c), () => t.delete(c)),
      },
      l = (e = n(i, r, o));
    return o;
  },
  L$ = (n) => (n ? iT(n) : iT),
  { useSyncExternalStoreWithSelector: U$ } = O$,
  k$ = (n) => n;
function B$(n, e = k$, t) {
  const i = U$(n.subscribe, n.getState, n.getInitialState, e, t);
  return ($3.useDebugValue(i), i);
}
const rT = (n, e) => {
    const t = L$(n),
      i = (r, s = e) => B$(t, r, s);
    return (Object.assign(i, t), i);
  },
  cie = (n, e) => (n ? rT(n, e) : rT);
var mv = { exports: {} },
  gv = {};
var sT;
function N$() {
  return (
    sT ||
      ((sT = 1),
      (function (n) {
        function e(C, N) {
          var U = C.length;
          C.push(N);
          e: for (; 0 < U; ) {
            var W = (U - 1) >>> 1,
              G = C[W];
            if (0 < r(G, N)) ((C[W] = N), (C[U] = G), (U = W));
            else break e;
          }
        }
        function t(C) {
          return C.length === 0 ? null : C[0];
        }
        function i(C) {
          if (C.length === 0) return null;
          var N = C[0],
            U = C.pop();
          if (U !== N) {
            C[0] = U;
            e: for (var W = 0, G = C.length, ne = G >>> 1; W < ne; ) {
              var ve = 2 * (W + 1) - 1,
                Se = C[ve],
                Ae = ve + 1,
                Oe = C[Ae];
              if (0 > r(Se, U))
                Ae < G && 0 > r(Oe, Se)
                  ? ((C[W] = Oe), (C[Ae] = U), (W = Ae))
                  : ((C[W] = Se), (C[ve] = U), (W = ve));
              else if (Ae < G && 0 > r(Oe, U))
                ((C[W] = Oe), (C[Ae] = U), (W = Ae));
              else break e;
            }
          }
          return N;
        }
        function r(C, N) {
          var U = C.sortIndex - N.sortIndex;
          return U !== 0 ? U : C.id - N.id;
        }
        if (
          ((n.unstable_now = void 0),
          typeof performance == 'object' &&
            typeof performance.now == 'function')
        ) {
          var s = performance;
          n.unstable_now = function () {
            return s.now();
          };
        } else {
          var a = Date,
            o = a.now();
          n.unstable_now = function () {
            return a.now() - o;
          };
        }
        var l = [],
          c = [],
          u = 1,
          h = null,
          d = 3,
          f = !1,
          p = !1,
          m = !1,
          g = typeof setTimeout == 'function' ? setTimeout : null,
          v = typeof clearTimeout == 'function' ? clearTimeout : null,
          y = typeof setImmediate < 'u' ? setImmediate : null;
        function _(C) {
          for (var N = t(c); N !== null; ) {
            if (N.callback === null) i(c);
            else if (N.startTime <= C)
              (i(c), (N.sortIndex = N.expirationTime), e(l, N));
            else break;
            N = t(c);
          }
        }
        function x(C) {
          if (((m = !1), _(C), !p))
            if (t(l) !== null) ((p = !0), O());
            else {
              var N = t(c);
              N !== null && z(x, N.startTime - C);
            }
        }
        var S = !1,
          b = -1,
          A = 5,
          E = -1;
        function w() {
          return !(n.unstable_now() - E < A);
        }
        function M() {
          if (S) {
            var C = n.unstable_now();
            E = C;
            var N = !0;
            try {
              e: {
                ((p = !1), m && ((m = !1), v(b), (b = -1)), (f = !0));
                var U = d;
                try {
                  t: {
                    for (
                      _(C), h = t(l);
                      h !== null && !(h.expirationTime > C && w());

                    ) {
                      var W = h.callback;
                      if (typeof W == 'function') {
                        ((h.callback = null), (d = h.priorityLevel));
                        var G = W(h.expirationTime <= C);
                        if (((C = n.unstable_now()), typeof G == 'function')) {
                          ((h.callback = G), _(C), (N = !0));
                          break t;
                        }
                        (h === t(l) && i(l), _(C));
                      } else i(l);
                      h = t(l);
                    }
                    if (h !== null) N = !0;
                    else {
                      var ne = t(c);
                      (ne !== null && z(x, ne.startTime - C), (N = !1));
                    }
                  }
                  break e;
                } finally {
                  ((h = null), (d = U), (f = !1));
                }
                N = void 0;
              }
            } finally {
              N ? T() : (S = !1);
            }
          }
        }
        var T;
        if (typeof y == 'function')
          T = function () {
            y(M);
          };
        else if (typeof MessageChannel < 'u') {
          var D = new MessageChannel(),
            L = D.port2;
          ((D.port1.onmessage = M),
            (T = function () {
              L.postMessage(null);
            }));
        } else
          T = function () {
            g(M, 0);
          };
        function O() {
          S || ((S = !0), T());
        }
        function z(C, N) {
          b = g(function () {
            C(n.unstable_now());
          }, N);
        }
        ((n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (C) {
            C.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            p || f || ((p = !0), O());
          }),
          (n.unstable_forceFrameRate = function (C) {
            0 > C || 125 < C
              ? console.error(
                  'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
                )
              : (A = 0 < C ? Math.floor(1e3 / C) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return d;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(l);
          }),
          (n.unstable_next = function (C) {
            switch (d) {
              case 1:
              case 2:
              case 3:
                var N = 3;
                break;
              default:
                N = d;
            }
            var U = d;
            d = N;
            try {
              return C();
            } finally {
              d = U;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (C, N) {
            switch (C) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                C = 3;
            }
            var U = d;
            d = C;
            try {
              return N();
            } finally {
              d = U;
            }
          }),
          (n.unstable_scheduleCallback = function (C, N, U) {
            var W = n.unstable_now();
            switch (
              (typeof U == 'object' && U !== null
                ? ((U = U.delay),
                  (U = typeof U == 'number' && 0 < U ? W + U : W))
                : (U = W),
              C)
            ) {
              case 1:
                var G = -1;
                break;
              case 2:
                G = 250;
                break;
              case 5:
                G = 1073741823;
                break;
              case 4:
                G = 1e4;
                break;
              default:
                G = 5e3;
            }
            return (
              (G = U + G),
              (C = {
                id: u++,
                callback: N,
                priorityLevel: C,
                startTime: U,
                expirationTime: G,
                sortIndex: -1,
              }),
              U > W
                ? ((C.sortIndex = U),
                  e(c, C),
                  t(l) === null &&
                    C === t(c) &&
                    (m ? (v(b), (b = -1)) : (m = !0), z(x, U - W)))
                : ((C.sortIndex = G), e(l, C), p || f || ((p = !0), O())),
              C
            );
          }),
          (n.unstable_shouldYield = w),
          (n.unstable_wrapCallback = function (C) {
            var N = d;
            return function () {
              var U = d;
              d = N;
              try {
                return C.apply(this, arguments);
              } finally {
                d = U;
              }
            };
          }));
      })(gv)),
    gv
  );
}
var aT;
function F$() {
  return (aT || ((aT = 1), (mv.exports = N$())), mv.exports);
}
var uie = F$();
function U3(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = U3(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function k3(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const Sb = k3(Ue.createContext(null));
class z$ extends Ue.Component {
  render() {
    return Ue.createElement(
      Sb.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function V$() {
  const n = Ue.useContext(Sb);
  if (n === null)
    throw new Error(
      'its-fine: useFiber must be called within a <FiberProvider />!'
    );
  const e = Ue.useId();
  return Ue.useMemo(() => {
    for (const t of [n, n?.alternate]) {
      if (!t) continue;
      const i = U3(t, !1, (r) => {
        let s = r.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
const H$ = Symbol.for('react.context'),
  G$ = (n) =>
    n !== null && typeof n == 'object' && '$$typeof' in n && n.$$typeof === H$;
function W$() {
  const n = V$(),
    [e] = Ue.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    const i = t.type;
    (G$(i) && i !== Sb && !e.has(i) && e.set(i, Ue.use(k3(i))), (t = t.return));
  }
  return e;
}
function hie() {
  const n = W$();
  return Ue.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          Ue.createElement(
            e,
            null,
            Ue.createElement(t.Provider, { ...i, value: n.get(t) })
          ),
        (e) => Ue.createElement(z$, { ...e })
      ),
    [n]
  );
}
function oT() {
  return (
    (oT = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    oT.apply(null, arguments)
  );
}
const B3 = parseInt(la.replace(/\D+/g, ''));
var tr = Uint8Array,
  Gs = Uint16Array,
  ay = Uint32Array,
  N3 = new tr([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  F3 = new tr([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  j$ = new tr([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  z3 = function (n, e) {
    for (var t = new Gs(31), i = 0; i < 31; ++i) t[i] = e += 1 << n[i - 1];
    for (var r = new ay(t[30]), i = 1; i < 30; ++i)
      for (var s = t[i]; s < t[i + 1]; ++s) r[s] = ((s - t[i]) << 5) | i;
    return [t, r];
  },
  V3 = z3(N3, 2),
  H3 = V3[0],
  X$ = V3[1];
((H3[28] = 258), (X$[258] = 28));
var q$ = z3(F3, 0),
  Y$ = q$[0],
  oy = new Gs(32768);
for (var tn = 0; tn < 32768; ++tn) {
  var Ds = ((tn & 43690) >>> 1) | ((tn & 21845) << 1);
  ((Ds = ((Ds & 52428) >>> 2) | ((Ds & 13107) << 2)),
    (Ds = ((Ds & 61680) >>> 4) | ((Ds & 3855) << 4)),
    (oy[tn] = (((Ds & 65280) >>> 8) | ((Ds & 255) << 8)) >>> 1));
}
var Nu = function (n, e, t) {
    for (var i = n.length, r = 0, s = new Gs(e); r < i; ++r) ++s[n[r] - 1];
    var a = new Gs(e);
    for (r = 0; r < e; ++r) a[r] = (a[r - 1] + s[r - 1]) << 1;
    var o;
    if (t) {
      o = new Gs(1 << e);
      var l = 15 - e;
      for (r = 0; r < i; ++r)
        if (n[r])
          for (
            var c = (r << 4) | n[r],
              u = e - n[r],
              h = a[n[r] - 1]++ << u,
              d = h | ((1 << u) - 1);
            h <= d;
            ++h
          )
            o[oy[h] >>> l] = c;
    } else
      for (o = new Gs(i), r = 0; r < i; ++r)
        n[r] && (o[r] = oy[a[n[r] - 1]++] >>> (15 - n[r]));
    return o;
  },
  Qh = new tr(288);
for (var tn = 0; tn < 144; ++tn) Qh[tn] = 8;
for (var tn = 144; tn < 256; ++tn) Qh[tn] = 9;
for (var tn = 256; tn < 280; ++tn) Qh[tn] = 7;
for (var tn = 280; tn < 288; ++tn) Qh[tn] = 8;
var G3 = new tr(32);
for (var tn = 0; tn < 32; ++tn) G3[tn] = 5;
var K$ = Nu(Qh, 9, 1),
  J$ = Nu(G3, 5, 1),
  vv = function (n) {
    for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
    return e;
  },
  mr = function (n, e, t) {
    var i = (e / 8) | 0;
    return ((n[i] | (n[i + 1] << 8)) >> (e & 7)) & t;
  },
  _v = function (n, e) {
    var t = (e / 8) | 0;
    return (n[t] | (n[t + 1] << 8) | (n[t + 2] << 16)) >> (e & 7);
  },
  Q$ = function (n) {
    return ((n / 8) | 0) + (n & 7 && 1);
  },
  Z$ = function (n, e, t) {
    (t == null || t > n.length) && (t = n.length);
    var i = new (n instanceof Gs ? Gs : n instanceof ay ? ay : tr)(t - e);
    return (i.set(n.subarray(e, t)), i);
  },
  $$ = function (n, e, t) {
    var i = n.length;
    if (!i || (t && !t.l && i < 5)) return e || new tr(0);
    var r = !e || t,
      s = !t || t.i;
    (t || (t = {}), e || (e = new tr(i * 3)));
    var a = function (Z) {
        var J = e.length;
        if (Z > J) {
          var de = new tr(Math.max(J * 2, Z));
          (de.set(e), (e = de));
        }
      },
      o = t.f || 0,
      l = t.p || 0,
      c = t.b || 0,
      u = t.l,
      h = t.d,
      d = t.m,
      f = t.n,
      p = i * 8;
    do {
      if (!u) {
        t.f = o = mr(n, l, 1);
        var m = mr(n, l + 1, 3);
        if (((l += 3), m))
          if (m == 1) ((u = K$), (h = J$), (d = 9), (f = 5));
          else if (m == 2) {
            var _ = mr(n, l, 31) + 257,
              x = mr(n, l + 10, 15) + 4,
              S = _ + mr(n, l + 5, 31) + 1;
            l += 14;
            for (var b = new tr(S), A = new tr(19), E = 0; E < x; ++E)
              A[j$[E]] = mr(n, l + E * 3, 7);
            l += x * 3;
            for (
              var w = vv(A), M = (1 << w) - 1, T = Nu(A, w, 1), E = 0;
              E < S;

            ) {
              var D = T[mr(n, l, M)];
              l += D & 15;
              var g = D >>> 4;
              if (g < 16) b[E++] = g;
              else {
                var L = 0,
                  O = 0;
                for (
                  g == 16
                    ? ((O = 3 + mr(n, l, 3)), (l += 2), (L = b[E - 1]))
                    : g == 17
                      ? ((O = 3 + mr(n, l, 7)), (l += 3))
                      : g == 18 && ((O = 11 + mr(n, l, 127)), (l += 7));
                  O--;

                )
                  b[E++] = L;
              }
            }
            var z = b.subarray(0, _),
              C = b.subarray(_);
            ((d = vv(z)), (f = vv(C)), (u = Nu(z, d, 1)), (h = Nu(C, f, 1)));
          } else throw 'invalid block type';
        else {
          var g = Q$(l) + 4,
            v = n[g - 4] | (n[g - 3] << 8),
            y = g + v;
          if (y > i) {
            if (s) throw 'unexpected EOF';
            break;
          }
          (r && a(c + v),
            e.set(n.subarray(g, y), c),
            (t.b = c += v),
            (t.p = l = y * 8));
          continue;
        }
        if (l > p) {
          if (s) throw 'unexpected EOF';
          break;
        }
      }
      r && a(c + 131072);
      for (var N = (1 << d) - 1, U = (1 << f) - 1, W = l; ; W = l) {
        var L = u[_v(n, l) & N],
          G = L >>> 4;
        if (((l += L & 15), l > p)) {
          if (s) throw 'unexpected EOF';
          break;
        }
        if (!L) throw 'invalid length/literal';
        if (G < 256) e[c++] = G;
        else if (G == 256) {
          ((W = l), (u = null));
          break;
        } else {
          var ne = G - 254;
          if (G > 264) {
            var E = G - 257,
              ve = N3[E];
            ((ne = mr(n, l, (1 << ve) - 1) + H3[E]), (l += ve));
          }
          var Se = h[_v(n, l) & U],
            Ae = Se >>> 4;
          if (!Se) throw 'invalid distance';
          l += Se & 15;
          var C = Y$[Ae];
          if (Ae > 3) {
            var ve = F3[Ae];
            ((C += _v(n, l) & ((1 << ve) - 1)), (l += ve));
          }
          if (l > p) {
            if (s) throw 'unexpected EOF';
            break;
          }
          r && a(c + 131072);
          for (var Oe = c + ne; c < Oe; c += 4)
            ((e[c] = e[c - C]),
              (e[c + 1] = e[c + 1 - C]),
              (e[c + 2] = e[c + 2 - C]),
              (e[c + 3] = e[c + 3 - C]));
          c = Oe;
        }
      }
      ((t.l = u),
        (t.p = W),
        (t.b = c),
        u && ((o = 1), (t.m = d), (t.d = h), (t.n = f)));
    } while (!o);
    return c == e.length ? e : Z$(e, 0, c);
  },
  eee = new tr(0),
  tee = function (n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || ((n[0] << 8) | n[1]) % 31)
      throw 'invalid zlib data';
    if (n[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
  };
function pf(n, e) {
  return $$((tee(n), n.subarray(2, -4)), e);
}
var nee = typeof TextDecoder < 'u' && new TextDecoder(),
  iee = 0;
try {
  (nee.decode(eee, { stream: !0 }), (iee = 1));
} catch {}
const ree = (n) => n && n.isCubeTexture;
class die extends hn {
  constructor(e, t) {
    var i, r;
    const s = ree(e),
      o =
        ((r = s
          ? (i = e.image[0]) == null
            ? void 0
            : i.width
          : e.image.width) != null
          ? r
          : 1024) / 4,
      l = Math.floor(Math.log2(o)),
      c = Math.pow(2, l),
      u = 3 * Math.max(c, 112),
      h = 4 * c,
      d = [
        s ? '#define ENVMAP_TYPE_CUBE' : '',
        `#define CUBEUV_TEXEL_WIDTH ${1 / u}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / h}`,
        `#define CUBEUV_MAX_MIP ${l}.0`,
      ],
      f = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      p =
        d.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${B3 >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>
        }
        `,
      m = {
        map: { value: e },
        height: { value: t?.height || 15 },
        radius: { value: t?.radius || 100 },
      },
      g = new Wh(1, 16),
      v = new rn({ uniforms: m, fragmentShader: p, vertexShader: f, side: ci });
    super(g, v);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
class fie extends gb {
  constructor(e) {
    (super(e), (this.type = Gn));
  }
  parse(e) {
    const a = function (E, w) {
        switch (E) {
          case 1:
            throw new Error('THREE.RGBELoader: Read Error: ' + (w || ''));
          case 2:
            throw new Error('THREE.RGBELoader: Write Error: ' + (w || ''));
          case 3:
            throw new Error('THREE.RGBELoader: Bad File Format: ' + (w || ''));
          default:
          case 4:
            throw new Error('THREE.RGBELoader: Memory Error: ' + (w || ''));
        }
      },
      h = function (E, w, M) {
        w = w || 1024;
        let D = E.pos,
          L = -1,
          O = 0,
          z = '',
          C = String.fromCharCode.apply(
            null,
            new Uint16Array(E.subarray(D, D + 128))
          );
        for (
          ;
          0 >
            (L = C.indexOf(`
`)) &&
          O < w &&
          D < E.byteLength;

        )
          ((z += C),
            (O += C.length),
            (D += 128),
            (C += String.fromCharCode.apply(
              null,
              new Uint16Array(E.subarray(D, D + 128))
            )));
        return -1 < L ? ((E.pos += O + L + 1), z + C.slice(0, L)) : !1;
      },
      d = function (E) {
        const w = /^#\?(\S+)/,
          M = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          T = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          D = /^\s*FORMAT=(\S+)\s*$/,
          L = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          O = {
            valid: 0,
            string: '',
            comments: '',
            programtype: 'RGBE',
            format: '',
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let z, C;
        for (
          (E.pos >= E.byteLength || !(z = h(E))) && a(1, 'no header found'),
            (C = z.match(w)) || a(3, 'bad initial token'),
            O.valid |= 1,
            O.programtype = C[1],
            O.string +=
              z +
              `
`;
          (z = h(E)), z !== !1;

        ) {
          if (
            ((O.string +=
              z +
              `
`),
            z.charAt(0) === '#')
          ) {
            O.comments +=
              z +
              `
`;
            continue;
          }
          if (
            ((C = z.match(M)) && (O.gamma = parseFloat(C[1])),
            (C = z.match(T)) && (O.exposure = parseFloat(C[1])),
            (C = z.match(D)) && ((O.valid |= 2), (O.format = C[1])),
            (C = z.match(L)) &&
              ((O.valid |= 4),
              (O.height = parseInt(C[1], 10)),
              (O.width = parseInt(C[2], 10))),
            O.valid & 2 && O.valid & 4)
          )
            break;
        }
        return (
          O.valid & 2 || a(3, 'missing format specifier'),
          O.valid & 4 || a(3, 'missing image size specifier'),
          O
        );
      },
      f = function (E, w, M) {
        const T = w;
        if (T < 8 || T > 32767 || E[0] !== 2 || E[1] !== 2 || E[2] & 128)
          return new Uint8Array(E);
        T !== ((E[2] << 8) | E[3]) && a(3, 'wrong scanline width');
        const D = new Uint8Array(4 * w * M);
        D.length || a(4, 'unable to allocate buffer space');
        let L = 0,
          O = 0;
        const z = 4 * T,
          C = new Uint8Array(4),
          N = new Uint8Array(z);
        let U = M;
        for (; U > 0 && O < E.byteLength; ) {
          (O + 4 > E.byteLength && a(1),
            (C[0] = E[O++]),
            (C[1] = E[O++]),
            (C[2] = E[O++]),
            (C[3] = E[O++]),
            (C[0] != 2 || C[1] != 2 || ((C[2] << 8) | C[3]) != T) &&
              a(3, 'bad rgbe scanline format'));
          let W = 0,
            G;
          for (; W < z && O < E.byteLength; ) {
            G = E[O++];
            const ve = G > 128;
            if (
              (ve && (G -= 128),
              (G === 0 || W + G > z) && a(3, 'bad scanline data'),
              ve)
            ) {
              const Se = E[O++];
              for (let Ae = 0; Ae < G; Ae++) N[W++] = Se;
            } else (N.set(E.subarray(O, O + G), W), (W += G), (O += G));
          }
          const ne = T;
          for (let ve = 0; ve < ne; ve++) {
            let Se = 0;
            ((D[L] = N[ve + Se]),
              (Se += T),
              (D[L + 1] = N[ve + Se]),
              (Se += T),
              (D[L + 2] = N[ve + Se]),
              (Se += T),
              (D[L + 3] = N[ve + Se]),
              (L += 4));
          }
          U--;
        }
        return D;
      },
      p = function (E, w, M, T) {
        const D = E[w + 3],
          L = Math.pow(2, D - 128) / 255;
        ((M[T + 0] = E[w + 0] * L),
          (M[T + 1] = E[w + 1] * L),
          (M[T + 2] = E[w + 2] * L),
          (M[T + 3] = 1));
      },
      m = function (E, w, M, T) {
        const D = E[w + 3],
          L = Math.pow(2, D - 128) / 255;
        ((M[T + 0] = po.toHalfFloat(Math.min(E[w + 0] * L, 65504))),
          (M[T + 1] = po.toHalfFloat(Math.min(E[w + 1] * L, 65504))),
          (M[T + 2] = po.toHalfFloat(Math.min(E[w + 2] * L, 65504))),
          (M[T + 3] = po.toHalfFloat(1)));
      },
      g = new Uint8Array(e);
    g.pos = 0;
    const v = d(g),
      y = v.width,
      _ = v.height,
      x = f(g.subarray(g.pos), y, _);
    let S, b, A;
    switch (this.type) {
      case un:
        A = x.length / 4;
        const E = new Float32Array(A * 4);
        for (let M = 0; M < A; M++) p(x, M * 4, E, M * 4);
        ((S = E), (b = un));
        break;
      case Gn:
        A = x.length / 4;
        const w = new Uint16Array(A * 4);
        for (let M = 0; M < A; M++) m(x, M * 4, w, M * 4);
        ((S = w), (b = Gn));
        break;
      default:
        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type);
    }
    return {
      width: y,
      height: _,
      data: S,
      header: v.string,
      gamma: v.gamma,
      exposure: v.exposure,
      type: b,
    };
  }
  setDataType(e) {
    return ((this.type = e), this);
  }
  load(e, t, i, r) {
    function s(a, o) {
      switch (a.type) {
        case un:
        case Gn:
          ('colorSpace' in a
            ? (a.colorSpace = 'srgb-linear')
            : (a.encoding = 3e3),
            (a.minFilter = Dt),
            (a.magFilter = Dt),
            (a.generateMipmaps = !1),
            (a.flipY = !0));
          break;
      }
      t && t(a, o);
    }
    return super.load(e, s, i, r);
  }
}
const au = B3 >= 152;
class pie extends gb {
  constructor(e) {
    (super(e), (this.type = Gn));
  }
  parse(e) {
    const w = Math.pow(2.7182818, 2.2);
    function M(R, k) {
      for (var q = 0, te = 0; te < 65536; ++te)
        (te == 0 || R[te >> 3] & (1 << (te & 7))) && (k[q++] = te);
      for (var ce = q - 1; q < 65536; ) k[q++] = 0;
      return ce;
    }
    function T(R) {
      for (var k = 0; k < 16384; k++)
        ((R[k] = {}), (R[k].len = 0), (R[k].lit = 0), (R[k].p = null));
    }
    const D = { l: 0, c: 0, lc: 0 };
    function L(R, k, q, te, ce) {
      for (; q < R; ) ((k = (k << 8) | ct(te, ce)), (q += 8));
      ((q -= R), (D.l = (k >> q) & ((1 << R) - 1)), (D.c = k), (D.lc = q));
    }
    const O = new Array(59);
    function z(R) {
      for (var k = 0; k <= 58; ++k) O[k] = 0;
      for (var k = 0; k < 65537; ++k) O[R[k]] += 1;
      for (var q = 0, k = 58; k > 0; --k) {
        var te = (q + O[k]) >> 1;
        ((O[k] = q), (q = te));
      }
      for (var k = 0; k < 65537; ++k) {
        var ce = R[k];
        ce > 0 && (R[k] = ce | (O[ce]++ << 6));
      }
    }
    function C(R, k, q, te, ce, ue, De) {
      for (var Re = q, Fe = 0, I = 0; ce <= ue; ce++) {
        if (Re.value - q.value > te) return !1;
        L(6, Fe, I, R, Re);
        var H = D.l;
        if (((Fe = D.c), (I = D.lc), (De[ce] = H), H == 63)) {
          if (Re.value - q.value > te)
            throw 'Something wrong with hufUnpackEncTable';
          L(8, Fe, I, R, Re);
          var X = D.l + 6;
          if (((Fe = D.c), (I = D.lc), ce + X > ue + 1))
            throw 'Something wrong with hufUnpackEncTable';
          for (; X--; ) De[ce++] = 0;
          ce--;
        } else if (H >= 59) {
          var X = H - 59 + 2;
          if (ce + X > ue + 1) throw 'Something wrong with hufUnpackEncTable';
          for (; X--; ) De[ce++] = 0;
          ce--;
        }
      }
      z(De);
    }
    function N(R) {
      return R & 63;
    }
    function U(R) {
      return R >> 6;
    }
    function W(R, k, q, te) {
      for (; k <= q; k++) {
        var ce = U(R[k]),
          ue = N(R[k]);
        if (ce >> ue) throw 'Invalid table entry';
        if (ue > 14) {
          var De = te[ce >> (ue - 14)];
          if (De.len) throw 'Invalid table entry';
          if ((De.lit++, De.p)) {
            var Re = De.p;
            De.p = new Array(De.lit);
            for (var Fe = 0; Fe < De.lit - 1; ++Fe) De.p[Fe] = Re[Fe];
          } else De.p = new Array(1);
          De.p[De.lit - 1] = k;
        } else if (ue)
          for (var I = 0, Fe = 1 << (14 - ue); Fe > 0; Fe--) {
            var De = te[(ce << (14 - ue)) + I];
            if (De.len || De.p) throw 'Invalid table entry';
            ((De.len = ue), (De.lit = k), I++);
          }
      }
      return !0;
    }
    const G = { c: 0, lc: 0 };
    function ne(R, k, q, te) {
      ((R = (R << 8) | ct(q, te)), (k += 8), (G.c = R), (G.lc = k));
    }
    const ve = { c: 0, lc: 0 };
    function Se(R, k, q, te, ce, ue, De, Re, Fe, I) {
      if (R == k) {
        (te < 8 && (ne(q, te, ce, De), (q = G.c), (te = G.lc)), (te -= 8));
        var H = q >> te,
          H = new Uint8Array([H])[0];
        if (Fe.value + H > I) return !1;
        for (var X = Re[Fe.value - 1]; H-- > 0; ) Re[Fe.value++] = X;
      } else if (Fe.value < I) Re[Fe.value++] = R;
      else return !1;
      ((ve.c = q), (ve.lc = te));
    }
    function Ae(R) {
      return R & 65535;
    }
    function Oe(R) {
      var k = Ae(R);
      return k > 32767 ? k - 65536 : k;
    }
    const Z = { a: 0, b: 0 };
    function J(R, k) {
      var q = Oe(R),
        te = Oe(k),
        ce = te,
        ue = q + (ce & 1) + (ce >> 1),
        De = ue,
        Re = ue - ce;
      ((Z.a = De), (Z.b = Re));
    }
    function de(R, k) {
      var q = Ae(R),
        te = Ae(k),
        ce = (q - (te >> 1)) & 65535,
        ue = (te + ce - 32768) & 65535;
      ((Z.a = ue), (Z.b = ce));
    }
    function fe(R, k, q, te, ce, ue, De) {
      for (var Re = De < 16384, Fe = q > ce ? ce : q, I = 1, H; I <= Fe; )
        I <<= 1;
      for (I >>= 1, H = I, I >>= 1; I >= 1; ) {
        for (
          var X = 0,
            $ = X + ue * (ce - H),
            j = ue * I,
            ae = ue * H,
            _e = te * I,
            Me = te * H,
            Pe,
            Ve,
            Ye,
            qe;
          X <= $;
          X += ae
        ) {
          for (var nt = X, Tt = X + te * (q - H); nt <= Tt; nt += Me) {
            var ht = nt + _e,
              wt = nt + j,
              It = wt + _e;
            Re
              ? (J(R[nt + k], R[wt + k]),
                (Pe = Z.a),
                (Ye = Z.b),
                J(R[ht + k], R[It + k]),
                (Ve = Z.a),
                (qe = Z.b),
                J(Pe, Ve),
                (R[nt + k] = Z.a),
                (R[ht + k] = Z.b),
                J(Ye, qe),
                (R[wt + k] = Z.a),
                (R[It + k] = Z.b))
              : (de(R[nt + k], R[wt + k]),
                (Pe = Z.a),
                (Ye = Z.b),
                de(R[ht + k], R[It + k]),
                (Ve = Z.a),
                (qe = Z.b),
                de(Pe, Ve),
                (R[nt + k] = Z.a),
                (R[ht + k] = Z.b),
                de(Ye, qe),
                (R[wt + k] = Z.a),
                (R[It + k] = Z.b));
          }
          if (q & I) {
            var wt = nt + j;
            (Re ? J(R[nt + k], R[wt + k]) : de(R[nt + k], R[wt + k]),
              (Pe = Z.a),
              (R[wt + k] = Z.b),
              (R[nt + k] = Pe));
          }
        }
        if (ce & I)
          for (var nt = X, Tt = X + te * (q - H); nt <= Tt; nt += Me) {
            var ht = nt + _e;
            (Re ? J(R[nt + k], R[ht + k]) : de(R[nt + k], R[ht + k]),
              (Pe = Z.a),
              (R[ht + k] = Z.b),
              (R[nt + k] = Pe));
          }
        ((H = I), (I >>= 1));
      }
      return X;
    }
    function K(R, k, q, te, ce, ue, De, Re, Fe, I) {
      for (
        var H = 0, X = 0, $ = Re, j = Math.trunc(ce.value + (ue + 7) / 8);
        ce.value < j;

      )
        for (ne(H, X, q, ce), H = G.c, X = G.lc; X >= 14; ) {
          var ae = (H >> (X - 14)) & 16383,
            _e = k[ae];
          if (_e.len)
            ((X -= _e.len),
              Se(_e.lit, De, H, X, q, te, ce, Fe, I, $),
              (H = ve.c),
              (X = ve.lc));
          else {
            if (!_e.p) throw 'hufDecode issues';
            var Me;
            for (Me = 0; Me < _e.lit; Me++) {
              for (var Pe = N(R[_e.p[Me]]); X < Pe && ce.value < j; )
                (ne(H, X, q, ce), (H = G.c), (X = G.lc));
              if (
                X >= Pe &&
                U(R[_e.p[Me]]) == ((H >> (X - Pe)) & ((1 << Pe) - 1))
              ) {
                ((X -= Pe),
                  Se(_e.p[Me], De, H, X, q, te, ce, Fe, I, $),
                  (H = ve.c),
                  (X = ve.lc));
                break;
              }
            }
            if (Me == _e.lit) throw 'hufDecode issues';
          }
        }
      var Ve = (8 - ue) & 7;
      for (H >>= Ve, X -= Ve; X > 0; ) {
        var _e = k[(H << (14 - X)) & 16383];
        if (_e.len)
          ((X -= _e.len),
            Se(_e.lit, De, H, X, q, te, ce, Fe, I, $),
            (H = ve.c),
            (X = ve.lc));
        else throw 'hufDecode issues';
      }
      return !0;
    }
    function oe(R, k, q, te, ce, ue) {
      var De = { value: 0 },
        Re = q.value,
        Fe = Ce(k, q),
        I = Ce(k, q);
      q.value += 4;
      var H = Ce(k, q);
      if (((q.value += 4), Fe < 0 || Fe >= 65537 || I < 0 || I >= 65537))
        throw 'Something wrong with HUF_ENCSIZE';
      var X = new Array(65537),
        $ = new Array(16384);
      T($);
      var j = te - (q.value - Re);
      if ((C(R, k, q, j, Fe, I, X), H > 8 * (te - (q.value - Re))))
        throw 'Something wrong with hufUncompress';
      (W(X, Fe, I, $), K(X, $, R, k, q, H, I, ue, ce, De));
    }
    function he(R, k, q) {
      for (var te = 0; te < q; ++te) k[te] = R[k[te]];
    }
    function xe(R) {
      for (var k = 1; k < R.length; k++) {
        var q = R[k - 1] + R[k] - 128;
        R[k] = q;
      }
    }
    function ee(R, k) {
      for (
        var q = 0,
          te = Math.floor((R.length + 1) / 2),
          ce = 0,
          ue = R.length - 1;
        !(ce > ue || ((k[ce++] = R[q++]), ce > ue));

      )
        k[ce++] = R[te++];
    }
    function B(R) {
      for (
        var k = R.byteLength, q = new Array(), te = 0, ce = new DataView(R);
        k > 0;

      ) {
        var ue = ce.getInt8(te++);
        if (ue < 0) {
          var De = -ue;
          k -= De + 1;
          for (var Re = 0; Re < De; Re++) q.push(ce.getUint8(te++));
        } else {
          var De = ue;
          k -= 2;
          for (var Fe = ce.getUint8(te++), Re = 0; Re < De + 1; Re++)
            q.push(Fe);
        }
      }
      return q;
    }
    function me(R, k, q, te, ce, ue) {
      var ht = new DataView(ue.buffer),
        De = q[R.idx[0]].width,
        Re = q[R.idx[0]].height,
        Fe = 3,
        I = Math.floor(De / 8),
        H = Math.ceil(De / 8),
        X = Math.ceil(Re / 8),
        $ = De - (H - 1) * 8,
        j = Re - (X - 1) * 8,
        ae = { value: 0 },
        _e = new Array(Fe),
        Me = new Array(Fe),
        Pe = new Array(Fe),
        Ve = new Array(Fe),
        Ye = new Array(Fe);
      for (let rt = 0; rt < Fe; ++rt)
        ((Ye[rt] = k[R.idx[rt]]),
          (_e[rt] = rt < 1 ? 0 : _e[rt - 1] + H * X),
          (Me[rt] = new Float32Array(64)),
          (Pe[rt] = new Uint16Array(64)),
          (Ve[rt] = new Uint16Array(H * 64)));
      for (let rt = 0; rt < X; ++rt) {
        var qe = 8;
        rt == X - 1 && (qe = j);
        var nt = 8;
        for (let Ht = 0; Ht < H; ++Ht) {
          Ht == H - 1 && (nt = $);
          for (let yt = 0; yt < Fe; ++yt)
            (Pe[yt].fill(0),
              (Pe[yt][0] = ce[_e[yt]++]),
              ye(ae, te, Pe[yt]),
              Te(Pe[yt], Me[yt]),
              Ee(Me[yt]));
          Xe(Me);
          for (let yt = 0; yt < Fe; ++yt) Ne(Me[yt], Ve[yt], Ht * 64);
        }
        let Xt = 0;
        for (let Ht = 0; Ht < Fe; ++Ht) {
          const yt = q[R.idx[Ht]].type;
          for (let Nn = 8 * rt; Nn < 8 * rt + qe; ++Nn) {
            Xt = Ye[Ht][Nn];
            for (let Gt = 0; Gt < I; ++Gt) {
              const Kt = Gt * 64 + (Nn & 7) * 8;
              (ht.setUint16(Xt + 0 * yt, Ve[Ht][Kt + 0], !0),
                ht.setUint16(Xt + 2 * yt, Ve[Ht][Kt + 1], !0),
                ht.setUint16(Xt + 4 * yt, Ve[Ht][Kt + 2], !0),
                ht.setUint16(Xt + 6 * yt, Ve[Ht][Kt + 3], !0),
                ht.setUint16(Xt + 8 * yt, Ve[Ht][Kt + 4], !0),
                ht.setUint16(Xt + 10 * yt, Ve[Ht][Kt + 5], !0),
                ht.setUint16(Xt + 12 * yt, Ve[Ht][Kt + 6], !0),
                ht.setUint16(Xt + 14 * yt, Ve[Ht][Kt + 7], !0),
                (Xt += 16 * yt));
            }
          }
          if (I != H)
            for (let Nn = 8 * rt; Nn < 8 * rt + qe; ++Nn) {
              const Gt = Ye[Ht][Nn] + 8 * I * 2 * yt,
                Kt = I * 64 + (Nn & 7) * 8;
              for (let vn = 0; vn < nt; ++vn)
                ht.setUint16(Gt + vn * 2 * yt, Ve[Ht][Kt + vn], !0);
            }
        }
      }
      for (
        var Tt = new Uint16Array(De), ht = new DataView(ue.buffer), wt = 0;
        wt < Fe;
        ++wt
      ) {
        q[R.idx[wt]].decoded = !0;
        var It = q[R.idx[wt]].type;
        if (q[wt].type == 2)
          for (var ot = 0; ot < Re; ++ot) {
            const rt = Ye[wt][ot];
            for (var Ot = 0; Ot < De; ++Ot)
              Tt[Ot] = ht.getUint16(rt + Ot * 2 * It, !0);
            for (var Ot = 0; Ot < De; ++Ot)
              ht.setFloat32(rt + Ot * 2 * It, re(Tt[Ot]), !0);
          }
      }
    }
    function ye(R, k, q) {
      for (var te, ce = 1; ce < 64; )
        ((te = k[R.value]),
          te == 65280
            ? (ce = 64)
            : te >> 8 == 255
              ? (ce += te & 255)
              : ((q[ce] = te), ce++),
          R.value++);
    }
    function Te(R, k) {
      ((k[0] = re(R[0])),
        (k[1] = re(R[1])),
        (k[2] = re(R[5])),
        (k[3] = re(R[6])),
        (k[4] = re(R[14])),
        (k[5] = re(R[15])),
        (k[6] = re(R[27])),
        (k[7] = re(R[28])),
        (k[8] = re(R[2])),
        (k[9] = re(R[4])),
        (k[10] = re(R[7])),
        (k[11] = re(R[13])),
        (k[12] = re(R[16])),
        (k[13] = re(R[26])),
        (k[14] = re(R[29])),
        (k[15] = re(R[42])),
        (k[16] = re(R[3])),
        (k[17] = re(R[8])),
        (k[18] = re(R[12])),
        (k[19] = re(R[17])),
        (k[20] = re(R[25])),
        (k[21] = re(R[30])),
        (k[22] = re(R[41])),
        (k[23] = re(R[43])),
        (k[24] = re(R[9])),
        (k[25] = re(R[11])),
        (k[26] = re(R[18])),
        (k[27] = re(R[24])),
        (k[28] = re(R[31])),
        (k[29] = re(R[40])),
        (k[30] = re(R[44])),
        (k[31] = re(R[53])),
        (k[32] = re(R[10])),
        (k[33] = re(R[19])),
        (k[34] = re(R[23])),
        (k[35] = re(R[32])),
        (k[36] = re(R[39])),
        (k[37] = re(R[45])),
        (k[38] = re(R[52])),
        (k[39] = re(R[54])),
        (k[40] = re(R[20])),
        (k[41] = re(R[22])),
        (k[42] = re(R[33])),
        (k[43] = re(R[38])),
        (k[44] = re(R[46])),
        (k[45] = re(R[51])),
        (k[46] = re(R[55])),
        (k[47] = re(R[60])),
        (k[48] = re(R[21])),
        (k[49] = re(R[34])),
        (k[50] = re(R[37])),
        (k[51] = re(R[47])),
        (k[52] = re(R[50])),
        (k[53] = re(R[56])),
        (k[54] = re(R[59])),
        (k[55] = re(R[61])),
        (k[56] = re(R[35])),
        (k[57] = re(R[36])),
        (k[58] = re(R[48])),
        (k[59] = re(R[49])),
        (k[60] = re(R[57])),
        (k[61] = re(R[58])),
        (k[62] = re(R[62])),
        (k[63] = re(R[63])));
    }
    function Ee(R) {
      const k = 0.5 * Math.cos(0.7853975),
        q = 0.5 * Math.cos(3.14159 / 16),
        te = 0.5 * Math.cos(3.14159 / 8),
        ce = 0.5 * Math.cos((3 * 3.14159) / 16),
        ue = 0.5 * Math.cos((5 * 3.14159) / 16),
        De = 0.5 * Math.cos((3 * 3.14159) / 8),
        Re = 0.5 * Math.cos((7 * 3.14159) / 16);
      for (
        var Fe = new Array(4),
          I = new Array(4),
          H = new Array(4),
          X = new Array(4),
          $ = 0;
        $ < 8;
        ++$
      ) {
        var j = $ * 8;
        ((Fe[0] = te * R[j + 2]),
          (Fe[1] = De * R[j + 2]),
          (Fe[2] = te * R[j + 6]),
          (Fe[3] = De * R[j + 6]),
          (I[0] = q * R[j + 1] + ce * R[j + 3] + ue * R[j + 5] + Re * R[j + 7]),
          (I[1] = ce * R[j + 1] - Re * R[j + 3] - q * R[j + 5] - ue * R[j + 7]),
          (I[2] = ue * R[j + 1] - q * R[j + 3] + Re * R[j + 5] + ce * R[j + 7]),
          (I[3] = Re * R[j + 1] - ue * R[j + 3] + ce * R[j + 5] - q * R[j + 7]),
          (H[0] = k * (R[j + 0] + R[j + 4])),
          (H[3] = k * (R[j + 0] - R[j + 4])),
          (H[1] = Fe[0] + Fe[3]),
          (H[2] = Fe[1] - Fe[2]),
          (X[0] = H[0] + H[1]),
          (X[1] = H[3] + H[2]),
          (X[2] = H[3] - H[2]),
          (X[3] = H[0] - H[1]),
          (R[j + 0] = X[0] + I[0]),
          (R[j + 1] = X[1] + I[1]),
          (R[j + 2] = X[2] + I[2]),
          (R[j + 3] = X[3] + I[3]),
          (R[j + 4] = X[3] - I[3]),
          (R[j + 5] = X[2] - I[2]),
          (R[j + 6] = X[1] - I[1]),
          (R[j + 7] = X[0] - I[0]));
      }
      for (var ae = 0; ae < 8; ++ae)
        ((Fe[0] = te * R[16 + ae]),
          (Fe[1] = De * R[16 + ae]),
          (Fe[2] = te * R[48 + ae]),
          (Fe[3] = De * R[48 + ae]),
          (I[0] =
            q * R[8 + ae] +
            ce * R[24 + ae] +
            ue * R[40 + ae] +
            Re * R[56 + ae]),
          (I[1] =
            ce * R[8 + ae] -
            Re * R[24 + ae] -
            q * R[40 + ae] -
            ue * R[56 + ae]),
          (I[2] =
            ue * R[8 + ae] -
            q * R[24 + ae] +
            Re * R[40 + ae] +
            ce * R[56 + ae]),
          (I[3] =
            Re * R[8 + ae] -
            ue * R[24 + ae] +
            ce * R[40 + ae] -
            q * R[56 + ae]),
          (H[0] = k * (R[ae] + R[32 + ae])),
          (H[3] = k * (R[ae] - R[32 + ae])),
          (H[1] = Fe[0] + Fe[3]),
          (H[2] = Fe[1] - Fe[2]),
          (X[0] = H[0] + H[1]),
          (X[1] = H[3] + H[2]),
          (X[2] = H[3] - H[2]),
          (X[3] = H[0] - H[1]),
          (R[0 + ae] = X[0] + I[0]),
          (R[8 + ae] = X[1] + I[1]),
          (R[16 + ae] = X[2] + I[2]),
          (R[24 + ae] = X[3] + I[3]),
          (R[32 + ae] = X[3] - I[3]),
          (R[40 + ae] = X[2] - I[2]),
          (R[48 + ae] = X[1] - I[1]),
          (R[56 + ae] = X[0] - I[0]));
    }
    function Xe(R) {
      for (var k = 0; k < 64; ++k) {
        var q = R[0][k],
          te = R[1][k],
          ce = R[2][k];
        ((R[0][k] = q + 1.5747 * ce),
          (R[1][k] = q - 0.1873 * te - 0.4682 * ce),
          (R[2][k] = q + 1.8556 * te));
      }
    }
    function Ne(R, k, q) {
      for (var te = 0; te < 64; ++te) k[q + te] = po.toHalfFloat(We(R[te]));
    }
    function We(R) {
      return R <= 1
        ? Math.sign(R) * Math.pow(Math.abs(R), 2.2)
        : Math.sign(R) * Math.pow(w, Math.abs(R) - 1);
    }
    function F(R) {
      return new DataView(R.array.buffer, R.offset.value, R.size);
    }
    function P(R) {
      var k = R.viewer.buffer.slice(R.offset.value, R.offset.value + R.size),
        q = new Uint8Array(B(k)),
        te = new Uint8Array(q.length);
      return (xe(q), ee(q, te), new DataView(te.buffer));
    }
    function Q(R) {
      var k = R.array.slice(R.offset.value, R.offset.value + R.size),
        q = pf(k),
        te = new Uint8Array(q.length);
      return (xe(q), ee(q, te), new DataView(te.buffer));
    }
    function le(R) {
      for (
        var k = R.viewer,
          q = { value: R.offset.value },
          te = new Uint16Array(
            R.width * R.scanlineBlockSize * (R.channels * R.type)
          ),
          ce = new Uint8Array(8192),
          ue = 0,
          De = new Array(R.channels),
          Re = 0;
        Re < R.channels;
        Re++
      )
        ((De[Re] = {}),
          (De[Re].start = ue),
          (De[Re].end = De[Re].start),
          (De[Re].nx = R.width),
          (De[Re].ny = R.lines),
          (De[Re].size = R.type),
          (ue += De[Re].nx * De[Re].ny * De[Re].size));
      var Fe = ke(k, q),
        I = ke(k, q);
      if (I >= 8192)
        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';
      if (Fe <= I)
        for (var Re = 0; Re < I - Fe + 1; Re++) ce[Re + Fe] = it(k, q);
      var H = new Uint16Array(65536),
        X = M(ce, H),
        $ = Ce(k, q);
      oe(R.array, k, q, $, te, ue);
      for (var Re = 0; Re < R.channels; ++Re)
        for (var j = De[Re], ae = 0; ae < De[Re].size; ++ae)
          fe(te, j.start + ae, j.nx, j.size, j.ny, j.nx * j.size, X);
      he(H, te, ue);
      for (
        var _e = 0, Me = new Uint8Array(te.buffer.byteLength), Pe = 0;
        Pe < R.lines;
        Pe++
      )
        for (var Ve = 0; Ve < R.channels; Ve++) {
          var j = De[Ve],
            Ye = j.nx * j.size,
            qe = new Uint8Array(te.buffer, j.end * 2, Ye * 2);
          (Me.set(qe, _e), (_e += Ye * 2), (j.end += Ye));
        }
      return new DataView(Me.buffer);
    }
    function ge(R) {
      var k = R.array.slice(R.offset.value, R.offset.value + R.size),
        q = pf(k);
      const te = R.lines * R.channels * R.width,
        ce = R.type == 1 ? new Uint16Array(te) : new Uint32Array(te);
      let ue = 0,
        De = 0;
      const Re = new Array(4);
      for (let Fe = 0; Fe < R.lines; Fe++)
        for (let I = 0; I < R.channels; I++) {
          let H = 0;
          switch (R.type) {
            case 1:
              ((Re[0] = ue), (Re[1] = Re[0] + R.width), (ue = Re[1] + R.width));
              for (let X = 0; X < R.width; ++X) {
                const $ = (q[Re[0]++] << 8) | q[Re[1]++];
                ((H += $), (ce[De] = H), De++);
              }
              break;
            case 2:
              ((Re[0] = ue),
                (Re[1] = Re[0] + R.width),
                (Re[2] = Re[1] + R.width),
                (ue = Re[2] + R.width));
              for (let X = 0; X < R.width; ++X) {
                const $ =
                  (q[Re[0]++] << 24) | (q[Re[1]++] << 16) | (q[Re[2]++] << 8);
                ((H += $), (ce[De] = H), De++);
              }
              break;
          }
        }
      return new DataView(ce.buffer);
    }
    function se(R) {
      var k = R.viewer,
        q = { value: R.offset.value },
        te = new Uint8Array(R.width * R.lines * (R.channels * R.type * 2)),
        ce = {
          version: Le(k, q),
          unknownUncompressedSize: Le(k, q),
          unknownCompressedSize: Le(k, q),
          acCompressedSize: Le(k, q),
          dcCompressedSize: Le(k, q),
          rleCompressedSize: Le(k, q),
          rleUncompressedSize: Le(k, q),
          rleRawSize: Le(k, q),
          totalAcUncompressedCount: Le(k, q),
          totalDcUncompressedCount: Le(k, q),
          acCompression: Le(k, q),
        };
      if (ce.version < 2)
        throw (
          'EXRLoader.parse: ' +
          bs.compression +
          ' version ' +
          ce.version +
          ' is unsupported'
        );
      for (var ue = new Array(), De = ke(k, q) - 2; De > 0; ) {
        var Re = Ke(k.buffer, q),
          Fe = it(k, q),
          I = (Fe >> 2) & 3,
          H = (Fe >> 4) - 1,
          X = new Int8Array([H])[0],
          $ = it(k, q);
        (ue.push({ name: Re, index: X, type: $, compression: I }),
          (De -= Re.length + 3));
      }
      for (
        var j = bs.channels, ae = new Array(R.channels), _e = 0;
        _e < R.channels;
        ++_e
      ) {
        var Me = (ae[_e] = {}),
          Pe = j[_e];
        ((Me.name = Pe.name),
          (Me.compression = 0),
          (Me.decoded = !1),
          (Me.type = Pe.pixelType),
          (Me.pLinear = Pe.pLinear),
          (Me.width = R.width),
          (Me.height = R.lines));
      }
      for (var Ve = { idx: new Array(3) }, Ye = 0; Ye < R.channels; ++Ye)
        for (var Me = ae[Ye], _e = 0; _e < ue.length; ++_e) {
          var qe = ue[_e];
          Me.name == qe.name &&
            ((Me.compression = qe.compression),
            qe.index >= 0 && (Ve.idx[qe.index] = Ye),
            (Me.offset = Ye));
        }
      if (ce.acCompressedSize > 0)
        switch (ce.acCompression) {
          case 0:
            var ht = new Uint16Array(ce.totalAcUncompressedCount);
            oe(
              R.array,
              k,
              q,
              ce.acCompressedSize,
              ht,
              ce.totalAcUncompressedCount
            );
            break;
          case 1:
            var nt = R.array.slice(
                q.value,
                q.value + ce.totalAcUncompressedCount
              ),
              Tt = pf(nt),
              ht = new Uint16Array(Tt.buffer);
            q.value += ce.totalAcUncompressedCount;
            break;
        }
      if (ce.dcCompressedSize > 0) {
        var wt = { array: R.array, offset: q, size: ce.dcCompressedSize },
          It = new Uint16Array(Q(wt).buffer);
        q.value += ce.dcCompressedSize;
      }
      if (ce.rleRawSize > 0) {
        var nt = R.array.slice(q.value, q.value + ce.rleCompressedSize),
          Tt = pf(nt),
          ot = B(Tt.buffer);
        q.value += ce.rleCompressedSize;
      }
      for (var Ot = 0, rt = new Array(ae.length), _e = 0; _e < rt.length; ++_e)
        rt[_e] = new Array();
      for (var Xt = 0; Xt < R.lines; ++Xt)
        for (var Ht = 0; Ht < ae.length; ++Ht)
          (rt[Ht].push(Ot), (Ot += ae[Ht].width * R.type * 2));
      me(Ve, rt, ae, ht, It, te);
      for (var _e = 0; _e < ae.length; ++_e) {
        var Me = ae[_e];
        if (!Me.decoded)
          switch (Me.compression) {
            case 2:
              for (var yt = 0, Nn = 0, Xt = 0; Xt < R.lines; ++Xt) {
                for (var Gt = rt[_e][yt], Kt = 0; Kt < Me.width; ++Kt) {
                  for (var vn = 0; vn < 2 * Me.type; ++vn)
                    te[Gt++] = ot[Nn + vn * Me.width * Me.height];
                  Nn++;
                }
                yt++;
              }
              break;
            case 1:
            default:
              throw 'EXRLoader.parse: unsupported channel compression';
          }
      }
      return new DataView(te.buffer);
    }
    function Ke(R, k) {
      for (var q = new Uint8Array(R), te = 0; q[k.value + te] != 0; ) te += 1;
      var ce = new TextDecoder().decode(q.slice(k.value, k.value + te));
      return ((k.value = k.value + te + 1), ce);
    }
    function Be(R, k, q) {
      var te = new TextDecoder().decode(
        new Uint8Array(R).slice(k.value, k.value + q)
      );
      return ((k.value = k.value + q), te);
    }
    function at(R, k) {
      var q = we(R, k),
        te = Ce(R, k);
      return [q, te];
    }
    function Je(R, k) {
      var q = Ce(R, k),
        te = Ce(R, k);
      return [q, te];
    }
    function we(R, k) {
      var q = R.getInt32(k.value, !0);
      return ((k.value = k.value + 4), q);
    }
    function Ce(R, k) {
      var q = R.getUint32(k.value, !0);
      return ((k.value = k.value + 4), q);
    }
    function ct(R, k) {
      var q = R[k.value];
      return ((k.value = k.value + 1), q);
    }
    function it(R, k) {
      var q = R.getUint8(k.value);
      return ((k.value = k.value + 1), q);
    }
    const Le = function (R, k) {
      let q;
      return (
        'getBigInt64' in DataView.prototype
          ? (q = Number(R.getBigInt64(k.value, !0)))
          : (q =
              R.getUint32(k.value + 4, !0) +
              Number(R.getUint32(k.value, !0) << 32)),
        (k.value += 8),
        q
      );
    };
    function et(R, k) {
      var q = R.getFloat32(k.value, !0);
      return ((k.value += 4), q);
    }
    function Y(R, k) {
      return po.toHalfFloat(et(R, k));
    }
    function re(R) {
      var k = (R & 31744) >> 10,
        q = R & 1023;
      return (
        (R >> 15 ? -1 : 1) *
        (k
          ? k === 31
            ? q
              ? NaN
              : 1 / 0
            : Math.pow(2, k - 15) * (1 + q / 1024)
          : 6103515625e-14 * (q / 1024))
      );
    }
    function ke(R, k) {
      var q = R.getUint16(k.value, !0);
      return ((k.value += 2), q);
    }
    function ze(R, k) {
      return re(ke(R, k));
    }
    function Ie(R, k, q, te) {
      for (var ce = q.value, ue = []; q.value < ce + te - 1; ) {
        var De = Ke(k, q),
          Re = we(R, q),
          Fe = it(R, q);
        q.value += 3;
        var I = we(R, q),
          H = we(R, q);
        ue.push({
          name: De,
          pixelType: Re,
          pLinear: Fe,
          xSampling: I,
          ySampling: H,
        });
      }
      return ((q.value += 1), ue);
    }
    function be(R, k) {
      var q = et(R, k),
        te = et(R, k),
        ce = et(R, k),
        ue = et(R, k),
        De = et(R, k),
        Re = et(R, k),
        Fe = et(R, k),
        I = et(R, k);
      return {
        redX: q,
        redY: te,
        greenX: ce,
        greenY: ue,
        blueX: De,
        blueY: Re,
        whiteX: Fe,
        whiteY: I,
      };
    }
    function tt(R, k) {
      var q = [
          'NO_COMPRESSION',
          'RLE_COMPRESSION',
          'ZIPS_COMPRESSION',
          'ZIP_COMPRESSION',
          'PIZ_COMPRESSION',
          'PXR24_COMPRESSION',
          'B44_COMPRESSION',
          'B44A_COMPRESSION',
          'DWAA_COMPRESSION',
          'DWAB_COMPRESSION',
        ],
        te = it(R, k);
      return q[te];
    }
    function vt(R, k) {
      var q = Ce(R, k),
        te = Ce(R, k),
        ce = Ce(R, k),
        ue = Ce(R, k);
      return { xMin: q, yMin: te, xMax: ce, yMax: ue };
    }
    function Qt(R, k) {
      var q = ['INCREASING_Y'],
        te = it(R, k);
      return q[te];
    }
    function jt(R, k) {
      var q = et(R, k),
        te = et(R, k);
      return [q, te];
    }
    function Ji(R, k) {
      var q = et(R, k),
        te = et(R, k),
        ce = et(R, k);
      return [q, te, ce];
    }
    function Di(R, k, q, te, ce) {
      if (te === 'string' || te === 'stringvector' || te === 'iccProfile')
        return Be(k, q, ce);
      if (te === 'chlist') return Ie(R, k, q, ce);
      if (te === 'chromaticities') return be(R, q);
      if (te === 'compression') return tt(R, q);
      if (te === 'box2i') return vt(R, q);
      if (te === 'lineOrder') return Qt(R, q);
      if (te === 'float') return et(R, q);
      if (te === 'v2f') return jt(R, q);
      if (te === 'v3f') return Ji(R, q);
      if (te === 'int') return we(R, q);
      if (te === 'rational') return at(R, q);
      if (te === 'timecode') return Je(R, q);
      if (te === 'preview') return ((q.value += ce), 'skipped');
      q.value += ce;
    }
    function tg(R, k, q) {
      const te = {};
      if (R.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      te.version = R.getUint8(4);
      const ce = R.getUint8(5);
      ((te.spec = {
        singleTile: !!(ce & 2),
        longName: !!(ce & 4),
        deepFormat: !!(ce & 8),
        multiPart: !!(ce & 16),
      }),
        (q.value = 8));
      for (var ue = !0; ue; ) {
        var De = Ke(k, q);
        if (De == 0) ue = !1;
        else {
          var Re = Ke(k, q),
            Fe = Ce(R, q),
            I = Di(R, k, q, Re, Fe);
          I === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${Re}'.`
              )
            : (te[De] = I);
        }
      }
      if ((ce & -5) != 0)
        throw (
          console.error('EXRHeader:', te),
          'THREE.EXRLoader: provided file is currently unsupported.'
        );
      return te;
    }
    function Zh(R, k, q, te, ce) {
      const ue = {
        size: 0,
        viewer: k,
        array: q,
        offset: te,
        width: R.dataWindow.xMax - R.dataWindow.xMin + 1,
        height: R.dataWindow.yMax - R.dataWindow.yMin + 1,
        channels: R.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: R.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [au ? 'colorSpace' : 'encoding']: null,
      };
      switch (R.compression) {
        case 'NO_COMPRESSION':
          ((ue.lines = 1), (ue.uncompress = F));
          break;
        case 'RLE_COMPRESSION':
          ((ue.lines = 1), (ue.uncompress = P));
          break;
        case 'ZIPS_COMPRESSION':
          ((ue.lines = 1), (ue.uncompress = Q));
          break;
        case 'ZIP_COMPRESSION':
          ((ue.lines = 16), (ue.uncompress = Q));
          break;
        case 'PIZ_COMPRESSION':
          ((ue.lines = 32), (ue.uncompress = le));
          break;
        case 'PXR24_COMPRESSION':
          ((ue.lines = 16), (ue.uncompress = ge));
          break;
        case 'DWAA_COMPRESSION':
          ((ue.lines = 32), (ue.uncompress = se));
          break;
        case 'DWAB_COMPRESSION':
          ((ue.lines = 256), (ue.uncompress = se));
          break;
        default:
          throw 'EXRLoader.parse: ' + R.compression + ' is unsupported';
      }
      if (((ue.scanlineBlockSize = ue.lines), ue.type == 1))
        switch (ce) {
          case un:
            ((ue.getter = ze), (ue.inputSize = 2));
            break;
          case Gn:
            ((ue.getter = ke), (ue.inputSize = 2));
            break;
        }
      else if (ue.type == 2)
        switch (ce) {
          case un:
            ((ue.getter = et), (ue.inputSize = 4));
            break;
          case Gn:
            ((ue.getter = Y), (ue.inputSize = 4));
        }
      else
        throw (
          'EXRLoader.parse: unsupported pixelType ' +
          ue.type +
          ' for ' +
          R.compression +
          '.'
        );
      ue.blockCount = (R.dataWindow.yMax + 1) / ue.scanlineBlockSize;
      for (var De = 0; De < ue.blockCount; De++) Le(k, te);
      ue.outputChannels = ue.channels == 3 ? 4 : ue.channels;
      const Re = ue.width * ue.height * ue.outputChannels;
      switch (ce) {
        case un:
          ((ue.byteArray = new Float32Array(Re)),
            ue.channels < ue.outputChannels && ue.byteArray.fill(1, 0, Re));
          break;
        case Gn:
          ((ue.byteArray = new Uint16Array(Re)),
            ue.channels < ue.outputChannels && ue.byteArray.fill(15360, 0, Re));
          break;
        default:
          console.error('THREE.EXRLoader: unsupported type: ', ce);
          break;
      }
      return (
        (ue.bytesPerLine = ue.width * ue.inputSize * ue.channels),
        ue.outputChannels == 4 ? (ue.format = Rn) : (ue.format = Nh),
        au ? (ue.colorSpace = 'srgb-linear') : (ue.encoding = 3e3),
        ue
      );
    }
    const pa = new DataView(e),
      Xr = new Uint8Array(e),
      qr = { value: 0 },
      bs = tg(pa, e, qr),
      Rt = Zh(bs, pa, Xr, qr, this.type),
      ma = { value: 0 },
      $h = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let R = 0; R < Rt.height / Rt.scanlineBlockSize; R++) {
      const k = Ce(pa, qr);
      ((Rt.size = Ce(pa, qr)),
        (Rt.lines =
          k + Rt.scanlineBlockSize > Rt.height
            ? Rt.height - k
            : Rt.scanlineBlockSize));
      const te =
        Rt.size < Rt.lines * Rt.bytesPerLine ? Rt.uncompress(Rt) : F(Rt);
      qr.value += Rt.size;
      for (let ce = 0; ce < Rt.scanlineBlockSize; ce++) {
        const ue = ce + R * Rt.scanlineBlockSize;
        if (ue >= Rt.height) break;
        for (let De = 0; De < Rt.channels; De++) {
          const Re = $h[bs.channels[De].name];
          for (let Fe = 0; Fe < Rt.width; Fe++) {
            ma.value =
              (ce * (Rt.channels * Rt.width) + De * Rt.width + Fe) *
              Rt.inputSize;
            const I =
              (Rt.height - 1 - ue) * (Rt.width * Rt.outputChannels) +
              Fe * Rt.outputChannels +
              Re;
            Rt.byteArray[I] = Rt.getter(te, ma);
          }
        }
      }
    }
    return {
      header: bs,
      width: Rt.width,
      height: Rt.height,
      data: Rt.byteArray,
      format: Rt.format,
      [au ? 'colorSpace' : 'encoding']: Rt[au ? 'colorSpace' : 'encoding'],
      type: this.type,
    };
  }
  setDataType(e) {
    return ((this.type = e), this);
  }
  load(e, t, i, r) {
    function s(a, o) {
      (au ? (a.colorSpace = o.colorSpace) : (a.encoding = o.encoding),
        (a.minFilter = Dt),
        (a.magFilter = Dt),
        (a.generateMipmaps = !1),
        (a.flipY = !1),
        t && t(a, o));
    }
    return super.load(e, s, i, r);
  }
}
const W3 = (n, e, t) => {
  let i;
  switch (n) {
    case gn:
      i = new Uint8ClampedArray(e * t * 4);
      break;
    case Gn:
      i = new Uint16Array(e * t * 4);
      break;
    case Mr:
      i = new Uint32Array(e * t * 4);
      break;
    case Sm:
      i = new Int8Array(e * t * 4);
      break;
    case wm:
      i = new Int16Array(e * t * 4);
      break;
    case Bh:
      i = new Int32Array(e * t * 4);
      break;
    case un:
      i = new Float32Array(e * t * 4);
      break;
    default:
      throw new Error('Unsupported data type');
  }
  return i;
};
let mf;
const see = (n, e, t, i) => {
  if (mf !== void 0) return mf;
  const r = new Sn(1, 1, i);
  e.setRenderTarget(r);
  const s = new hn(new da(), new xs({ color: 16777215 }));
  (e.render(s, t), e.setRenderTarget(null));
  const a = W3(n, r.width, r.height);
  return (
    e.readRenderTargetPixels(r, 0, 0, r.width, r.height, a),
    r.dispose(),
    s.geometry.dispose(),
    s.material.dispose(),
    (mf = a[0] !== 0),
    mf
  );
};
class wb {
  constructor(e) {
    var t, i, r, s, a, o, l, c, u, h, d, f, p, m, g, v;
    ((this._rendererIsDisposable = !1),
      (this._supportsReadPixels = !0),
      (this.render = () => {
        this._renderer.setRenderTarget(this._renderTarget);
        try {
          this._renderer.render(this._scene, this._camera);
        } catch (_) {
          throw (this._renderer.setRenderTarget(null), _);
        }
        this._renderer.setRenderTarget(null);
      }),
      (this._width = e.width),
      (this._height = e.height),
      (this._type = e.type),
      (this._colorSpace = e.colorSpace));
    const y = {
      format: Rn,
      depthBuffer: !1,
      stencilBuffer: !1,
      type: this._type,
      colorSpace: this._colorSpace,
      anisotropy:
        ((t = e.renderTargetOptions) === null || t === void 0
          ? void 0
          : t.anisotropy) !== void 0
          ? (i = e.renderTargetOptions) === null || i === void 0
            ? void 0
            : i.anisotropy
          : 1,
      generateMipmaps:
        ((r = e.renderTargetOptions) === null || r === void 0
          ? void 0
          : r.generateMipmaps) !== void 0
          ? (s = e.renderTargetOptions) === null || s === void 0
            ? void 0
            : s.generateMipmaps
          : !1,
      magFilter:
        ((a = e.renderTargetOptions) === null || a === void 0
          ? void 0
          : a.magFilter) !== void 0
          ? (o = e.renderTargetOptions) === null || o === void 0
            ? void 0
            : o.magFilter
          : Dt,
      minFilter:
        ((l = e.renderTargetOptions) === null || l === void 0
          ? void 0
          : l.minFilter) !== void 0
          ? (c = e.renderTargetOptions) === null || c === void 0
            ? void 0
            : c.minFilter
          : Dt,
      samples:
        ((u = e.renderTargetOptions) === null || u === void 0
          ? void 0
          : u.samples) !== void 0
          ? (h = e.renderTargetOptions) === null || h === void 0
            ? void 0
            : h.samples
          : void 0,
      wrapS:
        ((d = e.renderTargetOptions) === null || d === void 0
          ? void 0
          : d.wrapS) !== void 0
          ? (f = e.renderTargetOptions) === null || f === void 0
            ? void 0
            : f.wrapS
          : mn,
      wrapT:
        ((p = e.renderTargetOptions) === null || p === void 0
          ? void 0
          : p.wrapT) !== void 0
          ? (m = e.renderTargetOptions) === null || m === void 0
            ? void 0
            : m.wrapT
          : mn,
    };
    if (
      ((this._material = e.material),
      e.renderer
        ? (this._renderer = e.renderer)
        : ((this._renderer = wb.instantiateRenderer()),
          (this._rendererIsDisposable = !0)),
      (this._scene = new ph()),
      (this._camera = new Jh()),
      this._camera.position.set(0, 0, 10),
      (this._camera.left = -0.5),
      (this._camera.right = 0.5),
      (this._camera.top = 0.5),
      (this._camera.bottom = -0.5),
      this._camera.updateProjectionMatrix(),
      !see(this._type, this._renderer, this._camera, y))
    ) {
      let _;
      switch (this._type) {
        case Gn:
          _ = this._renderer.extensions.has('EXT_color_buffer_float')
            ? un
            : void 0;
          break;
      }
      _ !== void 0
        ? (console.warn(
            `This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${un}`
          ),
          (this._type = _))
        : ((this._supportsReadPixels = !1),
          console.warn(
            'This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown'
          ));
    }
    ((this._quad = new hn(new da(), this._material)),
      this._quad.geometry.computeBoundingBox(),
      this._scene.add(this._quad),
      (this._renderTarget = new Sn(this.width, this.height, y)),
      (this._renderTarget.texture.mapping =
        ((g = e.renderTargetOptions) === null || g === void 0
          ? void 0
          : g.mapping) !== void 0
          ? (v = e.renderTargetOptions) === null || v === void 0
            ? void 0
            : v.mapping
          : ea));
  }
  static instantiateRenderer() {
    const e = new L3();
    return (e.setSize(128, 128), e);
  }
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const e = W3(this._type, this._width, this._height);
    return (
      this._renderer.readRenderTargetPixels(
        this._renderTarget,
        0,
        0,
        this._width,
        this._height,
        e
      ),
      e
    );
  }
  toDataTexture(e) {
    const t = new or(
      this.toArray(),
      this.width,
      this.height,
      Rn,
      this._type,
      e?.mapping || ea,
      e?.wrapS || mn,
      e?.wrapT || mn,
      e?.magFilter || Dt,
      e?.minFilter || Dt,
      e?.anisotropy || 1,
      cr
    );
    return (
      (t.generateMipmaps =
        e?.generateMipmaps !== void 0 ? e?.generateMipmaps : !1),
      t
    );
  }
  disposeOnDemandRenderer() {
    (this._renderer.setRenderTarget(null),
      this._rendererIsDisposable &&
        (this._renderer.dispose(), this._renderer.forceContextLoss()));
  }
  dispose(e) {
    (this.disposeOnDemandRenderer(),
      e && this.renderTarget.dispose(),
      this.material instanceof rn &&
        Object.values(this.material.uniforms).forEach((t) => {
          t.value instanceof Vt && t.value.dispose();
        }),
      Object.values(this.material).forEach((t) => {
        t instanceof Vt && t.dispose();
      }),
      this.material.dispose(),
      this._quad.geometry.dispose());
  }
  get width() {
    return this._width;
  }
  set width(e) {
    ((this._width = e), this._renderTarget.setSize(this._width, this._height));
  }
  get height() {
    return this._height;
  }
  set height(e) {
    ((this._height = e), this._renderTarget.setSize(this._width, this._height));
  }
  get renderer() {
    return this._renderer;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    ((this._renderTarget = e),
      (this._width = e.width),
      (this._height = e.height));
  }
  get material() {
    return this._material;
  }
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const aee = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  oee = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class lee extends rn {
  constructor({
    gamma: e,
    offsetHdr: t,
    offsetSdr: i,
    gainMapMin: r,
    gainMapMax: s,
    maxDisplayBoost: a,
    hdrCapacityMin: o,
    hdrCapacityMax: l,
    sdr: c,
    gainMap: u,
  }) {
    (super({
      name: 'GainMapDecoderMaterial',
      vertexShader: aee,
      fragmentShader: oee,
      uniforms: {
        sdr: { value: c },
        gainMap: { value: u },
        gamma: { value: new V(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new V().fromArray(t) },
        offsetSdr: { value: new V().fromArray(i) },
        gainMapMin: { value: new V().fromArray(r) },
        gainMapMax: { value: new V().fromArray(s) },
        weightFactor: { value: (Math.log2(a) - o) / (l - o) },
      },
      blending: Ln,
      depthTest: !1,
      depthWrite: !1,
    }),
      (this._maxDisplayBoost = a),
      (this._hdrCapacityMin = o),
      (this._hdrCapacityMax = l),
      (this.needsUpdate = !0),
      (this.uniformsNeedUpdate = !0));
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    ((t.x = 1 / e[0]), (t.y = 1 / e[1]), (t.z = 1 / e[2]));
  }
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    ((this._hdrCapacityMin = e), this.calculateWeight());
  }
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    ((this._hdrCapacityMax = e), this.calculateWeight());
  }
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    ((this._maxDisplayBoost = Math.max(1, Math.min(65504, e))),
      this.calculateWeight());
  }
  calculateWeight() {
    const e =
      (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) /
      (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class j3 extends Error {}
class X3 extends Error {}
const ou = (n, e, t) => {
    const i = new RegExp(`${e}="([^"]*)"`, 'i').exec(n);
    if (i) return i[1];
    const r = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, 'i').exec(n);
    if (r) {
      const s = r[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
      return s && s.length === 3
        ? s.map((a) => a.replace(/<\/?rdf:li>/g, ''))
        : r[1].trim();
    }
    if (t !== void 0) return t;
    throw new Error(`Can't find ${e} in gainmap metadata`);
  },
  cee = (n) => {
    let e;
    typeof TextDecoder < 'u'
      ? (e = new TextDecoder().decode(n))
      : (e = n.toString());
    let t = e.indexOf('<x:xmpmeta');
    for (; t !== -1; ) {
      const i = e.indexOf('x:xmpmeta>', t),
        r = e.slice(t, i + 10);
      try {
        const s = ou(r, 'hdrgm:GainMapMin', '0'),
          a = ou(r, 'hdrgm:GainMapMax'),
          o = ou(r, 'hdrgm:Gamma', '1'),
          l = ou(r, 'hdrgm:OffsetSDR', '0.015625'),
          c = ou(r, 'hdrgm:OffsetHDR', '0.015625'),
          u = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(r),
          h = u ? u[1] : '0',
          d = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(r);
        if (!d) throw new Error('Incomplete gainmap metadata');
        const f = d[1];
        return {
          gainMapMin: Array.isArray(s)
            ? s.map((p) => parseFloat(p))
            : [parseFloat(s), parseFloat(s), parseFloat(s)],
          gainMapMax: Array.isArray(a)
            ? a.map((p) => parseFloat(p))
            : [parseFloat(a), parseFloat(a), parseFloat(a)],
          gamma: Array.isArray(o)
            ? o.map((p) => parseFloat(p))
            : [parseFloat(o), parseFloat(o), parseFloat(o)],
          offsetSdr: Array.isArray(l)
            ? l.map((p) => parseFloat(p))
            : [parseFloat(l), parseFloat(l), parseFloat(l)],
          offsetHdr: Array.isArray(c)
            ? c.map((p) => parseFloat(p))
            : [parseFloat(c), parseFloat(c), parseFloat(c)],
          hdrCapacityMin: parseFloat(h),
          hdrCapacityMax: parseFloat(f),
        };
      } catch {}
      t = e.indexOf('<x:xmpmeta', i);
    }
  };
class uee {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0,
    };
  }
  extract(e) {
    return new Promise((t, i) => {
      const r = this.options.debug,
        s = new DataView(e.buffer);
      if (s.getUint16(0) !== 65496) {
        i(new Error('Not a valid jpeg'));
        return;
      }
      const a = s.byteLength;
      let o = 2,
        l = 0,
        c;
      for (; o < a; ) {
        if (++l > 250) {
          i(new Error(`Found no marker after ${l} loops `));
          return;
        }
        if (s.getUint8(o) !== 255) {
          i(
            new Error(
              `Not a valid marker at offset 0x${o.toString(16)}, found: 0x${s.getUint8(o).toString(16)}`
            )
          );
          return;
        }
        if (
          ((c = s.getUint8(o + 1)),
          r && console.log(`Marker: ${c.toString(16)}`),
          c === 226)
        ) {
          r && console.log('Found APP2 marker (0xffe2)');
          const u = o + 4;
          if (s.getUint32(u) === 1297106432) {
            const h = u + 4;
            let d;
            if (s.getUint16(h) === 18761) d = !1;
            else if (s.getUint16(h) === 19789) d = !0;
            else {
              i(new Error('No valid endianness marker found in TIFF header'));
              return;
            }
            if (s.getUint16(h + 2, !d) !== 42) {
              i(new Error('Not valid TIFF data! (no 0x002A marker)'));
              return;
            }
            const f = s.getUint32(h + 4, !d);
            if (f < 8) {
              i(new Error('Not valid TIFF data! (First offset less than 8)'));
              return;
            }
            const p = h + f,
              m = s.getUint16(p, !d),
              g = p + 2;
            let v = 0;
            for (let S = g; S < g + 12 * m; S += 12)
              s.getUint16(S, !d) === 45057 && (v = s.getUint32(S + 8, !d));
            const _ = p + 2 + m * 12 + 4,
              x = [];
            for (let S = _; S < _ + v * 16; S += 16) {
              const b = {
                MPType: s.getUint32(S, !d),
                size: s.getUint32(S + 4, !d),
                dataOffset: s.getUint32(S + 8, !d),
                dependantImages: s.getUint32(S + 12, !d),
                start: -1,
                end: -1,
                isFII: !1,
              };
              (b.dataOffset
                ? ((b.start = h + b.dataOffset), (b.isFII = !1))
                : ((b.start = 0), (b.isFII = !0)),
                (b.end = b.start + b.size),
                x.push(b));
            }
            if (this.options.extractNonFII && x.length) {
              const S = new Blob([s]),
                b = [];
              for (const A of x) {
                if (A.isFII && !this.options.extractFII) continue;
                const E = S.slice(A.start, A.end + 1, 'image/jpeg');
                b.push(E);
              }
              t(b);
            }
          }
        }
        o += 2 + s.getUint16(o + 2);
      }
    });
  }
}
const hee = async (n) => {
    const e = cee(n);
    if (!e) throw new X3('Gain map XMP metadata not found');
    const i = await new uee({ extractFII: !0, extractNonFII: !0 }).extract(n);
    if (i.length !== 2) throw new j3('Gain map recovery image not found');
    return {
      sdr: new Uint8Array(await i[0].arrayBuffer()),
      gainMap: new Uint8Array(await i[1].arrayBuffer()),
      metadata: e,
    };
  },
  lT = (n) =>
    new Promise((e, t) => {
      const i = document.createElement('img');
      ((i.onload = () => {
        e(i);
      }),
        (i.onerror = (r) => {
          t(r);
        }),
        (i.src = URL.createObjectURL(n)));
    });
class q3 extends vi {
  constructor(e, t) {
    (super(t),
      e && (this._renderer = e),
      (this._internalLoadingManager = new Kh()));
  }
  setRenderer(e) {
    return ((this._renderer = e), this);
  }
  setRenderTargetOptions(e) {
    return ((this._renderTargetOptions = e), this);
  }
  prepareQuadRenderer() {
    this._renderer ||
      console.warn(
        'WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.'
      );
    const e = new lee({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Vt(),
      sdr: new Vt(),
    });
    return new wb({
      width: 16,
      height: 16,
      type: Gn,
      colorSpace: cr,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions,
    });
  }
  async render(e, t, i, r) {
    const s = r ? new Blob([r], { type: 'image/jpeg' }) : void 0,
      a = new Blob([i], { type: 'image/jpeg' });
    let o,
      l,
      c = !1;
    if (typeof createImageBitmap > 'u') {
      const d = await Promise.all([s ? lT(s) : Promise.resolve(void 0), lT(a)]);
      ((l = d[0]), (o = d[1]), (c = !0));
    } else {
      const d = await Promise.all([
        s
          ? createImageBitmap(s, { imageOrientation: 'flipY' })
          : Promise.resolve(void 0),
        createImageBitmap(a, { imageOrientation: 'flipY' }),
      ]);
      ((l = d[0]), (o = d[1]));
    }
    const u = new Vt(
      l || new ImageData(2, 2),
      ea,
      mn,
      mn,
      Dt,
      Y_,
      Rn,
      gn,
      1,
      cr
    );
    ((u.flipY = c), (u.needsUpdate = !0));
    const h = new Vt(o, ea, mn, mn, Dt, Y_, Rn, gn, 1, Wt);
    ((h.flipY = c),
      (h.needsUpdate = !0),
      (e.width = o.width),
      (e.height = o.height),
      (e.material.gainMap = u),
      (e.material.sdr = h),
      (e.material.gainMapMin = t.gainMapMin),
      (e.material.gainMapMax = t.gainMapMax),
      (e.material.offsetHdr = t.offsetHdr),
      (e.material.offsetSdr = t.offsetSdr),
      (e.material.gamma = t.gamma),
      (e.material.hdrCapacityMin = t.hdrCapacityMin),
      (e.material.hdrCapacityMax = t.hdrCapacityMax),
      (e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax)),
      (e.material.needsUpdate = !0),
      e.render());
  }
}
class mie extends q3 {
  load([e, t, i], r, s, a) {
    const o = this.prepareQuadRenderer();
    let l, c, u;
    const h = async () => {
      if (l && c && u) {
        try {
          await this.render(o, u, l, c);
        } catch (w) {
          (this.manager.itemError(e),
            this.manager.itemError(t),
            this.manager.itemError(i),
            typeof a == 'function' && a(w),
            o.disposeOnDemandRenderer());
          return;
        }
        (typeof r == 'function' && r(o),
          this.manager.itemEnd(e),
          this.manager.itemEnd(t),
          this.manager.itemEnd(i),
          o.disposeOnDemandRenderer());
      }
    };
    let d = !0,
      f = 0,
      p = 0,
      m = !0,
      g = 0,
      v = 0,
      y = !0,
      _ = 0,
      x = 0;
    const S = () => {
      if (typeof s == 'function') {
        const w = f + g + _,
          M = p + v + x,
          T = d && m && y;
        s(
          new ProgressEvent('progress', {
            lengthComputable: T,
            loaded: M,
            total: w,
          })
        );
      }
    };
    (this.manager.itemStart(e),
      this.manager.itemStart(t),
      this.manager.itemStart(i));
    const b = new ji(this._internalLoadingManager);
    (b.setResponseType('arraybuffer'),
      b.setRequestHeader(this.requestHeader),
      b.setPath(this.path),
      b.setWithCredentials(this.withCredentials),
      b.load(
        e,
        async (w) => {
          if (typeof w == 'string') throw new Error('Invalid sdr buffer');
          ((l = w), await h());
        },
        (w) => {
          ((d = w.lengthComputable), (p = w.loaded), (f = w.total), S());
        },
        (w) => {
          (this.manager.itemError(e), typeof a == 'function' && a(w));
        }
      ));
    const A = new ji(this._internalLoadingManager);
    (A.setResponseType('arraybuffer'),
      A.setRequestHeader(this.requestHeader),
      A.setPath(this.path),
      A.setWithCredentials(this.withCredentials),
      A.load(
        t,
        async (w) => {
          if (typeof w == 'string') throw new Error('Invalid gainmap buffer');
          ((c = w), await h());
        },
        (w) => {
          ((m = w.lengthComputable), (v = w.loaded), (g = w.total), S());
        },
        (w) => {
          (this.manager.itemError(t), typeof a == 'function' && a(w));
        }
      ));
    const E = new ji(this._internalLoadingManager);
    return (
      E.setRequestHeader(this.requestHeader),
      E.setPath(this.path),
      E.setWithCredentials(this.withCredentials),
      E.load(
        i,
        async (w) => {
          if (typeof w != 'string') throw new Error('Invalid metadata string');
          ((u = JSON.parse(w)), await h());
        },
        (w) => {
          ((y = w.lengthComputable), (x = w.loaded), (_ = w.total), S());
        },
        (w) => {
          (this.manager.itemError(i), typeof a == 'function' && a(w));
        }
      ),
      o
    );
  }
}
class gie extends q3 {
  load(e, t, i, r) {
    const s = this.prepareQuadRenderer(),
      a = new ji(this._internalLoadingManager);
    return (
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(this.withCredentials),
      this.manager.itemStart(e),
      a.load(
        e,
        async (o) => {
          if (typeof o == 'string')
            throw new Error(
              'Invalid buffer, received [string], was expecting [ArrayBuffer]'
            );
          const l = new Uint8Array(o);
          let c, u, h;
          try {
            const d = await hee(l);
            ((c = d.sdr), (u = d.gainMap), (h = d.metadata));
          } catch (d) {
            if (d instanceof X3 || d instanceof j3)
              (console.warn(
                `Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`
              ),
                (h = {
                  gainMapMin: [0, 0, 0],
                  gainMapMax: [1, 1, 1],
                  gamma: [1, 1, 1],
                  hdrCapacityMin: 0,
                  hdrCapacityMax: 1,
                  offsetHdr: [0, 0, 0],
                  offsetSdr: [0, 0, 0],
                }),
                (c = l));
            else throw d;
          }
          try {
            await this.render(s, h, c, u);
          } catch (d) {
            (this.manager.itemError(e),
              typeof r == 'function' && r(d),
              s.disposeOnDemandRenderer());
            return;
          }
          (typeof t == 'function' && t(s),
            this.manager.itemEnd(e),
            s.disposeOnDemandRenderer());
        },
        i,
        (o) => {
          (this.manager.itemError(e), typeof r == 'function' && r(o));
        }
      ),
      s
    );
  }
}
function vie(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function (r) {
    if ((n?.(r), t === !1 || !r.defaultPrevented)) return e?.(r);
  };
}
var dee = function (n) {
    if (typeof document > 'u') return null;
    var e = Array.isArray(n) ? n[0] : n;
    return e.ownerDocument.body;
  },
  xl = new WeakMap(),
  gf = new WeakMap(),
  vf = {},
  yv = 0,
  Y3 = function (n) {
    return n && (n.host || Y3(n.parentNode));
  },
  fee = function (n, e) {
    return e
      .map(function (t) {
        if (n.contains(t)) return t;
        var i = Y3(t);
        return i && n.contains(i)
          ? i
          : (console.error(
              'aria-hidden',
              t,
              'in not contained inside',
              n,
              '. Doing nothing'
            ),
            null);
      })
      .filter(function (t) {
        return !!t;
      });
  },
  pee = function (n, e, t, i) {
    var r = fee(e, Array.isArray(n) ? n : [n]);
    vf[t] || (vf[t] = new WeakMap());
    var s = vf[t],
      a = [],
      o = new Set(),
      l = new Set(r),
      c = function (h) {
        !h || o.has(h) || (o.add(h), c(h.parentNode));
      };
    r.forEach(c);
    var u = function (h) {
      !h ||
        l.has(h) ||
        Array.prototype.forEach.call(h.children, function (d) {
          if (o.has(d)) u(d);
          else
            try {
              var f = d.getAttribute(i),
                p = f !== null && f !== 'false',
                m = (xl.get(d) || 0) + 1,
                g = (s.get(d) || 0) + 1;
              (xl.set(d, m),
                s.set(d, g),
                a.push(d),
                m === 1 && p && gf.set(d, !0),
                g === 1 && d.setAttribute(t, 'true'),
                p || d.setAttribute(i, 'true'));
            } catch (v) {
              console.error('aria-hidden: cannot operate on ', d, v);
            }
        });
    };
    return (
      u(e),
      o.clear(),
      yv++,
      function () {
        (a.forEach(function (h) {
          var d = xl.get(h) - 1,
            f = s.get(h) - 1;
          (xl.set(h, d),
            s.set(h, f),
            d || (gf.has(h) || h.removeAttribute(i), gf.delete(h)),
            f || h.removeAttribute(t));
        }),
          yv--,
          yv ||
            ((xl = new WeakMap()),
            (xl = new WeakMap()),
            (gf = new WeakMap()),
            (vf = {})));
      }
    );
  },
  _ie = function (n, e, t) {
    t === void 0 && (t = 'data-aria-hidden');
    var i = Array.from(Array.isArray(n) ? n : [n]),
      r = dee(n);
    return r
      ? (i.push.apply(i, Array.from(r.querySelectorAll('[aria-live], script'))),
        pee(i, r, t, 'aria-hidden'))
      : function () {
          return null;
        };
  };
var xv = 1 / 1e3,
  mee = 1e3,
  gee = class {
    constructor() {
      ((this.startTime = performance.now()),
        (this.previousTime = 0),
        (this.currentTime = 0),
        (this._delta = 0),
        (this._elapsed = 0),
        (this._fixedDelta = 1e3 / 60),
        (this.timescale = 1),
        (this.useFixedDelta = !1),
        (this._autoReset = !1));
    }
    get autoReset() {
      return this._autoReset;
    }
    set autoReset(n) {
      typeof document < 'u' &&
        document.hidden !== void 0 &&
        (n
          ? document.addEventListener('visibilitychange', this)
          : document.removeEventListener('visibilitychange', this),
        (this._autoReset = n));
    }
    get delta() {
      return this._delta * xv;
    }
    get fixedDelta() {
      return this._fixedDelta * xv;
    }
    set fixedDelta(n) {
      this._fixedDelta = n * mee;
    }
    get elapsed() {
      return this._elapsed * xv;
    }
    update(n) {
      (this.useFixedDelta
        ? (this._delta = this.fixedDelta)
        : ((this.previousTime = this.currentTime),
          (this.currentTime =
            (n !== void 0 ? n : performance.now()) - this.startTime),
          (this._delta = this.currentTime - this.previousTime)),
        (this._delta *= this.timescale),
        (this._elapsed += this._delta));
    }
    reset() {
      ((this._delta = 0),
        (this._elapsed = 0),
        (this.currentTime = performance.now() - this.startTime));
    }
    getDelta() {
      return this.delta;
    }
    getElapsed() {
      return this.elapsed;
    }
    handleEvent(n) {
      document.hidden ||
        (this.currentTime = performance.now() - this.startTime);
    }
    dispose() {
      this.autoReset = !1;
    }
  },
  vee = (() => {
    const n = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
      e = new Float32Array([0, 0, 2, 0, 0, 2]),
      t = new _t();
    return (
      t.setAttribute('position', new qt(n, 3)),
      t.setAttribute('uv', new qt(e, 2)),
      t
    );
  })(),
  hr = class ly {
    static get fullscreenGeometry() {
      return vee;
    }
    constructor(e = 'Pass', t = new ph(), i = new zh()) {
      ((this.name = e),
        (this.renderer = null),
        (this.scene = t),
        (this.camera = i),
        (this.screen = null),
        (this.rtt = !0),
        (this.needsSwap = !0),
        (this.needsDepthTexture = !1),
        (this.enabled = !0));
    }
    get renderToScreen() {
      return !this.rtt;
    }
    set renderToScreen(e) {
      if (this.rtt === e) {
        const t = this.fullscreenMaterial;
        (t !== null && (t.needsUpdate = !0), (this.rtt = !e));
      }
    }
    set mainScene(e) {}
    set mainCamera(e) {}
    setRenderer(e) {
      this.renderer = e;
    }
    isEnabled() {
      return this.enabled;
    }
    setEnabled(e) {
      this.enabled = e;
    }
    get fullscreenMaterial() {
      return this.screen !== null ? this.screen.material : null;
    }
    set fullscreenMaterial(e) {
      let t = this.screen;
      t !== null
        ? (t.material = e)
        : ((t = new hn(ly.fullscreenGeometry, e)),
          (t.frustumCulled = !1),
          this.scene === null && (this.scene = new ph()),
          this.scene.add(t),
          (this.screen = t));
    }
    getFullscreenMaterial() {
      return this.fullscreenMaterial;
    }
    setFullscreenMaterial(e) {
      this.fullscreenMaterial = e;
    }
    getDepthTexture() {
      return null;
    }
    setDepthTexture(e, t = ca) {}
    render(e, t, i, r, s) {
      throw new Error('Render method not implemented!');
    }
    setSize(e, t) {}
    initialize(e, t, i) {}
    dispose() {
      for (const e of Object.keys(this)) {
        const t = this[e];
        (t instanceof Sn ||
          t instanceof jn ||
          t instanceof Vt ||
          t instanceof ly) &&
          this[e].dispose();
      }
      this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose();
    }
  },
  _ee = class extends hr {
    constructor() {
      (super('ClearMaskPass', null, null), (this.needsSwap = !1));
    }
    render(n, e, t, i, r) {
      const s = n.state.buffers.stencil;
      (s.setLocked(!1), s.setTest(!1));
    }
  },
  yee = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,
  K3 =
    'varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}',
  J3 = class extends rn {
    constructor() {
      super({
        name: 'CopyMaterial',
        uniforms: { inputBuffer: new Mt(null), opacity: new Mt(1) },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: yee,
        vertexShader: K3,
      });
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setInputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    getOpacity(n) {
      return this.uniforms.opacity.value;
    }
    setOpacity(n) {
      this.uniforms.opacity.value = n;
    }
  },
  xee = class extends hr {
    constructor(n, e = !0) {
      (super('CopyPass'),
        (this.fullscreenMaterial = new J3()),
        (this.needsSwap = !1),
        (this.renderTarget = n),
        n === void 0 &&
          ((this.renderTarget = new Sn(1, 1, {
            minFilter: Dt,
            magFilter: Dt,
            stencilBuffer: !1,
            depthBuffer: !1,
          })),
          (this.renderTarget.texture.name = 'CopyPass.Target')),
        (this.autoResize = e));
    }
    get resize() {
      return this.autoResize;
    }
    set resize(n) {
      this.autoResize = n;
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    setAutoResizeEnabled(n) {
      this.autoResize = n;
    }
    render(n, e, t, i, r) {
      ((this.fullscreenMaterial.inputBuffer = e.texture),
        n.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        n.render(this.scene, this.camera));
    }
    setSize(n, e) {
      this.autoResize && this.renderTarget.setSize(n, e);
    }
    initialize(n, e, t) {
      t !== void 0 &&
        ((this.renderTarget.texture.type = t),
        t !== gn
          ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1')
          : n !== null &&
            n.outputColorSpace === Wt &&
            (this.renderTarget.texture.colorSpace = Wt));
    }
  },
  cT = new je(),
  Eb = class extends hr {
    constructor(n = !0, e = !0, t = !1) {
      (super('ClearPass', null, null),
        (this.needsSwap = !1),
        (this.color = n),
        (this.depth = e),
        (this.stencil = t),
        (this.overrideClearColor = null),
        (this.overrideClearAlpha = -1));
    }
    setClearFlags(n, e, t) {
      ((this.color = n), (this.depth = e), (this.stencil = t));
    }
    getOverrideClearColor() {
      return this.overrideClearColor;
    }
    setOverrideClearColor(n) {
      this.overrideClearColor = n;
    }
    getOverrideClearAlpha() {
      return this.overrideClearAlpha;
    }
    setOverrideClearAlpha(n) {
      this.overrideClearAlpha = n;
    }
    render(n, e, t, i, r) {
      const s = this.overrideClearColor,
        a = this.overrideClearAlpha,
        o = n.getClearAlpha(),
        l = s !== null,
        c = a >= 0;
      (l
        ? (n.getClearColor(cT), n.setClearColor(s, c ? a : o))
        : c && n.setClearAlpha(a),
        n.setRenderTarget(this.renderToScreen ? null : e),
        n.clear(this.color, this.depth, this.stencil),
        l ? n.setClearColor(cT, o) : c && n.setClearAlpha(o));
    }
  },
  bee = class extends hr {
    constructor(n, e) {
      (super('MaskPass', n, e),
        (this.needsSwap = !1),
        (this.clearPass = new Eb(!1, !1, !0)),
        (this.inverse = !1));
    }
    set mainScene(n) {
      this.scene = n;
    }
    set mainCamera(n) {
      this.camera = n;
    }
    get inverted() {
      return this.inverse;
    }
    set inverted(n) {
      this.inverse = n;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(n) {
      this.clearPass.enabled = n;
    }
    getClearPass() {
      return this.clearPass;
    }
    isInverted() {
      return this.inverted;
    }
    setInverted(n) {
      this.inverted = n;
    }
    render(n, e, t, i, r) {
      const s = n.getContext(),
        a = n.state.buffers,
        o = this.scene,
        l = this.camera,
        c = this.clearPass,
        u = this.inverted ? 0 : 1,
        h = 1 - u;
      (a.color.setMask(!1),
        a.depth.setMask(!1),
        a.color.setLocked(!0),
        a.depth.setLocked(!0),
        a.stencil.setTest(!0),
        a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
        a.stencil.setFunc(s.ALWAYS, u, 4294967295),
        a.stencil.setClear(h),
        a.stencil.setLocked(!0),
        this.clearPass.enabled &&
          (this.renderToScreen
            ? c.render(n, null)
            : (c.render(n, e), c.render(n, t))),
        this.renderToScreen
          ? (n.setRenderTarget(null), n.render(o, l))
          : (n.setRenderTarget(e),
            n.render(o, l),
            n.setRenderTarget(t),
            n.render(o, l)),
        a.color.setLocked(!1),
        a.depth.setLocked(!1),
        a.stencil.setLocked(!1),
        a.stencil.setFunc(s.EQUAL, 1, 4294967295),
        a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
        a.stencil.setLocked(!0));
    }
  },
  yie = class {
    constructor(
      n = null,
      {
        depthBuffer: e = !0,
        stencilBuffer: t = !1,
        multisampling: i = 0,
        frameBufferType: r,
      } = {}
    ) {
      ((this.renderer = null),
        (this.inputBuffer = this.createBuffer(e, t, r, i)),
        (this.outputBuffer = this.inputBuffer.clone()),
        (this.copyPass = new xee()),
        (this.depthTexture = null),
        (this.passes = []),
        (this.timer = new gee()),
        (this.autoRenderToScreen = !0),
        this.setRenderer(n));
    }
    get multisampling() {
      return this.inputBuffer.samples || 0;
    }
    set multisampling(n) {
      const e = this.inputBuffer,
        t = this.multisampling;
      t > 0 && n > 0
        ? ((this.inputBuffer.samples = n),
          (this.outputBuffer.samples = n),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose())
        : t !== n &&
          (this.inputBuffer.dispose(),
          this.outputBuffer.dispose(),
          (this.inputBuffer = this.createBuffer(
            e.depthBuffer,
            e.stencilBuffer,
            e.texture.type,
            n
          )),
          (this.inputBuffer.depthTexture = this.depthTexture),
          (this.outputBuffer = this.inputBuffer.clone()));
    }
    getTimer() {
      return this.timer;
    }
    getRenderer() {
      return this.renderer;
    }
    setRenderer(n) {
      if (((this.renderer = n), n !== null)) {
        const e = n.getSize(new pe()),
          t = n.getContext().getContextAttributes().alpha,
          i = this.inputBuffer.texture.type;
        (i === gn &&
          n.outputColorSpace === Wt &&
          ((this.inputBuffer.texture.colorSpace = Wt),
          (this.outputBuffer.texture.colorSpace = Wt),
          this.inputBuffer.dispose(),
          this.outputBuffer.dispose()),
          (n.autoClear = !1),
          this.setSize(e.width, e.height));
        for (const r of this.passes) r.initialize(n, t, i);
      }
    }
    replaceRenderer(n, e = !0) {
      const t = this.renderer,
        i = t.domElement.parentNode;
      return (
        this.setRenderer(n),
        e &&
          i !== null &&
          (i.removeChild(t.domElement), i.appendChild(n.domElement)),
        t
      );
    }
    createDepthTexture() {
      const n = (this.depthTexture = new Fm());
      return (
        (this.inputBuffer.depthTexture = n),
        this.inputBuffer.dispose(),
        this.inputBuffer.stencilBuffer
          ? ((n.format = Lo), (n.type = Oo))
          : (n.type = Mr),
        n
      );
    }
    deleteDepthTexture() {
      if (this.depthTexture !== null) {
        (this.depthTexture.dispose(),
          (this.depthTexture = null),
          (this.inputBuffer.depthTexture = null),
          this.inputBuffer.dispose());
        for (const n of this.passes) n.setDepthTexture(null);
      }
    }
    createBuffer(n, e, t, i) {
      const r = this.renderer,
        s = r === null ? new pe() : r.getDrawingBufferSize(new pe()),
        a = {
          minFilter: Dt,
          magFilter: Dt,
          stencilBuffer: e,
          depthBuffer: n,
          type: t,
        },
        o = new Sn(s.width, s.height, a);
      return (
        i > 0 && ((o.ignoreDepthForMultisampleCopy = !1), (o.samples = i)),
        t === gn &&
          r !== null &&
          r.outputColorSpace === Wt &&
          (o.texture.colorSpace = Wt),
        (o.texture.name = 'EffectComposer.Buffer'),
        (o.texture.generateMipmaps = !1),
        o
      );
    }
    setMainScene(n) {
      for (const e of this.passes) e.mainScene = n;
    }
    setMainCamera(n) {
      for (const e of this.passes) e.mainCamera = n;
    }
    addPass(n, e) {
      const t = this.passes,
        i = this.renderer,
        r = i.getDrawingBufferSize(new pe()),
        s = i.getContext().getContextAttributes().alpha,
        a = this.inputBuffer.texture.type;
      if (
        (n.setRenderer(i),
        n.setSize(r.width, r.height),
        n.initialize(i, s, a),
        this.autoRenderToScreen &&
          (t.length > 0 && (t[t.length - 1].renderToScreen = !1),
          n.renderToScreen && (this.autoRenderToScreen = !1)),
        e !== void 0 ? t.splice(e, 0, n) : t.push(n),
        this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0),
        n.needsDepthTexture || this.depthTexture !== null)
      )
        if (this.depthTexture === null) {
          const o = this.createDepthTexture();
          for (n of t) n.setDepthTexture(o);
        } else n.setDepthTexture(this.depthTexture);
    }
    removePass(n) {
      const e = this.passes,
        t = e.indexOf(n);
      if (t !== -1 && e.splice(t, 1).length > 0) {
        if (this.depthTexture !== null) {
          const s = (o, l) => o || l.needsDepthTexture;
          e.reduce(s, !1) ||
            (n.getDepthTexture() === this.depthTexture &&
              n.setDepthTexture(null),
            this.deleteDepthTexture());
        }
        this.autoRenderToScreen &&
          t === e.length &&
          ((n.renderToScreen = !1),
          e.length > 0 && (e[e.length - 1].renderToScreen = !0));
      }
    }
    removeAllPasses() {
      const n = this.passes;
      (this.deleteDepthTexture(),
        n.length > 0 &&
          (this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !1),
          (this.passes = [])));
    }
    render(n) {
      const e = this.renderer,
        t = this.copyPass;
      let i = this.inputBuffer,
        r = this.outputBuffer,
        s = !1,
        a,
        o,
        l;
      n === void 0 && (this.timer.update(), (n = this.timer.getDelta()));
      for (const c of this.passes)
        c.enabled &&
          (c.render(e, i, r, n, s),
          c.needsSwap &&
            (s &&
              ((t.renderToScreen = c.renderToScreen),
              (a = e.getContext()),
              (o = e.state.buffers.stencil),
              o.setFunc(a.NOTEQUAL, 1, 4294967295),
              t.render(e, i, r, n, s),
              o.setFunc(a.EQUAL, 1, 4294967295)),
            (l = i),
            (i = r),
            (r = l)),
          c instanceof bee ? (s = !0) : c instanceof _ee && (s = !1));
    }
    setSize(n, e, t) {
      const i = this.renderer,
        r = i.getSize(new pe());
      ((n === void 0 || e === void 0) && ((n = r.width), (e = r.height)),
        (r.width !== n || r.height !== e) && i.setSize(n, e, t));
      const s = i.getDrawingBufferSize(new pe());
      (this.inputBuffer.setSize(s.width, s.height),
        this.outputBuffer.setSize(s.width, s.height));
      for (const a of this.passes) a.setSize(s.width, s.height);
    }
    reset() {
      (this.dispose(), (this.autoRenderToScreen = !0));
    }
    dispose() {
      for (const n of this.passes) n.dispose();
      ((this.passes = []),
        this.inputBuffer !== null && this.inputBuffer.dispose(),
        this.outputBuffer !== null && this.outputBuffer.dispose(),
        this.deleteDepthTexture(),
        this.copyPass.dispose(),
        this.timer.dispose(),
        hr.fullscreenGeometry.dispose());
    }
  },
  ps = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
  zt = {
    FRAGMENT_HEAD: 'FRAGMENT_HEAD',
    FRAGMENT_MAIN_UV: 'FRAGMENT_MAIN_UV',
    FRAGMENT_MAIN_IMAGE: 'FRAGMENT_MAIN_IMAGE',
    VERTEX_HEAD: 'VERTEX_HEAD',
    VERTEX_MAIN_SUPPORT: 'VERTEX_MAIN_SUPPORT',
  },
  See = class {
    constructor() {
      ((this.shaderParts = new Map([
        [zt.FRAGMENT_HEAD, null],
        [zt.FRAGMENT_MAIN_UV, null],
        [zt.FRAGMENT_MAIN_IMAGE, null],
        [zt.VERTEX_HEAD, null],
        [zt.VERTEX_MAIN_SUPPORT, null],
      ])),
        (this.defines = new Map()),
        (this.uniforms = new Map()),
        (this.blendModes = new Map()),
        (this.extensions = new Set()),
        (this.attributes = ps.NONE),
        (this.varyings = new Set()),
        (this.uvTransformation = !1),
        (this.readDepth = !1),
        (this.colorSpace = cr));
    }
  },
  bv = !1,
  uT = class {
    constructor(n = null) {
      ((this.originalMaterials = new Map()),
        (this.material = null),
        (this.materials = null),
        (this.materialsBackSide = null),
        (this.materialsDoubleSide = null),
        (this.materialsFlatShaded = null),
        (this.materialsFlatShadedBackSide = null),
        (this.materialsFlatShadedDoubleSide = null),
        this.setMaterial(n),
        (this.meshCount = 0),
        (this.replaceMaterial = (e) => {
          if (e.isMesh) {
            let t;
            if (e.material.flatShading)
              switch (e.material.side) {
                case ci:
                  t = this.materialsFlatShadedDoubleSide;
                  break;
                case On:
                  t = this.materialsFlatShadedBackSide;
                  break;
                default:
                  t = this.materialsFlatShaded;
                  break;
              }
            else
              switch (e.material.side) {
                case ci:
                  t = this.materialsDoubleSide;
                  break;
                case On:
                  t = this.materialsBackSide;
                  break;
                default:
                  t = this.materials;
                  break;
              }
            (this.originalMaterials.set(e, e.material),
              e.isSkinnedMesh
                ? (e.material = t[2])
                : e.isInstancedMesh
                  ? (e.material = t[1])
                  : (e.material = t[0]),
              ++this.meshCount);
          }
        }));
    }
    cloneMaterial(n) {
      if (!(n instanceof rn)) return n.clone();
      const e = n.uniforms,
        t = new Map();
      for (const r in e) {
        const s = e[r].value;
        s.isRenderTargetTexture && ((e[r].value = null), t.set(r, s));
      }
      const i = n.clone();
      for (const r of t)
        ((e[r[0]].value = r[1]), (i.uniforms[r[0]].value = r[1]));
      return i;
    }
    setMaterial(n) {
      if ((this.disposeMaterials(), (this.material = n), n !== null)) {
        const e = (this.materials = [
          this.cloneMaterial(n),
          this.cloneMaterial(n),
          this.cloneMaterial(n),
        ]);
        for (const t of e)
          ((t.uniforms = Object.assign({}, n.uniforms)), (t.side = Wr));
        ((e[2].skinning = !0),
          (this.materialsBackSide = e.map((t) => {
            const i = this.cloneMaterial(t);
            return (
              (i.uniforms = Object.assign({}, n.uniforms)),
              (i.side = On),
              i
            );
          })),
          (this.materialsDoubleSide = e.map((t) => {
            const i = this.cloneMaterial(t);
            return (
              (i.uniforms = Object.assign({}, n.uniforms)),
              (i.side = ci),
              i
            );
          })),
          (this.materialsFlatShaded = e.map((t) => {
            const i = this.cloneMaterial(t);
            return (
              (i.uniforms = Object.assign({}, n.uniforms)),
              (i.flatShading = !0),
              i
            );
          })),
          (this.materialsFlatShadedBackSide = e.map((t) => {
            const i = this.cloneMaterial(t);
            return (
              (i.uniforms = Object.assign({}, n.uniforms)),
              (i.flatShading = !0),
              (i.side = On),
              i
            );
          })),
          (this.materialsFlatShadedDoubleSide = e.map((t) => {
            const i = this.cloneMaterial(t);
            return (
              (i.uniforms = Object.assign({}, n.uniforms)),
              (i.flatShading = !0),
              (i.side = ci),
              i
            );
          })));
      }
    }
    render(n, e, t) {
      const i = n.shadowMap.enabled;
      if (((n.shadowMap.enabled = !1), bv)) {
        const r = this.originalMaterials;
        ((this.meshCount = 0),
          e.traverse(this.replaceMaterial),
          n.render(e, t));
        for (const s of r) s[0].material = s[1];
        this.meshCount !== r.size && r.clear();
      } else {
        const r = e.overrideMaterial;
        ((e.overrideMaterial = this.material),
          n.render(e, t),
          (e.overrideMaterial = r));
      }
      n.shadowMap.enabled = i;
    }
    disposeMaterials() {
      if (this.material !== null) {
        const n = this.materials
          .concat(this.materialsBackSide)
          .concat(this.materialsDoubleSide)
          .concat(this.materialsFlatShaded)
          .concat(this.materialsFlatShadedBackSide)
          .concat(this.materialsFlatShadedDoubleSide);
        for (const e of n) e.dispose();
      }
    }
    dispose() {
      (this.originalMaterials.clear(), this.disposeMaterials());
    }
    static get workaroundEnabled() {
      return bv;
    }
    static set workaroundEnabled(n) {
      bv = n;
    }
  },
  Os = -1,
  Nr = class extends Ki {
    constructor(n, e = Os, t = Os, i = 1) {
      (super(),
        (this.resizable = n),
        (this.baseSize = new pe(1, 1)),
        (this.preferredSize = new pe(e, t)),
        (this.target = this.preferredSize),
        (this.s = i),
        (this.effectiveSize = new pe()),
        this.addEventListener('change', () => this.updateEffectiveSize()),
        this.updateEffectiveSize());
    }
    updateEffectiveSize() {
      const n = this.baseSize,
        e = this.preferredSize,
        t = this.effectiveSize,
        i = this.scale;
      (e.width !== Os
        ? (t.width = e.width)
        : e.height !== Os
          ? (t.width = Math.round(e.height * (n.width / Math.max(n.height, 1))))
          : (t.width = Math.round(n.width * i)),
        e.height !== Os
          ? (t.height = e.height)
          : e.width !== Os
            ? (t.height = Math.round(
                e.width / Math.max(n.width / Math.max(n.height, 1), 1)
              ))
            : (t.height = Math.round(n.height * i)));
    }
    get width() {
      return this.effectiveSize.width;
    }
    set width(n) {
      this.preferredWidth = n;
    }
    get height() {
      return this.effectiveSize.height;
    }
    set height(n) {
      this.preferredHeight = n;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    get scale() {
      return this.s;
    }
    set scale(n) {
      this.s !== n &&
        ((this.s = n),
        this.preferredSize.setScalar(Os),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getScale() {
      return this.scale;
    }
    setScale(n) {
      this.scale = n;
    }
    get baseWidth() {
      return this.baseSize.width;
    }
    set baseWidth(n) {
      this.baseSize.width !== n &&
        ((this.baseSize.width = n),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getBaseWidth() {
      return this.baseWidth;
    }
    setBaseWidth(n) {
      this.baseWidth = n;
    }
    get baseHeight() {
      return this.baseSize.height;
    }
    set baseHeight(n) {
      this.baseSize.height !== n &&
        ((this.baseSize.height = n),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getBaseHeight() {
      return this.baseHeight;
    }
    setBaseHeight(n) {
      this.baseHeight = n;
    }
    setBaseSize(n, e) {
      (this.baseSize.width !== n || this.baseSize.height !== e) &&
        (this.baseSize.set(n, e),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    get preferredWidth() {
      return this.preferredSize.width;
    }
    set preferredWidth(n) {
      this.preferredSize.width !== n &&
        ((this.preferredSize.width = n),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getPreferredWidth() {
      return this.preferredWidth;
    }
    setPreferredWidth(n) {
      this.preferredWidth = n;
    }
    get preferredHeight() {
      return this.preferredSize.height;
    }
    set preferredHeight(n) {
      this.preferredSize.height !== n &&
        ((this.preferredSize.height = n),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    getPreferredHeight() {
      return this.preferredHeight;
    }
    setPreferredHeight(n) {
      this.preferredHeight = n;
    }
    setPreferredSize(n, e) {
      (this.preferredSize.width !== n || this.preferredSize.height !== e) &&
        (this.preferredSize.set(n, e),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    copy(n) {
      ((this.s = n.scale),
        this.baseSize.set(n.baseWidth, n.baseHeight),
        this.preferredSize.set(n.preferredWidth, n.preferredHeight),
        this.dispatchEvent({ type: 'change' }),
        this.resizable.setSize(this.baseSize.width, this.baseSize.height));
    }
    static get AUTO_SIZE() {
      return Os;
    }
  },
  Pt = {
    ADD: 0,
    ALPHA: 1,
    AVERAGE: 2,
    COLOR: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    DIVIDE: 8,
    DST: 9,
    EXCLUSION: 10,
    HARD_LIGHT: 11,
    HARD_MIX: 12,
    HUE: 13,
    INVERT: 14,
    INVERT_RGB: 15,
    LIGHTEN: 16,
    LINEAR_BURN: 17,
    LINEAR_DODGE: 18,
    LINEAR_LIGHT: 19,
    LUMINOSITY: 20,
    MULTIPLY: 21,
    NEGATION: 22,
    NORMAL: 23,
    OVERLAY: 24,
    PIN_LIGHT: 25,
    REFLECT: 26,
    SATURATION: 27,
    SCREEN: 28,
    SOFT_LIGHT: 29,
    SRC: 30,
    SUBTRACT: 31,
    VIVID_LIGHT: 32,
  },
  wee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}',
  Eee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}',
  Aee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}',
  Mee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}',
  Tee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}',
  Cee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}',
  Ree =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}',
  Iee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}',
  Pee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}',
  Dee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}',
  Oee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}',
  Lee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}',
  Uee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}',
  kee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}',
  Bee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}',
  Nee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}',
  Fee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}',
  zee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}',
  Vee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}',
  Hee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}',
  Gee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}',
  Wee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}',
  jee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}',
  Xee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}',
  qee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}',
  Yee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}',
  Kee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}',
  Jee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}',
  Qee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}',
  Zee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}',
  $ee =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}',
  ete =
    'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}',
  tte = new Map([
    [Pt.ADD, wee],
    [Pt.ALPHA, Eee],
    [Pt.AVERAGE, Aee],
    [Pt.COLOR, Mee],
    [Pt.COLOR_BURN, Tee],
    [Pt.COLOR_DODGE, Cee],
    [Pt.DARKEN, Ree],
    [Pt.DIFFERENCE, Iee],
    [Pt.DIVIDE, Pee],
    [Pt.DST, null],
    [Pt.EXCLUSION, Dee],
    [Pt.HARD_LIGHT, Oee],
    [Pt.HARD_MIX, Lee],
    [Pt.HUE, Uee],
    [Pt.INVERT, kee],
    [Pt.INVERT_RGB, Bee],
    [Pt.LIGHTEN, Nee],
    [Pt.LINEAR_BURN, Fee],
    [Pt.LINEAR_DODGE, zee],
    [Pt.LINEAR_LIGHT, Vee],
    [Pt.LUMINOSITY, Hee],
    [Pt.MULTIPLY, Gee],
    [Pt.NEGATION, Wee],
    [Pt.NORMAL, jee],
    [Pt.OVERLAY, Xee],
    [Pt.PIN_LIGHT, qee],
    [Pt.REFLECT, Yee],
    [Pt.SATURATION, Kee],
    [Pt.SCREEN, Jee],
    [Pt.SOFT_LIGHT, Qee],
    [Pt.SRC, Zee],
    [Pt.SUBTRACT, $ee],
    [Pt.VIVID_LIGHT, ete],
  ]),
  nte = class extends Ki {
    constructor(n, e = 1) {
      (super(), (this._blendFunction = n), (this.opacity = new Mt(e)));
    }
    getOpacity() {
      return this.opacity.value;
    }
    setOpacity(n) {
      this.opacity.value = n;
    }
    get blendFunction() {
      return this._blendFunction;
    }
    set blendFunction(n) {
      ((this._blendFunction = n), this.dispatchEvent({ type: 'change' }));
    }
    getBlendFunction() {
      return this.blendFunction;
    }
    setBlendFunction(n) {
      this.blendFunction = n;
    }
    getShaderCode() {
      return tte.get(this.blendFunction);
    }
  },
  Q3 = class extends Ki {
    constructor(
      n,
      e,
      {
        attributes: t = ps.NONE,
        blendFunction: i = Pt.NORMAL,
        defines: r = new Map(),
        uniforms: s = new Map(),
        extensions: a = null,
        vertexShader: o = null,
      } = {}
    ) {
      (super(),
        (this.name = n),
        (this.renderer = null),
        (this.attributes = t),
        (this.fragmentShader = e),
        (this.vertexShader = o),
        (this.defines = r),
        (this.uniforms = s),
        (this.extensions = a),
        (this.blendMode = new nte(i)),
        this.blendMode.addEventListener('change', (l) => this.setChanged()),
        (this._inputColorSpace = cr),
        (this._outputColorSpace = Sr));
    }
    get inputColorSpace() {
      return this._inputColorSpace;
    }
    set inputColorSpace(n) {
      ((this._inputColorSpace = n), this.setChanged());
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(n) {
      ((this._outputColorSpace = n), this.setChanged());
    }
    set mainScene(n) {}
    set mainCamera(n) {}
    getName() {
      return this.name;
    }
    setRenderer(n) {
      this.renderer = n;
    }
    getDefines() {
      return this.defines;
    }
    getUniforms() {
      return this.uniforms;
    }
    getExtensions() {
      return this.extensions;
    }
    getBlendMode() {
      return this.blendMode;
    }
    getAttributes() {
      return this.attributes;
    }
    setAttributes(n) {
      ((this.attributes = n), this.setChanged());
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    setFragmentShader(n) {
      ((this.fragmentShader = n), this.setChanged());
    }
    getVertexShader() {
      return this.vertexShader;
    }
    setVertexShader(n) {
      ((this.vertexShader = n), this.setChanged());
    }
    setChanged() {
      this.dispatchEvent({ type: 'change' });
    }
    setDepthTexture(n, e = ca) {}
    update(n, e, t) {}
    setSize(n, e) {}
    initialize(n, e, t) {}
    dispose() {
      for (const n of Object.keys(this)) {
        const e = this[n];
        (e instanceof Sn ||
          e instanceof jn ||
          e instanceof Vt ||
          e instanceof hr) &&
          this[n].dispose();
      }
    }
  },
  Ab = { MEDIUM: 2, LARGE: 3 },
  ite = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,
  rte =
    'uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}',
  ste = [
    new Float32Array([0, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([0, 1, 1, 2]),
    new Float32Array([0, 1, 2, 2, 3]),
    new Float32Array([0, 1, 2, 3, 4, 4, 5]),
    new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
  ],
  ate = class extends rn {
    constructor(n = new Lt()) {
      (super({
        name: 'KawaseBlurMaterial',
        uniforms: {
          inputBuffer: new Mt(null),
          texelSize: new Mt(new Lt()),
          scale: new Mt(1),
          kernel: new Mt(0),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: ite,
        vertexShader: rte,
      }),
        this.setTexelSize(n.x, n.y),
        (this.kernelSize = Ab.MEDIUM));
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setInputBuffer(n) {
      this.inputBuffer = n;
    }
    get kernelSequence() {
      return ste[this.kernelSize];
    }
    get scale() {
      return this.uniforms.scale.value;
    }
    set scale(n) {
      this.uniforms.scale.value = n;
    }
    getScale() {
      return this.uniforms.scale.value;
    }
    setScale(n) {
      this.uniforms.scale.value = n;
    }
    getKernel() {
      return null;
    }
    get kernel() {
      return this.uniforms.kernel.value;
    }
    set kernel(n) {
      this.uniforms.kernel.value = n;
    }
    setKernel(n) {
      this.kernel = n;
    }
    setTexelSize(n, e) {
      this.uniforms.texelSize.value.set(n, e, n * 0.5, e * 0.5);
    }
    setSize(n, e) {
      const t = 1 / n,
        i = 1 / e;
      this.uniforms.texelSize.value.set(t, i, t * 0.5, i * 0.5);
    }
  },
  ote = class extends hr {
    constructor({
      kernelSize: n = Ab.MEDIUM,
      resolutionScale: e = 0.5,
      width: t = Nr.AUTO_SIZE,
      height: i = Nr.AUTO_SIZE,
      resolutionX: r = t,
      resolutionY: s = i,
    } = {}) {
      (super('KawaseBlurPass'),
        (this.renderTargetA = new Sn(1, 1, { depthBuffer: !1 })),
        (this.renderTargetA.texture.name = 'Blur.Target.A'),
        (this.renderTargetB = this.renderTargetA.clone()),
        (this.renderTargetB.texture.name = 'Blur.Target.B'));
      const a = (this.resolution = new Nr(this, r, s, e));
      (a.addEventListener('change', (o) =>
        this.setSize(a.baseWidth, a.baseHeight)
      ),
        (this._blurMaterial = new ate()),
        (this._blurMaterial.kernelSize = n),
        (this.copyMaterial = new J3()));
    }
    getResolution() {
      return this.resolution;
    }
    get blurMaterial() {
      return this._blurMaterial;
    }
    set blurMaterial(n) {
      this._blurMaterial = n;
    }
    get dithering() {
      return this.copyMaterial.dithering;
    }
    set dithering(n) {
      this.copyMaterial.dithering = n;
    }
    get kernelSize() {
      return this.blurMaterial.kernelSize;
    }
    set kernelSize(n) {
      this.blurMaterial.kernelSize = n;
    }
    get width() {
      return this.resolution.width;
    }
    set width(n) {
      this.resolution.preferredWidth = n;
    }
    get height() {
      return this.resolution.height;
    }
    set height(n) {
      this.resolution.preferredHeight = n;
    }
    get scale() {
      return this.blurMaterial.scale;
    }
    set scale(n) {
      this.blurMaterial.scale = n;
    }
    getScale() {
      return this.blurMaterial.scale;
    }
    setScale(n) {
      this.blurMaterial.scale = n;
    }
    getKernelSize() {
      return this.kernelSize;
    }
    setKernelSize(n) {
      this.kernelSize = n;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(n) {
      this.resolution.scale = n;
    }
    render(n, e, t, i, r) {
      const s = this.scene,
        a = this.camera,
        o = this.renderTargetA,
        l = this.renderTargetB,
        c = this.blurMaterial,
        u = c.kernelSequence;
      let h = e;
      this.fullscreenMaterial = c;
      for (let d = 0, f = u.length; d < f; ++d) {
        const p = (d & 1) === 0 ? o : l;
        ((c.kernel = u[d]),
          (c.inputBuffer = h.texture),
          n.setRenderTarget(p),
          n.render(s, a),
          (h = p));
      }
      ((this.fullscreenMaterial = this.copyMaterial),
        (this.copyMaterial.inputBuffer = h.texture),
        n.setRenderTarget(this.renderToScreen ? null : t),
        n.render(s, a));
    }
    setSize(n, e) {
      const t = this.resolution;
      t.setBaseSize(n, e);
      const i = t.width,
        r = t.height;
      (this.renderTargetA.setSize(i, r),
        this.renderTargetB.setSize(i, r),
        this.blurMaterial.setSize(n, e));
    }
    initialize(n, e, t) {
      t !== void 0 &&
        ((this.renderTargetA.texture.type = t),
        (this.renderTargetB.texture.type = t),
        t !== gn
          ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'),
            (this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'))
          : n !== null &&
            n.outputColorSpace === Wt &&
            ((this.renderTargetA.texture.colorSpace = Wt),
            (this.renderTargetB.texture.colorSpace = Wt)));
    }
    static get AUTO_SIZE() {
      return Nr.AUTO_SIZE;
    }
  },
  lte = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`,
  cte = class extends rn {
    constructor(n = !1, e = null) {
      (super({
        name: 'LuminanceMaterial',
        defines: { THREE_REVISION: la.replace(/\D+/g, '') },
        uniforms: {
          inputBuffer: new Mt(null),
          threshold: new Mt(0),
          smoothing: new Mt(1),
          range: new Mt(null),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: lte,
        vertexShader: K3,
      }),
        (this.colorOutput = n),
        (this.luminanceRange = e));
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setInputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    get threshold() {
      return this.uniforms.threshold.value;
    }
    set threshold(n) {
      (this.smoothing > 0 || n > 0
        ? (this.defines.THRESHOLD = '1')
        : delete this.defines.THRESHOLD,
        (this.uniforms.threshold.value = n));
    }
    getThreshold() {
      return this.threshold;
    }
    setThreshold(n) {
      this.threshold = n;
    }
    get smoothing() {
      return this.uniforms.smoothing.value;
    }
    set smoothing(n) {
      (this.threshold > 0 || n > 0
        ? (this.defines.THRESHOLD = '1')
        : delete this.defines.THRESHOLD,
        (this.uniforms.smoothing.value = n));
    }
    getSmoothingFactor() {
      return this.smoothing;
    }
    setSmoothingFactor(n) {
      this.smoothing = n;
    }
    get useThreshold() {
      return this.threshold > 0 || this.smoothing > 0;
    }
    set useThreshold(n) {}
    get colorOutput() {
      return this.defines.COLOR !== void 0;
    }
    set colorOutput(n) {
      (n ? (this.defines.COLOR = '1') : delete this.defines.COLOR,
        (this.needsUpdate = !0));
    }
    isColorOutputEnabled(n) {
      return this.colorOutput;
    }
    setColorOutputEnabled(n) {
      this.colorOutput = n;
    }
    get useRange() {
      return this.luminanceRange !== null;
    }
    set useRange(n) {
      this.luminanceRange = null;
    }
    get luminanceRange() {
      return this.uniforms.range.value;
    }
    set luminanceRange(n) {
      (n !== null ? (this.defines.RANGE = '1') : delete this.defines.RANGE,
        (this.uniforms.range.value = n),
        (this.needsUpdate = !0));
    }
    getLuminanceRange() {
      return this.luminanceRange;
    }
    setLuminanceRange(n) {
      this.luminanceRange = n;
    }
  },
  ute = class extends hr {
    constructor({
      renderTarget: n,
      luminanceRange: e,
      colorOutput: t,
      resolutionScale: i = 1,
      width: r = Nr.AUTO_SIZE,
      height: s = Nr.AUTO_SIZE,
      resolutionX: a = r,
      resolutionY: o = s,
    } = {}) {
      (super('LuminancePass'),
        (this.fullscreenMaterial = new cte(t, e)),
        (this.needsSwap = !1),
        (this.renderTarget = n),
        this.renderTarget === void 0 &&
          ((this.renderTarget = new Sn(1, 1, { depthBuffer: !1 })),
          (this.renderTarget.texture.name = 'LuminancePass.Target')));
      const l = (this.resolution = new Nr(this, a, o, i));
      l.addEventListener('change', (c) =>
        this.setSize(l.baseWidth, l.baseHeight)
      );
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getTexture() {
      return this.renderTarget.texture;
    }
    getResolution() {
      return this.resolution;
    }
    render(n, e, t, i, r) {
      const s = this.fullscreenMaterial;
      ((s.inputBuffer = e.texture),
        n.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
        n.render(this.scene, this.camera));
    }
    setSize(n, e) {
      const t = this.resolution;
      (t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height));
    }
    initialize(n, e, t) {
      t !== void 0 &&
        t !== gn &&
        ((this.renderTarget.texture.type = t),
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'));
    }
  },
  hte = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,
  dte =
    'uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}',
  fte = class extends rn {
    constructor() {
      super({
        name: 'DownsamplingMaterial',
        uniforms: { inputBuffer: new Mt(null), texelSize: new Mt(new pe()) },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: hte,
        vertexShader: dte,
      });
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setSize(n, e) {
      this.uniforms.texelSize.value.set(1 / n, 1 / e);
    }
  },
  pte = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,
  mte =
    'uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}',
  gte = class extends rn {
    constructor() {
      super({
        name: 'UpsamplingMaterial',
        uniforms: {
          inputBuffer: new Mt(null),
          supportBuffer: new Mt(null),
          texelSize: new Mt(new pe()),
          radius: new Mt(0.85),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: pte,
        vertexShader: mte,
      });
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    set supportBuffer(n) {
      this.uniforms.supportBuffer.value = n;
    }
    get radius() {
      return this.uniforms.radius.value;
    }
    set radius(n) {
      this.uniforms.radius.value = n;
    }
    setSize(n, e) {
      this.uniforms.texelSize.value.set(1 / n, 1 / e);
    }
  },
  vte = class extends hr {
    constructor() {
      (super('MipmapBlurPass'),
        (this.needsSwap = !1),
        (this.renderTarget = new Sn(1, 1, { depthBuffer: !1 })),
        (this.renderTarget.texture.name = 'Upsampling.Mipmap0'),
        (this.downsamplingMipmaps = []),
        (this.upsamplingMipmaps = []),
        (this.downsamplingMaterial = new fte()),
        (this.upsamplingMaterial = new gte()),
        (this.resolution = new pe()));
    }
    get texture() {
      return this.renderTarget.texture;
    }
    get levels() {
      return this.downsamplingMipmaps.length;
    }
    set levels(n) {
      if (this.levels !== n) {
        const e = this.renderTarget;
        (this.dispose(),
          (this.downsamplingMipmaps = []),
          (this.upsamplingMipmaps = []));
        for (let t = 0; t < n; ++t) {
          const i = e.clone();
          ((i.texture.name = 'Downsampling.Mipmap' + t),
            this.downsamplingMipmaps.push(i));
        }
        this.upsamplingMipmaps.push(e);
        for (let t = 1, i = n - 1; t < i; ++t) {
          const r = e.clone();
          ((r.texture.name = 'Upsampling.Mipmap' + t),
            this.upsamplingMipmaps.push(r));
        }
        this.setSize(this.resolution.x, this.resolution.y);
      }
    }
    get radius() {
      return this.upsamplingMaterial.radius;
    }
    set radius(n) {
      this.upsamplingMaterial.radius = n;
    }
    render(n, e, t, i, r) {
      const { scene: s, camera: a } = this,
        { downsamplingMaterial: o, upsamplingMaterial: l } = this,
        { downsamplingMipmaps: c, upsamplingMipmaps: u } = this;
      let h = e;
      this.fullscreenMaterial = o;
      for (let d = 0, f = c.length; d < f; ++d) {
        const p = c[d];
        (o.setSize(h.width, h.height),
          (o.inputBuffer = h.texture),
          n.setRenderTarget(p),
          n.render(s, a),
          (h = p));
      }
      this.fullscreenMaterial = l;
      for (let d = u.length - 1; d >= 0; --d) {
        const f = u[d];
        (l.setSize(h.width, h.height),
          (l.inputBuffer = h.texture),
          (l.supportBuffer = c[d].texture),
          n.setRenderTarget(f),
          n.render(s, a),
          (h = f));
      }
    }
    setSize(n, e) {
      const t = this.resolution;
      t.set(n, e);
      let i = t.width,
        r = t.height;
      for (let s = 0, a = this.downsamplingMipmaps.length; s < a; ++s)
        ((i = Math.round(i * 0.5)),
          (r = Math.round(r * 0.5)),
          this.downsamplingMipmaps[s].setSize(i, r),
          s < this.upsamplingMipmaps.length &&
            this.upsamplingMipmaps[s].setSize(i, r));
    }
    initialize(n, e, t) {
      if (t !== void 0) {
        const i = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
        for (const r of i) r.texture.type = t;
        if (t !== gn)
          ((this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'),
            (this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'));
        else if (n !== null && n.outputColorSpace === Wt)
          for (const r of i) r.texture.colorSpace = Wt;
      }
    }
    dispose() {
      super.dispose();
      for (const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
        n.dispose();
    }
  },
  _te = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`,
  xie = class extends Q3 {
    constructor({
      blendFunction: n = Pt.SCREEN,
      luminanceThreshold: e = 1,
      luminanceSmoothing: t = 0.03,
      mipmapBlur: i = !0,
      intensity: r = 1,
      radius: s = 0.85,
      levels: a = 8,
      kernelSize: o = Ab.LARGE,
      resolutionScale: l = 0.5,
      width: c = Nr.AUTO_SIZE,
      height: u = Nr.AUTO_SIZE,
      resolutionX: h = c,
      resolutionY: d = u,
    } = {}) {
      (super('BloomEffect', _te, {
        blendFunction: n,
        uniforms: new Map([
          ['map', new Mt(null)],
          ['intensity', new Mt(r)],
        ]),
      }),
        (this.renderTarget = new Sn(1, 1, { depthBuffer: !1 })),
        (this.renderTarget.texture.name = 'Bloom.Target'),
        (this.blurPass = new ote({ kernelSize: o })),
        (this.luminancePass = new ute({ colorOutput: !0 })),
        (this.luminanceMaterial.threshold = e),
        (this.luminanceMaterial.smoothing = t),
        (this.mipmapBlurPass = new vte()),
        (this.mipmapBlurPass.enabled = i),
        (this.mipmapBlurPass.radius = s),
        (this.mipmapBlurPass.levels = a),
        (this.uniforms.get('map').value = i
          ? this.mipmapBlurPass.texture
          : this.renderTarget.texture));
      const f = (this.resolution = new Nr(this, h, d, l));
      f.addEventListener('change', (p) =>
        this.setSize(f.baseWidth, f.baseHeight)
      );
    }
    get texture() {
      return this.mipmapBlurPass.enabled
        ? this.mipmapBlurPass.texture
        : this.renderTarget.texture;
    }
    getTexture() {
      return this.texture;
    }
    getResolution() {
      return this.resolution;
    }
    getBlurPass() {
      return this.blurPass;
    }
    getLuminancePass() {
      return this.luminancePass;
    }
    get luminanceMaterial() {
      return this.luminancePass.fullscreenMaterial;
    }
    getLuminanceMaterial() {
      return this.luminancePass.fullscreenMaterial;
    }
    get width() {
      return this.resolution.width;
    }
    set width(n) {
      this.resolution.preferredWidth = n;
    }
    get height() {
      return this.resolution.height;
    }
    set height(n) {
      this.resolution.preferredHeight = n;
    }
    get dithering() {
      return this.blurPass.dithering;
    }
    set dithering(n) {
      this.blurPass.dithering = n;
    }
    get kernelSize() {
      return this.blurPass.kernelSize;
    }
    set kernelSize(n) {
      this.blurPass.kernelSize = n;
    }
    get distinction() {
      return (console.warn(this.name, 'distinction was removed'), 1);
    }
    set distinction(n) {
      console.warn(this.name, 'distinction was removed');
    }
    get intensity() {
      return this.uniforms.get('intensity').value;
    }
    set intensity(n) {
      this.uniforms.get('intensity').value = n;
    }
    getIntensity() {
      return this.intensity;
    }
    setIntensity(n) {
      this.intensity = n;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(n) {
      this.resolution.scale = n;
    }
    update(n, e, t) {
      const i = this.renderTarget,
        r = this.luminancePass;
      r.enabled
        ? (r.render(n, e),
          this.mipmapBlurPass.enabled
            ? this.mipmapBlurPass.render(n, r.renderTarget)
            : this.blurPass.render(n, r.renderTarget, i))
        : this.mipmapBlurPass.enabled
          ? this.mipmapBlurPass.render(n, e)
          : this.blurPass.render(n, e, i);
    }
    setSize(n, e) {
      const t = this.resolution;
      (t.setBaseSize(n, e),
        this.renderTarget.setSize(t.width, t.height),
        this.blurPass.resolution.copy(t),
        this.luminancePass.setSize(n, e),
        this.mipmapBlurPass.setSize(n, e));
    }
    initialize(n, e, t) {
      (this.blurPass.initialize(n, e, t),
        this.luminancePass.initialize(n, e, t),
        this.mipmapBlurPass.initialize(n, e, t),
        t !== void 0 &&
          ((this.renderTarget.texture.type = t),
          n !== null &&
            n.outputColorSpace === Wt &&
            (this.renderTarget.texture.colorSpace = Wt)));
    }
  },
  hT = class extends hr {
    constructor(n, e = 'inputBuffer') {
      (super('ShaderPass'), (this.fullscreenMaterial = n), (this.input = e));
    }
    setInput(n) {
      this.input = n;
    }
    render(n, e, t, i, r) {
      const s = this.fullscreenMaterial.uniforms;
      (e !== null &&
        s !== void 0 &&
        s[this.input] !== void 0 &&
        (s[this.input].value = e.texture),
        n.setRenderTarget(this.renderToScreen ? null : t),
        n.render(this.scene, this.camera));
    }
    initialize(n, e, t) {
      t !== void 0 &&
        t !== gn &&
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1');
    }
  },
  bie = class extends hr {
    constructor(n, e, t = null) {
      (super('RenderPass', n, e),
        (this.needsSwap = !1),
        (this.clearPass = new Eb()),
        (this.overrideMaterialManager = t === null ? null : new uT(t)),
        (this.ignoreBackground = !1),
        (this.skipShadowMapUpdate = !1),
        (this.selection = null));
    }
    set mainScene(n) {
      this.scene = n;
    }
    set mainCamera(n) {
      this.camera = n;
    }
    get renderToScreen() {
      return super.renderToScreen;
    }
    set renderToScreen(n) {
      ((super.renderToScreen = n), (this.clearPass.renderToScreen = n));
    }
    get overrideMaterial() {
      const n = this.overrideMaterialManager;
      return n !== null ? n.material : null;
    }
    set overrideMaterial(n) {
      const e = this.overrideMaterialManager;
      n !== null
        ? e !== null
          ? e.setMaterial(n)
          : (this.overrideMaterialManager = new uT(n))
        : e !== null && (e.dispose(), (this.overrideMaterialManager = null));
    }
    getOverrideMaterial() {
      return this.overrideMaterial;
    }
    setOverrideMaterial(n) {
      this.overrideMaterial = n;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(n) {
      this.clearPass.enabled = n;
    }
    getSelection() {
      return this.selection;
    }
    setSelection(n) {
      this.selection = n;
    }
    isBackgroundDisabled() {
      return this.ignoreBackground;
    }
    setBackgroundDisabled(n) {
      this.ignoreBackground = n;
    }
    isShadowMapDisabled() {
      return this.skipShadowMapUpdate;
    }
    setShadowMapDisabled(n) {
      this.skipShadowMapUpdate = n;
    }
    getClearPass() {
      return this.clearPass;
    }
    render(n, e, t, i, r) {
      const s = this.scene,
        a = this.camera,
        o = this.selection,
        l = a.layers.mask,
        c = s.background,
        u = n.shadowMap.autoUpdate,
        h = this.renderToScreen ? null : e;
      (o !== null && a.layers.set(o.getLayer()),
        this.skipShadowMapUpdate && (n.shadowMap.autoUpdate = !1),
        (this.ignoreBackground || this.clearPass.overrideClearColor !== null) &&
          (s.background = null),
        this.clearPass.enabled && this.clearPass.render(n, e),
        n.setRenderTarget(h),
        this.overrideMaterialManager !== null
          ? this.overrideMaterialManager.render(n, s, a)
          : n.render(s, a),
        (a.layers.mask = l),
        (s.background = c),
        (n.shadowMap.autoUpdate = u));
    }
  },
  Z3 = { COLOR: 2 },
  yte = { DISABLED: 0 },
  lu = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 },
  xte = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`,
  bte = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`,
  Ste = class extends rn {
    constructor(n = new pe(), e = Z3.COLOR) {
      (super({
        name: 'EdgeDetectionMaterial',
        defines: {
          THREE_REVISION: la.replace(/\D+/g, ''),
          LOCAL_CONTRAST_ADAPTATION_FACTOR: '2.0',
          EDGE_THRESHOLD: '0.1',
          DEPTH_THRESHOLD: '0.01',
          PREDICATION_MODE: '0',
          PREDICATION_THRESHOLD: '0.01',
          PREDICATION_SCALE: '2.0',
          PREDICATION_STRENGTH: '1.0',
          DEPTH_PACKING: '0',
        },
        uniforms: {
          inputBuffer: new Mt(null),
          depthBuffer: new Mt(null),
          predicationBuffer: new Mt(null),
          texelSize: new Mt(n),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: xte,
        vertexShader: bte,
      }),
        (this.edgeDetectionMode = e));
    }
    set depthBuffer(n) {
      this.uniforms.depthBuffer.value = n;
    }
    set depthPacking(n) {
      ((this.defines.DEPTH_PACKING = n.toFixed(0)), (this.needsUpdate = !0));
    }
    setDepthBuffer(n, e = ca) {
      ((this.depthBuffer = n), (this.depthPacking = e));
    }
    get edgeDetectionMode() {
      return Number(this.defines.EDGE_DETECTION_MODE);
    }
    set edgeDetectionMode(n) {
      ((this.defines.EDGE_DETECTION_MODE = n.toFixed(0)),
        (this.needsUpdate = !0));
    }
    getEdgeDetectionMode() {
      return this.edgeDetectionMode;
    }
    setEdgeDetectionMode(n) {
      this.edgeDetectionMode = n;
    }
    get localContrastAdaptationFactor() {
      return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
    }
    set localContrastAdaptationFactor(n) {
      ((this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = n.toFixed('6')),
        (this.needsUpdate = !0));
    }
    getLocalContrastAdaptationFactor() {
      return this.localContrastAdaptationFactor;
    }
    setLocalContrastAdaptationFactor(n) {
      this.localContrastAdaptationFactor = n;
    }
    get edgeDetectionThreshold() {
      return Number(this.defines.EDGE_THRESHOLD);
    }
    set edgeDetectionThreshold(n) {
      ((this.defines.EDGE_THRESHOLD = n.toFixed('6')),
        (this.defines.DEPTH_THRESHOLD = (n * 0.1).toFixed('6')),
        (this.needsUpdate = !0));
    }
    getEdgeDetectionThreshold() {
      return this.edgeDetectionThreshold;
    }
    setEdgeDetectionThreshold(n) {
      this.edgeDetectionThreshold = n;
    }
    get predicationMode() {
      return Number(this.defines.PREDICATION_MODE);
    }
    set predicationMode(n) {
      ((this.defines.PREDICATION_MODE = n.toFixed(0)), (this.needsUpdate = !0));
    }
    getPredicationMode() {
      return this.predicationMode;
    }
    setPredicationMode(n) {
      this.predicationMode = n;
    }
    set predicationBuffer(n) {
      this.uniforms.predicationBuffer.value = n;
    }
    setPredicationBuffer(n) {
      this.uniforms.predicationBuffer.value = n;
    }
    get predicationThreshold() {
      return Number(this.defines.PREDICATION_THRESHOLD);
    }
    set predicationThreshold(n) {
      ((this.defines.PREDICATION_THRESHOLD = n.toFixed('6')),
        (this.needsUpdate = !0));
    }
    getPredicationThreshold() {
      return this.predicationThreshold;
    }
    setPredicationThreshold(n) {
      this.predicationThreshold = n;
    }
    get predicationScale() {
      return Number(this.defines.PREDICATION_SCALE);
    }
    set predicationScale(n) {
      ((this.defines.PREDICATION_SCALE = n.toFixed('6')),
        (this.needsUpdate = !0));
    }
    getPredicationScale() {
      return this.predicationScale;
    }
    setPredicationScale(n) {
      this.predicationScale = n;
    }
    get predicationStrength() {
      return Number(this.defines.PREDICATION_STRENGTH);
    }
    set predicationStrength(n) {
      ((this.defines.PREDICATION_STRENGTH = n.toFixed('6')),
        (this.needsUpdate = !0));
    }
    getPredicationStrength() {
      return this.predicationStrength;
    }
    setPredicationStrength(n) {
      this.predicationStrength = n;
    }
    setSize(n, e) {
      this.uniforms.texelSize.value.set(1 / n, 1 / e);
    }
  },
  wte = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`,
  Ete =
    'uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}',
  Ate = class extends rn {
    constructor(n = new pe(), e = new pe()) {
      super({
        name: 'SMAAWeightsMaterial',
        defines: {
          MAX_SEARCH_STEPS_INT: '16',
          MAX_SEARCH_STEPS_FLOAT: '16.0',
          MAX_SEARCH_STEPS_DIAG_INT: '8',
          MAX_SEARCH_STEPS_DIAG_FLOAT: '8.0',
          CORNER_ROUNDING: '25',
          CORNER_ROUNDING_NORM: '0.25',
          AREATEX_MAX_DISTANCE: '16.0',
          AREATEX_MAX_DISTANCE_DIAG: '20.0',
          AREATEX_PIXEL_SIZE: '(1.0 / vec2(160.0, 560.0))',
          AREATEX_SUBTEX_SIZE: '(1.0 / 7.0)',
          SEARCHTEX_SIZE: 'vec2(66.0, 33.0)',
          SEARCHTEX_PACKED_SIZE: 'vec2(64.0, 16.0)',
        },
        uniforms: {
          inputBuffer: new Mt(null),
          searchTexture: new Mt(null),
          areaTexture: new Mt(null),
          resolution: new Mt(e),
          texelSize: new Mt(n),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        fragmentShader: wte,
        vertexShader: Ete,
      });
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setInputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    get searchTexture() {
      return this.uniforms.searchTexture.value;
    }
    set searchTexture(n) {
      this.uniforms.searchTexture.value = n;
    }
    get areaTexture() {
      return this.uniforms.areaTexture.value;
    }
    set areaTexture(n) {
      this.uniforms.areaTexture.value = n;
    }
    setLookupTextures(n, e) {
      ((this.searchTexture = n), (this.areaTexture = e));
    }
    get orthogonalSearchSteps() {
      return Number(this.defines.MAX_SEARCH_STEPS_INT);
    }
    set orthogonalSearchSteps(n) {
      const e = Math.min(Math.max(n, 0), 112);
      ((this.defines.MAX_SEARCH_STEPS_INT = e.toFixed('0')),
        (this.defines.MAX_SEARCH_STEPS_FLOAT = e.toFixed('1')),
        (this.needsUpdate = !0));
    }
    setOrthogonalSearchSteps(n) {
      this.orthogonalSearchSteps = n;
    }
    get diagonalSearchSteps() {
      return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
    }
    set diagonalSearchSteps(n) {
      const e = Math.min(Math.max(n, 0), 20);
      ((this.defines.MAX_SEARCH_STEPS_DIAG_INT = e.toFixed('0')),
        (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = e.toFixed('1')),
        (this.needsUpdate = !0));
    }
    setDiagonalSearchSteps(n) {
      this.diagonalSearchSteps = n;
    }
    get diagonalDetection() {
      return this.defines.DISABLE_DIAG_DETECTION === void 0;
    }
    set diagonalDetection(n) {
      (n
        ? delete this.defines.DISABLE_DIAG_DETECTION
        : (this.defines.DISABLE_DIAG_DETECTION = '1'),
        (this.needsUpdate = !0));
    }
    isDiagonalDetectionEnabled() {
      return this.diagonalDetection;
    }
    setDiagonalDetectionEnabled(n) {
      this.diagonalDetection = n;
    }
    get cornerRounding() {
      return Number(this.defines.CORNER_ROUNDING);
    }
    set cornerRounding(n) {
      const e = Math.min(Math.max(n, 0), 100);
      ((this.defines.CORNER_ROUNDING = e.toFixed('4')),
        (this.defines.CORNER_ROUNDING_NORM = (e / 100).toFixed('4')),
        (this.needsUpdate = !0));
    }
    setCornerRounding(n) {
      this.cornerRounding = n;
    }
    get cornerDetection() {
      return this.defines.DISABLE_CORNER_DETECTION === void 0;
    }
    set cornerDetection(n) {
      (n
        ? delete this.defines.DISABLE_CORNER_DETECTION
        : (this.defines.DISABLE_CORNER_DETECTION = '1'),
        (this.needsUpdate = !0));
    }
    isCornerRoundingEnabled() {
      return this.cornerDetection;
    }
    setCornerRoundingEnabled(n) {
      this.cornerDetection = n;
    }
    setSize(n, e) {
      const t = this.uniforms;
      (t.texelSize.value.set(1 / n, 1 / e), t.resolution.value.set(n, e));
    }
  },
  dT =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC',
  fT =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC',
  Mte =
    'uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}',
  Tte =
    'varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}',
  Sie = class extends Q3 {
    constructor({
      blendFunction: n = Pt.SRC,
      preset: e = lu.MEDIUM,
      edgeDetectionMode: t = Z3.COLOR,
      predicationMode: i = yte.DISABLED,
    } = {}) {
      super('SMAAEffect', Mte, {
        vertexShader: Tte,
        blendFunction: n,
        attributes: ps.CONVOLUTION | ps.DEPTH,
        uniforms: new Map([['weightMap', new Mt(null)]]),
      });
      let r, s;
      (arguments.length > 1 &&
        ((r = arguments[0]),
        (s = arguments[1]),
        arguments.length > 2 && (e = arguments[2]),
        arguments.length > 3 && (t = arguments[3])),
        (this.renderTargetEdges = new Sn(1, 1, { depthBuffer: !1 })),
        (this.renderTargetEdges.texture.name = 'SMAA.Edges'),
        (this.renderTargetWeights = this.renderTargetEdges.clone()),
        (this.renderTargetWeights.texture.name = 'SMAA.Weights'),
        (this.uniforms.get('weightMap').value =
          this.renderTargetWeights.texture),
        (this.clearPass = new Eb(!0, !1, !1)),
        (this.clearPass.overrideClearColor = new je(0)),
        (this.clearPass.overrideClearAlpha = 1),
        (this.edgeDetectionPass = new hT(new Ste())),
        (this.edgeDetectionMaterial.edgeDetectionMode = t),
        (this.edgeDetectionMaterial.predicationMode = i),
        (this.weightsPass = new hT(new Ate())));
      const a = new Kh();
      ((a.onLoad = () => {
        const o = new Vt(r);
        ((o.name = 'SMAA.Search'),
          (o.magFilter = Un),
          (o.minFilter = Un),
          (o.generateMipmaps = !1),
          (o.needsUpdate = !0),
          (o.flipY = !0),
          (this.weightsMaterial.searchTexture = o));
        const l = new Vt(s);
        ((l.name = 'SMAA.Area'),
          (l.magFilter = Dt),
          (l.minFilter = Dt),
          (l.generateMipmaps = !1),
          (l.needsUpdate = !0),
          (l.flipY = !1),
          (this.weightsMaterial.areaTexture = l),
          this.dispatchEvent({ type: 'load' }));
      }),
        a.itemStart('search'),
        a.itemStart('area'),
        r !== void 0 && s !== void 0
          ? (a.itemEnd('search'), a.itemEnd('area'))
          : typeof Image < 'u' &&
            ((r = new Image()),
            (s = new Image()),
            r.addEventListener('load', () => a.itemEnd('search')),
            s.addEventListener('load', () => a.itemEnd('area')),
            (r.src = dT),
            (s.src = fT)),
        this.applyPreset(e));
    }
    get edgesTexture() {
      return this.renderTargetEdges.texture;
    }
    getEdgesTexture() {
      return this.edgesTexture;
    }
    get weightsTexture() {
      return this.renderTargetWeights.texture;
    }
    getWeightsTexture() {
      return this.weightsTexture;
    }
    get edgeDetectionMaterial() {
      return this.edgeDetectionPass.fullscreenMaterial;
    }
    get colorEdgesMaterial() {
      return this.edgeDetectionMaterial;
    }
    getEdgeDetectionMaterial() {
      return this.edgeDetectionMaterial;
    }
    get weightsMaterial() {
      return this.weightsPass.fullscreenMaterial;
    }
    getWeightsMaterial() {
      return this.weightsMaterial;
    }
    setEdgeDetectionThreshold(n) {
      this.edgeDetectionMaterial.edgeDetectionThreshold = n;
    }
    setOrthogonalSearchSteps(n) {
      this.weightsMaterial.orthogonalSearchSteps = n;
    }
    applyPreset(n) {
      const e = this.edgeDetectionMaterial,
        t = this.weightsMaterial;
      switch (n) {
        case lu.LOW:
          ((e.edgeDetectionThreshold = 0.15),
            (t.orthogonalSearchSteps = 4),
            (t.diagonalDetection = !1),
            (t.cornerDetection = !1));
          break;
        case lu.MEDIUM:
          ((e.edgeDetectionThreshold = 0.1),
            (t.orthogonalSearchSteps = 8),
            (t.diagonalDetection = !1),
            (t.cornerDetection = !1));
          break;
        case lu.HIGH:
          ((e.edgeDetectionThreshold = 0.1),
            (t.orthogonalSearchSteps = 16),
            (t.diagonalSearchSteps = 8),
            (t.cornerRounding = 25),
            (t.diagonalDetection = !0),
            (t.cornerDetection = !0));
          break;
        case lu.ULTRA:
          ((e.edgeDetectionThreshold = 0.05),
            (t.orthogonalSearchSteps = 32),
            (t.diagonalSearchSteps = 16),
            (t.cornerRounding = 25),
            (t.diagonalDetection = !0),
            (t.cornerDetection = !0));
          break;
      }
    }
    setDepthTexture(n, e = ca) {
      ((this.edgeDetectionMaterial.depthBuffer = n),
        (this.edgeDetectionMaterial.depthPacking = e));
    }
    update(n, e, t) {
      (this.clearPass.render(n, this.renderTargetEdges),
        this.edgeDetectionPass.render(n, e, this.renderTargetEdges),
        this.weightsPass.render(
          n,
          this.renderTargetEdges,
          this.renderTargetWeights
        ));
    }
    setSize(n, e) {
      (this.edgeDetectionMaterial.setSize(n, e),
        this.weightsMaterial.setSize(n, e),
        this.renderTargetEdges.setSize(n, e),
        this.renderTargetWeights.setSize(n, e));
    }
    dispose() {
      const { searchTexture: n, areaTexture: e } = this.weightsMaterial;
      (n !== null && e !== null && (n.dispose(), e.dispose()), super.dispose());
    }
    static get searchImageDataURL() {
      return dT;
    }
    static get areaImageDataURL() {
      return fT;
    }
  },
  Cte = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,
  Rte =
    'uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}',
  Ite = class extends rn {
    constructor(n, e, t, i, r = !1) {
      (super({
        name: 'EffectMaterial',
        defines: {
          THREE_REVISION: la.replace(/\D+/g, ''),
          DEPTH_PACKING: '0',
          ENCODE_OUTPUT: '1',
        },
        uniforms: {
          inputBuffer: new Mt(null),
          depthBuffer: new Mt(null),
          resolution: new Mt(new pe()),
          texelSize: new Mt(new pe()),
          cameraNear: new Mt(0.3),
          cameraFar: new Mt(1e3),
          aspect: new Mt(1),
          time: new Mt(0),
        },
        blending: Ln,
        toneMapped: !1,
        depthWrite: !1,
        depthTest: !1,
        dithering: r,
      }),
        n && this.setShaderParts(n),
        e && this.setDefines(e),
        t && this.setUniforms(t),
        this.copyCameraSettings(i));
    }
    set inputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    setInputBuffer(n) {
      this.uniforms.inputBuffer.value = n;
    }
    get depthBuffer() {
      return this.uniforms.depthBuffer.value;
    }
    set depthBuffer(n) {
      this.uniforms.depthBuffer.value = n;
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(n) {
      ((this.defines.DEPTH_PACKING = n.toFixed(0)), (this.needsUpdate = !0));
    }
    setDepthBuffer(n, e = ca) {
      ((this.depthBuffer = n), (this.depthPacking = e));
    }
    setShaderData(n) {
      (this.setShaderParts(n.shaderParts),
        this.setDefines(n.defines),
        this.setUniforms(n.uniforms),
        this.setExtensions(n.extensions));
    }
    setShaderParts(n) {
      return (
        (this.fragmentShader = Cte.replace(
          zt.FRAGMENT_HEAD,
          n.get(zt.FRAGMENT_HEAD) || ''
        )
          .replace(zt.FRAGMENT_MAIN_UV, n.get(zt.FRAGMENT_MAIN_UV) || '')
          .replace(
            zt.FRAGMENT_MAIN_IMAGE,
            n.get(zt.FRAGMENT_MAIN_IMAGE) || ''
          )),
        (this.vertexShader = Rte.replace(
          zt.VERTEX_HEAD,
          n.get(zt.VERTEX_HEAD) || ''
        ).replace(zt.VERTEX_MAIN_SUPPORT, n.get(zt.VERTEX_MAIN_SUPPORT) || '')),
        (this.needsUpdate = !0),
        this
      );
    }
    setDefines(n) {
      for (const e of n.entries()) this.defines[e[0]] = e[1];
      return ((this.needsUpdate = !0), this);
    }
    setUniforms(n) {
      for (const e of n.entries()) this.uniforms[e[0]] = e[1];
      return this;
    }
    setExtensions(n) {
      this.extensions = {};
      for (const e of n) this.extensions[e] = !0;
      return this;
    }
    get encodeOutput() {
      return this.defines.ENCODE_OUTPUT !== void 0;
    }
    set encodeOutput(n) {
      this.encodeOutput !== n &&
        (n
          ? (this.defines.ENCODE_OUTPUT = '1')
          : delete this.defines.ENCODE_OUTPUT,
        (this.needsUpdate = !0));
    }
    isOutputEncodingEnabled(n) {
      return this.encodeOutput;
    }
    setOutputEncodingEnabled(n) {
      this.encodeOutput = n;
    }
    get time() {
      return this.uniforms.time.value;
    }
    set time(n) {
      this.uniforms.time.value = n;
    }
    setDeltaTime(n) {
      this.uniforms.time.value += n;
    }
    adoptCameraSettings(n) {
      this.copyCameraSettings(n);
    }
    copyCameraSettings(n) {
      n &&
        ((this.uniforms.cameraNear.value = n.near),
        (this.uniforms.cameraFar.value = n.far),
        n instanceof Vn
          ? (this.defines.PERSPECTIVE_CAMERA = '1')
          : delete this.defines.PERSPECTIVE_CAMERA,
        (this.needsUpdate = !0));
    }
    setSize(n, e) {
      const t = this.uniforms;
      (t.resolution.value.set(n, e),
        t.texelSize.value.set(1 / n, 1 / e),
        (t.aspect.value = n / e));
    }
    static get Section() {
      return zt;
    }
  };
function pT(n, e, t) {
  for (const i of e) {
    const r = '$1' + n + i.charAt(0).toUpperCase() + i.slice(1),
      s = new RegExp('([^\\.])(\\b' + i + '\\b)', 'g');
    for (const a of t.entries())
      a[1] !== null && t.set(a[0], a[1].replace(s, r));
  }
}
function Pte(n, e, t) {
  let i = e.getFragmentShader(),
    r = e.getVertexShader();
  const s = i !== void 0 && /mainImage/.test(i),
    a = i !== void 0 && /mainUv/.test(i);
  if (((t.attributes |= e.getAttributes()), i === void 0))
    throw new Error(`Missing fragment shader (${e.name})`);
  if (a && (t.attributes & ps.CONVOLUTION) !== 0)
    throw new Error(
      `Effects that transform UVs are incompatible with convolution effects (${e.name})`
    );
  if (!s && !a)
    throw new Error(`Could not find mainImage or mainUv function (${e.name})`);
  {
    const o = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
      l = t.shaderParts;
    let c = l.get(zt.FRAGMENT_HEAD) || '',
      u = l.get(zt.FRAGMENT_MAIN_UV) || '',
      h = l.get(zt.FRAGMENT_MAIN_IMAGE) || '',
      d = l.get(zt.VERTEX_HEAD) || '',
      f = l.get(zt.VERTEX_MAIN_SUPPORT) || '';
    const p = new Set(),
      m = new Set();
    if (
      (a &&
        ((u += `	${n}MainUv(UV);
`),
        (t.uvTransformation = !0)),
      r !== null && /mainSupport/.test(r))
    ) {
      const y = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
      ((f += `	${n}MainSupport(`),
        (f += y
          ? `vUv);
`
          : `);
`));
      for (const _ of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
        for (const x of _[1].split(/\s*,\s*/))
          (t.varyings.add(x), p.add(x), m.add(x));
      for (const _ of r.matchAll(o)) m.add(_[1]);
    }
    for (const y of i.matchAll(o)) m.add(y[1]);
    for (const y of e.defines.keys()) m.add(y.replace(/\([\w\s,]*\)/g, ''));
    for (const y of e.uniforms.keys()) m.add(y);
    (m.delete('while'),
      m.delete('for'),
      m.delete('if'),
      e.uniforms.forEach((y, _) =>
        t.uniforms.set(n + _.charAt(0).toUpperCase() + _.slice(1), y)
      ),
      e.defines.forEach((y, _) =>
        t.defines.set(n + _.charAt(0).toUpperCase() + _.slice(1), y)
      ));
    const g = new Map([
      ['fragment', i],
      ['vertex', r],
    ]);
    (pT(n, m, t.defines),
      pT(n, m, g),
      (i = g.get('fragment')),
      (r = g.get('vertex')));
    const v = e.blendMode;
    if ((t.blendModes.set(v.blendFunction, v), s)) {
      (e.inputColorSpace !== null &&
        e.inputColorSpace !== t.colorSpace &&
        (h +=
          e.inputColorSpace === Wt
            ? `color0 = sRGBTransferOETF(color0);
	`
            : `color0 = sRGBToLinear(color0);
	`),
        e.outputColorSpace !== Sr
          ? (t.colorSpace = e.outputColorSpace)
          : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace));
      const y = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      ((h += `${n}MainImage(color0, UV, `),
        (t.attributes & ps.DEPTH) !== 0 &&
          y.test(i) &&
          ((h += 'depth, '), (t.readDepth = !0)),
        (h += `color1);
	`));
      const _ = n + 'BlendOpacity';
      (t.uniforms.set(_, v.opacity),
        (h += `color0 = blend${v.blendFunction}(color0, color1, ${_});

	`),
        (c += `uniform float ${_};

`));
    }
    if (
      ((c +=
        i +
        `
`),
      r !== null &&
        (d +=
          r +
          `
`),
      l.set(zt.FRAGMENT_HEAD, c),
      l.set(zt.FRAGMENT_MAIN_UV, u),
      l.set(zt.FRAGMENT_MAIN_IMAGE, h),
      l.set(zt.VERTEX_HEAD, d),
      l.set(zt.VERTEX_MAIN_SUPPORT, f),
      e.extensions !== null)
    )
      for (const y of e.extensions) t.extensions.add(y);
  }
}
var wie = class extends hr {
  constructor(n, ...e) {
    (super('EffectPass'),
      (this.fullscreenMaterial = new Ite(null, null, null, n)),
      (this.listener = (t) => this.handleEvent(t)),
      (this.effects = []),
      this.setEffects(e),
      (this.skipRendering = !1),
      (this.minTime = 1),
      (this.maxTime = Number.POSITIVE_INFINITY),
      (this.timeScale = 1));
  }
  set mainScene(n) {
    for (const e of this.effects) e.mainScene = n;
  }
  set mainCamera(n) {
    this.fullscreenMaterial.copyCameraSettings(n);
    for (const e of this.effects) e.mainCamera = n;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(n) {
    this.fullscreenMaterial.encodeOutput = n;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(n) {
    const e = this.fullscreenMaterial;
    ((e.dithering = n), (e.needsUpdate = !0));
  }
  setEffects(n) {
    for (const e of this.effects)
      e.removeEventListener('change', this.listener);
    this.effects = n.sort((e, t) => t.attributes - e.attributes);
    for (const e of this.effects) e.addEventListener('change', this.listener);
  }
  updateMaterial() {
    const n = new See();
    let e = 0;
    for (const a of this.effects)
      if (a.blendMode.blendFunction === Pt.DST)
        n.attributes |= a.getAttributes() & ps.DEPTH;
      else {
        if ((n.attributes & a.getAttributes() & ps.CONVOLUTION) !== 0)
          throw new Error(`Convolution effects cannot be merged (${a.name})`);
        Pte('e' + e++, a, n);
      }
    let t = n.shaderParts.get(zt.FRAGMENT_HEAD),
      i = n.shaderParts.get(zt.FRAGMENT_MAIN_IMAGE),
      r = n.shaderParts.get(zt.FRAGMENT_MAIN_UV);
    const s = /\bblend\b/g;
    for (const a of n.blendModes.values())
      t +=
        a.getShaderCode().replace(s, `blend${a.blendFunction}`) +
        `
`;
    ((n.attributes & ps.DEPTH) !== 0
      ? (n.readDepth &&
          (i =
            `float depth = readDepth(UV);

	` + i),
        (this.needsDepthTexture = this.getDepthTexture() === null))
      : (this.needsDepthTexture = !1),
      n.colorSpace === Wt &&
        (i += `color0 = sRGBToLinear(color0);
	`),
      n.uvTransformation
        ? ((r =
            `vec2 transformedUv = vUv;
` + r),
          n.defines.set('UV', 'transformedUv'))
        : n.defines.set('UV', 'vUv'),
      n.shaderParts.set(zt.FRAGMENT_HEAD, t),
      n.shaderParts.set(zt.FRAGMENT_MAIN_IMAGE, i),
      n.shaderParts.set(zt.FRAGMENT_MAIN_UV, r));
    for (const [a, o] of n.shaderParts)
      o !== null &&
        n.shaderParts.set(
          a,
          o.trim().replace(
            /^#/,
            `
#`
          )
        );
    ((this.skipRendering = e === 0),
      (this.needsSwap = !this.skipRendering),
      this.fullscreenMaterial.setShaderData(n));
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(n, e = ca) {
    ((this.fullscreenMaterial.depthBuffer = n),
      (this.fullscreenMaterial.depthPacking = e));
    for (const t of this.effects) t.setDepthTexture(n, e);
  }
  render(n, e, t, i, r) {
    for (const s of this.effects) s.update(n, e, i);
    if (!this.skipRendering || this.renderToScreen) {
      const s = this.fullscreenMaterial;
      ((s.inputBuffer = e.texture),
        (s.time += i * this.timeScale),
        n.setRenderTarget(this.renderToScreen ? null : t),
        n.render(this.scene, this.camera));
    }
  }
  setSize(n, e) {
    this.fullscreenMaterial.setSize(n, e);
    for (const t of this.effects) t.setSize(n, e);
  }
  initialize(n, e, t) {
    this.renderer = n;
    for (const i of this.effects) i.initialize(n, e, t);
    (this.updateMaterial(),
      t !== void 0 &&
        t !== gn &&
        (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'));
  }
  dispose() {
    super.dispose();
    for (const n of this.effects)
      (n.removeEventListener('change', this.listener), n.dispose());
  }
  handleEvent(n) {
    switch (n.type) {
      case 'change':
        this.recompile();
        break;
    }
  }
};
export {
  Wte as $,
  a2 as A,
  aX as B,
  je as C,
  pie as D,
  rh as E,
  I2 as F,
  mie as G,
  gie as H,
  Gn as I,
  die as J,
  vie as K,
  cr as L,
  Zf as M,
  ds as N,
  Jh as O,
  Vn as P,
  mc as Q,
  pY as R,
  ph as S,
  lie as T,
  gn as U,
  Dr as V,
  L3 as W,
  yI as X,
  _ie as Y,
  Xte as Z,
  oT as _,
  Gte as a,
  ci as a$,
  ine as a0,
  rne as a1,
  ane as a2,
  cne as a3,
  une as a4,
  VA as a5,
  Tne as a6,
  n6 as a7,
  Ane as a8,
  Ene as a9,
  fx as aA,
  qte as aB,
  Jte as aC,
  Yte as aD,
  JF as aE,
  Kte as aF,
  In as aG,
  Qne as aH,
  $ne as aI,
  DD as aJ,
  sie as aK,
  iie as aL,
  Jne as aM,
  tie as aN,
  aie as aO,
  sne as aP,
  xV as aQ,
  yie as aR,
  Lm as aS,
  bie as aT,
  wie as aU,
  xie as aV,
  Sie as aW,
  lu as aX,
  Kh as aY,
  da as aZ,
  rn as a_,
  bne as aa,
  nD as ab,
  fne as ac,
  pne as ad,
  xne as ae,
  vne as af,
  mne as ag,
  hne as ah,
  dne as ai,
  gne as aj,
  KW as ak,
  wne as al,
  HA as am,
  JW as an,
  Mne as ao,
  Ine as ap,
  Rne as aq,
  Pne as ar,
  Cne as as,
  p0 as at,
  yne as au,
  Sne as av,
  iD as aw,
  f0 as ax,
  e6 as ay,
  _ne as az,
  VL as b,
  Et as b0,
  hn as b1,
  W2 as b2,
  Qm as b3,
  x3 as b4,
  oc as b5,
  Lt as b6,
  Km as b7,
  Xh as b8,
  Hh as b9,
  Vo as ba,
  ub as bb,
  _t as bc,
  qt as bd,
  nb as be,
  On as bf,
  lq as bg,
  OG as c,
  F$ as d,
  V$ as e,
  U3 as f,
  cy as g,
  kD as h,
  lne as i,
  Hx as j,
  Wt as k,
  cie as l,
  Dm as m,
  Rn as n,
  pe as o,
  V as p,
  w3 as q,
  Vr as r,
  one as s,
  kt as t,
  uie as u,
  z$ as v,
  ys as w,
  hie as x,
  k7 as y,
  fie as z,
};
