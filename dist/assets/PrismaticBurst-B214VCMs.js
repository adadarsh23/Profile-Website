import{r as n,j as k}from"./vendor_react-BAzTK5eP.js";import{aR as J,aV as K,aW as Q,a$ as ee,aX as te}from"./vendor-CkpkedQS.js";const re="#version 300 es\nin vec2 position;\nin vec2 uv;\nout vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",ae="#version 300 es\nprecision highp float;\nprecision highp int;\n\nout vec4 fragColor;\n\nuniform vec2  uResolution;\nuniform float uTime;\n\nuniform float uIntensity;\nuniform float uSpeed;\nuniform int   uAnimType;\nuniform vec2  uMouse;\nuniform int   uColorCount;\nuniform float uDistort;\nuniform vec2  uOffset;\nuniform sampler2D uGradient;\nuniform float uNoiseAmount;\nuniform int   uRayCount;\n\nfloat hash21(vec2 p){\n    p = floor(p);\n    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\n    return fract(f);\n}\n\nmat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\n\nfloat layeredNoise(vec2 fragPx){\n    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\n    vec2 q = rot30() * p;\n    float n = 0.0;\n    n += 0.40 * hash21(q);\n    n += 0.25 * hash21(q * 2.0 + 17.0);\n    n += 0.20 * hash21(q * 4.0 + 47.0);\n    n += 0.10 * hash21(q * 8.0 + 113.0);\n    n += 0.05 * hash21(q * 16.0 + 191.0);\n    return n;\n}\n\nvec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\n    float focal = res.y * max(dist, 1e-3);\n    return normalize(vec3(2.0 * (frag - offset) - res, focal));\n}\n\nfloat edgeFade(vec2 frag, vec2 res, vec2 offset){\n    vec2 toC = frag - 0.5 * res - offset;\n    float r = length(toC) / (0.5 * min(res.x, res.y));\n    float x = clamp(r, 0.0, 1.0);\n    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n    float s = q * 0.5;\n    s = pow(s, 1.5);\n    float tail = 1.0 - pow(1.0 - s, 2.0);\n    s = mix(s, tail, 0.2);\n    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\n    return clamp(s + dn, 0.0, 1.0);\n}\n\nmat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\nmat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\nmat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\n\nvec3 sampleGradient(float t){\n    t = clamp(t, 0.0, 1.0);\n    return texture(uGradient, vec2(t, 0.5)).rgb;\n}\n\nvec2 rot2(vec2 v, float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c) * v;\n}\n\nfloat bendAngle(vec3 q, float t){\n    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\n            + 0.7 * sin(q.y * 0.50 - t * 0.5)\n            + 0.6 * sin(q.z * 0.60 + t * 0.7);\n    return a;\n}\n\nvoid main(){\n    vec2 frag = gl_FragCoord.xy;\n    float t = uTime * uSpeed;\n    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\n    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\n    float marchT = 0.0;\n    vec3 col = vec3(0.0);\n    float n = layeredNoise(frag);\n    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\n    mat2 M2 = mat2(c.x, c.y, c.z, c.w);\n    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\n\n    mat3 rot3dMat = mat3(1.0);\n    if(uAnimType == 1){\n      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\n      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\n    }\n    mat3 hoverMat = mat3(1.0);\n    if(uAnimType == 2){\n      vec2 m = uMouse * 2.0 - 1.0;\n      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\n      hoverMat = rotY(ang.y) * rotX(ang.x);\n    }\n\n    for (int i = 0; i < 44; ++i) {\n        vec3 P = marchT * dir;\n        P.z -= 2.0;\n        float rad = length(P);\n        vec3 Pl = P * (10.0 / max(rad, 1e-6));\n\n        if(uAnimType == 0){\n            Pl.xz *= M2;\n        } else if(uAnimType == 1){\n      Pl = rot3dMat * Pl;\n        } else {\n      Pl = hoverMat * Pl;\n        }\n\n        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\n\n        float grow = smoothstep(0.35, 3.0, marchT);\n        float a1 = amp * grow * bendAngle(Pl * 0.6, t);\n        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\n        vec3 Pb = Pl;\n        Pb.xz = rot2(Pb.xz, a1);\n        Pb.xy = rot2(Pb.xy, a2);\n\n        float rayPattern = smoothstep(\n            0.5, 0.7,\n            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\n            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\n        );\n\n        if (uRayCount > 0) {\n            float ang = atan(Pb.y, Pb.x);\n            float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\n            comb = pow(comb, 3.0);\n            rayPattern *= smoothstep(0.15, 0.95, comb);\n        }\n\n        vec3 spectralDefault = 1.0 + vec3(\n            cos(marchT * 3.0 + 0.0),\n            cos(marchT * 3.0 + 1.0),\n            cos(marchT * 3.0 + 2.0)\n        );\n\n        float saw = fract(marchT * 0.25);\n        float tRay = saw * saw * (3.0 - 2.0 * saw);\n        vec3 userGradient = 2.0 * sampleGradient(tRay);\n        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\n        vec3 base = (0.05 / (0.4 + stepLen))\n                  * smoothstep(5.0, 0.0, rad)\n                  * spectral;\n\n        col += base * rayPattern;\n        marchT += stepLen;\n    }\n\n    col *= edgeFade(frag, uResolution, uOffset);\n    col *= uIntensity;\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}",ne=l=>{let a=l.trim();if(a.startsWith("#")&&(a=a.slice(1)),a.length===3){const f=a[0],T=a[1],p=a[2];a=f+f+T+T+p+p}const c=parseInt(a,16);if(isNaN(c)||a.length!==6&&a.length!==8)return[1,1,1];const b=(c>>16&255)/255,M=(c>>8&255)/255,E=(c&255)/255;return[b,M,E]},Z=l=>{if(l==null)return 0;if(typeof l=="number")return l;const a=String(l).trim(),c=parseFloat(a.replace("px",""));return isNaN(c)?0:c},ce=({intensity:l=2,speed:a=.5,animationType:c="rotate3d",colors:b,distort:M=0,paused:E=!1,offset:f={x:0,y:0},hoverDampness:T=0,rayCount:p,mixBlendMode:x="lighten"})=>{const Y=n.useRef(null),N=n.useRef(null),C=n.useRef(null),U=n.useRef([.5,.5]),$=n.useRef([.5,.5]),j=n.useRef(E),z=n.useRef(null),X=n.useRef(T),V=n.useRef(!0),q=n.useRef(null),F=n.useRef(null);return n.useEffect(()=>{j.current=E},[E]),n.useEffect(()=>{X.current=T},[T]),n.useEffect(()=>{const e=Y.current;if(!e)return;const y=Math.min(window.devicePixelRatio||1,2),t=new J({dpr:y,alpha:!1,antialias:!1});C.current=t;const r=t.gl;r.canvas.style.position="absolute",r.canvas.style.inset="0",r.canvas.style.width="100%",r.canvas.style.height="100%",r.canvas.style.mixBlendMode=x&&x!=="none"?x:"",e.appendChild(r.canvas);const S=new Uint8Array([255,255,255,255]),h=new K(r,{image:S,width:1,height:1,generateMipmaps:!1,flipY:!1});h.minFilter=r.LINEAR,h.magFilter=r.LINEAR,h.wrapS=r.CLAMP_TO_EDGE,h.wrapT=r.CLAMP_TO_EDGE,z.current=h;const u=new Q(r,{vertex:re,fragment:ae,uniforms:{uResolution:{value:[1,1]},uTime:{value:0},uIntensity:{value:1},uSpeed:{value:1},uAnimType:{value:0},uMouse:{value:[.5,.5]},uColorCount:{value:0},uDistort:{value:0},uOffset:{value:[0,0]},uGradient:{value:h},uNoiseAmount:{value:.8},uRayCount:{value:0}}});N.current=u;const v=new ee(r),D=new te(r,{geometry:v,program:u});F.current=v,q.current=D;const m=()=>{const o=e.clientWidth||1,i=e.clientHeight||1;t.setSize(o,i),u.uniforms.uResolution.value=[r.drawingBufferWidth,r.drawingBufferHeight]};let s=null;"ResizeObserver"in window?(s=new ResizeObserver(m),s.observe(e)):window.addEventListener("resize",m),m();const G=o=>{const i=e.getBoundingClientRect(),g=(o.clientX-i.left)/Math.max(i.width,1),A=(o.clientY-i.top)/Math.max(i.height,1);U.current=[Math.min(Math.max(g,0),1),Math.min(Math.max(A,0),1)]};e.addEventListener("pointermove",G,{passive:!0});let R=null;"IntersectionObserver"in window&&(R=new IntersectionObserver(o=>{o[0]&&(V.current=o[0].isIntersecting)},{root:null,threshold:.01}),R.observe(e));const I=()=>{};document.addEventListener("visibilitychange",I);let O=0,W=performance.now(),B=0;const _=o=>{const i=Math.max(0,o-W)*.001;W=o;const g=V.current&&!document.hidden;if(j.current||(B+=i),!g){O=requestAnimationFrame(_);return}const A=.02+Math.max(0,Math.min(1,X.current))*.5,w=1-Math.exp(-i/A),L=U.current,d=$.current;d[0]+=(L[0]-d[0])*w,d[1]+=(L[1]-d[1])*w,u.uniforms.uMouse.value=d,u.uniforms.uTime.value=B,t.render({scene:q.current}),O=requestAnimationFrame(_)};return O=requestAnimationFrame(_),()=>{var o,i,g,A,w,L,d,H;cancelAnimationFrame(O),e.removeEventListener("pointermove",G),s==null||s.disconnect(),s||window.removeEventListener("resize",m),R==null||R.disconnect(),document.removeEventListener("visibilitychange",I);try{e.removeChild(r.canvas)}catch(P){}try{(i=(o=q.current)==null?void 0:o.remove)==null||i.call(o)}catch(P){}try{(A=(g=F.current)==null?void 0:g.remove)==null||A.call(g)}catch(P){}try{(L=(w=N.current)==null?void 0:w.remove)==null||L.call(w)}catch(P){}try{const P=(d=C.current)==null?void 0:d.gl;P&&((H=z.current)!=null&&H.texture)&&P.deleteTexture(z.current.texture)}catch(P){}N.current=null,C.current=null,z.current=null,q.current=null,F.current=null}},[]),n.useEffect(()=>{var y,t;const e=(t=(y=C.current)==null?void 0:y.gl)==null?void 0:t.canvas;e&&(e.style.mixBlendMode=x&&x!=="none"?x:"")},[x]),n.useEffect(()=>{const e=N.current,y=C.current,t=z.current;if(!e||!y||!t)return;e.uniforms.uIntensity.value=l!=null?l:1,e.uniforms.uSpeed.value=a!=null?a:1;const r={rotate:0,rotate3d:1,hover:2};e.uniforms.uAnimType.value=r[c!=null?c:"rotate"],e.uniforms.uDistort.value=typeof M=="number"?M:0;const S=Z(f==null?void 0:f.x),h=Z(f==null?void 0:f.y);e.uniforms.uOffset.value=[S,h],e.uniforms.uRayCount.value=Math.max(0,Math.floor(p!=null?p:0));let u=0;if(Array.isArray(b)&&b.length>0){const v=y.gl,D=b.slice(0,64);u=D.length;const m=new Uint8Array(u*4);for(let s=0;s<u;s++){const[G,R,I]=ne(D[s]);m[s*4+0]=Math.round(G*255),m[s*4+1]=Math.round(R*255),m[s*4+2]=Math.round(I*255),m[s*4+3]=255}t.image=m,t.width=u,t.height=1,t.minFilter=v.LINEAR,t.magFilter=v.LINEAR,t.wrapS=v.CLAMP_TO_EDGE,t.wrapT=v.CLAMP_TO_EDGE,t.flipY=!1,t.generateMipmaps=!1,t.format=v.RGBA,t.type=v.UNSIGNED_BYTE,t.needsUpdate=!0}else u=0;e.uniforms.uColorCount.value=u},[l,a,c,b,M,f,p]),k.jsx("div",{className:"w-full h-full relative overflow-hidden",ref:Y})};export{ce as default};
